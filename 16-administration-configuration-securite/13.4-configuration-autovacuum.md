üîù Retour au [Sommaire](/SOMMAIRE.md)

# 16.13.4. Configuration Autovacuum

## Introduction

L'**autovacuum** est l'un des m√©canismes les plus critiques de PostgreSQL, mais aussi l'un des plus mal compris. Une mauvaise configuration de l'autovacuum peut causer des probl√®mes de performance catastrophiques : tables gonfl√©es (bloat), requ√™tes lentes, et dans les cas extr√™mes, un arr√™t complet de la base de donn√©es (transaction ID wraparound).

Dans cette section, nous allons comprendre :
- Pourquoi PostgreSQL a besoin de VACUUM
- Comment fonctionne l'autovacuum
- Les param√®tres de configuration essentiels
- Comment surveiller et diagnostiquer les probl√®mes
- Les nouveaut√©s de PostgreSQL 18

> **‚ö†Ô∏è Avertissement** : L'autovacuum n'est pas optionnel. C'est un m√©canisme de maintenance vital pour la sant√© de votre base de donn√©es. Ne jamais le d√©sactiver en production !

---

## Comprendre le Probl√®me : Pourquoi VACUUM existe

### Le Mod√®le MVCC de PostgreSQL

PostgreSQL utilise un syst√®me appel√© **MVCC (Multi-Version Concurrency Control)** qui est au c≈ìur de sa gestion de la concurrence. Pour comprendre l'autovacuum, il faut d'abord comprendre MVCC.

#### Principe de MVCC

Contrairement √† d'autres syst√®mes de bases de donn√©es, PostgreSQL ne modifie **jamais** une ligne existante lors d'un UPDATE ou DELETE. √Ä la place :
- **UPDATE** : PostgreSQL cr√©e une **nouvelle version** de la ligne
- **DELETE** : PostgreSQL marque l'ancienne ligne comme "morte" mais ne la supprime pas physiquement

> **üí° Analogie** : Imaginez un document Word. Quand vous modifiez un paragraphe, au lieu de l'effacer et de le r√©√©crire, vous cr√©ez une nouvelle version du document complet. L'ancienne version reste disponible pour les lecteurs qui l'avaient ouverte. C'est ainsi que PostgreSQL g√®re les transactions concurrentes !

#### Exemple Concret

Soit une table simple :
```sql
CREATE TABLE users (id INT, name TEXT, email TEXT);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
```

**√âtat initial** :
```
Version 1: (1, 'Alice', 'alice@example.com') ‚Üê VISIBLE
```

**Apr√®s un UPDATE** :
```sql
UPDATE users SET email = 'alice.new@example.com' WHERE id = 1;
```

**√âtat sur disque** :
```
Version 1: (1, 'Alice', 'alice@example.com') ‚Üê MORTE (dead tuple)
Version 2: (1, 'Alice', 'alice.new@example.com') ‚Üê VISIBLE
```

PostgreSQL conserve **les deux versions** ! La version 1 est marqu√©e comme "morte" mais occupe toujours de l'espace.

### Le Probl√®me : Les Tuples Morts (Dead Tuples)

Au fil du temps, avec des milliers d'UPDATE et DELETE, votre base accumule des **tuples morts** :

```
Table "users" sur disque:
[Tuple vivant] [Tuple mort] [Tuple mort] [Tuple vivant] [Tuple mort]
[Tuple mort] [Tuple mort] [Tuple vivant] [Tuple mort] [Tuple mort]
[Tuple mort] [Tuple mort] [Tuple mort] [Tuple vivant] [Tuple mort]
```

**Cons√©quences** :
- üìà **Bloat** : La table gonfle artificiellement (peut atteindre 10√ó la taille r√©elle)
- üêå **Performance** : Les scans s√©quentiels lisent les tuples morts (inutilement)
- üíæ **Espace disque** : Gaspillage d'espace
- üìä **Index** : Les index pointent aussi vers des tuples morts (gonflent √©galement)

> **üí° Analogie** : C'est comme une biblioth√®que o√π on ne jette jamais les anciens livres. On empile les nouvelles √©ditions par-dessus les anciennes. Au bout d'un moment, la biblioth√®que est remplie √† 80% de vieux livres inutiles et on ne trouve plus rien !

---

## La Solution : VACUUM et Autovacuum

### Qu'est-ce que VACUUM ?

**VACUUM** est l'op√©ration de nettoyage qui :
1. Identifie les tuples morts
2. Marque l'espace occup√© comme r√©utilisable
3. Met √† jour les statistiques de la table
4. Pr√©vient le transaction ID wraparound (cas extr√™me)

**Important** : VACUUM ne retourne PAS imm√©diatement l'espace au syst√®me d'exploitation (sauf VACUUM FULL). Il marque juste l'espace comme r√©utilisable par PostgreSQL.

### Types de VACUUM

| Type | Commande | Action | Verrouillage |
|------|----------|--------|--------------|
| **Standard** | `VACUUM` | Nettoie et marque espace r√©utilisable | ‚úÖ Aucun (concurrentiel) |
| **Analyze** | `VACUUM ANALYZE` | Nettoie + met √† jour statistiques | ‚úÖ Aucun |
| **Full** | `VACUUM FULL` | R√©√©crit la table compl√®tement | ‚ùå EXCLUSIVE (bloquant) |
| **Freeze** | `VACUUM FREEZE` | G√®le les XIDs anciens | ‚úÖ Aucun |

### L'Autovacuum : Le Nettoyeur Automatique

G√©rer manuellement VACUUM sur toutes les tables serait impossible. C'est pourquoi PostgreSQL a l'**autovacuum** : un syst√®me automatique qui lance des VACUUM en arri√®re-plan.

**Fonctionnement** :
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   PostgreSQL en fonctionnement          ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ  [Processus Autovacuum Launcher]        ‚îÇ
‚îÇ           ‚Üì                             ‚îÇ
‚îÇ  D√©tecte tables ayant besoin VACUUM     ‚îÇ
‚îÇ           ‚Üì                             ‚îÇ
‚îÇ  Lance Autovacuum Workers (max 3)       ‚îÇ
‚îÇ           ‚Üì                             ‚îÇ
‚îÇ  [Worker 1] ‚Üí Table A                   ‚îÇ
‚îÇ  [Worker 2] ‚Üí Table B                   ‚îÇ
‚îÇ  [Worker 3] ‚Üí Table C                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

> **üí° Analogie** : L'autovacuum, c'est comme un robot-aspirateur qui se d√©clenche automatiquement quand il d√©tecte trop de poussi√®re. Vous n'avez pas besoin d'y penser, il s'active tout seul en arri√®re-plan.

---

## Les D√©clencheurs d'Autovacuum

### Quand l'Autovacuum se D√©clenche-t-il ?

L'autovacuum √©value chaque table et d√©cide de lancer un VACUUM selon cette formule :

```
Seuil de d√©clenchement = autovacuum_vacuum_threshold +
                         (autovacuum_vacuum_scale_factor √ó nombre_tuples_table)
```

**Autovacuum se d√©clenche quand** :
```
nombre_tuples_morts > Seuil de d√©clenchement
```

### Les Param√®tres de D√©clenchement

#### autovacuum_vacuum_threshold

```conf
autovacuum_vacuum_threshold = 50  # D√©faut
```

**Signification** : Nombre minimum de tuples morts avant de consid√©rer un VACUUM.

**Exemple** :
- Petite table de 100 lignes avec 40 tuples morts ‚Üí Pas de VACUUM (< 50)
- Petite table de 100 lignes avec 60 tuples morts ‚Üí VACUUM d√©clench√© (> 50)

#### autovacuum_vacuum_scale_factor

```conf
autovacuum_vacuum_scale_factor = 0.2  # D√©faut = 20%
```

**Signification** : Fraction de la table devant √™tre "morte" pour d√©clencher VACUUM.

**Exemple avec une table de 10,000 lignes** :
```
Seuil = 50 + (0.2 √ó 10,000) = 50 + 2,000 = 2,050 tuples morts
```

Donc autovacuum se d√©clenche quand il y a **2,050+ tuples morts**.

### Visualisation : Tables de Diff√©rentes Tailles

| Taille Table | Seuil (threshold=50, scale=0.2) | % de la table |
|--------------|--------------------------------|---------------|
| 100 lignes | 50 + 20 = **70** | 70% |
| 1,000 lignes | 50 + 200 = **250** | 25% |
| 10,000 lignes | 50 + 2,000 = **2,050** | 20.5% |
| 100,000 lignes | 50 + 20,000 = **20,050** | 20% |
| 1,000,000 lignes | 50 + 200,000 = **200,050** | 20% |
| 10,000,000 lignes | 50 + 2,000,000 = **2,000,050** | 20% |

**Observation** : Pour les grandes tables, il faut que **20% de la table soit morte** avant un VACUUM. C'est beaucoup !

### Le Probl√®me des Grosses Tables

Sur de tr√®s grosses tables (100+ millions de lignes), attendre 20% de tuples morts peut causer :
- üìà **Bloat massif** (tables gonfl√©es de 30-50%)
- üêå **D√©gradation progressive** des performances
- ‚è±Ô∏è **VACUUM tr√®s long** quand il se d√©clenche enfin

**Solution** : Ajuster les param√®tres pour les grosses tables.

---

## Configuration des Param√®tres Autovacuum

### Param√®tres Globaux (postgresql.conf)

#### 1. autovacuum (Activation Globale)

```conf
autovacuum = on  # ‚ö†Ô∏è JAMAIS d√©sactiver en production !
```

**Valeurs** :
- `on` : Autovacuum actif ‚úÖ (d√©faut)
- `off` : Autovacuum d√©sactiv√© ‚ùå (DANGER)

> **‚ö†Ô∏è DANGER CRITIQUE** : D√©sactiver l'autovacuum peut causer un **transaction ID wraparound** au bout de quelques jours/semaines, entra√Ænant un arr√™t complet de la base. Ne JAMAIS d√©sactiver en production.

#### 2. autovacuum_max_workers

```conf
autovacuum_max_workers = 3  # D√©faut
```

**Signification** : Nombre de processus autovacuum pouvant tourner simultan√©ment.

**Impact** :
- Trop peu de workers ‚Üí Tables ne sont pas nettoy√©es assez vite
- Trop de workers ‚Üí Consommation I/O et CPU excessive

**Recommandations** :

| Contexte | Recommandation | Explication |
|----------|----------------|-------------|
| Petit serveur (< 1000 tables) | 3 | D√©faut suffisant |
| Serveur moyen (1000-5000 tables) | 5-8 | Plus de tables = plus de workers |
| Gros serveur (5000+ tables) | 10-15 | Beaucoup de tables √† g√©rer |
| Charge d'√©criture intense | 8-12 | Beaucoup de tuples morts g√©n√©r√©s |

**üÜï PostgreSQL 18** : Nouveau param√®tre compl√©mentaire `autovacuum_worker_slots` (voir section nouveaut√©s).

#### 3. autovacuum_naptime

```conf
autovacuum_naptime = 1min  # D√©faut
```

**Signification** : Intervalle entre deux cycles de d√©tection par le launcher.

**Impact** :
- Valeur basse (10s) ‚Üí D√©tection rapide mais plus de CPU
- Valeur haute (5min) ‚Üí Moins de CPU mais r√©activit√© moindre

**Recommandations** :
- OLTP intensif : **30 secondes** (d√©tection rapide)
- Standard : **1 minute** (d√©faut)
- Charge l√©g√®re : **2-3 minutes**

#### 4. autovacuum_vacuum_threshold

```conf
autovacuum_vacuum_threshold = 50  # D√©faut
```

**Recommandations** :
- Tables petites/moyennes : **50** (d√©faut)
- Tables tr√®s actives : **10-20** (plus agressif)
- Tables stables : **100-200** (moins agressif)

#### 5. autovacuum_vacuum_scale_factor

```conf
autovacuum_vacuum_scale_factor = 0.2  # D√©faut = 20%
```

**‚ö†Ô∏è Param√®tre CRITIQUE** : C'est souvent celui-ci qu'il faut ajuster !

**Recommandations** :

| Taille Table | Recommandation | Explication |
|--------------|----------------|-------------|
| < 10,000 lignes | 0.2 (20%) | D√©faut OK |
| 10,000 - 100,000 lignes | 0.1 (10%) | Plus agressif |
| 100,000 - 1M lignes | 0.05 (5%) | Beaucoup plus agressif |
| > 1M lignes | 0.01-0.02 (1-2%) | Tr√®s agressif |
| Tables TR√àS actives | 0.01 (1%) | Maximum agressivit√© |

**Exemple : Table de 10 millions de lignes**

Avec `scale_factor = 0.2` (d√©faut) :
```
Seuil = 50 + (0.2 √ó 10,000,000) = 2,000,050 tuples morts
‚Üí 20% de la table doit √™tre morte !
```

Avec `scale_factor = 0.02` (ajust√©) :
```
Seuil = 50 + (0.02 √ó 10,000,000) = 200,050 tuples morts
‚Üí 2% de la table morte (beaucoup mieux)
```

#### 6. autovacuum_analyze_threshold et autovacuum_analyze_scale_factor

```conf
autovacuum_analyze_threshold = 50
autovacuum_analyze_scale_factor = 0.1  # D√©faut = 10%
```

**R√¥le** : D√©clenchent ANALYZE (mise √† jour des statistiques du planificateur).

**Formule** :
```
Seuil ANALYZE = analyze_threshold + (analyze_scale_factor √ó nombre_tuples)
```

**Pourquoi 10% et non 20%** : Les statistiques doivent √™tre mises √† jour plus fr√©quemment que le nettoyage.

**Recommandations** : G√©n√©ralement, garder les d√©fauts. Si plans de requ√™tes instables, r√©duire `analyze_scale_factor` √† 0.05.

#### 7. autovacuum_vacuum_cost_delay et autovacuum_vacuum_cost_limit

```conf
autovacuum_vacuum_cost_delay = 2ms   # D√©faut
autovacuum_vacuum_cost_limit = 200   # D√©faut
```

**R√¥le** : Contr√¥lent la "vitesse" de l'autovacuum pour √©viter de saturer les I/O.

**Fonctionnement** :
1. Autovacuum accumule des "points de co√ªt" pour chaque I/O
2. Quand il atteint `cost_limit`, il s'endort pendant `cost_delay`
3. C'est un m√©canisme de throttling (limitation)

**Impact** :
- `cost_delay` √©lev√© ‚Üí Autovacuum lent, moins d'impact sur performances
- `cost_delay` faible ‚Üí Autovacuum rapide, mais peut ralentir les requ√™tes

**Recommandations** :

| Contexte | cost_delay | cost_limit | Explication |
|----------|------------|------------|-------------|
| SSD Rapide + Peu de charge | 0-1 ms | 400-1000 | Autovacuum rapide, pas de throttling |
| SSD Standard | 2 ms | 200 | D√©faut OK |
| HDD ou Charge intensive | 5-10 ms | 200 | Throttling agressif |
| Nuit (fen√™tre maintenance) | 0 ms | 2000 | Pas de throttling |

**Configuration dynamique par p√©riode** :
```sql
-- En journ√©e (ralentir autovacuum)
ALTER SYSTEM SET autovacuum_vacuum_cost_delay = 10;

-- La nuit (acc√©l√©rer autovacuum)
ALTER SYSTEM SET autovacuum_vacuum_cost_delay = 2;
```

#### 8. autovacuum_work_mem

```conf
autovacuum_work_mem = -1  # D√©faut = utilise maintenance_work_mem
```

**R√¥le** : M√©moire allou√©e √† chaque worker autovacuum pour ses op√©rations.

**Recommandations** :
- `-1` : Utilise `maintenance_work_mem` (souvent OK)
- Si bloat important : Augmenter √† 256 MB - 1 GB

**Calcul de s√©curit√©** :
```
Total m√©moire autovacuum = autovacuum_work_mem √ó autovacuum_max_workers
```

Avec 3 workers et 512 MB chacun = **1.5 GB RAM** maximum.

---

## Configuration Par Table (Granularit√© Fine)

### Pourquoi Configurer Par Table ?

Toutes les tables ne se comportent pas de la m√™me fa√ßon :
- Table `logs` : 1 million d'INSERT par jour, aucun UPDATE
- Table `users` : Quelques INSERT, beaucoup d'UPDATE
- Table `cache` : UPDATE constant, besoin VACUUM fr√©quent

**Solution** : Override des param√®tres autovacuum **par table**.

### Syntaxe ALTER TABLE

```sql
-- Modifier les param√®tres autovacuum d'une table sp√©cifique
ALTER TABLE nom_table SET (
    autovacuum_vacuum_threshold = valeur,
    autovacuum_vacuum_scale_factor = valeur,
    autovacuum_vacuum_cost_delay = valeur
);
```

### Exemples Concrets

#### Exemple 1 : Grande Table Tr√®s Active

```sql
-- Table "orders" : 50 millions de lignes, 10,000 UPDATE/sec
ALTER TABLE orders SET (
    autovacuum_vacuum_scale_factor = 0.01,  -- 1% au lieu de 20%
    autovacuum_vacuum_threshold = 10000,
    autovacuum_vacuum_cost_delay = 0        -- Pas de throttling
);
```

**Effet** :
- Avant : VACUUM se d√©clenchait √† 10 millions de tuples morts (20%)
- Apr√®s : VACUUM se d√©clenche √† 510,000 tuples morts (1%)
- R√©sultat : Bloat r√©duit de 70%, performances stables

#### Exemple 2 : Table de Cache avec Turnover √âlev√©

```sql
-- Table "session_cache" : Tuples ont une dur√©e de vie courte
ALTER TABLE session_cache SET (
    autovacuum_vacuum_scale_factor = 0.02,  -- 2%
    autovacuum_vacuum_threshold = 50,
    autovacuum_vacuum_cost_delay = 0,       -- Rapide
    autovacuum_naptime = '30s'              -- Non support√© (global seulement)
);
```

#### Exemple 3 : Table Historique Append-Only

```sql
-- Table "audit_log" : INSERT seulement, jamais d'UPDATE/DELETE
ALTER TABLE audit_log SET (
    autovacuum_vacuum_scale_factor = 0.5,   -- 50% (tr√®s tol√©rant)
    autovacuum_vacuum_threshold = 10000,
    autovacuum_enabled = true               -- S'assurer qu'il est actif
);
```

**Logique** : Cette table g√©n√®re peu de tuples morts, inutile de VACUUM souvent.

#### Exemple 4 : D√©sactiver Autovacuum (Cas Rare)

```sql
-- Table temporaire g√©r√©e manuellement
ALTER TABLE temp_import SET (
    autovacuum_enabled = false  -- ‚ö†Ô∏è √Ä utiliser avec EXTR√äME prudence
);
```

**‚ö†Ô∏è ATTENTION** : Ne d√©sactivez l'autovacuum sur une table QUE si :
1. Vous g√©rez manuellement les VACUUM
2. La table a un cycle de vie court (DROP √† la fin)
3. Vous comprenez les risques (XID wraparound)

### Voir la Configuration Par Table

```sql
-- Voir les param√®tres autovacuum d'une table
SELECT
    schemaname,
    tablename,
    reloptions
FROM pg_tables
WHERE tablename = 'nom_table';
```

```sql
-- Exemple de r√©sultat
 tablename |              reloptions
-----------+--------------------------------------
 orders    | {autovacuum_vacuum_scale_factor=0.01,
           |  autovacuum_vacuum_threshold=10000}
```

### R√©initialiser la Configuration Par Table

```sql
-- Retour aux valeurs globales
ALTER TABLE orders RESET (autovacuum_vacuum_scale_factor);
-- Ou tout r√©initialiser :
ALTER TABLE orders RESET (autovacuum_enabled);
```

---

## Nouveaut√©s PostgreSQL 18

PostgreSQL 18 introduit plusieurs am√©liorations majeures pour l'autovacuum :

### 1. autovacuum_worker_slots (Nouveau Param√®tre)

```conf
autovacuum_max_workers = 3            # Nombre de workers simultan√©s
autovacuum_worker_slots = 8           # üÜï Total de slots disponibles
```

**Diff√©rence importante** :
- **Avant PG 18** : `max_workers` √©tait fixe, si 3 workers √©taient occup√©s sur de longues tables, d'autres tables attendaient
- **PG 18** : `worker_slots` permet de pr√©-allouer plus de capacit√©

**Analogie** :
- `max_workers` = Nombre de caissiers actifs dans un supermarch√©
- `worker_slots` = Nombre total de caisses disponibles

**B√©n√©fice** : Permet de g√©rer des pics de charge autovacuum sans bloquer les petites tables.

**Recommandation** :
```conf
autovacuum_max_workers = 5
autovacuum_worker_slots = 10  # 2√ó max_workers
```

### 2. autovacuum_vacuum_max_threshold (Nouveau Param√®tre)

```conf
autovacuum_vacuum_max_threshold = -1  # üÜï D√©faut = illimit√©
```

**R√¥le** : Plafonne le nombre de tuples morts avant de FORCER un autovacuum, m√™me si `scale_factor` n'est pas atteint.

**Probl√®me r√©solu** : Sur tables g√©antes (1+ milliard de lignes), avec `scale_factor = 0.01`, le seuil peut atteindre **10 millions de tuples morts**. C'est parfois trop.

**Exemple** :
```conf
# Limiter √† 5 millions de tuples morts maximum
autovacuum_vacuum_max_threshold = 5000000
```

**Cas d'usage** : Tables ultra-massives o√π m√™me 1-2% repr√©sente des millions de tuples.

### 3. Statistiques Autovacuum Enrichies (pg_stat_all_tables)

PostgreSQL 18 ajoute des colonnes √† `pg_stat_all_tables` :

```sql
SELECT
    schemaname,
    tablename,
    last_vacuum,
    last_autovacuum,
    vacuum_count,
    autovacuum_count,
    n_tup_ins,          -- Insertions
    n_tup_upd,          -- Updates
    n_tup_del,          -- Deletions
    n_tup_hot_upd,      -- HOT updates (efficaces)
    n_live_tup,         -- Tuples vivants estim√©s
    n_dead_tup,         -- üÜï Tuples morts R√âELS (pr√©cision am√©lior√©e)
    n_mod_since_analyze, -- Modifications depuis dernier ANALYZE
    last_autoanalyze,
    autoanalyze_count,
    -- üÜï Nouvelles colonnes PostgreSQL 18
    autovacuum_vacuum_cost_accumulated,  -- Co√ªt total accumul√©
    autovacuum_last_duration              -- Dur√©e du dernier autovacuum
FROM pg_stat_all_tables
WHERE schemaname = 'public';
```

**B√©n√©fice** : Meilleure observabilit√© pour diagnostiquer les probl√®mes d'autovacuum.

### 4. Ajustements Dynamiques Plus Intelligents

PostgreSQL 18 am√©liore l'algorithme d'autovacuum :
- D√©tection plus pr√©cise du bloat
- Ajustement dynamique du `cost_delay` selon la charge syst√®me
- Priorisation des tables critiques

---

## Monitoring et Diagnostics Autovacuum

### 1. Vue d'Ensemble : Tables √† Probl√®me

```sql
-- Identifier les tables avec beaucoup de tuples morts
SELECT
    schemaname,
    tablename,
    n_live_tup,
    n_dead_tup,
    ROUND(100.0 * n_dead_tup / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS dead_pct,
    last_autovacuum,
    autovacuum_count
FROM pg_stat_all_tables
WHERE n_dead_tup > 1000
ORDER BY n_dead_tup DESC
LIMIT 20;
```

**Interpr√©tation** :
- `dead_pct > 20%` : ‚ö†Ô∏è Table a besoin d'un VACUUM
- `dead_pct > 50%` : üî¥ Probl√®me s√©rieux, ajuster config
- `last_autovacuum` ancien : üî¥ Autovacuum n'arrive pas √† traiter la table

### 2. Tables Jamais Nettoy√©es

```sql
-- Tables qui n'ont JAMAIS eu d'autovacuum
SELECT
    schemaname,
    tablename,
    n_live_tup,
    n_dead_tup,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
    last_autovacuum
FROM pg_stat_all_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
  AND last_autovacuum IS NULL
  AND n_live_tup > 0
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

**Action** : Ces tables ont peut-√™tre besoin d'ajustement de seuils.

### 3. Autovacuum En Cours

```sql
-- Voir les autovacuum actifs en ce moment
SELECT
    pid,
    usename,
    datname,
    query,
    state,
    query_start,
    now() - query_start AS duration
FROM pg_stat_activity
WHERE query LIKE '%autovacuum%'
  AND pid != pg_backend_pid();
```

### 4. Bloat Estimation (Gonflement des Tables)

```sql
-- Estimer le bloat d'une table (approximation)
WITH table_stats AS (
    SELECT
        schemaname,
        tablename,
        n_live_tup,
        n_dead_tup
    FROM pg_stat_all_tables
    WHERE schemaname = 'public'
),
table_sizes AS (
    SELECT
        schemaname,
        tablename,
        pg_total_relation_size(schemaname||'.'||tablename) AS total_bytes,
        pg_relation_size(schemaname||'.'||tablename) AS table_bytes
    FROM pg_tables
    WHERE schemaname = 'public'
)
SELECT
    ts.schemaname,
    ts.tablename,
    pg_size_pretty(sz.table_bytes) AS table_size,
    n_live_tup,
    n_dead_tup,
    ROUND(100.0 * n_dead_tup / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS dead_pct,
    CASE
        WHEN n_live_tup + n_dead_tup = 0 THEN 0
        ELSE ROUND(sz.table_bytes::numeric / NULLIF(n_live_tup + n_dead_tup, 0), 2)
    END AS bytes_per_tuple,
    CASE
        WHEN (n_live_tup + n_dead_tup) > 0 AND
             (sz.table_bytes::numeric / (n_live_tup + n_dead_tup)) > 300
        THEN '‚ö†Ô∏è Bloat probable'
        ELSE '‚úÖ OK'
    END AS bloat_status
FROM table_stats ts
JOIN table_sizes sz USING (schemaname, tablename)
WHERE n_live_tup + n_dead_tup > 0
ORDER BY dead_pct DESC;
```

**Interpr√©tation** :
- `bytes_per_tuple` normal : 100-200 bytes (d√©pend du sch√©ma)
- `bytes_per_tuple > 300` : Probablement du bloat
- `bytes_per_tuple > 500` : Bloat important

### 5. Historique des Autovacuum

```sql
-- Voir l'historique des autovacuum (n√©cessite log_autovacuum_min_duration)
-- Dans postgresql.conf :
-- log_autovacuum_min_duration = 0
```

**Dans les logs PostgreSQL** :
```
automatic vacuum of table "mydb.public.orders":
    index scans: 1
    pages: 0 removed, 823421 remain, 12453 skipped due to pins
    tuples: 1234567 removed, 45678901 remain, 0 are dead but not yet removable
    buffer usage: 1567890 hits, 234567 misses, 123456 dirtied
    avg read rate: 12.345 MB/s, avg write rate: 5.678 MB/s
    system usage: CPU 12.34s/23.45s, elapsed 456.78s
```

### 6. Dashboard Complet

```sql
-- Vue compl√®te pour monitoring quotidien
SELECT
    stat.schemaname,
    stat.tablename,
    pg_size_pretty(pg_total_relation_size(stat.schemaname||'.'||stat.tablename)) AS total_size,
    stat.n_live_tup AS live,
    stat.n_dead_tup AS dead,
    ROUND(100.0 * stat.n_dead_tup / NULLIF(stat.n_live_tup + stat.n_dead_tup, 0), 2) AS dead_pct,
    stat.last_autovacuum,
    stat.autovacuum_count AS av_count,
    COALESCE(
        EXTRACT(epoch FROM (now() - stat.last_autovacuum)) / 3600,
        999999
    ) AS hours_since_av,
    -- Calculer le seuil th√©orique
    (
        SELECT COALESCE(
            (regexp_match(reloptions::text, 'autovacuum_vacuum_threshold=([0-9]+)'))[1]::int,
            50
        ) +
        COALESCE(
            (regexp_match(reloptions::text, 'autovacuum_vacuum_scale_factor=([0-9.]+)'))[1]::numeric,
            0.2
        ) * stat.n_live_tup
        FROM pg_class c
        WHERE c.oid = (stat.schemaname||'.'||stat.tablename)::regclass
    ) AS threshold,
    CASE
        WHEN stat.n_dead_tup > (
            SELECT COALESCE(
                (regexp_match(reloptions::text, 'autovacuum_vacuum_threshold=([0-9]+)'))[1]::int, 50
            ) +
            COALESCE(
                (regexp_match(reloptions::text, 'autovacuum_vacuum_scale_factor=([0-9.]+)'))[1]::numeric, 0.2
            ) * stat.n_live_tup
            FROM pg_class c
            WHERE c.oid = (stat.schemaname||'.'||stat.tablename)::regclass
        )
        THEN 'üü¢ Devrait √™tre vacuum bient√¥t'
        WHEN stat.n_dead_tup::float / NULLIF(stat.n_live_tup, 0) > 0.3
        THEN 'üî¥ Probl√®me : Trop de tuples morts'
        ELSE '‚úÖ OK'
    END AS status
FROM pg_stat_all_tables stat
WHERE stat.schemaname NOT IN ('pg_catalog', 'information_schema')
  AND stat.n_live_tup > 0
ORDER BY stat.n_dead_tup DESC
LIMIT 30;
```

---

## Troubleshooting : Probl√®mes Courants

### Probl√®me 1 : Autovacuum Ne Se D√©clenche Jamais

**Sympt√¥mes** :
- Tables gonflent continuellement
- `last_autovacuum` est NULL ou tr√®s ancien
- Requ√™tes de plus en plus lentes

**Causes Possibles** :

#### Cause 1.1 : Autovacuum D√©sactiv√© Globalement

```sql
SHOW autovacuum;
-- Si "off" ‚Üí PROBL√àME CRITIQUE
```

**Solution** :
```conf
# Dans postgresql.conf
autovacuum = on  # TOUJOURS
```

```bash
sudo systemctl restart postgresql
```

#### Cause 1.2 : Autovacuum D√©sactiv√© Sur la Table

```sql
SELECT reloptions
FROM pg_class
WHERE relname = 'ma_table';
-- Si contient "autovacuum_enabled=false" ‚Üí Probl√®me
```

**Solution** :
```sql
ALTER TABLE ma_table SET (autovacuum_enabled = true);
```

#### Cause 1.3 : Seuils Trop √âlev√©s

Sur une table de 100 millions de lignes, avec d√©fauts :
```
Seuil = 50 + (0.2 √ó 100,000,000) = 20,000,050
```

Il faut 20 millions de tuples morts ! C'est trop.

**Solution** :
```sql
ALTER TABLE ma_table SET (
    autovacuum_vacuum_scale_factor = 0.01,  -- 1% au lieu de 20%
    autovacuum_vacuum_threshold = 10000
);
```

#### Cause 1.4 : Transactions Longues Bloquent Autovacuum

Une transaction ouverte depuis longtemps emp√™che VACUUM de nettoyer.

```sql
-- Identifier les transactions longues
SELECT
    pid,
    usename,
    application_name,
    state,
    query_start,
    now() - query_start AS duration,
    query
FROM pg_stat_activity
WHERE state IN ('idle in transaction', 'active')
  AND (now() - query_start) > interval '10 minutes'
ORDER BY query_start;
```

**Solution** : Terminer les transactions longues :
```sql
-- Terminer gentiment
SELECT pg_cancel_backend(pid);

-- Si pas de r√©ponse, terminer brutalement
SELECT pg_terminate_backend(pid);
```

### Probl√®me 2 : Autovacuum Trop Lent

**Sympt√¥mes** :
- Autovacuum se d√©clenche mais met des heures
- Tables restent gonfl√©es pendant longtemps
- Queues de tuples morts s'accumulent

**Causes et Solutions** :

#### Cause 2.1 : Throttling Trop Agressif

```sql
SHOW autovacuum_vacuum_cost_delay;
-- Si 10ms ou plus ‚Üí tr√®s lent
```

**Solution** :
```conf
autovacuum_vacuum_cost_delay = 2ms    # D√©faut
autovacuum_vacuum_cost_limit = 400    # Double du d√©faut
```

#### Cause 2.2 : Pas Assez de Workers

```sql
SHOW autovacuum_max_workers;
-- Si 3 workers pour 5000 tables ‚Üí insuffisant
```

**Solution** :
```conf
autovacuum_max_workers = 8
autovacuum_worker_slots = 16  # PostgreSQL 18
```

#### Cause 2.3 : autovacuum_work_mem Trop Faible

```sql
SHOW autovacuum_work_mem;
-- Si -1, v√©rifie maintenance_work_mem
SHOW maintenance_work_mem;
-- Si < 256MB ‚Üí peut-√™tre insuffisant
```

**Solution** :
```conf
autovacuum_work_mem = 512MB  # Ou plus selon RAM disponible
```

### Probl√®me 3 : Transaction ID Wraparound Warning

**Sympt√¥me** : Log alarmant :
```
WARNING: database "mydb" must be vacuumed within 1234567 transactions
```

**Explication** : PostgreSQL utilise des XIDs (Transaction IDs) sur 32 bits = 2 milliards de valeurs. Si on ne VACUUM pas, on risque le wraparound (r√©utilisation des IDs anciens = corruption).

**Gravit√©** : üî¥ **CRITIQUE** - Si non trait√©, la base s'arr√™te automatiquement !

**V√©rifier l'√¢ge des bases** :
```sql
SELECT
    datname,
    age(datfrozenxid) AS xid_age,
    2147483648 - age(datfrozenxid) AS transactions_until_wraparound,
    CASE
        WHEN age(datfrozenxid) > 2000000000 THEN 'üî¥ CRITIQUE'
        WHEN age(datfrozenxid) > 1500000000 THEN 'üü† URGENT'
        WHEN age(datfrozenxid) > 1000000000 THEN 'üü° Attention'
        ELSE '‚úÖ OK'
    END AS status
FROM pg_database
ORDER BY age(datfrozenxid) DESC;
```

**Solution d'urgence** :
```sql
-- VACUUM FREEZE sur toutes les tables (peut prendre des heures)
VACUUM FREEZE;

-- Ou table par table si besoin de prioriser
VACUUM FREEZE ma_table_critique;
```

**Pr√©vention** :
```conf
# Forcer des autovacuum plus fr√©quents
autovacuum_freeze_max_age = 200000000  # D√©faut 200M (OK)
autovacuum_multixact_freeze_max_age = 400000000  # D√©faut 400M
```

### Probl√®me 4 : Bloat Malgr√© Autovacuum

**Sympt√¥me** : Autovacuum fonctionne mais les tables restent gonfl√©es.

**Cause** : VACUUM marque l'espace comme r√©utilisable mais ne le retourne PAS √† l'OS.

**V√©rification** :
```sql
-- Comparer taille th√©orique vs r√©elle
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size_on_disk,
    n_live_tup,
    ROUND(pg_total_relation_size(schemaname||'.'||tablename)::numeric / NULLIF(n_live_tup, 0)) AS bytes_per_tuple
FROM pg_stat_all_tables
WHERE schemaname = 'public'
  AND n_live_tup > 0
ORDER BY bytes_per_tuple DESC;
```

Si `bytes_per_tuple` >> 200-300, il y a du bloat.

**Solutions** :

#### Option 1 : VACUUM FULL (Bloquant)

```sql
-- ‚ö†Ô∏è BLOQUE la table pendant toute l'op√©ration
VACUUM FULL ma_table;
```

**Inconv√©nient** : Acquisition d'un verrou EXCLUSIVE (lecture/√©criture bloqu√©es).

#### Option 2 : pg_repack (Non Bloquant)

```bash
# Extension pg_repack (√† installer)
sudo apt install postgresql-18-repack

# Utilisation
pg_repack -d mydb -t ma_table
```

**Avantage** : R√©organise la table sans verrous bloquants.

#### Option 3 : Pr√©vention (Mieux)

Ajuster les seuils pour √©viter l'accumulation :
```sql
ALTER TABLE ma_table SET (
    autovacuum_vacuum_scale_factor = 0.01,  -- Plus agressif
    autovacuum_vacuum_cost_delay = 0        -- Plus rapide
);
```

---

## Configurations Recommand√©es

### Configuration Petit Serveur (Dev/Test, 8 GB RAM)

```conf
# Autovacuum - Petit serveur
autovacuum = on
autovacuum_max_workers = 3
autovacuum_naptime = 1min
autovacuum_vacuum_threshold = 50
autovacuum_vacuum_scale_factor = 0.2
autovacuum_analyze_threshold = 50
autovacuum_analyze_scale_factor = 0.1
autovacuum_vacuum_cost_delay = 2ms
autovacuum_vacuum_cost_limit = 200
autovacuum_work_mem = -1  # Utilise maintenance_work_mem
```

### Configuration Serveur Production OLTP (32 GB RAM, SSD)

```conf
# Autovacuum - Production OLTP optimis√©
autovacuum = on
autovacuum_max_workers = 6
autovacuum_naptime = 30s              # Plus r√©actif
autovacuum_vacuum_threshold = 50
autovacuum_vacuum_scale_factor = 0.05  # Plus agressif
autovacuum_analyze_threshold = 50
autovacuum_analyze_scale_factor = 0.05
autovacuum_vacuum_cost_delay = 1ms     # Plus rapide (SSD)
autovacuum_vacuum_cost_limit = 400     # Double du d√©faut
autovacuum_work_mem = 512MB

# PostgreSQL 18
autovacuum_worker_slots = 12           # Double des workers
```

### Configuration Data Warehouse (64 GB RAM, RAID SSD)

```conf
# Autovacuum - Data Warehouse
autovacuum = on
autovacuum_max_workers = 8
autovacuum_naptime = 1min
autovacuum_vacuum_threshold = 1000     # Tables massives
autovacuum_vacuum_scale_factor = 0.02  # 2% seulement
autovacuum_analyze_threshold = 1000
autovacuum_analyze_scale_factor = 0.05
autovacuum_vacuum_cost_delay = 0       # Pas de throttling (fen√™tre nuit)
autovacuum_vacuum_cost_limit = 1000
autovacuum_work_mem = 2GB              # Beaucoup de m√©moire

# PostgreSQL 18
autovacuum_worker_slots = 16
autovacuum_vacuum_max_threshold = 10000000  # Plafonner √† 10M tuples morts
```

### Configuration Haute Charge (Serveur E-commerce, 100+ GB RAM)

```conf
# Autovacuum - Tr√®s haute charge
autovacuum = on
autovacuum_max_workers = 10
autovacuum_naptime = 20s               # Tr√®s r√©actif
autovacuum_vacuum_threshold = 100
autovacuum_vacuum_scale_factor = 0.01  # 1% tr√®s agressif
autovacuum_analyze_threshold = 50
autovacuum_analyze_scale_factor = 0.02
autovacuum_vacuum_cost_delay = 0       # Aucun throttling
autovacuum_vacuum_cost_limit = 2000
autovacuum_work_mem = 1GB

# PostgreSQL 18
autovacuum_worker_slots = 20
autovacuum_vacuum_max_threshold = 5000000
```

---

## Strat√©gies Avanc√©es

### 1. Autovacuum par Plage Horaire

**Probl√®me** : Autovacuum consomme des ressources en pleine journ√©e.

**Solution** : Script pour ajuster dynamiquement selon l'heure.

```bash
#!/bin/bash
# /etc/cron.d/autovacuum-tuning

# √Ä 8h (d√©but journ√©e) : ralentir autovacuum
0 8 * * * postgres psql -c "ALTER SYSTEM SET autovacuum_vacuum_cost_delay = 10; SELECT pg_reload_conf();"

# √Ä 20h (fin journ√©e) : acc√©l√©rer autovacuum
0 20 * * * postgres psql -c "ALTER SYSTEM SET autovacuum_vacuum_cost_delay = 1; SELECT pg_reload_conf();"

# √Ä 23h (nuit) : mode agressif
0 23 * * * postgres psql -c "ALTER SYSTEM SET autovacuum_vacuum_cost_delay = 0; SELECT pg_reload_conf();"
```

### 2. VACUUM Manuel Compl√©mentaire

Pour les tables critiques, combiner autovacuum + VACUUM manuel programm√© :

```bash
#!/bin/bash
# VACUUM nocturne des tables critiques

# Chaque nuit √† 2h
psql -d production -c "VACUUM ANALYZE orders;"
psql -d production -c "VACUUM ANALYZE customers;"
psql -d production -c "VACUUM ANALYZE transactions;"
```

**Avantage** : Garantir que les tables importantes sont toujours propres.

### 3. Monitoring et Alerting

**M√©triques √† Surveiller** :

1. **Tables avec > 20% tuples morts**
```sql
-- Alerte si dead_pct > 20%
SELECT COUNT(*)
FROM pg_stat_all_tables
WHERE n_dead_tup::float / NULLIF(n_live_tup, 0) > 0.2;
```

2. **Tables jamais nettoy√©es depuis 24h**
```sql
-- Alerte si last_autovacuum > 24h
SELECT COUNT(*)
FROM pg_stat_all_tables
WHERE last_autovacuum < now() - interval '24 hours'
  AND n_live_tup > 1000;
```

3. **Transaction ID Age**
```sql
-- Alerte si age > 1 milliard
SELECT COUNT(*)
FROM pg_database
WHERE age(datfrozenxid) > 1000000000;
```

**Int√©gration Prometheus** :
```yaml
# prometheus.yml
- job_name: 'postgresql'
  static_configs:
    - targets: ['localhost:9187']
  metrics_path: /metrics

# Alertes
groups:
- name: postgresql_autovacuum
  rules:
  - alert: HighDeadTuples
    expr: pg_stat_user_tables_n_dead_tup / pg_stat_user_tables_n_live_tup > 0.2
    for: 1h
    annotations:
      summary: "Table {{ $labels.relname }} has high dead tuple ratio"
```

---

## Checklist Autovacuum

### ‚úÖ Configuration Minimale (Obligatoire)

- [ ] `autovacuum = on` (TOUJOURS)
- [ ] `log_autovacuum_min_duration = 0` (pour monitoring)
- [ ] Ajuster `autovacuum_vacuum_scale_factor` pour grandes tables
- [ ] V√©rifier r√©guli√®rement `pg_stat_all_tables`

### ‚úÖ Configuration Production Standard

- [ ] `autovacuum_max_workers` ajust√© selon nombre de tables
- [ ] `autovacuum_naptime` r√©duit pour bases actives
- [ ] `autovacuum_vacuum_cost_delay` optimis√© pour SSD
- [ ] Configuration par table pour tables critiques
- [ ] Monitoring avec alertes

### ‚úÖ Configuration Avanc√©e

- [ ] PostgreSQL 18 : `autovacuum_worker_slots` configur√©
- [ ] PostgreSQL 18 : `autovacuum_vacuum_max_threshold` pour tr√®s grandes tables
- [ ] `autovacuum_work_mem` augment√© si RAM disponible
- [ ] Scripts de tuning par plage horaire
- [ ] pg_repack install√© pour maintenance d'urgence
- [ ] Dashboard monitoring temps r√©el

---

## R√©sum√© et Points Cl√©s

### üéØ L'Essentiel √† Retenir

1. **Autovacuum est OBLIGATOIRE**
   - Ne JAMAIS d√©sactiver `autovacuum = off` en production
   - Risque de bloat extr√™me et de transaction ID wraparound

2. **Le Param√®tre Critique : `autovacuum_vacuum_scale_factor`**
   - D√©faut 0.2 (20%) est trop √©lev√© pour grandes tables
   - R√©duire √† 0.01-0.05 (1-5%) pour tables > 1M lignes

3. **Configuration Par Table**
   - Une taille unique ne convient pas √† toutes les tables
   - Utiliser `ALTER TABLE ... SET (autovacuum_...)` pour tables sp√©cifiques

4. **Nouveaut√©s PostgreSQL 18**
   - `autovacuum_worker_slots` : Meilleure gestion des pics
   - `autovacuum_vacuum_max_threshold` : Plafonner les seuils extr√™mes
   - Statistiques enrichies pour meilleur monitoring

5. **Monitoring Continu**
   - Surveiller `n_dead_tup` et `dead_pct`
   - V√©rifier `last_autovacuum` r√©guli√®rement
   - Alertes sur XID age > 1 milliard

6. **En Cas de Probl√®me**
   - Bloat : VACUUM FULL (bloquant) ou pg_repack (non bloquant)
   - Transactions longues : Identifier et terminer
   - XID wraparound : VACUUM FREEZE d'urgence

### üìä Formule de D√©clenchement (Rappel)

```
Autovacuum se d√©clenche quand :
n_dead_tup > (threshold + scale_factor √ó n_live_tup)

D√©faut : 50 + 0.2 √ó n_live_tup
Recommand√© grandes tables : 10000 + 0.01 √ó n_live_tup
```

### üîç Requ√™te de Sanity Check Quotidien

```sql
SELECT
    schemaname || '.' || tablename AS table,
    n_live_tup AS live,
    n_dead_tup AS dead,
    ROUND(100.0 * n_dead_tup / NULLIF(n_live_tup + n_dead_tup, 0), 1) AS dead_pct,
    last_autovacuum,
    CASE
        WHEN n_dead_tup::float / NULLIF(n_live_tup, 0) > 0.2 THEN 'üî¥ URGENT'
        WHEN n_dead_tup::float / NULLIF(n_live_tup, 0) > 0.1 THEN 'üü† Attention'
        ELSE '‚úÖ OK'
    END AS status
FROM pg_stat_all_tables
WHERE schemaname = 'public' AND n_live_tup > 0
ORDER BY dead_pct DESC NULLS LAST
LIMIT 20;
```

---

## Pour Aller Plus Loin

### Documentation Officielle
- [Routine Vacuuming](https://www.postgresql.org/docs/18/routine-vacuuming.html)
- [Autovacuum Daemon](https://www.postgresql.org/docs/18/runtime-config-autovacuum.html)
- [Preventing Transaction ID Wraparound](https://www.postgresql.org/docs/18/routine-vacuuming.html#VACUUM-FOR-WRAPAROUND)

### Articles Techniques
- "Understanding Autovacuum" - Percona Blog
- "Tuning Autovacuum for High-Throughput Workloads" - 2ndQuadrant
- "PostgreSQL Bloat and VACUUM Deep Dive" - CrunchyData

### Outils
- **pg_stat_all_tables** : Vue syst√®me principale
- **pgstattuple** : Extension pour analyse pr√©cise du bloat
- **pg_repack** : R√©organisation non bloquante
- **pgBadger** : Analyse logs autovacuum
- **check_postgres** : Monitoring et alerting

### Extensions Utiles
```sql
-- Analyse pr√©cise du bloat
CREATE EXTENSION pgstattuple;
SELECT * FROM pgstattuple('ma_table');

-- Estimation rapide du bloat
CREATE EXTENSION pg_freespacemap;
```

---

## Conclusion

L'autovacuum est le **syst√®me immunitaire** de PostgreSQL. Sans lui, votre base de donn√©es se d√©t√©riore progressivement jusqu'√† devenir inutilisable. Mais mal configur√©, il peut √™tre inefficace ou consommer trop de ressources.

**Les cl√©s du succ√®s** :
1. ‚úÖ Ne jamais d√©sactiver l'autovacuum
2. üéØ Ajuster `scale_factor` selon la taille des tables
3. üëÄ Monitorer r√©guli√®rement avec `pg_stat_all_tables`
4. ‚ö° Profiter des nouveaut√©s PostgreSQL 18 pour plus de flexibilit√©
5. üîß Configuration par table pour les cas sp√©cifiques

Avec une configuration appropri√©e et un monitoring attentif, l'autovacuum maintient votre base de donn√©es en excellente sant√©, sans intervention manuelle constante.

**Prochaine √©tape** : Dans la section suivante, nous explorerons les strat√©gies de sauvegarde et restauration, compl√©ments essentiels de l'autovacuum pour garantir la durabilit√© de vos donn√©es !

---


‚è≠Ô∏è [PGTune et outils d'aide √† la configuration](/16-administration-configuration-securite/13.5-pgtune-outils-aide.md)
