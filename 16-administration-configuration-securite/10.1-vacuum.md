üîù Retour au [Sommaire](/SOMMAIRE.md)

# 16.10.1. VACUUM : R√©cup√©ration d'espace et pr√©vention XID wraparound

## Introduction : Pourquoi VACUUM existe-t-il ?

PostgreSQL utilise un m√©canisme appel√© **MVCC** (Multiversion Concurrency Control) pour g√©rer la concurrence entre les transactions. Ce m√©canisme permet √† plusieurs utilisateurs de lire et modifier des donn√©es simultan√©ment sans se bloquer mutuellement.

### Le principe de MVCC en quelques mots

Quand vous **mettez √† jour** ou **supprimez** une ligne dans PostgreSQL, la base de donn√©es ne supprime pas imm√©diatement l'ancienne version de la ligne. Au lieu de cela :

- L'ancienne version est **marqu√©e comme obsol√®te** (on dit qu'elle devient un "tuple mort" ou *dead tuple*)
- Une nouvelle version de la ligne est cr√©√©e (pour un UPDATE)
- Les transactions en cours peuvent encore voir l'ancienne version si n√©cessaire

**Cons√©quence importante** : Les anciennes versions s'accumulent et occupent de l'espace disque !

### Exemple concret

Imaginons une table `clients` :

```sql
-- √âtat initial
id | nom      | email
1  | Alice    | alice@exemple.com

-- Vous faites un UPDATE
UPDATE clients SET email = 'alice.nouveau@exemple.com' WHERE id = 1;

-- En r√©alit√©, PostgreSQL conserve temporairement :
-- Ancienne version (marqu√©e comme morte) :
1  | Alice    | alice@exemple.com

-- Nouvelle version (visible) :
1  | Alice    | alice.nouveau@exemple.com
```

Si vous faites 1000 mises √† jour sur cette m√™me ligne, vous aurez 1000 versions "mortes" qui encombrent votre base !

C'est l√† qu'intervient **VACUUM**.

---

## Qu'est-ce que VACUUM ?

**VACUUM** est une op√©ration de maintenance essentielle qui :

1. **R√©cup√®re l'espace disque** occup√© par les lignes mortes (dead tuples)
2. **Pr√©vient un probl√®me critique** appel√© "transaction ID wraparound"
3. **Met √† jour les statistiques** de visibilit√© des pages

### Analogie simple

Imaginez votre base de donn√©es comme un grand classeur :
- Quand vous modifiez un document, vous ne d√©chirez pas l'ancien, vous le rayez et ajoutez le nouveau
- Avec le temps, le classeur se remplit de documents ray√©s qui prennent de la place
- **VACUUM** est comme une op√©ration de nettoyage qui retire physiquement les documents ray√©s pour r√©cup√©rer de l'espace

---

## 1. R√©cup√©ration d'espace disque

### Pourquoi l'espace disque augmente-t-il ?

Les op√©rations qui cr√©ent des lignes mortes :

- **UPDATE** : Cr√©e une nouvelle version, l'ancienne devient morte
- **DELETE** : Marque la ligne comme morte (elle n'est pas imm√©diatement supprim√©e !)
- **Transactions annul√©es (ROLLBACK)** : Les lignes cr√©√©es/modifi√©es deviennent mortes

### Comment VACUUM r√©cup√®re l'espace

Quand vous ex√©cutez VACUUM, PostgreSQL :

1. **Parcourt les tables** pour identifier les lignes mortes
2. **Marque l'espace comme r√©utilisable** (mais ne le rend pas imm√©diatement au syst√®me d'exploitation)
3. **Met √† jour les index** pour retirer les r√©f√©rences aux lignes mortes
4. **Permet la r√©utilisation** de cet espace pour de nouvelles insertions

### Les diff√©rents types de VACUUM

#### a) VACUUM simple (standard)

```sql
VACUUM;  -- Sur toute la base de donn√©es
VACUUM nom_table;  -- Sur une table sp√©cifique
```

**Caract√©ristiques** :
- R√©cup√®re l'espace mais **ne le rend pas au syst√®me d'exploitation**
- L'espace est marqu√© comme "r√©utilisable" dans la table
- **Rapide** et **non bloquant** (la table reste accessible en lecture/√©criture)
- Peut tourner en arri√®re-plan

**Quand l'utiliser** : C'est la maintenance quotidienne normale, souvent g√©r√©e automatiquement par *autovacuum*.

#### b) VACUUM FULL

```sql
VACUUM FULL nom_table;
```

**Caract√©ristiques** :
- **R√©√©crit compl√®tement la table** et ses index
- **Rend l'espace au syst√®me d'exploitation**
- **Tr√®s lent** et **bloquant** (pose un verrou exclusif, aucune lecture/√©criture possible)
- N√©cessite de l'espace disque temporaire (jusqu'√† 2√ó la taille de la table)

**Quand l'utiliser** : Seulement en cas de "bloat" extr√™me (table tr√®s gonfl√©e) et en dehors des heures de production.

‚ö†Ô∏è **Attention** : VACUUM FULL est une op√©ration lourde, √† utiliser avec pr√©caution !

#### c) VACUUM ANALYZE

```sql
VACUUM ANALYZE nom_table;
```

Combine VACUUM avec ANALYZE (mise √† jour des statistiques du planificateur de requ√™tes).

**Avantage** : Optimise √† la fois l'espace disque ET les performances des requ√™tes.

### Exemple de situation r√©elle

```sql
-- Vous avez une table "logs" avec beaucoup de suppressions quotidiennes
CREATE TABLE logs (
    id SERIAL PRIMARY KEY,
    message TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Insertion de 1 million de lignes
INSERT INTO logs (message)
SELECT 'Message ' || i FROM generate_series(1, 1000000) AS i;

-- Suppression de 900 000 lignes anciennes
DELETE FROM logs WHERE id < 900000;

-- √Ä ce stade, vous avez 900 000 lignes mortes !
-- La table occupe toujours l'espace des 1 million de lignes

-- Solution : VACUUM
VACUUM ANALYZE logs;

-- R√©sultat : L'espace des 900 000 lignes est maintenant r√©utilisable
-- Les nouvelles insertions utiliseront cet espace "lib√©r√©"
```

### V√©rifier le "bloat" (gonflement) d'une table

Le bloat est le ratio entre l'espace r√©ellement utilis√© et l'espace occup√© sur disque.

```sql
-- Voir la taille d'une table
SELECT pg_size_pretty(pg_total_relation_size('logs'));

-- Requ√™te simplifi√©e pour estimer le bloat
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
    n_dead_tup AS dead_tuples,
    n_live_tup AS live_tuples,
    ROUND(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS dead_ratio_pct
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY n_dead_tup DESC;
```

**Indicateurs** :
- `dead_ratio_pct > 20%` ‚Üí Il est temps de lancer un VACUUM
- `dead_ratio_pct > 50%` ‚Üí Situation critique, VACUUM urgent

---

## 2. Pr√©vention du XID Wraparound (Transaction ID Wraparound)

### Qu'est-ce qu'un Transaction ID (XID) ?

Chaque transaction dans PostgreSQL re√ßoit un **identifiant unique** appel√© **Transaction ID** (XID).

- C'est un **nombre entier 32 bits**
- Plage : de 0 √† environ 4 milliards (2^32)
- Utilis√© pour d√©terminer la **visibilit√© des lignes** (quelle transaction peut voir quelle version d'une ligne)

### Le probl√®me du wraparound

Imaginez un compteur qui va de 0 √† 4 milliards :

```
Transaction 1 ‚Üí XID = 1
Transaction 2 ‚Üí XID = 2
...
Transaction 4 000 000 000 ‚Üí XID = 4 000 000 000
Transaction 4 000 000 001 ‚Üí XID = ... 0 (retour au d√©but !)
```

**Le drame** : Quand le compteur fait le tour (wraparound), PostgreSQL ne peut plus d√©terminer correctement quelles donn√©es sont "anciennes" ou "r√©centes" !

### Cons√©quence catastrophique : Perte de donn√©es

Si le wraparound se produit sans intervention :
- PostgreSQL ne peut plus savoir quelles lignes doivent √™tre visibles
- Les anciennes lignes pourraient soudainement appara√Ætre comme "futures"
- **Perte totale de coh√©rence des donn√©es**

Pour √©viter ce d√©sastre, PostgreSQL arr√™tera automatiquement la base de donn√©es avant le wraparound.

### Comment VACUUM pr√©vient le wraparound

VACUUM "g√®le" (freeze) les anciennes lignes :

1. **Freezing** : VACUUM marque les anciennes transactions comme "infiniment dans le pass√©"
2. Une ligne "gel√©e" est visible par **toutes les transactions futures**, quel que soit leur XID
3. Cela lib√®re des XIDs pour de nouvelles transactions

### Illustration simplifi√©e

```
Ligne cr√©√©e par XID 100 :
‚îú‚îÄ Initialement visible uniquement pour XID > 100
‚îî‚îÄ Apr√®s VACUUM (freeze) ‚Üí visible par TOUTES les transactions (XID quelconque)
```

### Param√®tres critiques

PostgreSQL a des seuils de s√©curit√© :

```sql
-- Voir les param√®tres de wraparound
SHOW autovacuum_freeze_max_age;  -- Par d√©faut : 200 millions de transactions
SHOW vacuum_freeze_min_age;      -- Par d√©faut : 50 millions de transactions
```

**Explications** :

- **`autovacuum_freeze_max_age`** : Nombre maximum de transactions avant qu'un VACUUM "freeze" soit d√©clench√© automatiquement
- **`vacuum_freeze_min_age`** : √Çge minimum d'une transaction avant qu'elle puisse √™tre "gel√©e"

### Surveiller l'√©tat du wraparound

```sql
-- V√©rifier l'√¢ge des transactions par table
SELECT
    schemaname,
    tablename,
    age(relfrozenxid) AS xid_age,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_stat_user_tables
JOIN pg_class ON relname = tablename
ORDER BY age(relfrozenxid) DESC
LIMIT 10;
```

**Interpr√©tation** :
- `xid_age < 100 millions` ‚Üí Situation normale
- `xid_age > 150 millions` ‚Üí Surveiller de pr√®s
- `xid_age > 180 millions` ‚Üí Action urgente requise

### Que faire en cas d'alerte wraparound ?

1. **Vacuum manuel imm√©diat** :
   ```sql
   VACUUM FREEZE nom_table;
   ```

2. **Pour toute la base** :
   ```sql
   VACUUMDB --all --freeze
   ```

3. **En cas de blocage imminent**, PostgreSQL affiche des messages d'avertissement dans les logs :
   ```
   WARNING: database "mydb" must be vacuumed within 1000000 transactions
   ERROR: database is not accepting commands to avoid wraparound data loss
   ```

---

## Autovacuum : Le gardien automatique

Heureusement, vous n'avez g√©n√©ralement pas √† lancer VACUUM manuellement !

### Qu'est-ce que l'Autovacuum ?

**Autovacuum** est un processus d'arri√®re-plan qui :
- **Lance automatiquement VACUUM** sur les tables qui en ont besoin
- **Surveille le XID wraparound** et lance des VACUUM pr√©ventifs
- **Ajuste dynamiquement** sa fr√©quence selon l'activit√© de la base

### Configuration par d√©faut

```sql
-- Voir si autovacuum est activ√©
SHOW autovacuum;  -- Devrait √™tre 'on' (activ√© par d√©faut)

-- Param√®tres principaux
SHOW autovacuum_vacuum_threshold;         -- 50 lignes mortes minimum
SHOW autovacuum_vacuum_scale_factor;      -- 0.2 (20% de la table)
SHOW autovacuum_vacuum_cost_delay;        -- 2 ms (throttling)
SHOW autovacuum_naptime;                  -- 1 min (fr√©quence de r√©veil)
```

### Comment autovacuum d√©cide-t-il de lancer un VACUUM ?

Formule simplifi√©e :
```
Seuil = autovacuum_vacuum_threshold + (autovacuum_vacuum_scale_factor √ó nombre_total_de_lignes)
```

**Exemple** :
- Table avec 1 000 000 de lignes
- Seuil = 50 + (0.2 √ó 1 000 000) = **200 050 lignes mortes**
- Autovacuum se d√©clenche quand il y a plus de 200 050 lignes mortes

### Nouveaut√©s PostgreSQL 18 : Autovacuum am√©lior√©

#### 1. Ajustements dynamiques
PostgreSQL 18 ajuste automatiquement le nombre de workers autovacuum selon la charge :

```sql
-- Nouveau param√®tre dans PG 18
SHOW autovacuum_worker_slots;  -- Allocation dynamique de workers
```

#### 2. Nouveau param√®tre : autovacuum_vacuum_max_threshold

```sql
SHOW autovacuum_vacuum_max_threshold;  -- Nouveau dans PG 18
```

Ce param√®tre permet de **plafonner** le seuil de d√©clenchement pour les tr√®s grandes tables, √©vitant d'attendre trop longtemps avant le VACUUM.

### Surveiller l'activit√© de l'autovacuum

```sql
-- Voir les autovacuum en cours
SELECT
    pid,
    usename,
    query_start,
    state,
    query
FROM pg_stat_activity
WHERE query LIKE '%autovacuum%'
  AND query NOT LIKE '%pg_stat_activity%';

-- Historique des derniers autovacuum (nouveau dans PG 18)
SELECT
    schemaname,
    tablename,
    last_vacuum,
    last_autovacuum,
    vacuum_count,
    autovacuum_count
FROM pg_stat_all_tables
WHERE schemaname = 'public'
ORDER BY last_autovacuum DESC NULLS LAST;
```

---

## Bonnes pratiques

### 1. Faire confiance √† l'autovacuum

Dans 95% des cas, **autovacuum suffit** :
- ‚úÖ Activ√© par d√©faut
- ‚úÖ Fonctionne en arri√®re-plan
- ‚úÖ S'adapte √† la charge

**Ne d√©sactivez JAMAIS autovacuum** sauf si vous savez exactement ce que vous faites !

### 2. Quand lancer un VACUUM manuel

Situations o√π un VACUUM manuel est justifi√© :
- **Apr√®s une grosse op√©ration de suppression/mise √† jour** (ex : purge de 50% de la table)
- **Avant une op√©ration critique** (migration, export)
- **En cas d'alerte XID wraparound**

### 3. Surveiller r√©guli√®rement

Mettez en place un monitoring sur :
- **Le bloat des tables** (ratio dead tuples)
- **L'√¢ge XID** (`age(relfrozenxid)`)
- **L'activit√© autovacuum** (logs, pg_stat_activity)

### 4. Ajuster autovacuum pour les tables √† forte activit√©

Pour une table tr√®s sollicit√©e :

```sql
-- Rendre autovacuum plus agressif sur une table sp√©cifique
ALTER TABLE logs SET (
    autovacuum_vacuum_scale_factor = 0.05,  -- 5% au lieu de 20%
    autovacuum_vacuum_threshold = 1000      -- Plus r√©actif
);
```

### 5. VACUUM FULL : En dernier recours

N'utilisez **VACUUM FULL** que si :
- Le bloat est **extr√™me** (>50%)
- Vous pouvez vous permettre un **downtime** (verrou exclusif)
- Vous avez l'**espace disque n√©cessaire** (2√ó la taille de la table)

**Alternative moderne** : `pg_repack` (extension qui r√©organise sans verrou exclusif)

---

## R√©sum√©

### VACUUM en 5 points cl√©s

1. **R√©cup√©ration d'espace** : Lib√®re l'espace occup√© par les lignes mortes (UPDATE, DELETE)
2. **Pr√©vention XID wraparound** : √âvite une catastrophe de perte de donn√©es
3. **Autovacuum** : Processus automatique qui g√®re tout cela pour vous
4. **VACUUM simple** : Non bloquant, √† utiliser r√©guli√®rement (ou via autovacuum)
5. **VACUUM FULL** : Bloquant, seulement en cas de bloat extr√™me

### Checklist de maintenance

‚úÖ **V√©rifier que autovacuum est activ√©** :
```sql
SHOW autovacuum;  -- Doit √™tre 'on'
```

‚úÖ **Surveiller les tables √† forte activit√©** :
```sql
SELECT * FROM pg_stat_user_tables WHERE n_dead_tup > 10000;
```

‚úÖ **Surveiller l'√¢ge XID** :
```sql
SELECT max(age(relfrozenxid)) FROM pg_class WHERE relkind = 'r';
-- Alerte si > 150 millions
```

‚úÖ **Logs d'autovacuum** : Configurer `log_autovacuum_min_duration = 0` pour tracer tous les autovacuum

---

## Concepts avanc√©s (Bonus)

### Visibility Map et FSM

PostgreSQL utilise deux structures annexes pour optimiser VACUUM :

1. **Visibility Map (VM)** :
   - Carte des pages o√π toutes les lignes sont visibles par toutes les transactions
   - Permet √† VACUUM de **sauter les pages propres**
   - Optimise les scans et les index-only scans

2. **Free Space Map (FSM)** :
   - Carte de l'espace libre dans chaque page
   - Permet d'ins√©rer rapidement de nouvelles lignes dans l'espace r√©cup√©r√©

### VACUUM VERBOSE : Mode bavard

Pour voir ce que fait VACUUM en d√©tail :

```sql
VACUUM VERBOSE nom_table;
```

Affiche :
- Nombre de pages scann√©es
- Nombre de lignes mortes r√©cup√©r√©es
- Espace lib√©r√©
- Temps d'ex√©cution

---

## Conclusion

**VACUUM** est une op√©ration fondamentale de PostgreSQL qui garantit :
- üöÄ **Performances optimales** en r√©cup√©rant l'espace disque
- üõ°Ô∏è **Stabilit√© de la base** en pr√©venant le XID wraparound
- ü§ñ **Automatisation** via autovacuum pour une maintenance sans intervention

En tant que d√©veloppeur ou DevOps d√©butant, retenez :
- **Autovacuum fait le travail pour vous**, ne le d√©sactivez pas
- **Surveillez vos tables √† forte activit√©** (bloat et XID age)
- **VACUUM manuel** uniquement apr√®s de grosses op√©rations de masse
- **VACUUM FULL** est une arme √† double tranchant, √† utiliser avec pr√©caution

PostgreSQL 18 apporte des am√©liorations significatives √† l'autovacuum, le rendant encore plus intelligent et r√©actif. Avec une bonne compr√©hension de VACUUM, vous √©viterez 99% des probl√®mes de maintenance courants !

---

**Prochaines √©tapes recommand√©es** :
- D√©couvrir **ANALYZE** (16.10.2) : Mise √† jour des statistiques du planificateur
- Explorer **les strat√©gies de monitoring** (Chapitre 14)
- Approfondir **la configuration autovacuum** pour vos cas d'usage sp√©cifiques

---


‚è≠Ô∏è [ANALYZE : Mise √† jour des statistiques du planificateur](/16-administration-configuration-securite/10.2-analyze.md)
