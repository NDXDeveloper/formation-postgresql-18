üîù Retour au [Sommaire](/SOMMAIRE.md)

# 16.4.1. Permissions sur Objets (TABLE, SEQUENCE, FUNCTION)

## Introduction

Dans PostgreSQL, la gestion des permissions sur les objets de la base de donn√©es est essentielle pour assurer la s√©curit√© et contr√¥ler l'acc√®s aux donn√©es. Apr√®s avoir cr√©√© des utilisateurs (r√¥les) et leur avoir donn√© acc√®s √† une base de donn√©es, il faut d√©finir pr√©cis√©ment ce qu'ils peuvent faire sur chaque objet : lire des donn√©es, les modifier, ex√©cuter des fonctions, etc.

Cette section explique comment accorder et r√©voquer des permissions sur trois types d'objets fondamentaux : les tables, les s√©quences et les fonctions.

---

## Concept de Base : GRANT et REVOKE

PostgreSQL utilise deux commandes principales pour g√©rer les permissions :

- **GRANT** : Accorder des permissions √† un r√¥le
- **REVOKE** : Retirer des permissions √† un r√¥le

### Syntaxe G√©n√©rale

```sql
-- Accorder une permission
GRANT permission ON objet TO role;

-- R√©voquer une permission
REVOKE permission ON objet FROM role;
```

### Principe Important : Les Permissions sont Additives

Par d√©faut, un r√¥le n'a **aucune permission** sur les objets qu'il ne poss√®de pas. Il faut explicitement lui accorder chaque permission n√©cessaire. C'est le principe du **moindre privil√®ge** : donner uniquement les droits n√©cessaires, pas plus.

---

## 1. Permissions sur les TABLES

Les tables sont les objets les plus courants dans une base de donn√©es. PostgreSQL propose plusieurs niveaux de permissions pour contr√¥ler l'acc√®s aux donn√©es.

### 1.1. Les Diff√©rents Types de Permissions

| Permission | Description | Cas d'usage |
|------------|-------------|-------------|
| **SELECT** | Lire les donn√©es (requ√™tes SELECT) | Utilisateurs en lecture seule, rapports, dashboards |
| **INSERT** | Ins√©rer de nouvelles lignes | Applications qui cr√©ent des enregistrements |
| **UPDATE** | Modifier des lignes existantes | Applications qui mettent √† jour des donn√©es |
| **DELETE** | Supprimer des lignes | Applications qui g√®rent la suppression de donn√©es |
| **TRUNCATE** | Vider compl√®tement une table | Maintenance, r√©initialisation de donn√©es |
| **REFERENCES** | Cr√©er des cl√©s √©trang√®res r√©f√©ren√ßant cette table | Mod√©lisation de relations entre tables |
| **TRIGGER** | Cr√©er des triggers sur la table | Automatisation avanc√©e, audit |
| **ALL PRIVILEGES** | Toutes les permissions ci-dessus | Propri√©taire ou administrateur de la table |

### 1.2. Exemples Pratiques

#### Exemple 1 : Accorder la Lecture Seule

Imaginons un utilisateur `lecteur` qui doit uniquement consulter les donn√©es de la table `clients` :

```sql
-- Cr√©er l'utilisateur
CREATE ROLE lecteur LOGIN PASSWORD 'mot_de_passe_securise';

-- Accorder la permission de lecture
GRANT SELECT ON TABLE clients TO lecteur;
```

Maintenant, `lecteur` peut faire :
```sql
SELECT * FROM clients;
SELECT nom, email FROM clients WHERE ville = 'Paris';
```

Mais il **ne peut pas** faire :
```sql
INSERT INTO clients VALUES (...);  -- ‚ùå Erreur : permission refus√©e
UPDATE clients SET email = '...';  -- ‚ùå Erreur : permission refus√©e
DELETE FROM clients WHERE id = 1;  -- ‚ùå Erreur : permission refus√©e
```

#### Exemple 2 : Accorder Lecture et √âcriture

Un utilisateur `application` doit pouvoir lire et modifier les donn√©es :

```sql
-- Cr√©er l'utilisateur
CREATE ROLE application LOGIN PASSWORD 'mot_de_passe_securise';

-- Accorder lecture, insertion et mise √† jour
GRANT SELECT, INSERT, UPDATE ON TABLE clients TO application;
```

Maintenant, `application` peut :
- Lire les donn√©es (SELECT)
- Ajouter de nouveaux clients (INSERT)
- Modifier les clients existants (UPDATE)

Mais il **ne peut toujours pas** supprimer de donn√©es (DELETE).

#### Exemple 3 : Accorder Toutes les Permissions

Pour un administrateur qui doit avoir un contr√¥le total :

```sql
-- Cr√©er l'administrateur
CREATE ROLE admin_app LOGIN PASSWORD 'mot_de_passe_securise';

-- Accorder toutes les permissions
GRANT ALL PRIVILEGES ON TABLE clients TO admin_app;
```

#### Exemple 4 : Permissions sur Plusieurs Tables

Accorder des permissions sur plusieurs tables en une seule commande :

```sql
-- Accorder SELECT sur plusieurs tables
GRANT SELECT ON TABLE clients, commandes, produits TO lecteur;

-- Accorder plusieurs permissions sur plusieurs tables
GRANT SELECT, INSERT, UPDATE ON TABLE clients, commandes TO application;
```

#### Exemple 5 : Permissions sur Toutes les Tables d'un Sch√©ma

Pour accorder des permissions sur toutes les tables d'un sch√©ma :

```sql
-- Accorder SELECT sur toutes les tables du sch√©ma public
GRANT SELECT ON ALL TABLES IN SCHEMA public TO lecteur;

-- Accorder plusieurs permissions sur toutes les tables
GRANT SELECT, INSERT, UPDATE ON ALL TABLES IN SCHEMA public TO application;
```

### 1.3. Permissions au Niveau des Colonnes

PostgreSQL permet √©galement de limiter les permissions √† certaines colonnes sp√©cifiques d'une table. C'est utile pour prot√©ger des donn√©es sensibles.

#### Exemple : Masquer des Colonnes Sensibles

Imaginons une table `employes` avec des informations sensibles :

```sql
CREATE TABLE employes (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    prenom VARCHAR(100),
    email VARCHAR(150),
    salaire NUMERIC(10, 2),  -- Donn√©e sensible
    numero_securite_sociale VARCHAR(15)  -- Donn√©e tr√®s sensible
);
```

Un utilisateur RH doit voir les noms et emails, mais pas les salaires :

```sql
-- Accorder SELECT uniquement sur certaines colonnes
GRANT SELECT (id, nom, prenom, email) ON TABLE employes TO utilisateur_rh;
```

Maintenant, `utilisateur_rh` peut faire :
```sql
SELECT id, nom, prenom, email FROM employes;  -- ‚úÖ OK
```

Mais il **ne peut pas** faire :
```sql
SELECT salaire FROM employes;  -- ‚ùå Erreur : permission refus√©e
SELECT * FROM employes;  -- ‚ùå Erreur : permission refus√©e (inclut des colonnes interdites)
```

### 1.4. R√©voquer des Permissions

Pour retirer des permissions pr√©c√©demment accord√©es :

```sql
-- R√©voquer une permission sp√©cifique
REVOKE INSERT ON TABLE clients FROM application;

-- R√©voquer plusieurs permissions
REVOKE INSERT, UPDATE ON TABLE clients FROM application;

-- R√©voquer toutes les permissions
REVOKE ALL PRIVILEGES ON TABLE clients FROM application;
```

#### Option CASCADE

Lorsqu'on r√©voque une permission qui a √©t√© transmise √† d'autres r√¥les (via GRANT OPTION, voir plus loin), on peut utiliser CASCADE :

```sql
-- R√©voquer et supprimer les permissions d√©riv√©es
REVOKE SELECT ON TABLE clients FROM utilisateur CASCADE;

-- R√©voquer sans affecter les permissions d√©riv√©es (par d√©faut)
REVOKE SELECT ON TABLE clients FROM utilisateur RESTRICT;
```

---

## 2. Permissions sur les SEQUENCES

Les s√©quences sont des objets qui g√©n√®rent des nombres uniques, souvent utilis√©es pour les colonnes auto-incr√©ment√©es (SERIAL, IDENTITY).

### 2.1. Pourquoi G√©rer les Permissions sur les S√©quences ?

Lorsque vous cr√©ez une colonne avec `SERIAL` ou `IDENTITY`, PostgreSQL cr√©e automatiquement une s√©quence en arri√®re-plan. Pour qu'un utilisateur puisse ins√©rer des donn√©es dans une table avec une colonne auto-incr√©ment√©e, il doit avoir la permission **USAGE** sur cette s√©quence.

### 2.2. Les Permissions Disponibles

| Permission | Description | Cas d'usage |
|------------|-------------|-------------|
| **USAGE** | Utiliser la s√©quence (nextval, currval) | N√©cessaire pour INSERT dans une table avec SERIAL |
| **SELECT** | Lire la valeur actuelle de la s√©quence | Monitoring, v√©rification |
| **UPDATE** | Modifier la s√©quence (setval) | R√©initialisation, maintenance |
| **ALL PRIVILEGES** | Toutes les permissions ci-dessus | Propri√©taire ou administrateur |

### 2.3. Exemples Pratiques

#### Exemple 1 : Probl√®me Courant - Permission Manquante

Cr√©ons une table avec une colonne SERIAL :

```sql
CREATE TABLE commandes (
    id SERIAL PRIMARY KEY,
    client_id INTEGER,
    montant NUMERIC(10, 2)
);

-- PostgreSQL cr√©e automatiquement une s√©quence : commandes_id_seq
```

Un utilisateur avec INSERT sur la table, mais sans USAGE sur la s√©quence :

```sql
GRANT INSERT ON TABLE commandes TO application;

-- L'utilisateur essaie d'ins√©rer
INSERT INTO commandes (client_id, montant) VALUES (1, 100.00);
-- ‚ùå Erreur : permission refus√©e pour la s√©quence commandes_id_seq
```

#### Exemple 2 : Solution - Accorder USAGE sur la S√©quence

```sql
-- Accorder USAGE sur la s√©quence
GRANT USAGE ON SEQUENCE commandes_id_seq TO application;

-- Maintenant l'insertion fonctionne
INSERT INTO commandes (client_id, montant) VALUES (1, 100.00);  -- ‚úÖ OK
```

#### Exemple 3 : Permissions sur Toutes les S√©quences

Pour √©viter ce probl√®me, accordez USAGE sur toutes les s√©quences d'un sch√©ma :

```sql
-- Accorder USAGE sur toutes les s√©quences du sch√©ma
GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO application;
```

#### Exemple 4 : R√©initialiser une S√©quence (UPDATE)

Un administrateur doit pouvoir r√©initialiser une s√©quence :

```sql
-- Accorder UPDATE sur la s√©quence
GRANT UPDATE ON SEQUENCE commandes_id_seq TO admin_app;

-- L'administrateur peut maintenant r√©initialiser
SELECT setval('commandes_id_seq', 1, false);  -- Red√©marre √† 1
```

### 2.4. Bonne Pratique : Permissions Automatiques

Pour simplifier la gestion, on peut configurer des permissions par d√©faut sur les nouvelles s√©quences (voir section sur ALTER DEFAULT PRIVILEGES plus loin).

---

## 3. Permissions sur les FUNCTIONS

Les fonctions (et proc√©dures stock√©es) sont des blocs de code SQL ou PL/pgSQL qui peuvent √™tre ex√©cut√©s par les utilisateurs.

### 3.1. La Permission EXECUTE

Il n'y a qu'**une seule permission** sur les fonctions :

| Permission | Description | Cas d'usage |
|------------|-------------|-------------|
| **EXECUTE** | Ex√©cuter la fonction | Permettre √† un utilisateur d'appeler la fonction |

**Important** : Par d√©faut, PostgreSQL accorde automatiquement EXECUTE √† PUBLIC (tous les utilisateurs) sur les nouvelles fonctions. C'est un comportement √† surveiller pour la s√©curit√©.

### 3.2. Exemples Pratiques

#### Exemple 1 : Cr√©er et Ex√©cuter une Fonction

Cr√©ons une fonction simple :

```sql
CREATE FUNCTION calculer_tva(montant_ht NUMERIC)
RETURNS NUMERIC AS $$
BEGIN
    RETURN montant_ht * 1.20;  -- TVA √† 20%
END;
$$ LANGUAGE plpgsql;
```

Par d√©faut, **tous les utilisateurs** peuvent l'ex√©cuter :

```sql
-- N'importe quel utilisateur peut faire :
SELECT calculer_tva(100);  -- Retourne 120
```

#### Exemple 2 : Restreindre l'Acc√®s √† une Fonction

Pour limiter l'ex√©cution √† certains utilisateurs seulement :

```sql
-- R√©voquer l'acc√®s public
REVOKE EXECUTE ON FUNCTION calculer_tva(NUMERIC) FROM PUBLIC;

-- Accorder l'ex√©cution √† un utilisateur sp√©cifique
GRANT EXECUTE ON FUNCTION calculer_tva(NUMERIC) TO application;
```

Maintenant :
- `application` peut ex√©cuter la fonction ‚úÖ
- Les autres utilisateurs ne peuvent pas ‚ùå

#### Exemple 3 : Fonction avec S√©curit√© DEFINER

Les fonctions peuvent √™tre cr√©√©es avec `SECURITY DEFINER`, ce qui signifie qu'elles s'ex√©cutent avec les permissions de leur cr√©ateur, pas de l'appelant. C'est utile pour donner un acc√®s contr√¥l√© √† des donn√©es sensibles.

```sql
-- Fonction qui acc√®de √† des donn√©es sensibles
CREATE FUNCTION obtenir_salaire_moyen()
RETURNS NUMERIC
SECURITY DEFINER  -- S'ex√©cute avec les droits du cr√©ateur
AS $$
BEGIN
    RETURN (SELECT AVG(salaire) FROM employes);
END;
$$ LANGUAGE plpgsql;

-- R√©voquer l'acc√®s public
REVOKE EXECUTE ON FUNCTION obtenir_salaire_moyen() FROM PUBLIC;

-- Accorder √† un utilisateur sp√©cifique
GRANT EXECUTE ON FUNCTION obtenir_salaire_moyen() TO manager;
```

Ici, `manager` peut obtenir le salaire moyen **sans avoir acc√®s direct** √† la table `employes`. La fonction agit comme une "porte contr√¥l√©e" vers les donn√©es sensibles.

#### Exemple 4 : Permissions sur Toutes les Fonctions

Pour accorder EXECUTE sur toutes les fonctions d'un sch√©ma :

```sql
-- Accorder EXECUTE sur toutes les fonctions
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO application;
```

### 3.3. R√©voquer des Permissions sur les Fonctions

```sql
-- R√©voquer EXECUTE pour un utilisateur
REVOKE EXECUTE ON FUNCTION calculer_tva(NUMERIC) FROM application;

-- R√©voquer pour tout le monde
REVOKE EXECUTE ON FUNCTION calculer_tva(NUMERIC) FROM PUBLIC;
```

---

## 4. L'Option WITH GRANT OPTION

Cette option permet √† un utilisateur de **transmettre** les permissions qu'il a re√ßues √† d'autres utilisateurs.

### 4.1. Syntaxe

```sql
GRANT permission ON objet TO role WITH GRANT OPTION;
```

### 4.2. Exemple Pratique

```sql
-- Cr√©er un utilisateur "chef_projet"
CREATE ROLE chef_projet LOGIN PASSWORD 'mot_de_passe';

-- Lui accorder SELECT avec la possibilit√© de le transmettre
GRANT SELECT ON TABLE clients TO chef_projet WITH GRANT OPTION;

-- Maintenant, chef_projet peut donner SELECT √† d'autres
-- (en se connectant avec ce r√¥le)
GRANT SELECT ON TABLE clients TO developpeur;
```

### 4.3. Cas d'Usage

Cette option est utile dans les organisations hi√©rarchiques o√π certains utilisateurs (managers, chefs de projet) doivent pouvoir g√©rer les permissions de leur √©quipe sans intervention d'un DBA.

‚ö†Ô∏è **Attention** : Cette option doit √™tre utilis√©e avec pr√©caution, car elle dilue le contr√¥le central des permissions.

---

## 5. V√©rifier les Permissions Existantes

### 5.1. Commande \dp dans psql

Dans `psql`, la commande `\dp` (ou `\z`) affiche les permissions sur les objets :

```sql
\dp clients
```

R√©sultat exemple :
```
                              Access privileges
 Schema |  Name   | Type  |     Access privileges     | Column privileges
--------+---------+-------+---------------------------+-------------------
 public | clients | table | postgres=arwdDxt/postgres+|
        |         |       | lecteur=r/postgres       +|
        |         |       | application=arw/postgres  |
```

L√©gende des lettres :
- `a` = INSERT
- `r` = SELECT (read)
- `w` = UPDATE (write)
- `d` = DELETE
- `D` = TRUNCATE
- `x` = REFERENCES
- `t` = TRIGGER

### 5.2. Requ√™tes sur les Vues Syst√®me

Pour une analyse plus d√©taill√©e, on peut interroger les vues syst√®me :

```sql
-- Permissions sur une table sp√©cifique
SELECT
    grantee,
    privilege_type
FROM information_schema.table_privileges
WHERE table_name = 'clients';
```

R√©sultat exemple :
```
  grantee   | privilege_type
------------+----------------
 lecteur    | SELECT
 application| SELECT
 application| INSERT
 application| UPDATE
```

### 5.3. V√©rifier les Permissions d'un R√¥le Sp√©cifique

```sql
-- Toutes les permissions d'un r√¥le
SELECT
    table_schema,
    table_name,
    privilege_type
FROM information_schema.table_privileges
WHERE grantee = 'application';
```

---

## 6. Bonnes Pratiques

### 6.1. Principe du Moindre Privil√®ge

Accordez **uniquement** les permissions n√©cessaires, rien de plus. Si un utilisateur n'a besoin que de lire les donn√©es, ne lui donnez que SELECT, pas UPDATE ou DELETE.

‚ùå **Mauvaise pratique** :
```sql
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO application;
```

‚úÖ **Bonne pratique** :
```sql
-- Accorder uniquement ce qui est n√©cessaire
GRANT SELECT, INSERT, UPDATE ON TABLE clients TO application;
GRANT SELECT ON TABLE produits TO application;
```

### 6.2. Utiliser des R√¥les Groupes

Au lieu d'accorder des permissions √† chaque utilisateur individuellement, cr√©ez des r√¥les groupes :

```sql
-- Cr√©er un r√¥le groupe
CREATE ROLE lecture_seule;

-- Accorder les permissions au groupe
GRANT SELECT ON ALL TABLES IN SCHEMA public TO lecture_seule;

-- Cr√©er des utilisateurs et les ajouter au groupe
CREATE ROLE user1 LOGIN PASSWORD 'pass1';
CREATE ROLE user2 LOGIN PASSWORD 'pass2';

GRANT lecture_seule TO user1;
GRANT lecture_seule TO user2;
```

Avantages :
- Gestion centralis√©e
- Coh√©rence des permissions
- Facilit√© de maintenance

### 6.3. R√©voquer PUBLIC par D√©faut

PostgreSQL accorde automatiquement certaines permissions √† PUBLIC. Pour une s√©curit√© maximale, r√©voquez-les :

```sql
-- R√©voquer les permissions par d√©faut sur les fonctions
REVOKE EXECUTE ON ALL FUNCTIONS IN SCHEMA public FROM PUBLIC;

-- Puis accorder s√©lectivement
GRANT EXECUTE ON FUNCTION ma_fonction() TO application;
```

### 6.4. Documenter les Permissions

Documentez les raisons des permissions accord√©es, soit dans un fichier de migration, soit en commentaires :

```sql
-- R√¥le lecture_seule : Utilis√© par les analystes BI pour les rapports
CREATE ROLE lecture_seule;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO lecture_seule;

-- R√¥le application : Utilis√© par l'application web principale
CREATE ROLE application;
GRANT SELECT, INSERT, UPDATE ON TABLE clients, commandes TO application;
```

### 6.5. Audit R√©gulier des Permissions

V√©rifiez r√©guli√®rement qui a acc√®s √† quoi :

```sql
-- Lister tous les utilisateurs et leurs permissions sur une table critique
SELECT
    grantee,
    string_agg(privilege_type, ', ') AS permissions
FROM information_schema.table_privileges
WHERE table_name = 'donnees_sensibles'
GROUP BY grantee;
```

### 6.6. Automatiser avec ALTER DEFAULT PRIVILEGES

Pour que les permissions soient automatiquement accord√©es sur les nouveaux objets (voir section 16.4.3 pour les d√©tails) :

```sql
-- Les nouvelles tables cr√©√©es auront automatiquement ces permissions
ALTER DEFAULT PRIVILEGES IN SCHEMA public
GRANT SELECT ON TABLES TO lecture_seule;

ALTER DEFAULT PRIVILEGES IN SCHEMA public
GRANT USAGE ON SEQUENCES TO application;
```

---

## 7. Sc√©narios Pratiques

### Sc√©nario 1 : Application Web Standard

Une application web avec :
- Un frontend qui lit des donn√©es
- Un backend qui lit et √©crit

```sql
-- R√¥le pour le backend
CREATE ROLE app_backend LOGIN PASSWORD 'secure_password';
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE clients, commandes, produits TO app_backend;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO app_backend;

-- R√¥le pour un service de reporting (lecture seule)
CREATE ROLE app_reporting LOGIN PASSWORD 'secure_password';
GRANT SELECT ON ALL TABLES IN SCHEMA public TO app_reporting;
```

### Sc√©nario 2 : Environnement Multi-√©quipes

Une base de donn√©es partag√©e entre plusieurs √©quipes :

```sql
-- √âquipe Marketing (lecture seule)
CREATE ROLE equipe_marketing;
GRANT SELECT ON TABLE clients, campagnes TO equipe_marketing;
CREATE ROLE user_marketing LOGIN PASSWORD 'pass';
GRANT equipe_marketing TO user_marketing;

-- √âquipe Support (lecture + mise √† jour limit√©e)
CREATE ROLE equipe_support;
GRANT SELECT ON TABLE clients, tickets TO equipe_support;
GRANT UPDATE (statut, commentaire) ON TABLE tickets TO equipe_support;
CREATE ROLE user_support LOGIN PASSWORD 'pass';
GRANT equipe_support TO user_support;

-- √âquipe Dev (acc√®s complet en dev, limit√© en prod)
CREATE ROLE equipe_dev;
-- En dev : acc√®s complet
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO equipe_dev;
-- En prod : seulement lecture sur la plupart des tables
-- (√† adapter selon les besoins)
```

### Sc√©nario 3 : API avec Fonctions SECURITY DEFINER

Une API qui expose des donn√©es via des fonctions, sans acc√®s direct aux tables :

```sql
-- Les utilisateurs de l'API n'ont AUCUN acc√®s direct aux tables
REVOKE ALL ON ALL TABLES IN SCHEMA public FROM app_api;

-- Cr√©er des fonctions qui contr√¥lent l'acc√®s
CREATE FUNCTION api_get_client(p_client_id INTEGER)
RETURNS TABLE(id INTEGER, nom VARCHAR, email VARCHAR)
SECURITY DEFINER
AS $$
BEGIN
    -- Validation, logging, etc.
    RETURN QUERY
    SELECT id, nom, email FROM clients WHERE id = p_client_id;
END;
$$ LANGUAGE plpgsql;

-- Accorder uniquement EXECUTE sur les fonctions
GRANT EXECUTE ON FUNCTION api_get_client(INTEGER) TO app_api;
```

---

## Conclusion

La gestion des permissions sur les objets PostgreSQL (tables, s√©quences, fonctions) est un pilier de la s√©curit√© et de la gouvernance des donn√©es. Les points cl√©s √† retenir :

- ‚úÖ **Principe du moindre privil√®ge** : N'accordez que ce qui est n√©cessaire
- ‚úÖ **Utilisez des r√¥les groupes** : Simplifiez la gestion
- ‚úÖ **N'oubliez pas les s√©quences** : N√©cessaires pour les colonnes SERIAL
- ‚úÖ **Soyez prudent avec PUBLIC** : R√©voquez les permissions par d√©faut sur les fonctions
- ‚úÖ **Auditez r√©guli√®rement** : V√©rifiez qui a acc√®s √† quoi
- ‚úÖ **Documentez** : Expliquez pourquoi chaque permission existe

La ma√Ætrise de ces concepts vous permettra de construire des syst√®mes s√©curis√©s, maintenables et conformes aux bonnes pratiques de l'industrie.

---


‚è≠Ô∏è [Permissions de sch√©ma et database](/16-administration-configuration-securite/04.2-permissions-schema-database.md)
