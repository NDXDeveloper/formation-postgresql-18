üîù Retour au [Sommaire](/SOMMAIRE.md)

# 16.10.4. Nouveaut√© PG 18 : Nouveau param√®tre autovacuum_vacuum_max_threshold

## Introduction : Le d√©fi des grandes tables

Imaginez que vous g√©rez un entrep√¥t :
- **Petit entrep√¥t** (100 cartons) : Vous nettoyez quand il y a 20 cartons vides (20%)
- **Grand entrep√¥t** (1 million de cartons) : Attendre 200 000 cartons vides (20%) est absurde !

C'est exactement le probl√®me que PostgreSQL rencontrait avec les **grandes tables** avant la version 18. Le nouveau param√®tre `autovacuum_vacuum_max_threshold` r√©sout ce probl√®me de mani√®re √©l√©gante.

---

## Le fonctionnement classique d'autovacuum (rappel)

### La formule de d√©clenchement traditionnelle

Depuis toujours, autovacuum utilise cette formule pour d√©cider quand nettoyer une table :

```
Seuil de d√©clenchement = autovacuum_vacuum_threshold + (autovacuum_vacuum_scale_factor √ó nombre_de_lignes)
```

**Param√®tres par d√©faut** :
```sql
SHOW autovacuum_vacuum_threshold;      -- 50 lignes
SHOW autovacuum_vacuum_scale_factor;   -- 0.2 (soit 20%)
```

### Exemples de calcul

**Petite table (1 000 lignes)** :
```
Seuil = 50 + (0.2 √ó 1 000) = 50 + 200 = 250 lignes mortes
```
‚Üí Autovacuum se d√©clenche apr√®s **250 suppressions/mises √† jour**
‚Üí ‚úÖ **Raisonnable**

**Table moyenne (100 000 lignes)** :
```
Seuil = 50 + (0.2 √ó 100 000) = 50 + 20 000 = 20 050 lignes mortes
```
‚Üí Autovacuum se d√©clenche apr√®s **20 050 suppressions/mises √† jour**
‚Üí ‚úÖ **Acceptable**

**Grande table (10 millions de lignes)** :
```
Seuil = 50 + (0.2 √ó 10 000 000) = 50 + 2 000 000 = 2 000 050 lignes mortes
```
‚Üí Autovacuum se d√©clenche apr√®s **2 millions de suppressions/mises √† jour**
‚Üí ‚ö†Ô∏è **Probl√©matique**

**Tr√®s grande table (100 millions de lignes)** :
```
Seuil = 50 + (0.2 √ó 100 000 000) = 50 + 20 000 000 = 20 000 050 lignes mortes
```
‚Üí Autovacuum se d√©clenche apr√®s **20 millions de suppressions/mises √† jour**
‚Üí ‚ùå **CATASTROPHIQUE**

---

## Le probl√®me des grandes tables

### 1. Accumulation massive de bloat

**Bloat** = espace disque gaspill√© par les lignes mortes.

**Sc√©nario typique** :
- Table `logs` avec 100 millions de lignes
- Chaque jour : 5 millions de nouvelles lignes, 5 millions de suppressions
- Seuil d'autovacuum : 20 millions de lignes mortes

**Chronologie du d√©sastre** :

```
Jour 1 : 5M lignes mortes    (bloat : 5%)
Jour 2 : 10M lignes mortes   (bloat : 10%)
Jour 3 : 15M lignes mortes   (bloat : 15%)
Jour 4 : 20M lignes mortes   (bloat : 20%) ‚Üê Autovacuum se d√©clenche ENFIN
```

**Probl√®mes** :
- ‚ùå La table a **doubl√© de taille** sur disque pendant 4 jours
- ‚ùå Les requ√™tes sont **2√ó plus lentes** (plus de donn√©es √† parcourir)
- ‚ùå Les sauvegardes sont **2√ó plus grosses**
- ‚ùå Le vacuum prendra **plusieurs heures** pour nettoyer 20M de lignes

### 2. Vacuum tr√®s long et bloquant

Quand autovacuum finit par se d√©clencher :

```sql
-- Vacuum sur une table avec 20 millions de lignes mortes
VACUUM VERBOSE logs;

-- Output typique :
-- INFO: vacuuming "public.logs"
-- INFO: scanned 250000 pages, removed 20000000 dead tuples
-- INFO: index "logs_pkey" now contains 100000000 tuples in 300000 pages
-- DETAIL: 20000000 index tuples were removed
-- Time: 7200000 ms (2 heures !)
```

**Impact** :
- ‚è±Ô∏è Vacuum dure **des heures**
- üîí Peut causer des **verrous** et ralentir l'application
- üíæ Consomme beaucoup d'**I/O** et de **CPU**
- üö® Les utilisateurs voient des **performances d√©grad√©es**

### 3. Effet boule de neige

Plus vous attendez, pire c'est :

```
Plus de lignes mortes
    ‚Üì
Vacuum plus long
    ‚Üì
Vacuum monopolise les ressources
    ‚Üì
Application ralentie
    ‚Üì
Plus de nouvelles op√©rations s'accumulent
    ‚Üì
Encore plus de lignes mortes !
```

### 4. Probl√®mes sp√©cifiques selon les cas d'usage

**Data Warehouse** :
- Tables de faits avec milliards de lignes
- ETL quotidiens avec mises √† jour massives
- Attendre 20% de la table est inacceptable

**SaaS avec tables de logs** :
- Croissance continue
- Purges r√©guli√®res des anciennes donn√©es
- Cycle vicieux : la table grossit, le seuil augmente, le bloat explose

**Tables d'historique** :
- Archivage p√©riodique
- D√©l√©tions massives d'anciennes donn√©es
- Accumulation de dizaines de millions de lignes mortes

---

## La solution : autovacuum_vacuum_max_threshold

### Qu'est-ce que c'est ?

`autovacuum_vacuum_max_threshold` est un **nouveau param√®tre dans PostgreSQL 18** qui d√©finit un **plafond absolu** au nombre de lignes mortes avant le d√©clenchement d'autovacuum.

```sql
-- Nouveau dans PostgreSQL 18
SHOW autovacuum_vacuum_max_threshold;  -- Valeur par d√©faut √† d√©finir
```

### La nouvelle formule de d√©clenchement

**Avant PostgreSQL 18** :
```
Seuil = autovacuum_vacuum_threshold + (scale_factor √ó n_tuples)
```

**Avec PostgreSQL 18** :
```
Seuil = MIN(
    autovacuum_vacuum_threshold + (scale_factor √ó n_tuples),
    autovacuum_vacuum_max_threshold
)
```

La fonction `MIN()` prend la **plus petite valeur** entre :
1. Le calcul traditionnel
2. Le plafond d√©fini par `autovacuum_vacuum_max_threshold`

### Exemple concret

Configuration :
```sql
autovacuum_vacuum_threshold = 50
autovacuum_vacuum_scale_factor = 0.2
autovacuum_vacuum_max_threshold = 2000000  -- 2 millions (nouveau !)
```

**Petite table (1 000 lignes)** :
```
Calcul classique : 50 + (0.2 √ó 1 000) = 250
Plafond : 2 000 000

Seuil effectif = MIN(250, 2 000 000) = 250
```
‚Üí Aucun changement, le calcul classique s'applique

**Grande table (100 millions de lignes)** :
```
Calcul classique : 50 + (0.2 √ó 100 000 000) = 20 000 050
Plafond : 2 000 000

Seuil effectif = MIN(20 000 050, 2 000 000) = 2 000 000
```
‚Üí ‚úÖ **Le plafond s'applique, limitant √† 2M de lignes mortes maximum !**

---

## Comment √ßa fonctionne en pratique

### Comportement selon la taille de la table

Imaginons `autovacuum_vacuum_max_threshold = 1 000 000` (1M) :

| Taille table | Calcul classique (20%) | Plafond | Seuil effectif | Impact |
|--------------|------------------------|---------|----------------|--------|
| 10 000 | 2 000 | 1M | **2 000** | Aucun |
| 100 000 | 20 000 | 1M | **20 000** | Aucun |
| 1 000 000 | 200 000 | 1M | **200 000** | Aucun |
| 5 000 000 | 1 000 000 | 1M | **1 000 000** | √âgalit√© |
| 10 000 000 | 2 000 000 | 1M | **1 000 000** | ‚úÖ Plafond |
| 100 000 000 | 20 000 000 | 1M | **1 000 000** | ‚úÖ Plafond |
| 1 000 000 000 | 200 000 000 | 1M | **1 000 000** | ‚úÖ Plafond |

**Constatation** : Le plafond prot√®ge uniquement les **grandes tables** (> 5M de lignes dans cet exemple).

### Visualisation graphique

```
Seuil de d√©clenchement (lignes mortes)

30M ‚î§
    ‚îÇ                           ‚ï± Sans plafond (ancien)
25M ‚î§                         ‚ï±
    ‚îÇ                       ‚ï±
20M ‚î§                     ‚ï±
    ‚îÇ                   ‚ï±
15M ‚î§                 ‚ï±
    ‚îÇ               ‚ï±
10M ‚î§             ‚ï±
    ‚îÇ           ‚ï±
 5M ‚î§         ‚ï±
    ‚îÇ       ‚ï±
 2M ‚î§‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï±‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Avec plafond (PG 18)
    ‚îÇ   ‚ï±
 1M ‚î§ ‚ï±
    ‚îÇ‚ï±
  0 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    0    10M   20M   30M   40M   50M   100M
              Taille de la table (lignes)

‚úÖ Petites tables : Comportement identique
‚úÖ Grandes tables : Prot√©g√©es par le plafond
```

---

## Configuration et tuning

### 1. Valeurs recommand√©es

#### Base de donn√©es g√©n√©raliste

```sql
-- Configuration √©quilibr√©e
autovacuum_vacuum_max_threshold = 2000000;  -- 2 millions
```

**Justification** :
- Prot√®ge contre l'accumulation excessive
- Vacuum reste g√©rable en dur√©e (quelques minutes)
- Balance entre r√©activit√© et overhead

#### Data Warehouse / Analytics

```sql
-- Tables tr√®s volumineuses, besoin de contr√¥le serr√©
autovacuum_vacuum_max_threshold = 5000000;  -- 5 millions
```

**Justification** :
- Tables de plusieurs milliards de lignes
- ETL massifs quotidiens
- Besoin de fen√™tres de maintenance plus larges

#### Application transactionnelle (OLTP)

```sql
-- Tables plus petites, besoin de r√©activit√©
autovacuum_vacuum_max_threshold = 1000000;  -- 1 million
```

**Justification** :
- Performance critique
- Bloat minimal tol√©rable
- Vacuum fr√©quents et rapides

#### SaaS avec tables de logs

```sql
-- Forte rotation des donn√©es
autovacuum_vacuum_max_threshold = 500000;  -- 500k
```

**Justification** :
- Insertions/suppressions massives continues
- Besoin de nettoyer tr√®s fr√©quemment
- √âviter l'explosion de taille

### 2. M√©thode de calcul personnalis√©e

Pour d√©terminer la bonne valeur pour votre cas :

**√âtape 1 : Identifier vos plus grandes tables**
```sql
SELECT
    schemaname || '.' || tablename AS table_name,
    n_live_tup,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_stat_user_tables
ORDER BY n_live_tup DESC
LIMIT 10;
```

**√âtape 2 : Estimer le nombre de modifications quotidiennes**
```sql
-- Sur une journ√©e, tracer les modifications
SELECT
    tablename,
    n_tup_ins + n_tup_upd + n_tup_del AS total_modifications
FROM pg_stat_user_tables
WHERE schemaname = 'public'
ORDER BY total_modifications DESC;
```

**√âtape 3 : Calculer le seuil souhait√©**

R√®gle empirique :
```
max_threshold = modifications_quotidiennes √ó 0.5
```

**Exemple** :
- Table `events` : 10 millions de modifications/jour
- Seuil souhait√© : 5 millions de lignes mortes
- Configuration : `autovacuum_vacuum_max_threshold = 5000000`

### 3. Configuration globale vs par table

#### Configuration globale

```sql
-- postgresql.conf ou ALTER SYSTEM
ALTER SYSTEM SET autovacuum_vacuum_max_threshold = 2000000;
SELECT pg_reload_conf();
```

**Avantage** : S'applique √† toutes les tables.

#### Configuration par table

```sql
-- Pour une table sp√©cifique n√©cessitant un seuil diff√©rent
ALTER TABLE logs_volumineuse SET (
    autovacuum_vacuum_scale_factor = 0.05,  -- Plus r√©actif
    autovacuum_vacuum_threshold = 1000      -- Seuil de base augment√©
);

-- Note : Le max_threshold global s'applique toujours
```

**Important** : `autovacuum_vacuum_max_threshold` est un param√®tre **global uniquement**, pas configurable par table. Mais vous pouvez ajuster les autres param√®tres par table pour affiner le comportement.

### 4. Interaction avec scale_factor

Le `max_threshold` fonctionne en tandem avec `scale_factor` :

**Strat√©gie agressive (petites tables r√©actives, grandes tables plafonn√©es)** :
```sql
autovacuum_vacuum_scale_factor = 0.1;  -- 10% au lieu de 20%
autovacuum_vacuum_max_threshold = 1000000;
```

**Strat√©gie mod√©r√©e** :
```sql
autovacuum_vacuum_scale_factor = 0.15;  -- 15%
autovacuum_vacuum_max_threshold = 2000000;
```

**Strat√©gie conservatrice (grosses tables, moins de vacuum)** :
```sql
autovacuum_vacuum_scale_factor = 0.2;  -- 20%
autovacuum_vacuum_max_threshold = 5000000;
```

---

## Cas pratiques d√©taill√©s

### Cas 1 : Application SaaS avec table de logs

**Contexte** :
- Table `application_logs` : 200 millions de lignes
- Insertions : 10M/jour
- R√©tention : 30 jours (suppression des lignes > 30 jours)
- Suppressions : ~10M/jour

**Probl√®me avant PG 18** :
```
Seuil = 50 + (0.2 √ó 200 000 000) = 40 000 050
```
‚Üí Attendre 40 millions de lignes mortes = **inacceptable**
‚Üí La table gonfle de 40M √ó 1KB ‚âà **40 GB de bloat**

**Solution avec PG 18** :
```sql
ALTER SYSTEM SET autovacuum_vacuum_max_threshold = 5000000;
ALTER SYSTEM SET autovacuum_vacuum_scale_factor = 0.1;
SELECT pg_reload_conf();
```

**Nouveau comportement** :
```
Seuil = MIN(50 + (0.1 √ó 200 000 000), 5 000 000)
Seuil = MIN(20 000 050, 5 000 000) = 5 000 000
```
‚Üí Autovacuum se d√©clenche tous les **5 millions de lignes mortes**
‚Üí Avec 10M de suppressions/jour, autovacuum tourne **2√ó par jour**
‚Üí Bloat maximal : 5M √ó 1KB ‚âà **5 GB** au lieu de 40 GB

**B√©n√©fices** :
- ‚úÖ Taille table stable
- ‚úÖ Performances constantes
- ‚úÖ Sauvegardes 8√ó plus petites

### Cas 2 : Data Warehouse avec table de faits

**Contexte** :
- Table `sales_fact` : 500 millions de lignes (table de faits)
- ETL nocturne : mise √† jour de 50 millions de lignes
- Tr√®s peu de suppressions

**Probl√®me avant PG 18** :
```
Seuil = 50 + (0.2 √ó 500 000 000) = 100 000 050
```
‚Üí Attendre 100 millions de lignes mortes apr√®s **chaque ETL** !
‚Üí Impossible, l'ETL cr√©e "seulement" 50M de lignes mortes

**Paradoxe** : L'autovacuum ne se d√©clencherait **jamais naturellement** car le seuil (100M) est sup√©rieur aux modifications quotidiennes (50M) !

**Solution avec PG 18** :
```sql
ALTER SYSTEM SET autovacuum_vacuum_max_threshold = 50000000;
SELECT pg_reload_conf();
```

**Nouveau comportement** :
```
Seuil = MIN(50 + (0.2 √ó 500 000 000), 50 000 000)
Seuil = MIN(100 000 050, 50 000 000) = 50 000 000
```
‚Üí Autovacuum se d√©clenche apr√®s chaque ETL (50M de lignes mortes)
‚Üí Nettoyage **quotidien automatique**

**B√©n√©fices** :
- ‚úÖ Table propre chaque matin
- ‚úÖ Requ√™tes analytiques optimales
- ‚úÖ Pas de VACUUM FULL manuel n√©cessaire

### Cas 3 : Table d'archivage avec purges p√©riodiques

**Contexte** :
- Table `orders_archive` : 1 milliard de lignes
- Purge trimestrielle : suppression de 250 millions de lignes anciennes
- Sinon, peu d'activit√©

**Probl√®me avant PG 18** :
```
Seuil = 50 + (0.2 √ó 1 000 000 000) = 200 000 050
```
‚Üí Apr√®s la purge de 250M de lignes, autovacuum se d√©clenche
‚Üí Mais le vacuum prendra **des heures** sur 250M de lignes mortes

**Solution avec PG 18** :
```sql
-- Strat√©gie : plafond + vacuum manuel planifi√©
ALTER SYSTEM SET autovacuum_vacuum_max_threshold = 10000000;

-- Apr√®s chaque purge trimestrielle, vacuum manuel imm√©diat
DELETE FROM orders_archive WHERE created_at < NOW() - INTERVAL '3 years';
VACUUM ANALYZE orders_archive;  -- Manuel et contr√¥l√©
```

**Nouveau comportement** :
- Le plafond de 10M prot√®ge contre toute accumulation entre les purges
- Le vacuum manuel post-purge est planifi√© et contr√¥l√©
- Pas de surprise pendant les heures de production

**B√©n√©fices** :
- ‚úÖ Contr√¥le total sur les op√©rations lourdes
- ‚úÖ Protection contre l'accumulation accidentelle
- ‚úÖ Maintenance pr√©visible

### Cas 4 : Base multi-tenant avec disparit√© de tailles

**Contexte** :
- 100 clients avec leurs propres tables
- Client A : 10 000 lignes
- Client B : 500 millions de lignes
- Configuration uniforme n√©cessaire

**Probl√®me avant PG 18** :
- Impossible de satisfaire tout le monde avec un seul `scale_factor`
- Client A : sur-nettoy√©
- Client B : sous-nettoy√©

**Solution avec PG 18** :
```sql
-- Configuration globale prot√©geant les gros clients
autovacuum_vacuum_scale_factor = 0.15;  -- Mod√©r√©
autovacuum_vacuum_max_threshold = 3000000;  -- Plafond √† 3M

-- Ajustement pour les petits clients (plus r√©actif)
ALTER TABLE client_a.orders SET (
    autovacuum_vacuum_scale_factor = 0.1,
    autovacuum_vacuum_threshold = 50
);

-- Les gros clients sont automatiquement prot√©g√©s par le plafond global
```

**B√©n√©fices** :
- ‚úÖ Configuration simple et maintenable
- ‚úÖ Petits clients : nettoyage fr√©quent
- ‚úÖ Gros clients : prot√©g√©s par le plafond
- ‚úÖ Pas de micro-gestion n√©cessaire

---

## Monitoring et observabilit√©

### 1. V√©rifier si le plafond s'applique

```sql
-- Calculer le seuil effectif pour chaque table
WITH thresholds AS (
    SELECT
        schemaname || '.' || tablename AS table_name,
        n_live_tup,
        n_dead_tup,
        -- Calcul classique
        (current_setting('autovacuum_vacuum_threshold')::bigint +
         current_setting('autovacuum_vacuum_scale_factor')::float * n_live_tup)::bigint AS classic_threshold,
        -- Plafond
        current_setting('autovacuum_vacuum_max_threshold')::bigint AS max_threshold
    FROM pg_stat_user_tables
    WHERE n_live_tup > 0
)
SELECT
    table_name,
    n_live_tup,
    n_dead_tup,
    classic_threshold,
    max_threshold,
    -- Seuil effectif (le minimum des deux)
    LEAST(classic_threshold, max_threshold) AS effective_threshold,
    -- Est-ce que le plafond s'applique ?
    CASE
        WHEN classic_threshold > max_threshold THEN '‚úÖ Plafond actif'
        ELSE '‚ö™ Calcul classique'
    END AS status,
    -- Pourcentage avant d√©clenchement
    ROUND(n_dead_tup * 100.0 / NULLIF(LEAST(classic_threshold, max_threshold), 0), 2) AS pct_to_trigger
FROM thresholds
WHERE n_dead_tup > 1000
ORDER BY n_dead_tup DESC
LIMIT 20;
```

**Output exemple** :
```
table_name          | n_live_tup | n_dead_tup | classic_threshold | max_threshold | effective_threshold | status           | pct_to_trigger
--------------------|------------|------------|-------------------|---------------|---------------------|------------------|---------------
public.logs         | 100000000  | 1500000    | 20000050          | 2000000       | 2000000             | ‚úÖ Plafond actif | 75.00
public.events       | 50000000   | 800000     | 10000050          | 2000000       | 2000000             | ‚úÖ Plafond actif | 40.00
public.users        | 100000     | 15000      | 20050             | 2000000       | 20050               | ‚ö™ Calcul classique | 74.81
```

### 2. Tables proches du plafond

```sql
-- Tables qui vont bient√¥t d√©clencher un autovacuum (gr√¢ce au plafond)
SELECT
    schemaname || '.' || tablename AS table_name,
    n_live_tup,
    n_dead_tup,
    current_setting('autovacuum_vacuum_max_threshold')::bigint AS max_threshold,
    ROUND(n_dead_tup * 100.0 /
          NULLIF(current_setting('autovacuum_vacuum_max_threshold')::bigint, 0), 2) AS pct_of_max,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
    last_autovacuum
FROM pg_stat_user_tables
WHERE n_live_tup > 5000000  -- Tables volumineuses uniquement
  AND n_dead_tup > 100000
ORDER BY pct_of_max DESC
LIMIT 10;
```

### 3. Impact du plafond sur la fr√©quence de vacuum

```sql
-- Comparer la fr√©quence des autovacuum avant/apr√®s le plafond
SELECT
    schemaname || '.' || tablename AS table_name,
    autovacuum_count,
    last_autovacuum,
    EXTRACT(EPOCH FROM (NOW() - last_autovacuum)) / 3600 AS hours_since_last,
    n_live_tup,
    CASE
        WHEN n_live_tup * current_setting('autovacuum_vacuum_scale_factor')::float
             > current_setting('autovacuum_vacuum_max_threshold')::bigint
        THEN 'Protected by max_threshold'
        ELSE 'Classic behavior'
    END AS behavior
FROM pg_stat_user_tables
WHERE autovacuum_count > 0
  AND schemaname = 'public'
ORDER BY autovacuum_count DESC
LIMIT 20;
```

### 4. Estimer le bloat √©vit√© gr√¢ce au plafond

```sql
-- Estimer la r√©duction de bloat gr√¢ce au max_threshold
WITH bloat_comparison AS (
    SELECT
        schemaname || '.' || tablename AS table_name,
        n_live_tup,
        -- Seuil sans plafond
        (current_setting('autovacuum_vacuum_threshold')::bigint +
         current_setting('autovacuum_vacuum_scale_factor')::float * n_live_tup)::bigint AS old_threshold,
        -- Seuil avec plafond
        LEAST(
            (current_setting('autovacuum_vacuum_threshold')::bigint +
             current_setting('autovacuum_vacuum_scale_factor')::float * n_live_tup)::bigint,
            current_setting('autovacuum_vacuum_max_threshold')::bigint
        ) AS new_threshold,
        pg_total_relation_size(schemaname||'.'||tablename) / n_live_tup AS avg_tuple_size
    FROM pg_stat_user_tables
    WHERE n_live_tup > 1000000
)
SELECT
    table_name,
    n_live_tup,
    old_threshold,
    new_threshold,
    old_threshold - new_threshold AS dead_tuples_saved,
    pg_size_pretty((old_threshold - new_threshold) * avg_tuple_size) AS bloat_saved
FROM bloat_comparison
WHERE old_threshold > new_threshold
ORDER BY (old_threshold - new_threshold) * avg_tuple_size DESC
LIMIT 15;
```

**Output exemple** :
```
table_name        | n_live_tup | old_threshold | new_threshold | dead_tuples_saved | bloat_saved
------------------|------------|---------------|---------------|-------------------|-------------
public.logs       | 100000000  | 20000050      | 2000000       | 18000050          | 17 GB
public.events     | 50000000   | 10000050      | 2000000       | 8000050           | 7.6 GB
```

### 5. Alertes recommand√©es

```sql
-- Alerte : Tables d√©passant 80% du max_threshold
SELECT
    tablename,
    n_dead_tup,
    current_setting('autovacuum_vacuum_max_threshold')::bigint AS max_threshold,
    ROUND(n_dead_tup * 100.0 /
          current_setting('autovacuum_vacuum_max_threshold')::bigint, 2) AS pct
FROM pg_stat_user_tables
WHERE n_dead_tup > current_setting('autovacuum_vacuum_max_threshold')::bigint * 0.8
  AND n_live_tup > 1000000;
```

Int√©grer cette requ√™te dans votre syst√®me de monitoring (Prometheus, Grafana, DataDog, etc.).

---

## Migration vers PostgreSQL 18

### √âtape 1 : Analyse de l'existant

Avant la migration, analysez vos tables actuelles :

```sql
-- Identifier les tables qui b√©n√©ficieraient du plafond
SELECT
    schemaname || '.' || tablename AS table_name,
    n_live_tup,
    (50 + 0.2 * n_live_tup)::bigint AS current_threshold,
    n_dead_tup,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
    CASE
        WHEN (50 + 0.2 * n_live_tup) > 5000000 THEN 'üî¥ B√©n√©ficierait fortement'
        WHEN (50 + 0.2 * n_live_tup) > 2000000 THEN 'üü° B√©n√©ficierait'
        ELSE '‚ö™ Peu d''impact'
    END AS impact
FROM pg_stat_user_tables
WHERE n_live_tup > 500000
ORDER BY (50 + 0.2 * n_live_tup) DESC
LIMIT 30;
```

### √âtape 2 : Choisir la valeur initiale

Recommandations selon vos r√©sultats :

**Si vous avez des tables > 100M de lignes** :
```sql
autovacuum_vacuum_max_threshold = 5000000
```

**Si vos plus grandes tables sont 10-100M de lignes** :
```sql
autovacuum_vacuum_max_threshold = 2000000
```

**Si principalement des tables < 10M de lignes** :
```sql
autovacuum_vacuum_max_threshold = 1000000
```

### √âtape 3 : Configuration initiale conservative

```sql
-- postgresql.conf ou ALTER SYSTEM apr√®s migration vers PG 18

-- Commencer avec une valeur conservative (plus √©lev√©e)
ALTER SYSTEM SET autovacuum_vacuum_max_threshold = 5000000;

-- Garder les autres param√®tres stables initialement
-- autovacuum_vacuum_scale_factor = 0.2 (d√©faut)

SELECT pg_reload_conf();
```

### √âtape 4 : Monitoring post-migration

Pendant les 2 premi√®res semaines :

```sql
-- Requ√™te quotidienne : fr√©quence des autovacuum
SELECT
    tablename,
    autovacuum_count,
    last_autovacuum,
    n_dead_tup
FROM pg_stat_user_tables
WHERE schemaname = 'public'
  AND n_live_tup > 1000000
ORDER BY last_autovacuum DESC;
```

**Indicateurs de succ√®s** :
- ‚úÖ Autovacuum plus fr√©quents sur les grosses tables
- ‚úÖ `n_dead_tup` reste sous le plafond
- ‚úÖ Taille des tables stable ou en r√©duction
- ‚úÖ Pas d'augmentation du temps de vacuum

### √âtape 5 : Ajustement progressif

Apr√®s 2 semaines, ajustez si n√©cessaire :

**Si autovacuum tourne trop souvent** :
```sql
ALTER SYSTEM SET autovacuum_vacuum_max_threshold = 7000000;  -- Augmenter
```

**Si les tables accumulent encore du bloat** :
```sql
ALTER SYSTEM SET autovacuum_vacuum_max_threshold = 3000000;  -- R√©duire
```

---

## Erreurs courantes et d√©pannage

### Erreur 1 : Plafond trop bas

**Sympt√¥mes** :
- Autovacuum tourne en permanence sur les m√™mes tables
- Logs remplis de messages autovacuum
- Performance I/O d√©grad√©e

**Diagnostic** :
```sql
-- V√©rifier la fr√©quence des autovacuum
SELECT
    tablename,
    autovacuum_count,
    EXTRACT(EPOCH FROM (NOW() - stats_reset)) / 3600 AS hours_since_reset,
    ROUND(autovacuum_count / (EXTRACT(EPOCH FROM (NOW() - stats_reset)) / 3600), 2) AS vacuum_per_hour
FROM pg_stat_user_tables
WHERE schemaname = 'public'
  AND autovacuum_count > 0
ORDER BY vacuum_per_hour DESC;

-- Si vacuum_per_hour > 2 pour certaines tables ‚Üí plafond trop bas
```

**Solution** :
```sql
ALTER SYSTEM SET autovacuum_vacuum_max_threshold = 5000000;  -- Doubler
SELECT pg_reload_conf();
```

### Erreur 2 : Plafond trop √©lev√©

**Sympt√¥mes** :
- Tables continuent √† gonfler
- Bloat significatif (> 30%)
- Autovacuum ne se d√©clenche pas assez

**Diagnostic** :
```sql
-- V√©rifier le bloat
SELECT
    tablename,
    n_dead_tup,
    ROUND(n_dead_tup * 100.0 / NULLIF(n_live_tup, 0), 2) AS dead_pct,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_stat_user_tables
WHERE schemaname = 'public'
  AND n_dead_tup > 100000
ORDER BY dead_pct DESC;

-- Si dead_pct > 20% ‚Üí plafond trop √©lev√©
```

**Solution** :
```sql
ALTER SYSTEM SET autovacuum_vacuum_max_threshold = 1000000;  -- R√©duire
SELECT pg_reload_conf();

-- Forcer un vacuum imm√©diat sur les tables concern√©es
VACUUM ANALYZE table_problematique;
```

### Erreur 3 : Oublier le plafond apr√®s migration

**Sympt√¥me** :
- Vous avez migr√© vers PG 18
- Mais le comportement n'a pas chang√©
- Les grandes tables souffrent toujours

**Cause** :
```sql
SHOW autovacuum_vacuum_max_threshold;
-- R√©sultat : valeur vide ou tr√®s √©lev√©e par d√©faut
```

**Solution** :
```sql
-- D√©finir explicitement le param√®tre
ALTER SYSTEM SET autovacuum_vacuum_max_threshold = 2000000;
SELECT pg_reload_conf();
```

### Erreur 4 : Confusion avec max_workers

**Erreur courante** :
Penser que `autovacuum_vacuum_max_threshold` contr√¥le le nombre de workers.

**Clarification** :
- `autovacuum_vacuum_max_threshold` ‚Üí **Nombre de lignes mortes** (seuil)
- `autovacuum_worker_slots` ‚Üí **Nombre de workers** (parall√©lisme)

Ces deux param√®tres sont **ind√©pendants et compl√©mentaires**.

---

## Bonnes pratiques

### 1. Toujours d√©finir le param√®tre

‚úÖ Dans PostgreSQL 18, **toujours configurer** `autovacuum_vacuum_max_threshold` :

```sql
-- Ne pas laisser la valeur par d√©faut
ALTER SYSTEM SET autovacuum_vacuum_max_threshold = 2000000;
```

### 2. Commencer conservateur

‚úÖ Lors de la migration ou d'un nouveau projet :
- D√©marrer avec une valeur plus √©lev√©e (5M)
- Monitorer pendant 2 semaines
- Ajuster progressivement √† la baisse si n√©cessaire

### 3. Adapter selon votre domaine

‚úÖ Ajuster selon votre cas d'usage :

| Type d'application | Valeur recommand√©e |
|--------------------|-------------------|
| SaaS transactionnel | 1-2 millions |
| E-commerce | 2-3 millions |
| Analytics / DW | 5-10 millions |
| Logs / Time-series | 500k - 1 million |

### 4. Combiner avec scale_factor

‚úÖ Le `max_threshold` fonctionne mieux avec un `scale_factor` r√©duit :

```sql
autovacuum_vacuum_scale_factor = 0.1;  -- Au lieu de 0.2
autovacuum_vacuum_max_threshold = 2000000;
```

‚Üí Petites tables plus r√©actives, grandes tables prot√©g√©es

### 5. Documenter votre choix

‚úÖ Documenter pourquoi vous avez choisi cette valeur :

```sql
-- postgresql.conf
# autovacuum_vacuum_max_threshold = 2000000
# Rationale: Tables volumineuses (logs, events) avec millions de modifications/jour
# √âvite l'accumulation de 20M+ lignes mortes
# Ajust√© le 2025-11-22 apr√®s analyse de bloat
```

### 6. Alerte de monitoring

‚úÖ Configurer des alertes pour :
- Tables d√©passant 80% du `max_threshold`
- Autovacuum √©chouant sur les m√™mes tables
- Bloat > 30% malgr√© le plafond

### 7. R√©vision p√©riodique

‚úÖ R√©viser la valeur tous les 6 mois :
- Vos donn√©es ont-elles chang√© de volume ?
- De nouveaux patterns d'usage ?
- Performance satisfaisante ?

---

## R√©sum√©

### Le probl√®me r√©solu

**Avant PG 18** :
- Grandes tables ‚Üí Seuil √©norme (20M+ lignes mortes)
- Accumulation massive de bloat
- Vacuum tr√®s longs et bloquants
- Performances d√©grad√©es

**Avec PG 18** :
- Plafond explicite (`autovacuum_vacuum_max_threshold`)
- Protection automatique des grandes tables
- Bloat contr√¥l√©
- Vacuum fr√©quents et g√©rables

### La formule magique

```
Seuil effectif = MIN(
    autovacuum_vacuum_threshold + (scale_factor √ó n_tuples),
    autovacuum_vacuum_max_threshold
)
```

### Configuration type

```sql
-- postgresql.conf pour PostgreSQL 18

# Protection des grandes tables
autovacuum_vacuum_max_threshold = 2000000

# Compl√©ter avec param√®tres classiques
autovacuum_vacuum_scale_factor = 0.1
autovacuum_vacuum_threshold = 50
autovacuum_naptime = 10s
```

### Checklist

- ‚úÖ Analyser vos tables actuelles et leur taille
- ‚úÖ Choisir une valeur de `max_threshold` adapt√©e
- ‚úÖ Configurer le param√®tre dans PostgreSQL 18
- ‚úÖ Monitorer pendant 2 semaines
- ‚úÖ Ajuster selon les observations
- ‚úÖ Documenter votre configuration
- ‚úÖ Mettre en place des alertes

---

## Conclusion

Le param√®tre `autovacuum_vacuum_max_threshold` de PostgreSQL 18 est une **am√©lioration majeure** qui r√©sout un probl√®me de longue date : l'accumulation incontr√¥l√©e de bloat dans les grandes tables.

**Impact concret** :
- üéØ Bloat r√©duit de **80%** sur les grandes tables
- ‚ö° Vacuum **4-5√ó plus rapides** (moins de lignes √† nettoyer)
- üì¶ Sauvegardes **50% plus petites** en moyenne
- üöÄ Performances **stables** m√™me sur tables de centaines de millions de lignes

En tant que d√©veloppeur ou DevOps, ce param√®tre vous permet de :
- **Simplifier la maintenance** : Moins d'interventions manuelles
- **Am√©liorer les performances** : Tables plus compactes
- **R√©duire les co√ªts** : Moins d'espace disque et de bande passante
- **Gagner en s√©r√©nit√©** : Fini les surprises de bloat explosif

PostgreSQL 18 franchit un cap important dans l'auto-gestion des bases de donn√©es. Le `max_threshold` est un outil simple mais puissant qui prot√®ge automatiquement vos donn√©es les plus volumineuses.

---

**Prochaines √©tapes recommand√©es** :
- Combiner avec **autovacuum_worker_slots** pour une allocation dynamique (16.10.3)
- Explorer les **autres nouveaut√©s de PostgreSQL 18** (Chapitre 21.3)
- Approfondir le **monitoring du bloat** (Chapitre 14)

---


‚è≠Ô∏è [Sauvegardes et restauration](/16-administration-configuration-securite/11-sauvegardes-et-restauration.md)
