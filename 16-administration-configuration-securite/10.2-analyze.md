üîù Retour au [Sommaire](/SOMMAIRE.md)

# 16.10.2. ANALYZE : Mise √† jour des statistiques du planificateur

## Introduction : Le probl√®me de la navigation √† l'aveugle

Imaginez que vous devez organiser un voyage en voiture :
- **Sans carte ni GPS** : Vous roulez au hasard, vous vous perdez, vous perdez du temps
- **Avec une carte √† jour** : Vous connaissez les routes, les distances, les limitations, vous choisissez le meilleur itin√©raire

PostgreSQL fonctionne de la m√™me mani√®re pour ex√©cuter vos requ√™tes SQL !

Pour chaque requ√™te, PostgreSQL doit d√©cider :
- Quel index utiliser (ou ne pas utiliser) ?
- Dans quel ordre joindre les tables ?
- Quelle strat√©gie de scan adopter ?

Pour prendre ces d√©cisions intelligemment, PostgreSQL a besoin de **statistiques √† jour** sur vos donn√©es. C'est exactement le r√¥le d'**ANALYZE**.

---

## Qu'est-ce qu'ANALYZE ?

**ANALYZE** est une commande qui :

1. **Collecte des statistiques** sur le contenu de vos tables
2. **Stocke ces statistiques** dans les tables syst√®me (`pg_statistics`)
3. **Permet au planificateur** de choisir le meilleur plan d'ex√©cution pour vos requ√™tes

### Syntaxe de base

```sql
ANALYZE;                    -- Analyse toute la base de donn√©es
ANALYZE nom_table;          -- Analyse une table sp√©cifique
ANALYZE nom_table (col1, col2);  -- Analyse des colonnes sp√©cifiques
```

### Diff√©rence cl√© avec VACUUM

| **VACUUM** | **ANALYZE** |
|------------|-------------|
| Nettoie les lignes mortes | Collecte des statistiques |
| R√©cup√®re l'espace disque | N'affecte pas l'espace disque |
| Pr√©vient le XID wraparound | Optimise les plans de requ√™tes |
| Impact : Sant√© de la base | Impact : Performance des requ√™tes |

**Bonne pratique** : Souvent utilis√©s ensemble avec `VACUUM ANALYZE`.

---

## Le planificateur de requ√™tes : Le cerveau de PostgreSQL

### Qu'est-ce que le planificateur ?

Le **Query Planner** (ou planificateur de requ√™tes) est le composant de PostgreSQL qui :
1. Re√ßoit votre requ√™te SQL
2. G√©n√®re **plusieurs plans d'ex√©cution possibles**
3. **Estime le co√ªt** de chaque plan
4. **Choisit le plan le moins co√ªteux**

### Exemple simple

Prenons cette requ√™te :

```sql
SELECT * FROM clients WHERE ville = 'Paris';
```

Le planificateur a plusieurs options :

**Option A - Sequential Scan** :
- Parcourir toute la table ligne par ligne
- Co√ªt estim√© : 10 000 unit√©s

**Option B - Index Scan** :
- Utiliser un index sur la colonne `ville`
- Co√ªt estim√© : 150 unit√©s

**D√©cision** : Le planificateur choisit l'index (Option B) car c'est plus rapide !

### Comment le planificateur estime-t-il les co√ªts ?

Le planificateur utilise des **statistiques** pour √©valuer :

1. **Nombre de lignes** dans la table (`n_live_tup`)
2. **Nombre de lignes qui correspondent au filtre** (s√©lectivit√©)
3. **Distribution des valeurs** (valeurs les plus fr√©quentes, histogrammes)
4. **Taille des donn√©es** (pages, tuples)
5. **Corr√©lation** entre l'ordre physique et l'ordre logique

**Sans statistiques √† jour, le planificateur est aveugle !**

---

## Quelles statistiques ANALYZE collecte-t-il ?

### 1. Statistiques de base

Pour chaque table :

```sql
-- Voir les statistiques d'une table
SELECT
    schemaname,
    tablename,
    n_live_tup,        -- Nombre de lignes vivantes
    n_dead_tup,        -- Nombre de lignes mortes
    last_analyze,      -- Derni√®re analyse manuelle
    last_autoanalyze   -- Derni√®re analyse automatique
FROM pg_stat_user_tables
WHERE tablename = 'clients';
```

### 2. Statistiques par colonne

Pour chaque colonne, PostgreSQL collecte :

- **null_frac** : Proportion de valeurs NULL
- **avg_width** : Largeur moyenne des valeurs (en octets)
- **n_distinct** : Nombre de valeurs distinctes (cardinalit√©)
- **most_common_vals** : Les valeurs les plus fr√©quentes (MCV)
- **most_common_freqs** : Fr√©quences de ces valeurs
- **histogram_bounds** : Distribution des valeurs (pour les autres valeurs)
- **correlation** : Corr√©lation entre ordre physique et logique

### Exemple : Voir les statistiques d'une colonne

```sql
-- Voir les statistiques de la colonne "ville"
SELECT
    attname,
    n_distinct,
    most_common_vals,
    most_common_freqs
FROM pg_stats
WHERE tablename = 'clients'
  AND attname = 'ville';
```

**R√©sultat possible** :

```
attname | n_distinct | most_common_vals              | most_common_freqs
--------|------------|-------------------------------|------------------
ville   | 50         | {Paris,Lyon,Marseille,Lille}  | {0.35,0.15,0.12,0.08}
```

**Interpr√©tation** :
- Il y a 50 villes distinctes
- 35% des clients sont √† Paris
- 15% √† Lyon, 12% √† Marseille, 8% √† Lille

Le planificateur utilise ces informations pour estimer combien de lignes retournera `WHERE ville = 'Paris'` ‚Üí environ 35% !

---

## Comment ANALYZE collecte-t-il les statistiques ?

### √âchantillonnage (Sampling)

ANALYZE ne lit **pas toute la table** ! Il utilise un **√©chantillonnage statistique** :

1. **S√©lection al√©atoire** de pages (blocs de 8 Ko)
2. **Lecture d'un √©chantillon** de lignes
3. **Extrapolation** des statistiques √† toute la table

### Param√®tre cl√© : default_statistics_target

```sql
-- Voir le param√®tre actuel
SHOW default_statistics_target;  -- D√©faut : 100
```

Ce param√®tre contr√¥le :
- **Nombre d'√©chantillons** collect√©s par ANALYZE
- **Pr√©cision des statistiques** (histogrammes, MCV)
- **Temps d'ex√©cution** d'ANALYZE

**Valeurs** :
- **10** : Rapide mais impr√©cis
- **100** : D√©faut, bon √©quilibre
- **1000** : Tr√®s pr√©cis mais lent (pour les colonnes critiques)
- **10000** : Maximum, pour les cas extr√™mes

### Ajuster pour une colonne sp√©cifique

Si une colonne est cruciale pour vos requ√™tes (ex : dans les WHERE, JOIN) :

```sql
-- Augmenter la pr√©cision des statistiques pour la colonne "ville"
ALTER TABLE clients
ALTER COLUMN ville SET STATISTICS 500;

-- Puis relancer ANALYZE
ANALYZE clients (ville);
```

**Impact** :
- ‚úÖ Meilleure estimation du planificateur pour cette colonne
- ‚ö†Ô∏è ANALYZE sera un peu plus lent sur cette colonne

---

## Les sympt√¥mes de statistiques obsol√®tes

### 1. Plans de requ√™tes sous-optimaux

**Exemple classique** : Le planificateur choisit un Sequential Scan alors qu'un Index Scan serait plus rapide.

```sql
EXPLAIN SELECT * FROM commandes WHERE client_id = 12345;
```

**Avec statistiques obsol√®tes** :
```
Seq Scan on commandes  (cost=0.00..25000.00 rows=500000 width=100)
  Filter: (client_id = 12345)
```
‚Üí Le planificateur pense qu'il y a 500 000 lignes, alors qu'en r√©alit√© il n'y en a que 50.

**Avec statistiques √† jour** :
```
Index Scan using idx_commandes_client_id on commandes
  (cost=0.42..8.44 rows=50 width=100)
  Index Cond: (client_id = 12345)
```
‚Üí Le planificateur sait qu'il y a 50 lignes, il choisit l'index !

### 2. Performances qui se d√©gradent progressivement

Vous remarquez que vos requ√™tes deviennent de plus en plus lentes avec le temps, sans raison apparente :
- Les donn√©es ont beaucoup √©volu√© (insertions, suppressions)
- Les statistiques ne refl√®tent plus la r√©alit√©
- Le planificateur fait de mauvais choix

**Solution** : ANALYZE !

### 3. Estimations compl√®tement fausses

Dans l'output d'EXPLAIN ANALYZE, vous voyez :

```
‚Üí Index Scan (cost=... rows=10 ...) (actual rows=100000 ...)
```

- **rows=10** : Estimation du planificateur
- **actual rows=100000** : R√©alit√©

**Ratio estimation/r√©alit√© de 1:10 000** ‚Üí Statistiques obsol√®tes !

---

## Quand lancer ANALYZE manuellement ?

### Situations typiques

1. **Apr√®s un chargement massif de donn√©es**
   ```sql
   -- Import de 10 millions de lignes
   COPY clients FROM '/data/clients.csv' WITH CSV;

   -- ANALYZE imm√©diatement apr√®s
   ANALYZE clients;
   ```

2. **Apr√®s des modifications massives**
   ```sql
   -- Mise √† jour de 50% de la table
   UPDATE produits SET prix = prix * 1.1 WHERE categorie = 'electronique';

   -- ANALYZE pour mettre √† jour les distributions
   ANALYZE produits;
   ```

3. **Apr√®s une suppression importante**
   ```sql
   -- Suppression de 80% des anciennes donn√©es
   DELETE FROM logs WHERE created_at < NOW() - INTERVAL '90 days';

   -- ANALYZE (souvent avec VACUUM)
   VACUUM ANALYZE logs;
   ```

4. **Avant une requ√™te critique**
   ```sql
   -- Vous allez lancer une requ√™te complexe importante
   ANALYZE;  -- Assure que les statistiques sont fra√Æches

   -- Puis votre requ√™te complexe
   SELECT ... FROM ... WHERE ... JOIN ... ;
   ```

5. **Apr√®s la cr√©ation d'un index**
   ```sql
   CREATE INDEX idx_clients_email ON clients(email);

   -- ANALYZE pour que le planificateur connaisse l'index
   ANALYZE clients;
   ```

---

## Auto-ANALYZE : Le pilote automatique

Comme pour VACUUM, PostgreSQL dispose d'**auto-ANALYZE** qui lance automatiquement ANALYZE quand c'est n√©cessaire.

### Comment auto-ANALYZE se d√©clenche-t-il ?

Formule de d√©clenchement :
```
Seuil = autovacuum_analyze_threshold + (autovacuum_analyze_scale_factor √ó nombre_total_de_lignes)
```

**Param√®tres par d√©faut** :

```sql
SHOW autovacuum_analyze_threshold;     -- 50 lignes modifi√©es
SHOW autovacuum_analyze_scale_factor;  -- 0.1 (10% de la table)
```

**Exemple** :
- Table avec 100 000 lignes
- Seuil = 50 + (0.1 √ó 100 000) = **10 050 modifications**
- Auto-ANALYZE se d√©clenche apr√®s 10 050 INSERT/UPDATE/DELETE

### V√©rifier l'activit√© d'auto-ANALYZE

```sql
-- Voir les derni√®res auto-analyses
SELECT
    schemaname,
    tablename,
    last_analyze,
    last_autoanalyze,
    analyze_count,
    autoanalyze_count,
    n_mod_since_analyze  -- Nombre de modifications depuis le dernier ANALYZE
FROM pg_stat_user_tables
WHERE schemaname = 'public'
ORDER BY n_mod_since_analyze DESC;
```

**Indicateurs** :
- `n_mod_since_analyze > 10 000` ‚Üí ANALYZE devrait se d√©clencher bient√¥t
- `last_autoanalyze` tr√®s ancien avec beaucoup de modifications ‚Üí Probl√®me potentiel

---

## Nouveaut√©s PostgreSQL 18 : ANALYZE am√©lior√©

### 1. Statistiques VACUUM et ANALYZE dans pg_stat_all_tables

PostgreSQL 18 enrichit la vue `pg_stat_all_tables` avec de nouvelles m√©triques :

```sql
-- Nouvelles colonnes dans PG 18
SELECT
    schemaname,
    tablename,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze,
    vacuum_count,
    autovacuum_count,
    analyze_count,
    autoanalyze_count,
    n_ins_since_vacuum,      -- Nouveau PG 18
    n_del_since_vacuum,      -- Nouveau PG 18
    n_mod_since_analyze      -- Am√©lior√© PG 18
FROM pg_stat_all_tables
WHERE schemaname = 'public';
```

**Avantages** :
- Meilleure visibilit√© sur l'activit√© de maintenance
- D√©tection plus facile des tables n√©cessitant ANALYZE
- Monitoring plus fin

### 2. Auto-ANALYZE plus r√©actif

Avec les am√©liorations de PG 18 sur autovacuum, auto-ANALYZE b√©n√©ficie aussi de :
- Meilleure allocation des workers
- Ajustements dynamiques selon la charge
- R√©activit√© accrue sur les tables √† forte activit√©

---

## ANALYZE vs VACUUM ANALYZE

### Quand utiliser quoi ?

| Commande | Quand l'utiliser |
|----------|------------------|
| `ANALYZE` | Vous voulez **uniquement** mettre √† jour les statistiques (rapide) |
| `VACUUM ANALYZE` | Vous voulez **nettoyer ET** mettre √† jour les statistiques (plus lent) |
| `VACUUM` | Vous voulez **uniquement** nettoyer (sans mise √† jour des stats) |

### Temps d'ex√©cution

**ANALYZE** est **tr√®s rapide** compar√© √† VACUUM :

- **ANALYZE** : √âchantillonnage, ne lit pas toute la table ‚Üí **quelques secondes** m√™me sur de grosses tables
- **VACUUM** : Parcourt toute la table pour nettoyer ‚Üí **plusieurs minutes √† heures**

**Exemple** :
```sql
-- Sur une table de 100 millions de lignes
ANALYZE clients;          -- ~5 secondes
VACUUM clients;           -- ~10 minutes
VACUUM ANALYZE clients;   -- ~10 minutes (VACUUM + quelques secondes pour ANALYZE)
```

---

## Monitoring des statistiques

### 1. V√©rifier si les statistiques sont √† jour

```sql
-- Tables avec beaucoup de modifications depuis le dernier ANALYZE
SELECT
    schemaname || '.' || tablename AS table_name,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
    n_live_tup,
    n_mod_since_analyze,
    ROUND(n_mod_since_analyze * 100.0 / NULLIF(n_live_tup, 0), 2) AS pct_modified,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
WHERE n_mod_since_analyze > 1000
ORDER BY n_mod_since_analyze DESC
LIMIT 20;
```

**Indicateurs** :
- `pct_modified > 10%` ‚Üí ANALYZE recommand√©
- `pct_modified > 20%` ‚Üí ANALYZE urgent

### 2. Identifier les colonnes avec peu de statistiques

```sql
-- Colonnes avec statistiques par d√©faut (peut-√™tre insuffisantes)
SELECT
    schemaname || '.' || tablename AS table_name,
    attname AS column_name,
    n_distinct,
    null_frac
FROM pg_stats
WHERE schemaname = 'public'
  AND n_distinct BETWEEN -1 AND 100  -- Peu de valeurs distinctes d√©tect√©es
ORDER BY tablename, attname;
```

### 3. D√©tecter les plans de requ√™tes avec mauvaises estimations

Utilisez `EXPLAIN ANALYZE` et comparez `rows` (estimation) vs `actual rows` :

```sql
EXPLAIN ANALYZE
SELECT * FROM commandes WHERE statut = 'livree';
```

**Output** :
```
Seq Scan on commandes  (cost=0.00..1500.00 rows=5000 width=200)
                       (actual time=0.050..25.123 rows=95000 loops=1)
```

- **rows=5000** (estimation) vs **actual rows=95000** (r√©alit√©)
- **Ratio de 1:19** ‚Üí Les statistiques sont obsol√®tes !

**Solution** :
```sql
ANALYZE commandes;
```

---

## Cas pratiques et exemples

### Cas 1 : Import quotidien de donn√©es

**Contexte** : Vous importez 1 million de lignes chaque nuit dans une table `transactions`.

```sql
-- Script d'import
BEGIN;

-- Import des donn√©es
COPY transactions FROM '/data/daily_transactions.csv' WITH CSV;

-- ANALYZE imm√©diatement apr√®s pour que les requ√™tes du matin soient optimales
ANALYZE transactions;

COMMIT;
```

**Pourquoi ?** Les requ√™tes du matin utiliseront des statistiques fra√Æches et seront rapides.

### Cas 2 : Requ√™te lente inexpliqu√©e

**Probl√®me** : Une requ√™te qui √©tait rapide est devenue lente.

```sql
-- Requ√™te lente
SELECT COUNT(*) FROM ventes WHERE pays = 'France';
```

**Diagnostic** :

```sql
-- 1. V√©rifier les statistiques
SELECT
    last_analyze,
    n_mod_since_analyze,
    n_live_tup
FROM pg_stat_user_tables
WHERE tablename = 'ventes';

-- R√©sultat : last_analyze = il y a 30 jours, n_mod_since_analyze = 500000 !

-- 2. Lancer ANALYZE
ANALYZE ventes;

-- 3. Relancer la requ√™te ‚Üí Rapide √† nouveau !
```

### Cas 3 : Nouvelle colonne avec index

**Contexte** : Vous ajoutez une colonne et cr√©ez un index dessus.

```sql
-- Ajout d'une colonne
ALTER TABLE clients ADD COLUMN score_fidelite INT;

-- Remplissage
UPDATE clients SET score_fidelite = FLOOR(RANDOM() * 100);

-- Cr√©ation d'un index
CREATE INDEX idx_clients_score ON clients(score_fidelite);

-- ANALYZE pour que le planificateur connaisse la distribution
ANALYZE clients (score_fidelite);

-- Maintenant les requ√™tes utilisent efficacement l'index
SELECT * FROM clients WHERE score_fidelite > 80;
```

### Cas 4 : Table avec distribution de donn√©es tr√®s in√©gale

**Contexte** : Une table `produits` o√π 90% des produits sont de cat√©gorie "standard" et 10% "premium".

```sql
-- Augmenter la pr√©cision des statistiques pour la colonne critique
ALTER TABLE produits
ALTER COLUMN categorie SET STATISTICS 1000;

-- ANALYZE avec statistiques d√©taill√©es
ANALYZE produits (categorie);

-- V√©rifier les statistiques collect√©es
SELECT
    attname,
    n_distinct,
    most_common_vals,
    most_common_freqs
FROM pg_stats
WHERE tablename = 'produits' AND attname = 'categorie';
```

**R√©sultat** : Le planificateur peut maintenant diff√©rencier efficacement les requ√™tes sur "standard" (beaucoup de lignes) vs "premium" (peu de lignes).

---

## Bonnes pratiques

### 1. Faire confiance √† auto-ANALYZE

Dans la plupart des cas, **auto-ANALYZE suffit** :
- ‚úÖ Activ√© par d√©faut (via autovacuum)
- ‚úÖ Se d√©clenche automatiquement selon l'activit√©
- ‚úÖ L√©ger et non bloquant

### 2. ANALYZE manuel dans ces situations

- ‚úÖ Apr√®s un import/export massif
- ‚úÖ Apr√®s cr√©ation d'index
- ‚úÖ Avant une migration ou une op√©ration critique
- ‚úÖ En cas de requ√™te lente avec mauvaises estimations

### 3. Combiner avec VACUUM apr√®s modifications importantes

```sql
-- Apr√®s une grosse op√©ration
VACUUM ANALYZE ma_table;
```

Cela nettoie ET met √† jour les statistiques en une seule passe.

### 4. Ajuster statistics_target pour les colonnes critiques

Pour les colonnes fr√©quemment utilis√©es dans WHERE, JOIN, ORDER BY :

```sql
ALTER TABLE ma_table
ALTER COLUMN colonne_importante SET STATISTICS 500;

ANALYZE ma_table (colonne_importante);
```

### 5. Monitorer r√©guli√®rement

Mettez en place des alertes sur :
- Tables avec `n_mod_since_analyze` √©lev√©
- Tables avec `last_autoanalyze` ancien (> 7 jours)
- Requ√™tes avec √©carts importants entre estimations et r√©alit√©

### 6. Ne pas abuser d'ANALYZE

ANALYZE est l√©ger mais pas gratuit :
- ‚ùå Ne pas lancer ANALYZE apr√®s chaque INSERT
- ‚úÖ Lancer ANALYZE apr√®s des modifications significatives (> 10% de la table)

### 7. ANALYZE apr√®s CREATE INDEX

Toujours analyser apr√®s la cr√©ation d'un index :

```sql
CREATE INDEX idx_nouveau ON ma_table(colonne);
ANALYZE ma_table;  -- Important !
```

Cela permet au planificateur de conna√Ætre imm√©diatement le nouvel index.

---

## D√©pannage et troubleshooting

### Probl√®me 1 : Auto-ANALYZE ne se d√©clenche jamais

**Sympt√¥mes** : `last_autoanalyze` est NULL ou tr√®s ancien.

**Causes possibles** :
1. Autovacuum d√©sactiv√©
   ```sql
   SHOW autovacuum;  -- V√©rifier que c'est 'on'
   ```

2. Seuil trop √©lev√© pour une petite table
   ```sql
   -- Ajuster pour la table sp√©cifique
   ALTER TABLE petite_table SET (
       autovacuum_analyze_threshold = 10,
       autovacuum_analyze_scale_factor = 0.05
   );
   ```

### Probl√®me 2 : ANALYZE est tr√®s lent

**Causes** :
- `default_statistics_target` trop √©lev√©
- Table tr√®s grande avec beaucoup de colonnes
- I/O disque satur√©

**Solutions** :
```sql
-- Analyser seulement les colonnes importantes
ANALYZE ma_table (col1, col2, col3);

-- R√©duire temporairement statistics_target
SET default_statistics_target = 50;
ANALYZE ma_table;
RESET default_statistics_target;
```

### Probl√®me 3 : Estimations toujours fausses malgr√© ANALYZE

**Causes** :
- Distribution de donn√©es tr√®s atypique
- Corr√©lation entre colonnes non captur√©e
- Statistics_target insuffisant

**Solutions** :
```sql
-- Augmenter drastiquement pour la colonne probl√©matique
ALTER TABLE ma_table
ALTER COLUMN colonne_problematique SET STATISTICS 5000;

ANALYZE ma_table (colonne_problematique);

-- V√©rifier les nouvelles statistiques
SELECT * FROM pg_stats
WHERE tablename = 'ma_table'
  AND attname = 'colonne_problematique';
```

---

## ANALYZE en production : Checklist

### Checklist de maintenance quotidienne

‚úÖ **V√©rifier auto-ANALYZE** :
```sql
SELECT COUNT(*) FROM pg_stat_user_tables
WHERE n_mod_since_analyze > 10000;
-- Devrait √™tre proche de 0
```

‚úÖ **Identifier les tables "en retard"** :
```sql
SELECT tablename, n_mod_since_analyze, last_autoanalyze
FROM pg_stat_user_tables
WHERE n_mod_since_analyze > 10000
ORDER BY n_mod_since_analyze DESC;
```

‚úÖ **ANALYZE manuel si n√©cessaire** :
```sql
ANALYZE; -- Ou sur tables sp√©cifiques
```

### Checklist avant d√©ploiement

- ‚úÖ Apr√®s migration de donn√©es : `ANALYZE;`
- ‚úÖ Apr√®s changement de sch√©ma : `ANALYZE tables_modifi√©es;`
- ‚úÖ Apr√®s cr√©ation d'index : `ANALYZE tables_index√©es;`

### Checklist de monitoring hebdomadaire

- ‚úÖ Audit des statistiques obsol√®tes
- ‚úÖ V√©rification des ratios estimation/r√©alit√© dans les requ√™tes lentes
- ‚úÖ Ajustement des `statistics_target` si n√©cessaire

---

## R√©sum√©

### ANALYZE en 5 points cl√©s

1. **Collecte de statistiques** : ANALYZE √©chantillonne vos donn√©es pour collecter des statistiques
2. **Optimisation du planificateur** : Ces statistiques permettent au planificateur de choisir les meilleurs plans d'ex√©cution
3. **Auto-ANALYZE** : Processus automatique qui g√®re la plupart des cas
4. **Rapide et l√©ger** : ANALYZE est beaucoup plus rapide que VACUUM
5. **Compl√©mentaire √† VACUUM** : Souvent utilis√© ensemble (`VACUUM ANALYZE`)

### Quand lancer ANALYZE ?

| Situation | Action |
|-----------|--------|
| Import massif de donn√©es | ‚úÖ ANALYZE imm√©diat |
| Cr√©ation d'index | ‚úÖ ANALYZE imm√©diat |
| Modifications importantes (>10% de la table) | ‚úÖ ANALYZE manuel |
| Requ√™tes avec mauvaises estimations | ‚úÖ ANALYZE puis v√©rifier |
| Maintenance quotidienne normale | ‚ö™ Auto-ANALYZE suffit |

### ANALYZE vs VACUUM

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  VACUUM          ANALYZE                ‚îÇ
‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÇ
‚îÇ  Nettoie         Collecte statistiques  ‚îÇ
‚îÇ  R√©cup√®re        N'affecte pas          ‚îÇ
‚îÇ  l'espace        l'espace disque        ‚îÇ
‚îÇ  Lent (minutes)  Rapide (secondes)      ‚îÇ
‚îÇ  Sant√© DB        Performance requ√™tes   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Concepts avanc√©s (Bonus)

### La vue pg_stats : Explorer les statistiques

```sql
-- Explorer toutes les statistiques d'une table
SELECT * FROM pg_stats WHERE tablename = 'clients' \gx
```

Colonnes int√©ressantes :
- **n_distinct** : Nombre de valeurs distinctes (-1 = unique, positif = estim√©)
- **most_common_vals** : Top N valeurs les plus fr√©quentes
- **most_common_freqs** : Leurs fr√©quences
- **histogram_bounds** : Distribution des valeurs restantes
- **correlation** : Corr√©lation ordre physique/logique (important pour les index)

### Extended Statistics (Statistiques √©tendues)

Pour les colonnes corr√©l√©es, PostgreSQL 10+ permet de cr√©er des **statistiques √©tendues** :

```sql
-- Exemple : colonnes ville et code_postal sont corr√©l√©es
CREATE STATISTICS stats_ville_cp (dependencies)
ON ville, code_postal FROM clients;

ANALYZE clients;

-- Le planificateur comprend maintenant la corr√©lation
```

### Statistics Targets extr√™mes

Pour des cas tr√®s sp√©cifiques :

```sql
-- Maximum absolu
ALTER TABLE ma_table ALTER COLUMN col SET STATISTICS 10000;

-- D√©sactiver les statistiques (rare, pour debugging)
ALTER TABLE ma_table ALTER COLUMN col SET STATISTICS 0;
```

---

## Conclusion

**ANALYZE** est l'outil qui permet √† PostgreSQL de prendre des d√©cisions intelligentes :
- üß† **Cerveau du planificateur** : Fournit les donn√©es n√©cessaires aux d√©cisions
- ‚ö° **Rapide et l√©ger** : Quelques secondes m√™me sur de grosses tables
- ü§ñ **Automatis√©** : Auto-ANALYZE g√®re la plupart des cas
- üéØ **Impact direct sur les performances** : Meilleures requ√™tes = application plus rapide

En tant que d√©veloppeur ou DevOps, retenez :
- **Auto-ANALYZE fait le travail**, mais surveillez les tables √† forte activit√©
- **ANALYZE manuel apr√®s imports/modifications massives** (> 10% de la table)
- **Combinez VACUUM ANALYZE** apr√®s nettoyage de donn√©es
- **Ajustez statistics_target** pour les colonnes critiques
- **Surveillez les estimations** dans vos requ√™tes lentes (EXPLAIN ANALYZE)

PostgreSQL 18 am√©liore encore le syst√®me de statistiques avec de nouvelles m√©triques dans `pg_stat_all_tables`, vous donnant une visibilit√© encore meilleure sur la sant√© de vos bases de donn√©es.

Avec VACUUM (maintenance physique) et ANALYZE (optimisation du planificateur), vous disposez des deux piliers essentiels pour maintenir PostgreSQL en pleine forme !

---

**Prochaines √©tapes recommand√©es** :
- Approfondir **EXPLAIN et le planificateur** (Chapitre 13.7)
- Explorer **les index et leur impact sur les plans** (Chapitre 13)
- D√©couvrir **pg_stat_statements pour l'analyse des requ√™tes** (Chapitre 14.1)

---


‚è≠Ô∏è [Nouveaut√© PG 18 : Autovacuum et ajustements dynamiques (autovacuum_worker_slots)](/16-administration-configuration-securite/10.3-autovacuum-ajustements-pg18.md)
