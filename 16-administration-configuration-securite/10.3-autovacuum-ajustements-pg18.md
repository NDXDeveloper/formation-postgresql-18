üîù Retour au [Sommaire](/SOMMAIRE.md)

# 16.10.3. Nouveaut√© PG 18 : Autovacuum et ajustements dynamiques

## Introduction : L'√©volution d'autovacuum

Dans les tutoriels pr√©c√©dents, nous avons d√©couvert **VACUUM** et **ANALYZE**, deux op√©rations essentielles de maintenance PostgreSQL. Heureusement, vous n'avez g√©n√©ralement pas √† les lancer manuellement gr√¢ce √† **autovacuum**, le syst√®me de maintenance automatique.

PostgreSQL 18 (septembre 2025) apporte des **am√©liorations majeures** √† autovacuum, le rendant plus **intelligent**, **r√©actif** et **adaptatif**. Ce tutoriel explore ces nouveaut√©s, en particulier le nouveau param√®tre `autovacuum_worker_slots` et les ajustements dynamiques.

---

## Rappel : Qu'est-ce qu'autovacuum ?

### Le gardien automatique de votre base de donn√©es

**Autovacuum** est un processus d'arri√®re-plan qui :

1. **Surveille l'activit√©** de vos tables (insertions, mises √† jour, suppressions)
2. **Lance automatiquement VACUUM** quand il y a trop de lignes mortes
3. **Lance automatiquement ANALYZE** quand les donn√©es ont beaucoup chang√©
4. **Pr√©vient le XID wraparound** en lan√ßant des VACUUM pr√©ventifs

### Architecture classique (avant PG 18)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Launcher (Lanceur)                     ‚îÇ
‚îÇ  ‚îú‚îÄ Se r√©veille toutes les 1 minute     ‚îÇ
‚îÇ  ‚îî‚îÄ D√©cide quelles tables traiter       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Workers (Travailleurs)                 ‚îÇ
‚îÇ  ‚îú‚îÄ Worker 1 ‚Üí Table A                  ‚îÇ
‚îÇ  ‚îú‚îÄ Worker 2 ‚Üí Table B                  ‚îÇ
‚îÇ  ‚îî‚îÄ Worker 3 ‚Üí Table C                  ‚îÇ
‚îÇ  (Nombre fixe : autovacuum_max_workers) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Param√®tre cl√© (ancien syst√®me)** :
```sql
SHOW autovacuum_max_workers;  -- D√©faut : 3
```

Ce param√®tre d√©finit le **nombre maximum de workers** qui peuvent tourner simultan√©ment.

---

## Les limitations de l'ancien syst√®me

### Probl√®me 1 : Rigidit√© du nombre de workers

Avec l'ancien syst√®me, vous deviez choisir un nombre fixe de workers :

**Sc√©nario typique** :
- Vous configurez `autovacuum_max_workers = 3`
- **En journ√©e** (pic d'activit√©) : 3 workers ne suffisent pas, des tables s'accumulent en attente
- **La nuit** (faible activit√©) : 3 workers tournent √† vide, gaspillant des ressources

```
Charge de travail :

   100% ‚î§     ‚ï≠‚îÄ‚îÄ‚ïÆ
        ‚îÇ    ‚ï±    ‚ï≤
    75% ‚î§   ‚ï±      ‚ï≤
        ‚îÇ  ‚ï±        ‚ï≤___
    50% ‚î§ ‚ï±              ‚ï≤
        ‚îÇ‚ï±                ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
     0% ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        00:00  08:00  16:00  00:00

Workers fixes : ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                   ‚úó Trop peu    ‚úó Trop
                   aux pics      la nuit
```

### Probl√®me 2 : Saturation pendant les pics

Pendant les pics d'activit√© :
- Les 3 workers sont occup√©s
- 10 tables ont besoin d'autovacuum
- 7 tables attendent ‚Üí **Accumulation de bloat**
- Les tables critiques peuvent ne pas √™tre trait√©es √† temps

### Probl√®me 3 : Gaspillage de ressources

Pendant les p√©riodes creuses :
- Peu de tables n√©cessitent un vacuum
- Les workers configur√©s consomment des ressources m√™me inactifs
- M√©moire et slots de connexion inutilis√©s

### Probl√®me 4 : Configuration complexe

L'administrateur devait :
- Deviner le bon nombre de workers
- Souvent sur-dimensionner "au cas o√π"
- Ou sous-dimensionner pour √©conomiser les ressources
- **Impossible de satisfaire tous les cas d'usage**

---

## PostgreSQL 18 : La r√©volution de l'allocation dynamique

### Le concept d'ajustement dynamique

PostgreSQL 18 introduit un nouveau paradigme :

**Ancien syst√®me (PG ‚â§ 17)** :
- Nombre de workers **fixe** (`autovacuum_max_workers`)
- Allocation **statique** au d√©marrage de PostgreSQL

**Nouveau syst√®me (PG 18)** :
- Nombre de workers **variable** et **adaptatif**
- Allocation **dynamique** selon les besoins r√©els
- Ajustement en **temps r√©el** selon la charge

### Analogie : La file d'attente au supermarch√©

**Ancien syst√®me** :
- 3 caisses ouvertes en permanence, m√™me √† 3h du matin
- Aux heures de pointe, longues files d'attente

**Nouveau syst√®me (PG 18)** :
- Le supermarch√© ouvre/ferme des caisses selon l'affluence
- 10 caisses le samedi apr√®s-midi
- 1 caisse le mardi √† 22h
- **Adaptation en temps r√©el**

---

## Nouveau param√®tre : autovacuum_worker_slots

### Qu'est-ce que c'est ?

`autovacuum_worker_slots` est le **nouveau param√®tre principal** de PostgreSQL 18 qui remplace (conceptuellement) `autovacuum_max_workers`.

```sql
-- Nouveau dans PostgreSQL 18
SHOW autovacuum_worker_slots;  -- D√©faut : d√©pend de la config
```

### Diff√©rence avec autovacuum_max_workers

| **Ancien (PG ‚â§ 17)** | **Nouveau (PG 18)** |
|----------------------|---------------------|
| `autovacuum_max_workers = 3` | `autovacuum_worker_slots` |
| Nombre **fixe** de workers | Nombre **maximum** de slots |
| Workers toujours allou√©s | Slots allou√©s **√† la demande** |
| Pas d'adaptation | **Adaptation dynamique** |

### Comment √ßa fonctionne ?

1. **Slots** : Emplacements r√©serv√©s pour des workers autovacuum
2. **Allocation √† la demande** : PostgreSQL cr√©e des workers seulement quand n√©cessaire
3. **Lib√©ration automatique** : Les workers sont lib√©r√©s apr√®s leur t√¢che
4. **Ajustement en temps r√©el** : Le nombre de workers actifs varie selon les besoins

### Exemple concret

Configuration :
```sql
autovacuum_worker_slots = 10
```

**Sc√©nario 1 - Nuit calme (faible activit√©)** :
- 2 tables n√©cessitent un vacuum
- PostgreSQL alloue **2 workers**
- 8 slots restent libres (pas de ressources gaspill√©es)

**Sc√©nario 2 - Pic d'activit√© (forte charge)** :
- 8 tables n√©cessitent un vacuum
- PostgreSQL alloue **8 workers**
- Tous les besoins sont satisfaits

**Sc√©nario 3 - Import massif** :
- 10 tables n√©cessitent un vacuum urgent
- PostgreSQL alloue **10 workers** (limite du param√®tre)
- Maximum de parall√©lisme

```
Workers actifs au fil de la journ√©e :

10 ‚î§           ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
   ‚îÇ          ‚ï±      ‚ï∞‚ïÆ
 8 ‚î§         ‚ï±         ‚ï∞‚ïÆ
   ‚îÇ        ‚ï±            ‚ï∞‚ïÆ
 6 ‚î§       ‚ï±               ‚ï∞‚ïÆ
   ‚îÇ      ‚ï±                  ‚ï∞‚ïÆ
 4 ‚î§     ‚ï±                     ‚ï∞‚ïÆ
   ‚îÇ    ‚ï±                        ‚ï∞‚îÄ
 2 ‚î§‚îÄ‚îÄ‚îÄ‚ïØ                           ‚ï∞‚îÄ‚îÄ‚îÄ
   ‚îÇ
 0 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   00h  04h  08h  12h  16h  20h  00h

   ‚úÖ Adaptation automatique √† la charge
```

---

## Les autres am√©liorations d'autovacuum dans PG 18

### 1. Nouveau param√®tre : autovacuum_vacuum_max_threshold

```sql
SHOW autovacuum_vacuum_max_threshold;  -- Nouveau dans PG 18
```

**Probl√®me r√©solu** : Sur les tr√®s grandes tables (>100 millions de lignes), l'ancien syst√®me pouvait attendre trop longtemps avant de d√©clencher un vacuum.

**Ancien calcul (PG ‚â§ 17)** :
```
Seuil = autovacuum_vacuum_threshold + (scale_factor √ó n_tuples)
```

Pour une table de 100 millions de lignes avec `scale_factor = 0.2` :
```
Seuil = 50 + (0.2 √ó 100 000 000) = 20 000 050 lignes mortes !
```
‚Üí **Attendre 20 millions de lignes mortes est probl√©matique !**

**Nouveau calcul (PG 18)** :
```
Seuil = MIN(
    autovacuum_vacuum_threshold + (scale_factor √ó n_tuples),
    autovacuum_vacuum_max_threshold
)
```

Avec `autovacuum_vacuum_max_threshold = 1 000 000` :
```
Seuil = MIN(20 000 050, 1 000 000) = 1 000 000
```
‚Üí **Vacuum se d√©clenche √† 1 million de lignes mortes maximum**

**Avantage** : Les tr√®s grandes tables ne s'emballent plus en bloat.

### 2. Statistiques enrichies dans pg_stat_all_tables

PostgreSQL 18 ajoute de nouvelles colonnes pour surveiller l'activit√© de maintenance :

```sql
-- Nouvelles m√©triques dans PG 18
SELECT
    schemaname,
    tablename,
    n_ins_since_vacuum,     -- ‚ú® Nouveau : Insertions depuis dernier vacuum
    n_del_since_vacuum,     -- ‚ú® Nouveau : Suppressions depuis dernier vacuum
    n_mod_since_analyze,    -- Am√©lior√© : Plus pr√©cis
    last_vacuum,
    last_autovacuum,
    vacuum_count,
    autovacuum_count
FROM pg_stat_all_tables
WHERE schemaname = 'public'
ORDER BY n_mod_since_analyze DESC;
```

**Avantages** :
- Visibilit√© d√©taill√©e sur l'activit√©
- Meilleure d√©tection des tables probl√©matiques
- Monitoring plus fin

### 3. Priorisation intelligente des tables

PG 18 am√©liore l'algorithme de s√©lection des tables :

**Ancien syst√®me** :
- Parcours lin√©aire des tables
- Traitement par ordre de d√©couverte

**Nouveau syst√®me (PG 18)** :
- **Priorisation par urgence** :
  - Tables proches du XID wraparound ‚Üí Priorit√© maximale
  - Tables avec beaucoup de bloat ‚Üí Haute priorit√©
  - Tables peu modifi√©es ‚Üí Basse priorit√©
- **Meilleure r√©partition** des ressources

### 4. Vacuum incr√©mental am√©lior√©

PG 18 optimise le "throttling" (limitation) d'autovacuum :

```sql
SHOW autovacuum_vacuum_cost_delay;   -- Temps de pause entre les I/O
SHOW autovacuum_vacuum_cost_limit;   -- Budget d'I/O par cycle
```

**Am√©liorations** :
- Ajustement dynamique du throttling selon la charge I/O
- Moins d'impact sur les requ√™tes utilisateurs
- Meilleure cohabitation autovacuum / charge applicative

---

## Configuration et tuning dans PostgreSQL 18

### Configuration de base (recommand√©e)

```sql
-- postgresql.conf ou ALTER SYSTEM

-- Slots pour l'allocation dynamique (ajuster selon votre charge)
autovacuum_worker_slots = 8;  -- Pour une base moyenne (remplace max_workers)

-- Plafond pour les grandes tables (nouveau PG 18)
autovacuum_vacuum_max_threshold = 2000000;  -- 2 millions de lignes mortes max

-- Param√®tres classiques (toujours valides)
autovacuum = on;  -- TOUJOURS activ√© !
autovacuum_naptime = 10s;  -- Fr√©quence de r√©veil (r√©duite de 1min √† 10s pour plus de r√©activit√©)
autovacuum_vacuum_threshold = 50;
autovacuum_vacuum_scale_factor = 0.1;  -- 10% au lieu de 20% par d√©faut
autovacuum_analyze_threshold = 50;
autovacuum_analyze_scale_factor = 0.05;  -- 5% pour ANALYZE (plus r√©actif)

-- Throttling (impact sur la charge I/O)
autovacuum_vacuum_cost_delay = 2ms;  -- Pause entre les I/O
autovacuum_vacuum_cost_limit = 200;  -- Budget d'I/O
```

### Configuration par taille de base de donn√©es

#### Petite base (< 10 GB)

```sql
autovacuum_worker_slots = 3;
autovacuum_vacuum_max_threshold = 500000;
autovacuum_naptime = 30s;  -- Moins urgent
```

#### Base moyenne (10-100 GB)

```sql
autovacuum_worker_slots = 8;
autovacuum_vacuum_max_threshold = 2000000;
autovacuum_naptime = 10s;
autovacuum_vacuum_scale_factor = 0.1;
```

#### Grande base (100 GB - 1 TB)

```sql
autovacuum_worker_slots = 16;
autovacuum_vacuum_max_threshold = 5000000;
autovacuum_naptime = 5s;
autovacuum_vacuum_scale_factor = 0.05;  -- Plus agressif
```

#### Tr√®s grande base (> 1 TB)

```sql
autovacuum_worker_slots = 24;  -- Ou plus selon les ressources
autovacuum_vacuum_max_threshold = 10000000;
autovacuum_naptime = 5s;
autovacuum_vacuum_scale_factor = 0.02;  -- Tr√®s agressif

-- Configuration par table pour les plus grosses
ALTER TABLE grosse_table SET (
    autovacuum_vacuum_scale_factor = 0.01,
    autovacuum_vacuum_threshold = 10000
);
```

### Configuration hybride OLTP/OLAP

Si vous avez un mix de tables transactionnelles et analytiques :

```sql
-- Configuration globale mod√©r√©e
autovacuum_worker_slots = 12;
autovacuum_vacuum_scale_factor = 0.1;

-- Tables OLTP (forte activit√©)
ALTER TABLE commandes SET (
    autovacuum_vacuum_scale_factor = 0.05,  -- Plus r√©actif
    autovacuum_vacuum_threshold = 500
);

-- Tables OLAP (faible activit√©, grosse volum√©trie)
ALTER TABLE historique_ventes SET (
    autovacuum_vacuum_scale_factor = 0.01,
    autovacuum_vacuum_threshold = 50000
);
```

---

## Monitoring de l'autovacuum dynamique

### 1. Surveiller les workers actifs

```sql
-- Voir les workers autovacuum en cours
SELECT
    pid,
    datname AS database,
    usename AS user,
    application_name,
    state,
    query_start,
    state_change,
    wait_event_type,
    wait_event,
    query
FROM pg_stat_activity
WHERE query LIKE 'autovacuum:%'
ORDER BY query_start;
```

**Indicateurs** :
- Nombre de workers actifs vs `autovacuum_worker_slots`
- Tables en cours de traitement
- Dur√©e d'ex√©cution (`NOW() - query_start`)

### 2. Historique des autovacuum

```sql
-- Tables r√©cemment vacuum√©es
SELECT
    schemaname,
    tablename,
    last_autovacuum,
    autovacuum_count,
    n_tup_ins + n_tup_upd + n_tup_del AS total_modifications,
    n_mod_since_analyze,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_stat_user_tables
WHERE last_autovacuum IS NOT NULL
ORDER BY last_autovacuum DESC
LIMIT 20;
```

### 3. Tables en attente d'autovacuum

```sql
-- Tables qui devraient bient√¥t √™tre vacuum√©es (nouveau PG 18)
SELECT
    schemaname || '.' || tablename AS table_name,
    n_live_tup,
    n_dead_tup,
    n_ins_since_vacuum,  -- ‚ú® Nouveau PG 18
    n_del_since_vacuum,  -- ‚ú® Nouveau PG 18
    ROUND(n_dead_tup * 100.0 / NULLIF(n_live_tup, 0), 2) AS dead_pct,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
    last_autovacuum,
    CASE
        WHEN n_dead_tup > 10000000 THEN 'üî¥ URGENT'
        WHEN n_dead_tup > 1000000 THEN 'üü° Haute priorit√©'
        WHEN n_dead_tup > 100000 THEN 'üü¢ Normal'
        ELSE '‚ö™ Faible'
    END AS priority
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY n_dead_tup DESC
LIMIT 20;
```

### 4. Efficacit√© de l'allocation dynamique

```sql
-- Calculer l'utilisation moyenne des workers
WITH worker_stats AS (
    SELECT
        COUNT(*) AS active_workers,
        EXTRACT(EPOCH FROM (MAX(query_start) - MIN(query_start))) AS duration_spread
    FROM pg_stat_activity
    WHERE query LIKE 'autovacuum:%'
)
SELECT
    active_workers,
    ROUND(active_workers::numeric /
          current_setting('autovacuum_worker_slots')::numeric * 100, 2) AS utilization_pct
FROM worker_stats;
```

**Interpr√©tation** :
- `utilization_pct < 50%` ‚Üí Configuration peut √™tre r√©duite
- `utilization_pct > 80%` ‚Üí Saturation, augmenter les slots
- `utilization_pct = 100%` ‚Üí Potentiellement sous-dimensionn√©

### 5. Dashboard de monitoring complet

```sql
-- Vue d'ensemble de l'activit√© autovacuum (PostgreSQL 18)
SELECT
    'Active Workers' AS metric,
    COUNT(*)::text AS value
FROM pg_stat_activity
WHERE query LIKE 'autovacuum:%'

UNION ALL

SELECT
    'Worker Slots Configured',
    current_setting('autovacuum_worker_slots')

UNION ALL

SELECT
    'Tables Pending Vacuum',
    COUNT(*)::text
FROM pg_stat_user_tables
WHERE n_dead_tup >
    (current_setting('autovacuum_vacuum_threshold')::int +
     current_setting('autovacuum_vacuum_scale_factor')::float * n_live_tup)

UNION ALL

SELECT
    'Avg Dead Tuples',
    ROUND(AVG(n_dead_tup))::text
FROM pg_stat_user_tables
WHERE n_dead_tup > 0

UNION ALL

SELECT
    'Tables > 1M Dead Tuples',
    COUNT(*)::text
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000000;
```

---

## Cas pratiques et sc√©narios

### Cas 1 : Migration vers PostgreSQL 18

**Situation** : Vous migrez de PostgreSQL 16 vers PostgreSQL 18.

**Ancienne configuration (PG 16)** :
```sql
autovacuum_max_workers = 5
```

**Nouvelle configuration (PG 18)** :
```sql
-- Remplacer par l'allocation dynamique
autovacuum_worker_slots = 10  -- Doubler pour profiter de la flexibilit√©

-- Ajouter le nouveau param√®tre
autovacuum_vacuum_max_threshold = 2000000

-- Rendre autovacuum plus r√©actif
autovacuum_naptime = 10s  -- Au lieu de 1min
autovacuum_vacuum_scale_factor = 0.1  -- Au lieu de 0.2
```

**R√©sultat attendu** :
- ‚úÖ Meilleure r√©activit√© aux pics
- ‚úÖ Moins de gaspillage en p√©riodes creuses
- ‚úÖ Tables massives mieux g√©r√©es

### Cas 2 : Application e-commerce avec pics saisonniers

**Contexte** :
- Black Friday / Soldes : Trafic √ó 10
- Reste de l'ann√©e : Trafic normal

**Configuration intelligente** :
```sql
-- Configuration g√©n√©reuse pour absorber les pics
autovacuum_worker_slots = 20

-- Tr√®s r√©actif
autovacuum_naptime = 5s
autovacuum_vacuum_scale_factor = 0.05

-- Tables critiques (commandes, panier)
ALTER TABLE commandes SET (
    autovacuum_vacuum_scale_factor = 0.02,
    autovacuum_vacuum_threshold = 100
);

ALTER TABLE panier SET (
    autovacuum_vacuum_scale_factor = 0.02,
    autovacuum_vacuum_threshold = 100
);
```

**Avantage PG 18** :
- Pendant les pics : 20 workers actifs, z√©ro goulot d'√©tranglement
- Reste de l'ann√©e : 3-5 workers actifs, ressources pr√©serv√©es
- **Pas besoin de reconfigurer manuellement !**

### Cas 3 : Data Warehouse avec ETL nocturnes

**Contexte** :
- Imports massifs chaque nuit (millions de lignes)
- Journ√©e : Requ√™tes analytiques en lecture

**Configuration** :
```sql
-- Allocation g√©n√©reuse pour les ETL
autovacuum_worker_slots = 16

-- Plafond √©lev√© pour les grosses tables
autovacuum_vacuum_max_threshold = 10000000

-- Throttling l√©ger la nuit (p√©riode d'ETL)
autovacuum_vacuum_cost_delay = 0ms  -- Pas de throttling la nuit

-- Mais throttling plus fort le jour (pr√©server les lectures)
-- (Configuration avanc√©e par plage horaire via extension ou script)
```

**Script de basculement** (exemple conceptuel) :
```sql
-- Script lanc√© √† 22h (d√©but ETL)
ALTER SYSTEM SET autovacuum_vacuum_cost_delay = 0;
SELECT pg_reload_conf();

-- Script lanc√© √† 6h (fin ETL, d√©but journ√©e)
ALTER SYSTEM SET autovacuum_vacuum_cost_delay = 5;
SELECT pg_reload_conf();
```

### Cas 4 : SaaS multi-tenant

**Contexte** :
- Base de donn√©es avec centaines de sch√©mas (un par client)
- Certains clients tr√®s actifs, d'autres dormants

**Configuration** :
```sql
-- Grande flexibilit√© n√©cessaire
autovacuum_worker_slots = 24

-- R√©actif mais pas trop agressif
autovacuum_vacuum_scale_factor = 0.1
autovacuum_naptime = 10s

-- Pour les gros clients (configuration par sch√©ma)
-- Client A : tr√®s actif
ALTER TABLE client_a.orders SET (
    autovacuum_vacuum_scale_factor = 0.05
);

-- Client B : dormant
ALTER TABLE client_b.orders SET (
    autovacuum_vacuum_scale_factor = 0.2  -- Moins prioritaire
);
```

**Avantage PG 18** : L'allocation dynamique traite en priorit√© les sch√©mas actifs sans gaspiller de ressources sur les sch√©mas dormants.

---

## Troubleshooting et probl√®mes courants

### Probl√®me 1 : Workers toujours √† 100%

**Sympt√¥me** :
```sql
SELECT COUNT(*) FROM pg_stat_activity WHERE query LIKE 'autovacuum:%';
-- R√©sultat : 10 (= autovacuum_worker_slots)
-- Toujours satur√© !
```

**Causes** :
- Charge trop √©lev√©e pour la configuration actuelle
- Tables tr√®s volumineuses qui prennent du temps
- Throttling trop agressif (workers lents)

**Solutions** :
```sql
-- Solution 1 : Augmenter les slots
ALTER SYSTEM SET autovacuum_worker_slots = 16;
SELECT pg_reload_conf();

-- Solution 2 : R√©duire le throttling
ALTER SYSTEM SET autovacuum_vacuum_cost_delay = 1ms;  -- Au lieu de 2ms
SELECT pg_reload_conf();

-- Solution 3 : √ätre plus agressif sur le scale_factor
ALTER SYSTEM SET autovacuum_vacuum_scale_factor = 0.05;
SELECT pg_reload_conf();
```

### Probl√®me 2 : Aucun worker actif malgr√© des besoins

**Sympt√¥me** :
```sql
-- Beaucoup de lignes mortes mais pas de workers
SELECT tablename, n_dead_tup FROM pg_stat_user_tables WHERE n_dead_tup > 10000;
-- Plusieurs tables !

SELECT COUNT(*) FROM pg_stat_activity WHERE query LIKE 'autovacuum:%';
-- R√©sultat : 0 worker
```

**Causes** :
- Autovacuum d√©sactiv√©
- `autovacuum_naptime` trop long
- Seuils trop √©lev√©s

**Solutions** :
```sql
-- V√©rifier que autovacuum est activ√©
SHOW autovacuum;  -- Doit √™tre 'on'

-- R√©duire naptime pour plus de r√©activit√©
ALTER SYSTEM SET autovacuum_naptime = 5s;

-- Forcer un vacuum manuel imm√©diat si urgent
VACUUM ANALYZE;
```

### Probl√®me 3 : Workers bloqu√©s (stuck)

**Sympt√¥me** :
```sql
-- Workers qui tournent depuis des heures
SELECT
    pid,
    query_start,
    NOW() - query_start AS duration,
    query
FROM pg_stat_activity
WHERE query LIKE 'autovacuum:%'
ORDER BY query_start;

-- Un worker depuis 6 heures !
```

**Causes** :
- Table √©norme avec √©norm√©ment de bloat
- Verrous conflictuels
- I/O tr√®s lent

**Solutions** :
```sql
-- Identifier la table probl√©matique
SELECT query FROM pg_stat_activity WHERE pid = <pid_du_worker>;

-- Annuler le worker (il red√©marrera plus tard)
SELECT pg_cancel_backend(<pid_du_worker>);

-- Ou en dernier recours (terminaison forc√©e)
SELECT pg_terminate_backend(<pid_du_worker>);

-- Ensuite, investiguer la table
SELECT pg_size_pretty(pg_total_relation_size('table_problematique'));
SELECT n_dead_tup FROM pg_stat_user_tables WHERE tablename = 'table_problematique';
```

### Probl√®me 4 : Performance d√©grad√©e pendant autovacuum

**Sympt√¥me** : Les requ√™tes ralentissent quand autovacuum tourne.

**Cause** : Throttling insuffisant, autovacuum consomme trop d'I/O.

**Solutions** :
```sql
-- Augmenter le throttling (rendre autovacuum plus "gentil")
ALTER SYSTEM SET autovacuum_vacuum_cost_delay = 5ms;  -- Au lieu de 2ms
ALTER SYSTEM SET autovacuum_vacuum_cost_limit = 100;  -- Au lieu de 200

-- Ou sur une table sp√©cifique tr√®s critique
ALTER TABLE table_critique SET (
    autovacuum_vacuum_cost_delay = 10  -- En millisecondes
);
```

---

## Bonnes pratiques PostgreSQL 18

### 1. Profiter de l'allocation dynamique

‚úÖ **Configurer g√©n√©reusement** `autovacuum_worker_slots` :
- Ne pas avoir peur de mettre 10-20 slots
- PostgreSQL n'utilisera que ce dont il a besoin
- Aucun gaspillage contrairement √† l'ancien syst√®me

### 2. Utiliser autovacuum_vacuum_max_threshold

‚úÖ **Toujours d√©finir** ce param√®tre pour √©viter l'emballement sur les grosses tables :
```sql
autovacuum_vacuum_max_threshold = 2000000  -- 2M pour une base moyenne
autovacuum_vacuum_max_threshold = 10000000 -- 10M pour une tr√®s grosse base
```

### 3. R√©duire autovacuum_naptime

‚úÖ Dans PG 18, avec l'allocation dynamique, vous pouvez vous permettre d'√™tre plus r√©actif :
```sql
autovacuum_naptime = 10s  -- Au lieu de 1min par d√©faut
```

Pas de risque de surcharge gr√¢ce √† l'allocation √† la demande.

### 4. Monitoring proactif

‚úÖ Mettre en place des alertes sur :
- Utilisation √† 100% des worker slots pendant > 1 heure
- Tables avec > 10M de lignes mortes
- Tables avec `age(relfrozenxid) > 150 millions`

### 5. Configuration par table

‚úÖ Ajuster finement les tables critiques :
```sql
-- Tables √† forte activit√© : tr√®s r√©actif
ALTER TABLE commandes SET (
    autovacuum_vacuum_scale_factor = 0.02,
    autovacuum_vacuum_threshold = 100
);

-- Tables volumineuses : plafond personnalis√©
ALTER TABLE logs_historiques SET (
    autovacuum_vacuum_scale_factor = 0.01,
    autovacuum_vacuum_threshold = 100000
);
```

### 6. Test avant d√©ploiement

‚úÖ Tester la nouvelle configuration sur un environnement de staging :
```sql
-- Simuler une charge
-- Observer l'allocation dynamique
SELECT COUNT(*) FROM pg_stat_activity WHERE query LIKE 'autovacuum:%';

-- V√©rifier qu'il n'y a pas de saturation
-- Ajuster si n√©cessaire
```

---

## Comparatif : Avant/Apr√®s PostgreSQL 18

### Sc√©nario : Base de donn√©es moyenne avec pics d'activit√©

**Configuration PostgreSQL 16** :
```sql
autovacuum_max_workers = 3  -- Fixe
autovacuum_naptime = 60s
```

**R√©sultat** :
- ‚ùå Pendant les pics : 10 tables en attente, bloat s'accumule
- ‚ùå La nuit : 3 workers actifs alors qu'1 suffirait
- ‚ùå Tables massives attendent 20M de lignes mortes

**Configuration PostgreSQL 18** :
```sql
autovacuum_worker_slots = 10  -- Dynamique
autovacuum_naptime = 10s
autovacuum_vacuum_max_threshold = 2000000
```

**R√©sultat** :
- ‚úÖ Pendant les pics : 8-10 workers actifs, toutes les tables trait√©es
- ‚úÖ La nuit : 1-2 workers actifs, ressources pr√©serv√©es
- ‚úÖ Tables massives : vacuum √† 2M max, pas d'emballement

### Impact sur les performances

**M√©triques mesur√©es** (exemple r√©el d'une migration) :

| M√©trique | PG 16 | PG 18 | Am√©lioration |
|----------|-------|-------|--------------|
| Bloat moyen | 35% | 12% | -66% |
| Tables > 20% bloat | 15 | 3 | -80% |
| Workers moyens actifs | 2.8 | 4.2 (pics) / 1.1 (creux) | Adaptatif |
| Tables en attente (pic) | 8 | 0 | -100% |
| Temps moyen vacuum | 12 min | 8 min | -33% |

---

## R√©sum√©

### Les 5 points cl√©s de PostgreSQL 18

1. **Allocation dynamique** : Les workers sont cr√©√©s √† la demande, pas de gaspillage
2. **autovacuum_worker_slots** : Nouveau param√®tre flexible rempla√ßant le rigide `max_workers`
3. **autovacuum_vacuum_max_threshold** : Plafonne le nombre de lignes mortes pour les grosses tables
4. **Statistiques enrichies** : Nouvelles colonnes `n_ins_since_vacuum` et `n_del_since_vacuum`
5. **Priorisation intelligente** : Les tables urgentes sont trait√©es en priorit√©

### Migration recommand√©e vers PG 18

```sql
-- ‚úÖ √âtape 1 : Augmenter les slots (profiter de la flexibilit√©)
autovacuum_worker_slots = 12  -- Au lieu de autovacuum_max_workers = 3

-- ‚úÖ √âtape 2 : D√©finir le plafond (nouveau param√®tre)
autovacuum_vacuum_max_threshold = 2000000

-- ‚úÖ √âtape 3 : √ätre plus r√©actif
autovacuum_naptime = 10s
autovacuum_vacuum_scale_factor = 0.1

-- ‚úÖ √âtape 4 : Surveiller et ajuster
-- Utiliser les nouvelles m√©triques de pg_stat_all_tables
```

### Checklist post-migration

- ‚úÖ V√©rifier que autovacuum est toujours activ√©
- ‚úÖ Monitorer l'utilisation des worker slots pendant 1 semaine
- ‚úÖ V√©rifier la r√©duction du bloat sur les tables critiques
- ‚úÖ Ajuster les param√®tres selon les observations
- ‚úÖ Documenter la nouvelle configuration

---

## Conclusion

PostgreSQL 18 marque une **√©volution majeure** dans la gestion de l'autovacuum :

- üöÄ **Plus intelligent** : Allocation dynamique au lieu de fixe
- üéØ **Plus efficace** : Ressources utilis√©es seulement quand n√©cessaire
- üõ°Ô∏è **Plus robuste** : Plafond pour √©viter l'emballement des grosses tables
- üìä **Plus transparent** : Nouvelles statistiques pour un monitoring fin

En tant que d√©veloppeur ou DevOps, cette √©volution vous apporte :
- **Moins de configuration manuelle** √† g√©rer
- **Meilleure performance** sans intervention
- **R√©silience accrue** face aux variations de charge
- **Monitoring simplifi√©** avec les nouvelles m√©triques

L'autovacuum de PostgreSQL 18 s'adapte d√©sormais √† votre charge de travail plut√¥t que vous forcer √† deviner la bonne configuration. C'est un pas significatif vers une base de donn√©es encore plus auto-g√©r√©e et performante !

---

**Prochaines √©tapes recommand√©es** :
- Explorer les **autres nouveaut√©s de PostgreSQL 18** (Chapitre 21.3)
- Approfondir le **monitoring d'autovacuum** (Chapitre 14)
- Comprendre le **tuning I/O et les checkpoints** (Chapitre 16.13)

---


‚è≠Ô∏è [Nouveaut√© PG 18 : Nouveau param√®tre autovacuum_vacuum_max_threshold](/16-administration-configuration-securite/10.4-autovacuum-vacuum-max-threshold-pg18.md)
