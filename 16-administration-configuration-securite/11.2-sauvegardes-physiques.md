üîù Retour au [Sommaire](/SOMMAIRE.md)

# 16.11.2. Sauvegardes Physiques (pg_basebackup)

## Introduction aux Sauvegardes Physiques

Les sauvegardes physiques repr√©sentent une approche fondamentalement diff√©rente des sauvegardes logiques. Alors qu'une sauvegarde logique extrait les donn√©es sous forme de commandes SQL, une sauvegarde physique copie directement les **fichiers binaires** qui constituent la base de donn√©es PostgreSQL sur le disque.

### Analogie Simple

Imaginez deux fa√ßons de sauvegarder une biblioth√®que :

- **Sauvegarde logique (pg_dump)** : Vous recopiez le contenu de chaque livre, page par page, dans de nouveaux cahiers. Vous pouvez lire et modifier ces cahiers, les r√©organiser, mais reconstituer la biblioth√®que prendra du temps.

- **Sauvegarde physique (pg_basebackup)** : Vous prenez une photo exacte de chaque √©tag√®re telle quelle, avec les livres dans leur position exacte. La restauration est rapide (remettre les √©tag√®res en place), mais vous ne pouvez pas facilement extraire un seul livre.

### Qu'est-ce qu'une Sauvegarde Physique ?

Une sauvegarde physique copie **l'int√©gralit√© du r√©pertoire de donn√©es PostgreSQL** (data directory), incluant :

- Les fichiers de tables et d'index
- Les fichiers de configuration
- Les fichiers WAL (Write-Ahead Log)
- Les fichiers de contr√¥le
- Les fichiers de transaction

Le r√©sultat est une copie **bit √† bit** du cluster PostgreSQL entier, pr√™te √† √™tre remont√©e telle quelle.

---

## Sauvegardes Logiques vs Sauvegardes Physiques

### Comparaison D√©taill√©e

| Crit√®re | Sauvegarde Logique (pg_dump) | Sauvegarde Physique (pg_basebackup) |
|---------|------------------------------|-------------------------------------|
| **Granularit√©** | Base par base, table par table | Cluster entier seulement |
| **Format** | SQL lisible ou binaire PostgreSQL | Fichiers binaires bruts |
| **Portabilit√©** | Excellente (versions, OS, architectures) | Limit√©e (m√™me version majeure, m√™me architecture) |
| **Taille** | G√©n√©ralement plus petite (donn√©es seules) | Plus grande (inclut index, TOAST, etc.) |
| **Vitesse de sauvegarde** | Lente (lecture + export) | Rapide (copie directe) |
| **Vitesse de restauration** | Lente (rejeu SQL) | Tr√®s rapide (copie de fichiers) |
| **Point-In-Time Recovery (PITR)** | Non | **Oui** ‚úÖ |
| **Restauration s√©lective** | Oui (tables sp√©cifiques) | Non (tout ou rien) |
| **D√©pendance version** | Flexible | Stricte (majeure identique) |
| **Coh√©rence transactionnelle** | Snapshot d'une base | Snapshot du cluster entier |
| **Impact performance** | Mod√©r√© (CPU, I/O) | Faible √† mod√©r√© (I/O r√©seau) |
| **Cas d'usage principal** | Migration, clonage, export | Production, HA, PITR |

### Avantages des Sauvegardes Physiques

‚úÖ **Rapidit√©** : Sauvegarde et restauration beaucoup plus rapides pour les grandes bases

‚úÖ **Point-In-Time Recovery** : Permet de restaurer √† n'importe quel moment pr√©cis dans le pass√©

‚úÖ **Haute Disponibilit√©** : Base pour la r√©plication streaming et les serveurs de secours

‚úÖ **Coh√©rence globale** : Snapshot coh√©rent de toutes les bases du cluster

‚úÖ **Automatisable** : Int√©gration facile dans des syst√®mes de HA (Patroni, Repmgr)

‚úÖ **Efficacit√©** : Id√©al pour les tr√®s grandes bases de donn√©es (plusieurs To)

### Inconv√©nients des Sauvegardes Physiques

‚ùå **Granularit√© limit√©e** : Impossible de restaurer une seule base ou une seule table

‚ùå **Compatibilit√© version** : Ne fonctionne qu'entre versions mineures (ex: 18.0 ‚Üí 18.3, mais pas 17 ‚Üí 18)

‚ùå **Compatibilit√© architecture** : M√™me architecture CPU requise (x86_64 ‚Üí x86_64)

‚ùå **Taille** : Plus volumineuse (inclut index, donn√©es temporaires, etc.)

‚ùå **Lisibilit√©** : Impossible d'inspecter le contenu directement

‚ùå **D√©pendance WAL** : Pour PITR, n√©cessite une archive continue des fichiers WAL

---

## pg_basebackup : L'Outil de Sauvegarde Physique

### Qu'est-ce que pg_basebackup ?

`pg_basebackup` est l'outil officiel PostgreSQL pour cr√©er des sauvegardes physiques compl√®tes d'un cluster PostgreSQL en cours d'ex√©cution. Il se connecte au serveur PostgreSQL via le protocole de r√©plication et copie l'int√©gralit√© du r√©pertoire de donn√©es.

### Fonctionnement Interne

Lorsque vous lancez `pg_basebackup`, voici ce qui se passe :

1. **Connexion au serveur** : pg_basebackup se connecte au serveur PostgreSQL via une connexion de r√©plication

2. **Checkpoint de d√©marrage** : Un checkpoint est d√©clench√© pour garantir que tous les changements en m√©moire sont √©crits sur disque

3. **Streaming des donn√©es** : Les fichiers du r√©pertoire de donn√©es sont copi√©s via le r√©seau

4. **Copie des WAL** : Les fichiers WAL n√©cessaires sont inclus ou archiv√©s

5. **Checkpoint de fin** : Un checkpoint final garantit la coh√©rence

6. **G√©n√©ration de m√©tadonn√©es** : Cr√©ation d'un fichier `backup_label` et `tablespace_map` si n√©cessaire

### Pr√©requis Configuration

Avant d'utiliser `pg_basebackup`, vous devez configurer PostgreSQL pour accepter les connexions de r√©plication.

#### 1. Configuration de postgresql.conf

```conf
# Activer la r√©plication
wal_level = replica               # Niveau WAL minimum pour r√©plication
max_wal_senders = 10              # Nombre max de processus de r√©plication
wal_keep_size = 1GB               # Taille min de WAL √† conserver (PostgreSQL 13+)
# Ancienne syntaxe : wal_keep_segments = 64 (avant PG 13)
```

**Explication** :
- `wal_level = replica` : Active la g√©n√©ration des WAL n√©cessaires pour la r√©plication
- `max_wal_senders` : R√©serve des slots de connexion pour les processus de r√©plication (pg_basebackup en utilise 1)
- `wal_keep_size` : √âvite que les WAL n√©cessaires soient supprim√©s pendant la sauvegarde

#### 2. Configuration de pg_hba.conf

Autoriser les connexions de r√©plication :

```conf
# TYPE  DATABASE        USER            ADDRESS                 METHOD
# R√©plication locale
local   replication     backup_user                             scram-sha-256

# R√©plication r√©seau
host    replication     backup_user     192.168.1.0/24          scram-sha-256
host    replication     backup_user     10.0.0.0/8              scram-sha-256
```

**Explication** :
- `replication` : Mot-cl√© sp√©cial pour les connexions de r√©plication
- `backup_user` : Utilisateur d√©di√© aux sauvegardes (√† cr√©er)
- Adresse r√©seau : Restreindre les IPs autoris√©es

#### 3. Cr√©er un Utilisateur de R√©plication

```sql
-- Cr√©er un r√¥le d√©di√© aux sauvegardes
CREATE ROLE backup_user WITH REPLICATION LOGIN PASSWORD 'MotDePasseSecurise';

-- Si besoin d'acc√©der √† des tablespaces ou configurations sp√©cifiques
GRANT pg_read_all_settings TO backup_user;
GRANT pg_read_all_stats TO backup_user;
```

**Bonnes pratiques** :
- Utilisez un utilisateur d√©di√© (principe du moindre privil√®ge)
- N'accordez pas de droits superutilisateur
- Utilisez un mot de passe fort
- Pr√©f√©rez `scram-sha-256` √† `md5`

#### 4. Recharger la Configuration

```bash
# M√©thode 1 : Depuis psql
psql -U postgres -c "SELECT pg_reload_conf();"

# M√©thode 2 : Depuis le shell
pg_ctl reload -D /var/lib/postgresql/data
```

---

## Utilisation de pg_basebackup

### Syntaxe de Base

```bash
pg_basebackup [options]
```

**Exemple minimal** :
```bash
pg_basebackup -D /backups/base_backup -U backup_user -h localhost -p 5432
```

### Options Essentielles

#### Options de Destination

**-D, --pgdata=DIRECTORY** : R√©pertoire de destination

```bash
pg_basebackup -D /backups/my_backup
```

‚ö†Ô∏è Le r√©pertoire doit √™tre **vide** ou ne pas exister.

#### Options de Connexion

Identiques √† psql et pg_dump :

```bash
pg_basebackup -D /backups/backup1 \
    -h db-server.company.com \    # H√¥te
    -p 5432 \                      # Port
    -U backup_user \               # Utilisateur
    -W                             # Demander mot de passe
```

**Astuce** : Utilisez un `.pgpass` pour √©viter de saisir le mot de passe :

```bash
# Fichier ~/.pgpass (permissions 600)
hostname:port:database:username:password
db-server.company.com:5432:replication:backup_user:MotDePasseSecurise
```

```bash
chmod 600 ~/.pgpass
```

#### Options de Format

**-F, --format=FORMAT** : Format de sortie (plain ou tar)

**Format Plain (par d√©faut)** :
```bash
pg_basebackup -D /backups/plain_backup -F p
```
- Copie directe du r√©pertoire de donn√©es
- Pr√™t √† √™tre utilis√© imm√©diatement
- Peut √™tre restaur√© en rempla√ßant le data directory

**Format Tar** :
```bash
pg_basebackup -D /backups/tar_backup -F t
```
- Cr√©e un ou plusieurs fichiers `.tar`
- Un fichier par tablespace
- N√©cessite extraction avant utilisation
- Plus compact et portable

**Format Tar avec Compression** :
```bash
# Compression gzip
pg_basebackup -D /backups/compressed -F t -z

# Sp√©cifier le niveau de compression (1-9)
pg_basebackup -D /backups/compressed -F t -Z 6

# Compression avec autre algorithme (PostgreSQL 15+)
pg_basebackup -D /backups/compressed -F t --compress=lz4
pg_basebackup -D /backups/compressed -F t --compress=zstd:5
```

#### Options WAL

**-X, --wal-method=METHOD** : M√©thode d'inclusion des WAL

**fetch (par d√©faut)** :
```bash
pg_basebackup -D /backup -X fetch
```
- Collecte les WAL √† la fin de la sauvegarde
- N√©cessite `wal_keep_size` suffisant
- Plus simple mais risque de perte de WAL sur bases tr√®s actives

**stream (recommand√©)** :
```bash
pg_basebackup -D /backup -X stream
```
- Streaming continu des WAL pendant la sauvegarde
- **Recommand√©** : aucun risque de perte de WAL
- N√©cessite un `max_wal_senders` suppl√©mentaire (utilise 2 connexions)

**none** :
```bash
pg_basebackup -D /backup -X none
```
- Aucun WAL inclus
- Utiliser uniquement si vous avez un archivage WAL s√©par√©

#### Options de Progression et Verbosit√©

**-v, --verbose** : Mode verbeux

```bash
pg_basebackup -D /backup -v
```
Affiche les d√©tails de l'op√©ration.

**-P, --progress** : Afficher la progression

```bash
pg_basebackup -D /backup -P
```
Affiche une barre de progression avec estimation du temps restant.

**Combinaison recommand√©e** :
```bash
pg_basebackup -D /backup -P -v
```

#### Options de Checkpoint

**-c, --checkpoint=MODE** : Mode de checkpoint

**fast (recommand√©)** :
```bash
pg_basebackup -D /backup -c fast
```
- Force un checkpoint imm√©diat
- La sauvegarde d√©marre rapidement
- **Recommand√©** pour la plupart des cas

**spread (par d√©faut)** :
```bash
pg_basebackup -D /backup -c spread
```
- Checkpoint progressif
- Moins d'impact sur les performances
- Sauvegarde d√©marre plus lentement

#### Options de Slots de R√©plication

**-S, --slot=SLOTNAME** : Utiliser un slot de r√©plication

```bash
# Cr√©er d'abord le slot
psql -U postgres -c "SELECT pg_create_physical_replication_slot('backup_slot');"

# Utiliser le slot pour la sauvegarde
pg_basebackup -D /backup -S backup_slot
```

**Avantages des slots** :
- Garantit que les WAL n√©cessaires ne seront pas supprim√©s
- Id√©al pour les environnements √† forte activit√©
- √âvite les erreurs "requested WAL segment has already been removed"

**--create-slot** : Cr√©er le slot automatiquement

```bash
pg_basebackup -D /backup -S backup_slot --create-slot
```

#### Options de Tablespace

**-T, --tablespace-mapping=OLDDIR=NEWDIR** : Remapper les tablespaces

```bash
pg_basebackup -D /backup \
    -T /mnt/tablespace1=/new/location/tablespace1
```

Utile lors de restauration sur un serveur avec une arborescence diff√©rente.

#### Options de Limitation

**--max-rate=RATE** : Limiter la bande passante

```bash
# Limiter √† 10 MB/s
pg_basebackup -D /backup --max-rate=10M

# Limiter √† 100 KB/s
pg_basebackup -D /backup --max-rate=100k
```

**Cas d'usage** : √âviter de saturer le r√©seau ou les disques pendant les heures de production.

---

## Exemples Pratiques

### Exemple 1 : Sauvegarde Locale Simple

```bash
pg_basebackup \
    -D /backups/postgres/$(date +%Y%m%d) \
    -U backup_user \
    -P -v \
    -X stream \
    -c fast
```

**Explications** :
- `-D` : Sauvegarde dans un r√©pertoire dat√©
- `-P -v` : Progression et verbosit√©
- `-X stream` : Streaming des WAL (recommand√©)
- `-c fast` : Checkpoint imm√©diat

### Exemple 2 : Sauvegarde Compress√©e vers Serveur Distant

```bash
pg_basebackup \
    -h production.db.company.com \
    -p 5432 \
    -U backup_user \
    -D /backups/prod_backup \
    -F t \
    -z \
    -Z 6 \
    -P -v \
    -X stream \
    -c fast
```

**Explications** :
- `-h` : Serveur distant
- `-F t -z -Z 6` : Format tar compress√© niveau 6
- Id√©al pour √©conomiser espace disque

### Exemple 3 : Sauvegarde avec Slot de R√©plication

```bash
# √âtape 1 : Cr√©er le slot (une seule fois)
psql -U postgres -h db-server -c "SELECT pg_create_physical_replication_slot('daily_backup_slot');"

# √âtape 2 : Sauvegarde utilisant le slot
pg_basebackup \
    -h db-server \
    -U backup_user \
    -D /backups/daily/$(date +%Y%m%d_%H%M) \
    -S daily_backup_slot \
    -P -v \
    -X stream \
    -c fast
```

### Exemple 4 : Sauvegarde Limit√©e en Bande Passante

```bash
# Limiter √† 20 MB/s pour ne pas saturer le r√©seau
pg_basebackup \
    -h db-server \
    -U backup_user \
    -D /backups/rate_limited \
    --max-rate=20M \
    -P -v \
    -X stream \
    -c fast
```

**Cas d'usage** : Sauvegardes durant les heures de production sur un r√©seau partag√©.

### Exemple 5 : Sauvegarde Plain pour Standby Imm√©diat

```bash
pg_basebackup \
    -h primary-db \
    -U replicator \
    -D /var/lib/postgresql/14/standby \
    -F p \
    -X stream \
    -c fast \
    -R
```

**-R (--write-recovery-conf)** : G√©n√®re automatiquement les fichiers de configuration pour un serveur standby.

---

## Restauration d'une Sauvegarde Physique

### Restauration Basique (Format Plain)

#### √âtape 1 : Arr√™ter PostgreSQL

```bash
sudo systemctl stop postgresql
# Ou
pg_ctl stop -D /var/lib/postgresql/data
```

#### √âtape 2 : Sauvegarder l'Ancien Data Directory (S√©curit√©)

```bash
mv /var/lib/postgresql/data /var/lib/postgresql/data.old
```

#### √âtape 3 : Copier la Sauvegarde

```bash
cp -a /backups/base_backup /var/lib/postgresql/data
```

**Important** : Utilisez `cp -a` pour pr√©server les permissions et propri√©taires.

#### √âtape 4 : Ajuster les Permissions

```bash
chown -R postgres:postgres /var/lib/postgresql/data
chmod 700 /var/lib/postgresql/data
```

#### √âtape 5 : D√©marrer PostgreSQL

```bash
sudo systemctl start postgresql
# Ou
pg_ctl start -D /var/lib/postgresql/data
```

### Restauration depuis Format Tar

#### √âtape 1 : Arr√™ter PostgreSQL

```bash
sudo systemctl stop postgresql
```

#### √âtape 2 : Cr√©er et Pr√©parer le R√©pertoire

```bash
rm -rf /var/lib/postgresql/data
mkdir /var/lib/postgresql/data
```

#### √âtape 3 : Extraire l'Archive Tar

```bash
# Si une seule archive (base.tar)
tar -xzf /backups/base.tar.gz -C /var/lib/postgresql/data

# Si plusieurs archives (tablespaces)
tar -xzf /backups/base.tar.gz -C /var/lib/postgresql/data
tar -xzf /backups/pg_tblspc_16384.tar.gz -C /mnt/tablespace1
```

#### √âtape 4 : Permissions et D√©marrage

```bash
chown -R postgres:postgres /var/lib/postgresql/data
chmod 700 /var/lib/postgresql/data
sudo systemctl start postgresql
```

### Restauration avec Point-In-Time Recovery (PITR)

Le PITR permet de restaurer la base √† un moment pr√©cis dans le pass√©. Cela n√©cessite :
1. Une sauvegarde de base (pg_basebackup)
2. Une archive continue des fichiers WAL

**Configuration pour PITR** :

#### √âtape 1 : Configurer l'Archivage WAL (Sur le Serveur Source)

```conf
# Dans postgresql.conf
wal_level = replica
archive_mode = on
archive_command = 'cp %p /mnt/wal_archive/%f'
# Ou vers un serveur distant
# archive_command = 'rsync -a %p backup-server:/wal_archive/%f'
```

#### √âtape 2 : Cr√©er la Sauvegarde de Base

```bash
pg_basebackup \
    -D /backups/pitr_base \
    -X stream \
    -c fast \
    -P -v
```

#### √âtape 3 : Restauration avec R√©cup√©ration

```bash
# Arr√™ter PostgreSQL
sudo systemctl stop postgresql

# Restaurer la sauvegarde de base
rm -rf /var/lib/postgresql/data
cp -a /backups/pitr_base /var/lib/postgresql/data

# Cr√©er un fichier de configuration de r√©cup√©ration
cat > /var/lib/postgresql/data/recovery.signal << EOF
# Fichier vide qui active le mode recovery
EOF

# Configurer les param√®tres de r√©cup√©ration
cat >> /var/lib/postgresql/data/postgresql.conf << EOF
restore_command = 'cp /mnt/wal_archive/%f %p'
recovery_target_time = '2025-11-22 14:30:00'
recovery_target_action = 'promote'
EOF

# Permissions
chown -R postgres:postgres /var/lib/postgresql/data

# D√©marrer PostgreSQL
sudo systemctl start postgresql
```

**Param√®tres de r√©cup√©ration** :
- `restore_command` : Commande pour r√©cup√©rer les WAL archiv√©s
- `recovery_target_time` : Moment pr√©cis de restauration
- `recovery_target_action` : Action apr√®s r√©cup√©ration (promote, pause, shutdown)

**Alternatives de ciblage** :
```conf
# Restaurer jusqu'√† une transaction sp√©cifique
recovery_target_xid = '12345678'

# Restaurer jusqu'√† un nom de point de sauvegarde
recovery_target_name = 'before_migration'

# Restaurer jusqu'au dernier WAL disponible
recovery_target = 'immediate'
```

---

## Automatisation et Scripts

### Script de Sauvegarde Automatique

```bash
#!/bin/bash
# /usr/local/bin/pg_physical_backup.sh

# Configuration
BACKUP_DIR="/backups/postgresql"
RETENTION_DAYS=7
DB_HOST="localhost"
DB_USER="backup_user"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_PATH="${BACKUP_DIR}/${DATE}"
LOG_FILE="${BACKUP_DIR}/backup.log"

# Fonction de log
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a ${LOG_FILE}
}

# V√©rifier l'espace disque disponible
AVAILABLE_SPACE=$(df -BG ${BACKUP_DIR} | tail -1 | awk '{print $4}' | sed 's/G//')
REQUIRED_SPACE=100  # GB

if [ ${AVAILABLE_SPACE} -lt ${REQUIRED_SPACE} ]; then
    log "ERROR: Insufficient disk space. Available: ${AVAILABLE_SPACE}GB, Required: ${REQUIRED_SPACE}GB"
    exit 1
fi

# Cr√©er le r√©pertoire de sauvegarde
mkdir -p ${BACKUP_PATH}

# Ex√©cuter pg_basebackup
log "Starting physical backup to ${BACKUP_PATH}"

pg_basebackup \
    -h ${DB_HOST} \
    -U ${DB_USER} \
    -D ${BACKUP_PATH} \
    -F t \
    -z \
    -Z 6 \
    -P -v \
    -X stream \
    -c fast \
    2>&1 | tee -a ${LOG_FILE}

# V√©rifier le succ√®s
if [ ${PIPESTATUS[0]} -eq 0 ]; then
    log "Backup completed successfully"

    # Calculer la taille
    BACKUP_SIZE=$(du -sh ${BACKUP_PATH} | cut -f1)
    log "Backup size: ${BACKUP_SIZE}"

    # Nettoyer les anciennes sauvegardes
    log "Cleaning backups older than ${RETENTION_DAYS} days"
    find ${BACKUP_DIR} -maxdepth 1 -type d -mtime +${RETENTION_DAYS} -exec rm -rf {} \;

    # Notification de succ√®s
    echo "PostgreSQL backup successful - ${DATE}" | mail -s "Backup Success" admin@company.com

    exit 0
else
    log "ERROR: Backup failed"
    echo "PostgreSQL backup FAILED - ${DATE}" | mail -s "BACKUP FAILED" admin@company.com
    exit 1
fi
```

**Installation** :
```bash
# Rendre le script ex√©cutable
chmod +x /usr/local/bin/pg_physical_backup.sh

# Ajouter √† crontab (tous les jours √† 2h du matin)
crontab -e
0 2 * * * /usr/local/bin/pg_physical_backup.sh
```

### Script de V√©rification de Sauvegarde

```bash
#!/bin/bash
# /usr/local/bin/verify_backup.sh

BACKUP_PATH=$1

if [ -z "${BACKUP_PATH}" ]; then
    echo "Usage: $0 <backup_path>"
    exit 1
fi

echo "Verifying backup at ${BACKUP_PATH}"

# V√©rifier la pr√©sence du fichier backup_label
if [ ! -f "${BACKUP_PATH}/backup_label" ]; then
    echo "ERROR: backup_label file not found"
    exit 1
fi

echo "‚úì backup_label found"

# V√©rifier la pr√©sence de PG_VERSION
if [ ! -f "${BACKUP_PATH}/PG_VERSION" ]; then
    echo "ERROR: PG_VERSION file not found"
    exit 1
fi

PG_VERSION=$(cat ${BACKUP_PATH}/PG_VERSION)
echo "‚úì PostgreSQL version: ${PG_VERSION}"

# V√©rifier la pr√©sence de pg_wal
if [ ! -d "${BACKUP_PATH}/pg_wal" ]; then
    echo "ERROR: pg_wal directory not found"
    exit 1
fi

WAL_COUNT=$(ls -1 ${BACKUP_PATH}/pg_wal | wc -l)
echo "‚úì pg_wal directory present (${WAL_COUNT} files)"

# V√©rifier la taille
BACKUP_SIZE=$(du -sh ${BACKUP_PATH} | cut -f1)
echo "‚úì Backup size: ${BACKUP_SIZE}"

echo "Backup verification completed successfully"
```

---

## Surveillance et Monitoring

### V√©rifier l'√âtat des Sauvegardes

#### Derni√®re Sauvegarde R√©ussie

```sql
-- V√©rifier la derni√®re sauvegarde de base
SELECT
    pg_backup_start_time() AS backup_in_progress_since
FROM pg_stat_activity
WHERE backend_type = 'walsender'
  AND state = 'streaming';
```

#### Espace Disque des Sauvegardes

```bash
# V√©rifier l'espace utilis√© par les sauvegardes
du -sh /backups/postgresql/*

# Surveiller l'espace disque disponible
df -h /backups
```

#### Logs de pg_basebackup

```bash
# Analyser les logs pour d√©tecter des erreurs
grep -i error /backups/postgresql/backup.log
grep -i failed /backups/postgresql/backup.log
```

### Alertes Recommand√©es

1. **Sauvegarde √âchou√©e** : Notification imm√©diate si pg_basebackup retourne un code d'erreur
2. **Sauvegarde Absente** : Alerte si aucune sauvegarde n'a √©t√© cr√©√©e dans les derni√®res 24h
3. **Espace Disque Faible** : Alerte si < 20% d'espace libre sur le volume de sauvegarde
4. **Taille Anormale** : Alerte si la taille de sauvegarde varie de > 50% par rapport √† la moyenne
5. **Dur√©e Anormale** : Alerte si la dur√©e de sauvegarde augmente significativement

### M√©triques √† Surveiller

```sql
-- Taille totale du cluster
SELECT
    pg_size_pretty(sum(pg_database_size(datname))) AS total_size
FROM pg_database;

-- Taille par base
SELECT
    datname,
    pg_size_pretty(pg_database_size(datname)) AS size
FROM pg_database
ORDER BY pg_database_size(datname) DESC;

-- WAL g√©n√©r√©s par heure (indicateur d'activit√©)
SELECT
    date_trunc('hour', now()) AS hour,
    pg_size_pretty(
        (pg_current_wal_lsn() - pg_wal_lsn_diff(pg_current_wal_lsn(), lag(pg_current_wal_lsn()) OVER (ORDER BY now())))::bigint
    ) AS wal_generated;
```

---

## Strat√©gies de Sauvegarde Physique

### Strat√©gie 1 : Sauvegarde Quotidienne Simple

**Contexte** : PME, base de donn√©es < 100 GB, RTO = 1h, RPO = 24h

```bash
# Cron : Tous les jours √† 2h
0 2 * * * /usr/local/bin/pg_physical_backup.sh

# R√©tention : 7 jours
```

**Co√ªt** : ~700 GB de stockage (100 GB √ó 7 jours)

### Strat√©gie 2 : Sauvegarde avec Archivage WAL (PITR)

**Contexte** : Entreprise, base critique, RTO = 30min, RPO = 5min

```bash
# Sauvegarde compl√®te : Dimanche √† 1h
0 1 * * 0 pg_basebackup -D /backups/weekly/$(date +%Y%m%d) ...

# Archivage WAL continu
archive_mode = on
archive_command = 'rsync -a %p backup-server:/wal_archive/%f'

# Nettoyage des WAL > 30 jours
0 3 * * * find /wal_archive -mtime +30 -delete
```

**Avantage** : R√©cup√©ration possible √† n'importe quel moment dans les 30 derniers jours.

### Strat√©gie 3 : Sauvegarde Incr√©mentale (PostgreSQL 17+)

**Contexte** : Tr√®s grande base de donn√©es (plusieurs To), optimisation de l'espace

```bash
# Sauvegarde compl√®te : 1er du mois
0 1 1 * * pg_basebackup -D /backups/full/$(date +%Y%m) ...

# Sauvegardes incr√©mentales : Tous les jours
0 2 * * * pg_basebackup -D /backups/incr/$(date +%Y%m%d) --incremental=/backups/full/manifest ...
```

**Avantage** : √âconomie d'espace disque significative (seuls les blocs modifi√©s sont sauvegard√©s).

### Strat√©gie 4 : Backup + R√©plication Streaming

**Contexte** : Haute disponibilit√©, RTO < 1min, RPO < 1sec

```bash
# Serveur Primary : Archivage WAL
archive_mode = on
archive_command = 'rsync -a %p backup-server:/wal_archive/%f'

# Serveur Standby : R√©plication en temps r√©el
standby_mode = on
restore_command = 'cp /wal_archive/%f %p'

# Sauvegarde depuis le Standby (pour ne pas impacter le Primary)
0 2 * * * pg_basebackup -h standby-server -D /backups/$(date +%Y%m%d) ...
```

**Avantage** :
- Aucun impact sur la production (sauvegarde depuis standby)
- R√©cup√©ration quasi-instantan√©e (promotion du standby)
- PITR disponible via archives WAL

---

## Consid√©rations de Performance

### Impact sur le Serveur Source

**CPU** :
- Faible : Principalement lecture disque et transfert r√©seau
- Compression (avec `-z`) augmente l√©g√®rement l'usage CPU

**I/O** :
- Mod√©r√© √† √©lev√© : Lecture compl√®te de tous les fichiers
- Peut affecter les performances des requ√™tes (contention I/O)

**R√©seau** :
- √âlev√© si sauvegarde distante : tout le cluster transite par le r√©seau
- Utiliser `--max-rate` pour limiter la bande passante

**M√©moire** :
- Faible : pg_basebackup n'utilise pas beaucoup de RAM

### Optimisations

#### 1. Sauvegarder depuis un Standby

```bash
# Connecter √† un serveur standby plut√¥t que le primary
pg_basebackup -h standby.company.com -D /backup ...
```

**Avantage** : Z√©ro impact sur le serveur de production.

#### 2. Planifier aux Heures Creuses

```bash
# Exemple : 2h du matin (faible activit√©)
0 2 * * * /usr/local/bin/pg_physical_backup.sh
```

#### 3. Limiter la Bande Passante

```bash
pg_basebackup -D /backup --max-rate=50M ...
```

#### 4. Utiliser la Compression

```bash
# R√©duire la taille et le transfert r√©seau
pg_basebackup -D /backup -F t -z -Z 6 ...
```

#### 5. Utiliser un Stockage Rapide

- SSD pour les sauvegardes locales
- NVMe si disponible
- R√©seau 10 Gigabit pour sauvegardes distantes

---

## D√©pannage et Erreurs Courantes

### Erreur 1 : "could not connect to server"

```
pg_basebackup: error: could not connect to server: could not connect to server: Connection refused
```

**Causes** :
- PostgreSQL non d√©marr√©
- Mauvais h√¥te/port
- Firewall bloque la connexion

**Solutions** :
```bash
# V√©rifier que PostgreSQL tourne
systemctl status postgresql

# Tester la connexion
psql -h db-server -U backup_user -c "SELECT version();"

# V√©rifier pg_hba.conf
cat /etc/postgresql/18/main/pg_hba.conf | grep replication
```

### Erreur 2 : "must be superuser or replication role"

```
pg_basebackup: error: must be superuser or replication role to start walsender
```

**Cause** : L'utilisateur n'a pas le privil√®ge REPLICATION.

**Solution** :
```sql
ALTER ROLE backup_user WITH REPLICATION;
```

### Erreur 3 : "directory not empty"

```
pg_basebackup: error: directory "/backup" exists but is not empty
```

**Solution** :
```bash
# Utiliser un r√©pertoire vide
rm -rf /backup/*
# Ou un nouveau r√©pertoire
pg_basebackup -D /backup_new
```

### Erreur 4 : "requested WAL segment has already been removed"

```
pg_basebackup: error: could not get write-ahead log end position from server: ERROR: requested WAL segment 000000010000000000000042 has already been removed
```

**Causes** :
- `wal_keep_size` trop petit
- Sauvegarde trop longue (base tr√®s volumineuse)
- Forte activit√© d'√©criture

**Solutions** :

**1. Augmenter wal_keep_size** :
```conf
# postgresql.conf
wal_keep_size = 2GB  # Ou plus selon l'activit√©
```

**2. Utiliser -X stream** :
```bash
pg_basebackup -D /backup -X stream  # Recommand√©
```

**3. Utiliser un slot de r√©plication** :
```bash
pg_basebackup -D /backup -S backup_slot
```

### Erreur 5 : "archive command failed"

Lors de la restauration avec PITR :

```
archive command failed with exit code 1
```

**Causes** :
- Chemin d'archive WAL incorrect
- Permissions insuffisantes
- Fichiers WAL manquants

**Solutions** :
```bash
# V√©rifier le chemin
ls -la /mnt/wal_archive/

# V√©rifier les permissions
chown -R postgres:postgres /mnt/wal_archive/

# Tester restore_command manuellement
su - postgres -c "cp /mnt/wal_archive/000000010000000000000001 /tmp/test"
```

### Erreur 6 : "insufficient max_wal_senders"

```
pg_basebackup: error: could not send replication command "BASE_BACKUP": ERROR: number of requested standby connections exceeds max_wal_senders
```

**Solution** :
```conf
# postgresql.conf
max_wal_senders = 10  # Augmenter la valeur
```

```bash
# Red√©marrer PostgreSQL
sudo systemctl restart postgresql
```

---

## S√©curit√© des Sauvegardes Physiques

### 1. Chiffrement des Sauvegardes

**Chiffrement avec GPG** :
```bash
pg_basebackup -D - -F t | gpg --encrypt --recipient admin@company.com > backup.tar.gpg
```

**D√©chiffrement** :
```bash
gpg --decrypt backup.tar.gpg | tar -x -C /restore_dir
```

**Chiffrement avec OpenSSL** :
```bash
pg_basebackup -D - -F t | openssl enc -aes-256-cbc -salt -out backup.tar.enc -pass pass:SecurePassword
```

### 2. Stockage S√©curis√©

**Permissions restrictives** :
```bash
chmod 700 /backups/postgresql
chown postgres:postgres /backups/postgresql
```

**Stockage hors-site** :
- Cloud storage (S3, Azure Blob, Google Cloud Storage)
- Serveur de backup distant (rsync via SSH)
- Support physique externe (pour archives √† long terme)

### 3. V√©rification d'Int√©grit√©

**Checksums PostgreSQL** :
```bash
# Activer lors de l'initdb (PostgreSQL 18 : activ√© par d√©faut)
initdb --data-checksums

# V√©rifier l'√©tat
psql -c "SHOW data_checksums;"
```

**Checksum de fichier** :
```bash
# Cr√©er un checksum MD5
md5sum /backups/backup.tar > /backups/backup.tar.md5

# V√©rifier
md5sum -c /backups/backup.tar.md5
```

### 4. Rotation et R√©tention

**R√®gle 3-2-1** :
- **3** copies de vos donn√©es
- Sur **2** supports diff√©rents
- **1** copie hors-site (off-site)

**Exemple d'impl√©mentation** :
```bash
# Copie 1 : Sauvegarde locale
pg_basebackup -D /backups/local/$(date +%Y%m%d)

# Copie 2 : Disque externe mont√©
rsync -a /backups/local/$(date +%Y%m%d) /mnt/external_drive/

# Copie 3 : Cloud (S3)
aws s3 sync /backups/local/$(date +%Y%m%d) s3://company-backups/postgres/$(date +%Y%m%d)
```

---

## Comparaison avec Autres Solutions de Sauvegarde

### pg_basebackup vs Sauvegarde Manuelle (rsync)

| Aspect | pg_basebackup | rsync du data directory |
|--------|---------------|-------------------------|
| **Coh√©rence** | Garantie (snapshot) | Incoh√©rente (sauf arr√™t PG) |
| **Facilit√©** | Simple, une commande | N√©cessite arr√™t du serveur |
| **S√©curit√©** | Protocole r√©plication | Acc√®s direct aux fichiers |
| **Recommandation** | ‚úÖ Recommand√© | ‚ùå √Ä √©viter (sauf PG arr√™t√©) |

### pg_basebackup vs Solutions Tierces

**Barman (Backup and Recovery Manager)** :
- Gestion centralis√©e de multiples serveurs
- Sauvegardes incr√©mentales
- PITR simplifi√©
- Monitoring int√©gr√©
- Plus complexe √† configurer

**pgBackRest** :
- Tr√®s performant (parall√©lisation, compression)
- Sauvegardes incr√©mentales et diff√©rentielles
- Restauration partielle de bases
- Configuration plus complexe

**WAL-G** :
- Optimis√© pour le cloud (S3, Azure, GCS)
- Compression efficace (avec Brotli, Zstandard)
- Sauvegardes incr√©mentales
- L√©ger et rapide

**Recommandation** :
- **pg_basebackup** : Simple, int√©gr√©, parfait pour d√©buter ou environnements simples
- **Barman/pgBackRest/WAL-G** : Environnements complexes, grandes bases, besoins avanc√©s

---

## Bonnes Pratiques en Production

### ‚úÖ DO - √Ä Faire

1. **Automatiser les sauvegardes** : Cron, systemd timers, ou orchestrateur
2. **Tester les restaurations** : Au moins mensuellement
3. **Utiliser -X stream** : Plus fiable que fetch
4. **Monitorer l'espace disque** : √âviter les sauvegardes √©chou√©es par manque d'espace
5. **Documenter la proc√©dure** : Runbook de restauration clair
6. **Chiffrer les sauvegardes** : Surtout pour le stockage hors-site
7. **Utiliser des slots de r√©plication** : Pour bases √† forte activit√©
8. **Sauvegarder depuis un standby** : Pour ne pas impacter la production
9. **Conserver plusieurs g√©n√©rations** : Au minimum 7 jours, id√©alement 30 jours
10. **V√©rifier les checksums** : D√©tecter les corruptions

### ‚ùå DON'T - √Ä √âviter

1. **Ne pas tester** : Une sauvegarde non test√©e est inutile
2. **Stocker uniquement localement** : Risque de perte totale (incendie, panne mat√©rielle)
3. **Ignorer les erreurs** : Toujours monitorer le succ√®s des sauvegardes
4. **Utiliser rsync sur un PG actif** : Incoh√©rent et dangereux
5. **Ne pas monitorer l'espace disque** : √âchecs silencieux
6. **Ne pas documenter** : En cas d'incident, chaque minute compte
7. **Oublier les objets globaux** : Sauvegarder aussi les r√¥les (pg_dumpall --globals-only)
8. **N√©gliger la s√©curit√©** : Permissions, chiffrement, acc√®s restreint

---

## Checklist de Mise en Place

### Configuration Initiale

- [ ] Configurer `wal_level = replica` dans postgresql.conf
- [ ] D√©finir `max_wal_senders >= 3`
- [ ] D√©finir `wal_keep_size` (1-2 GB minimum)
- [ ] Ajouter entr√©e `replication` dans pg_hba.conf
- [ ] Cr√©er utilisateur d√©di√© avec privil√®ge REPLICATION
- [ ] Recharger la configuration PostgreSQL
- [ ] Tester la connexion de r√©plication

### Pr√©paration Sauvegarde

- [ ] Cr√©er r√©pertoire de destination avec bonnes permissions
- [ ] V√©rifier espace disque disponible (3√ó taille du cluster minimum)
- [ ] Cr√©er un slot de r√©plication (optionnel mais recommand√©)
- [ ] Configurer fichier .pgpass pour automatisation
- [ ] Cr√©er script de sauvegarde
- [ ] Tester manuellement une premi√®re sauvegarde

### Automatisation

- [ ] Planifier dans cron/systemd timer
- [ ] Configurer rotation/r√©tention
- [ ] Mettre en place alertes (email, Slack, etc.)
- [ ] Configurer monitoring (espace disque, succ√®s/√©chec)
- [ ] Documenter la proc√©dure

### S√©curit√© et Conformit√©

- [ ] Chiffrer les sauvegardes
- [ ] Stocker hors-site (cloud, serveur distant)
- [ ] Impl√©menter r√®gle 3-2-1
- [ ] Tester restauration compl√®te
- [ ] Documenter proc√©dure de restauration (runbook)

### Archivage WAL (pour PITR)

- [ ] Configurer `archive_mode = on`
- [ ] D√©finir `archive_command`
- [ ] Cr√©er r√©pertoire d'archive WAL
- [ ] Tester commande d'archivage manuellement
- [ ] Configurer nettoyage des anciens WAL

---

## Conclusion

Les sauvegardes physiques avec `pg_basebackup` sont un pilier essentiel de toute strat√©gie de sauvegarde PostgreSQL en production. Elles offrent :

- ‚úÖ **Rapidit√©** : Sauvegarde et restauration bien plus rapides que les sauvegardes logiques
- ‚úÖ **PITR** : Capacit√© de restauration √† un point pr√©cis dans le temps
- ‚úÖ **Simplicit√©** : Outil int√©gr√©, une seule commande suffit
- ‚úÖ **Fiabilit√©** : Garantie de coh√©rence gr√¢ce au syst√®me MVCC
- ‚úÖ **Flexibilit√©** : Multiples formats et options d'optimisation

**Recommandation finale** : Pour un syst√®me de production, combinez :
- **Sauvegardes physiques** (pg_basebackup) : Pour restauration rapide et PITR
- **Archivage WAL continu** : Pour RPO minimal
- **Sauvegardes logiques** (pg_dump) : Pour flexibilit√© et portabilit√©
- **R√©plication streaming** : Pour haute disponibilit√©

Cette approche hybride offre la meilleure protection contre tous types de sc√©narios de perte de donn√©es.

---

## Ressources Compl√©mentaires

### Documentation Officielle

- [pg_basebackup Documentation](https://www.postgresql.org/docs/current/app-pgbasebackup.html)
- [Continuous Archiving and PITR](https://www.postgresql.org/docs/current/continuous-archiving.html)
- [Replication](https://www.postgresql.org/docs/current/runtime-config-replication.html)

### Outils Compl√©mentaires

- [Barman](https://www.pgbarman.org/) - Backup and Recovery Manager
- [pgBackRest](https://pgbackrest.org/) - Reliable PostgreSQL Backup & Restore
- [WAL-G](https://github.com/wal-g/wal-g) - Archival and Restoration Tool

### Commandes de R√©f√©rence Rapide

```bash
# Sauvegarde de base standard
pg_basebackup -D /backup -P -v -X stream -c fast

# Sauvegarde compress√©e
pg_basebackup -D /backup -F t -z -X stream

# Sauvegarde avec slot
pg_basebackup -D /backup -S backup_slot -X stream

# Sauvegarde limit√©e en bande passante
pg_basebackup -D /backup -X stream --max-rate=20M

# Restauration simple
cp -a /backup /var/lib/postgresql/data
chown -R postgres:postgres /var/lib/postgresql/data
systemctl start postgresql
```

---


‚è≠Ô∏è [Point-In-Time Recovery (PITR) et WAL archiving](/16-administration-configuration-securite/11.3-pitr-wal-archiving.md)
