üîù Retour au [Sommaire](/SOMMAIRE.md)

# 16.13.1. Param√®tres Critiques de Configuration PostgreSQL

## Introduction

La configuration de PostgreSQL est l'un des aspects les plus importants pour obtenir des performances optimales. Contrairement √† d'autres SGBD qui tentent de s'auto-configurer, PostgreSQL adopte une approche conservatrice avec des valeurs par d√©faut tr√®s prudentes qui fonctionnent sur presque tous les syst√®mes, mais qui sont rarement optimales.

Dans cette section, nous allons explorer les quatre param√®tres les plus critiques qui influencent directement les performances de votre base de donn√©es. Ces param√®tres se trouvent dans le fichier `postgresql.conf` et peuvent √™tre modifi√©s pour s'adapter aux ressources de votre serveur.

> **üí° Analogie** : Imaginez PostgreSQL comme un cuisinier dans une cuisine. Les param√®tres de configuration d√©finissent la taille de son plan de travail, la quantit√© d'ustensiles disponibles, et l'espace de stockage. Des param√®tres mal configur√©s, c'est comme demander √† un chef de pr√©parer un banquet dans une kitchenette avec un seul couteau !

---

## Vue d'Ensemble des Param√®tres

Avant d'entrer dans les d√©tails, voici un tableau r√©capitulatif des quatre param√®tres critiques :

| Param√®tre | R√¥le Principal | Valeur par D√©faut | Impact |
|-----------|---------------|-------------------|--------|
| `shared_buffers` | Cache des donn√©es en m√©moire partag√©e | 128 MB | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Critique |
| `work_mem` | M√©moire pour les op√©rations de tri/hachage | 4 MB | ‚≠ê‚≠ê‚≠ê‚≠ê Tr√®s important |
| `maintenance_work_mem` | M√©moire pour les op√©rations de maintenance | 64 MB | ‚≠ê‚≠ê‚≠ê Important |
| `effective_cache_size` | Estimation du cache syst√®me | 4 GB | ‚≠ê‚≠ê‚≠ê Important |

---

## 1. shared_buffers : Le Cache Central

### Qu'est-ce que c'est ?

`shared_buffers` d√©finit la quantit√© de m√©moire RAM que PostgreSQL va utiliser pour **mettre en cache les donn√©es** lues depuis le disque. C'est la m√©moire partag√©e entre tous les processus PostgreSQL.

### Comment √ßa fonctionne ?

Lorsqu'une requ√™te a besoin de donn√©es :
1. PostgreSQL cherche d'abord dans les `shared_buffers` (cache en m√©moire)
2. Si les donn√©es sont trouv√©es ‚Üí **Cache hit** (rapide ‚ö°)
3. Si les donn√©es ne sont pas trouv√©es ‚Üí **Cache miss** (lecture disque lente üêå)

> **üí° Analogie** : C'est comme la diff√©rence entre prendre un livre sur votre bureau (cache hit) et devoir aller √† la biblioth√®que municipale pour le chercher (cache miss). L'un prend 2 secondes, l'autre 20 minutes !

### Valeurs Recommand√©es

| Type de Serveur | RAM Totale | Recommandation | Exemple |
|----------------|------------|----------------|---------|
| Serveur d√©di√© PostgreSQL | 16 GB | 25% de la RAM | 4 GB |
| Serveur d√©di√© PostgreSQL | 64 GB | 25% de la RAM | 16 GB |
| Serveur partag√© | 16 GB | 15-20% de la RAM | 2-3 GB |
| D√©veloppement local | 8 GB | 512 MB - 1 GB | 1 GB |

**R√®gle d'or** : Entre **25% de la RAM** pour un serveur d√©di√©, mais rarement au-del√† de **32 GB**.

### Pourquoi ne pas mettre 80% de la RAM ?

C'est une erreur courante ! PostgreSQL s'appuie √©galement sur le **cache du syst√®me d'exploitation** (page cache Linux). Donner trop de m√©moire √† `shared_buffers` peut √™tre contre-productif :
- PostgreSQL doit g√©rer ce cache (overhead)
- Le syst√®me d'exploitation fait d√©j√† du cache tr√®s efficacement
- Au-del√† de 32 GB, les gains deviennent marginaux

### Configuration

```conf
# Dans postgresql.conf
shared_buffers = 4GB
```

**Attention** : Modifier ce param√®tre n√©cessite un **red√©marrage** de PostgreSQL.

---

## 2. work_mem : M√©moire de Travail par Op√©ration

### Qu'est-ce que c'est ?

`work_mem` d√©finit la quantit√© de m√©moire maximum qu'une **op√©ration individuelle** peut utiliser avant de devoir utiliser le disque. Ces op√©rations incluent :
- **Tri (ORDER BY, DISTINCT)**
- **Hash tables (jointures hash, agr√©gations)**
- **Bitmap operations**

### Comment √ßa fonctionne ?

Prenons l'exemple d'un tri :
1. Si la quantit√© de donn√©es √† trier tient dans `work_mem` ‚Üí **tri en m√©moire** (rapide ‚ö°)
2. Si elle ne tient pas ‚Üí **tri sur disque** (utilisation de fichiers temporaires, tr√®s lent üêå)

> **üí° Analogie** : Imaginez que vous devez trier un jeu de cartes. Si vous avez assez de place sur la table (work_mem), vous √©talez toutes les cartes et triez rapidement. Sinon, vous devez cr√©er des piles temporaires au sol (disque), c'est beaucoup plus lent !

### Le Pi√®ge Critique : Multiplication des work_mem

**‚ö†Ô∏è DANGER** : `work_mem` s'applique **par op√©ration**, et une requ√™te complexe peut utiliser plusieurs op√©rations simultan√©ment.

Exemple concret :
```sql
SELECT
    category,
    AVG(price) as avg_price
FROM products
WHERE status = 'active'
ORDER BY category;
```

Cette requ√™te simple peut utiliser :
- 1√ó `work_mem` pour le tri (ORDER BY)
- 1√ó `work_mem` pour l'agr√©gation (AVG + GROUP BY implicite)

Si vous avez 100 connexions actives ex√©cutant des requ√™tes complexes avec 3 op√©rations chacune :
- M√©moire potentielle = **100 connexions √ó 3 op√©rations √ó work_mem**
- Avec work_mem = 1 GB ‚Üí **300 GB de RAM** n√©cessaires ! üí•

### Valeurs Recommand√©es

| Contexte | Recommandation | Explication |
|----------|----------------|-------------|
| OLTP (Transactions) | 4-16 MB | Requ√™tes simples, beaucoup de connexions |
| OLAP (Analytique) | 64-256 MB | Requ√™tes complexes, peu de connexions |
| Mixed Workload | 16-64 MB | Compromis √©quilibr√© |
| Data Warehouse | 256 MB - 1 GB | Gros volumes, jointures complexes |

**Formule de s√©curit√©** :
```
work_mem_max = (RAM totale - shared_buffers) / (max_connections √ó 3)
```

Exemple pour un serveur avec 32 GB RAM, shared_buffers = 8 GB, max_connections = 100 :
```
work_mem_max = (32 GB - 8 GB) / (100 √ó 3) = 24 GB / 300 = 80 MB
```

### Strat√©gie Avanc√©e : Ajustement par Session

Il est souvent plus s√ªr de garder une valeur conservatrice par d√©faut et d'augmenter `work_mem` pour les requ√™tes sp√©cifiques qui en ont besoin :

```sql
-- Augmenter work_mem juste pour cette session
SET work_mem = '256MB';

-- Ex√©cuter une grosse requ√™te analytique
SELECT ... FROM huge_table ...;

-- work_mem reviendra √† la valeur par d√©faut √† la fin de la session
```

### Configuration

```conf
# Dans postgresql.conf
work_mem = 16MB  # Valeur conservatrice par d√©faut
```

**Avantage** : Ce param√®tre peut √™tre modifi√© **sans red√©marrage** (rechargement de configuration suffit).

---

## 3. maintenance_work_mem : M√©moire pour la Maintenance

### Qu'est-ce que c'est ?

`maintenance_work_mem` est la m√©moire allou√©e pour les **op√©rations de maintenance** :
- **CREATE INDEX** : Cr√©ation d'index
- **VACUUM** : Nettoyage et r√©cup√©ration d'espace
- **ALTER TABLE** : Modifications de structure
- **REINDEX** : Reconstruction d'index
- **ANALYZE** : Collecte de statistiques

### Diff√©rence avec work_mem

| Crit√®re | work_mem | maintenance_work_mem |
|---------|----------|---------------------|
| Usage | Requ√™tes normales | Op√©rations de maintenance |
| Fr√©quence | Tr√®s fr√©quent | Occasionnel |
| Nombre simultan√© | Potentiellement √©lev√© | G√©n√©ralement 1-2 |
| Impact si sous-dimensionn√© | Ralentissement requ√™tes | Maintenance tr√®s lente |

### Pourquoi c'est important ?

Une valeur trop faible peut **dramatiquement ralentir** les op√©rations de maintenance :
- Un `CREATE INDEX` sur une grosse table peut passer de 5 minutes √† 2 heures
- Un `VACUUM` inefficace peut causer du bloat (gonflement des tables)

> **üí° Analogie** : C'est comme faire le m√©nage d'une maison avec un seul petit sac poubelle vs un grand conteneur. Avec le petit sac, vous devez faire 50 allers-retours, avec le conteneur, vous videz tout d'un coup !

### Valeurs Recommand√©es

| Contexte | RAM Serveur | Recommandation |
|----------|-------------|----------------|
| Petit serveur | 8 GB | 256 MB - 512 MB |
| Serveur moyen | 16-32 GB | 1 GB - 2 GB |
| Gros serveur | 64+ GB | 2 GB - 4 GB |

**R√®gle simple** : 5-10% de la RAM, mais rarement au-del√† de **4 GB**.

### Cas d'Usage Critique : Autovacuum

PostgreSQL lance automatiquement des processus `autovacuum` en arri√®re-plan. Par d√©faut, il y a **3 workers autovacuum** qui peuvent tourner simultan√©ment.

Chaque worker peut utiliser jusqu'√† `maintenance_work_mem`, donc :
- Avec maintenance_work_mem = 2 GB et 3 workers ‚Üí **6 GB** de RAM potentiellement utilis√©s

C'est pourquoi PostgreSQL a introduit un param√®tre sp√©cifique :

```conf
autovacuum_work_mem = 512MB  # Limite sp√©cifique pour autovacuum
```

Si non d√©fini, autovacuum utilise `maintenance_work_mem`.

### Configuration

```conf
# Dans postgresql.conf
maintenance_work_mem = 1GB
autovacuum_work_mem = 512MB  # Optionnel, pour √©viter les surprises
```

**Avantage** : Peut √™tre modifi√© **sans red√©marrage**.

---

## 4. effective_cache_size : L'Indice pour le Planificateur

### Qu'est-ce que c'est ?

`effective_cache_size` est **une estimation** de la m√©moire totale disponible pour le cache :
- Le cache de PostgreSQL (`shared_buffers`)
- Le cache du syst√®me d'exploitation (page cache)

‚ö†Ô∏è **Important** : Ce param√®tre **n'alloue PAS de m√©moire**. C'est juste un indice donn√© au planificateur de requ√™tes.

### Comment √ßa fonctionne ?

Le planificateur utilise cette valeur pour **d√©cider des strat√©gies d'ex√©cution** :

**Exemple** : Pour une requ√™te avec un index :
- Si `effective_cache_size` est **faible** ‚Üí Le planificateur pense que l'index ne sera probablement pas en cache ‚Üí Pr√©f√®re un **scan s√©quentiel**
- Si `effective_cache_size` est **√©lev√©** ‚Üí Le planificateur pense que l'index est probablement en cache ‚Üí Pr√©f√®re un **index scan**

> **üí° Analogie** : C'est comme dire √† votre GPS s'il y a des embouteillages ou non. Le GPS (planificateur) va choisir un itin√©raire diff√©rent en fonction de cette information, m√™me si cette information ne change pas r√©ellement le trafic.

### Impact d'une Mauvaise Valeur

| Si trop bas | Si trop haut |
|-------------|--------------|
| Plans de requ√™te sous-optimaux | Peu d'impact n√©gatif |
| Pr√©f√©rence excessive pour les scans s√©quentiels | Le planificateur peut parfois sur-estimer |
| Performances d√©grad√©es | G√©n√©ralement sans danger |

**Bonne nouvelle** : Il vaut mieux surestimer que sous-estimer. Une valeur trop haute a peu d'impact n√©gatif.

### Valeurs Recommand√©es

**R√®gle d'or** : **50-75% de la RAM totale**

| RAM Serveur | Recommandation | Calcul |
|-------------|----------------|--------|
| 8 GB | 4-6 GB | 50-75% |
| 16 GB | 8-12 GB | 50-75% |
| 32 GB | 16-24 GB | 50-75% |
| 64 GB | 32-48 GB | 50-75% |
| 128+ GB | 64-96 GB | 50-75% |

### Calcul Plus Pr√©cis

Si vous voulez √™tre plus pr√©cis :
```
effective_cache_size = shared_buffers + (RAM libre pour OS cache)
```

Sur Linux, vous pouvez v√©rifier la taille du cache OS avec :
```bash
free -h
# Regarder la ligne "available" ou "buff/cache"
```

### Configuration

```conf
# Dans postgresql.conf
effective_cache_size = 12GB  # Pour un serveur avec 16 GB RAM
```

**Avantage** : Peut √™tre modifi√© **sans red√©marrage**.

---

## Tableau R√©capitulatif : Exemple de Configuration

Voici un exemple complet pour diff√©rents types de serveurs :

### Serveur de D√©veloppement (8 GB RAM)
```conf
shared_buffers = 1GB              # 12.5% de la RAM
work_mem = 8MB                    # Valeur conservatrice
maintenance_work_mem = 256MB      # Pour les maintenances l√©g√®res
effective_cache_size = 4GB        # 50% de la RAM
```

### Serveur OLTP Production (32 GB RAM)
```conf
shared_buffers = 8GB              # 25% de la RAM
work_mem = 16MB                   # Conservateur (100+ connexions)
maintenance_work_mem = 2GB        # Maintenances efficaces
effective_cache_size = 20GB       # 62% de la RAM
```

### Serveur OLAP / Data Warehouse (64 GB RAM)
```conf
shared_buffers = 16GB             # 25% de la RAM
work_mem = 128MB                  # Requ√™tes complexes, peu de connexions
maintenance_work_mem = 4GB        # Gros index √† cr√©er
effective_cache_size = 48GB       # 75% de la RAM
```

### Serveur Mixed Workload (32 GB RAM)
```conf
shared_buffers = 8GB              # 25% de la RAM
work_mem = 32MB                   # Compromis √©quilibr√©
maintenance_work_mem = 1GB        # Valeur interm√©diaire
effective_cache_size = 20GB       # 62% de la RAM
```

---

## V√©rifier l'Impact de vos Param√®tres

### 1. V√©rifier les Valeurs Actuelles

```sql
-- Afficher les param√®tres actuels
SHOW shared_buffers;
SHOW work_mem;
SHOW maintenance_work_mem;
SHOW effective_cache_size;

-- Ou tous en m√™me temps
SELECT name, setting, unit, source
FROM pg_settings
WHERE name IN ('shared_buffers', 'work_mem', 'maintenance_work_mem', 'effective_cache_size');
```

### 2. V√©rifier le Cache Hit Ratio (Taux de Succ√®s du Cache)

Un bon indicateur de l'efficacit√© de `shared_buffers` :

```sql
SELECT
    sum(heap_blks_read) as heap_read,
    sum(heap_blks_hit)  as heap_hit,
    sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)) AS cache_hit_ratio
FROM pg_statio_user_tables;
```

**Interpr√©tation** :
- **> 99%** : Excellent üü¢
- **95-99%** : Bon üü°
- **< 95%** : Probl√®me possible üî¥ (augmenter shared_buffers ou optimiser les requ√™tes)

### 3. D√©tecter les Tris sur Disque

Si `work_mem` est trop petit, vous verrez des tris sur disque dans les logs :

```sql
-- Activer le logging des tris temporaires (dans postgresql.conf)
log_temp_files = 0  # Log tous les fichiers temporaires

-- Ou pour une session
SET log_temp_files = 0;
```

Dans les logs, vous verrez :
```
LOG: temporary file: path "base/pgsql_tmp/pgsql_tmp1234.0", size 52428800
```

Si vous voyez beaucoup de ces messages, augmentez `work_mem`.

---

## Outils d'Aide √† la Configuration

### PGTune

**PGTune** (https://pgtune.leopard.in.ua/) est un outil en ligne qui g√©n√®re des configurations recommand√©es :

**Entr√©es** :
- Version de PostgreSQL
- Type de syst√®me d'exploitation
- Type de base de donn√©es (Web, OLTP, Data Warehouse, Desktop, Mixed)
- RAM totale
- Nombre de CPU
- Nombre de connexions
- Type de stockage (SSD, HDD)

**Sortie** : Configuration `postgresql.conf` compl√®te et optimis√©e.

### Commande pg_config sur le Serveur

```bash
# Afficher la configuration actuelle
psql -c "SELECT name, setting, unit FROM pg_settings WHERE name IN ('shared_buffers', 'work_mem', 'maintenance_work_mem', 'effective_cache_size');"
```

---

## Les Erreurs Classiques √† √âviter

### ‚ùå Erreur 1 : shared_buffers trop √©lev√©
```conf
# MAUVAIS pour un serveur avec 16 GB RAM
shared_buffers = 12GB  # 75% de la RAM - TROP !
```
**Probl√®me** : Le syst√®me d'exploitation n'a plus assez de RAM pour son propre cache.

**Solution** : Maximum 25-30% de la RAM.

### ‚ùå Erreur 2 : work_mem trop g√©n√©reux
```conf
# DANGEREUX avec 200 connexions
work_mem = 512MB
```
**Probl√®me** : 200 connexions √ó 3 op√©rations √ó 512 MB = **307 GB** de RAM potentiels !

**Solution** : Valeur conservatrice par d√©faut, augmentation par session si n√©cessaire.

### ‚ùå Erreur 3 : Ne pas ajuster effective_cache_size
```conf
# Garder la valeur par d√©faut sur un serveur de 64 GB
effective_cache_size = 4GB  # Beaucoup trop bas !
```
**Probl√®me** : Le planificateur sous-estime le cache et fait de mauvais choix.

**Solution** : Toujours ajuster √† 50-75% de la RAM.

### ‚ùå Erreur 4 : Oublier que shared_buffers n√©cessite un red√©marrage
```conf
# Modifier shared_buffers dans postgresql.conf
shared_buffers = 8GB
```
```bash
# Recharger la configuration
pg_ctl reload  # ‚ùå NE SUFFIT PAS !
```
**Solution** : Red√©marrage complet n√©cessaire :
```bash
pg_ctl restart
```

---

## Application des Changements

### Param√®tres n√©cessitant un red√©marrage
- ‚úÖ `shared_buffers`

### Param√®tres modifiables sans red√©marrage (reload)
- ‚úÖ `work_mem`
- ‚úÖ `maintenance_work_mem`
- ‚úÖ `effective_cache_size`

### Comment Appliquer les Changements

**M√©thode 1 : √âditer postgresql.conf**
```bash
# √âditer le fichier
sudo nano /etc/postgresql/18/main/postgresql.conf

# Recharger (pour work_mem, maintenance_work_mem, effective_cache_size)
sudo systemctl reload postgresql

# Red√©marrer (pour shared_buffers)
sudo systemctl restart postgresql
```

**M√©thode 2 : Via SQL (temporaire pour la session)**
```sql
-- S'applique uniquement √† la session courante
SET work_mem = '128MB';
SET maintenance_work_mem = '2GB';
```

**M√©thode 3 : ALTER SYSTEM (permanent)**
```sql
-- Modifie postgresql.auto.conf (prioritaire sur postgresql.conf)
ALTER SYSTEM SET work_mem = '64MB';
SELECT pg_reload_conf();  -- Recharger la configuration
```

---

## Points Cl√©s √† Retenir

1. **shared_buffers** : Le cache central de PostgreSQL
   - 25% de la RAM pour un serveur d√©di√©
   - N√©cessite un red√©marrage
   - Maximum 32 GB dans la plupart des cas

2. **work_mem** : M√©moire par op√©ration
   - Attention √† la multiplication (connexions √ó op√©rations)
   - Valeur conservatrice par d√©faut (4-16 MB)
   - Augmentation par session pour les grosses requ√™tes

3. **maintenance_work_mem** : Pour la maintenance
   - 5-10% de la RAM
   - Maximum 4 GB g√©n√©ralement suffisant
   - Impact majeur sur CREATE INDEX et VACUUM

4. **effective_cache_size** : Indice pour le planificateur
   - 50-75% de la RAM totale
   - N'alloue pas de m√©moire r√©elle
   - Mieux vaut surestimer que sous-estimer

> **üéØ R√®gle d'or finale** : Commencez avec des valeurs conservatrices, surveillez les m√©triques (cache hit ratio, fichiers temporaires), puis ajustez progressivement en fonction de vos besoins r√©els.

---

## Pour Aller Plus Loin

### Documentation Officielle
- PostgreSQL Resource Consumption : https://www.postgresql.org/docs/18/runtime-config-resource.html
- PostgreSQL Query Tuning : https://www.postgresql.org/docs/18/performance-tips.html

### Outils Recommand√©s
- **PGTune** : Configuration automatique (https://pgtune.leopard.in.ua/)
- **pg_stat_statements** : Extension pour analyser les requ√™tes
- **pgBadger** : Analyse de logs PostgreSQL

### Lectures Recommand√©es
- "PostgreSQL: Up and Running" (O'Reilly) - Chapitres sur la configuration
- "The Art of PostgreSQL" - Optimisation et tuning
- Blog officiel PostgreSQL : https://www.postgresql.org/about/news/

---

**Prochaine √©tape** : Nous verrons dans la section 16.13.2 le sous-syst√®me I/O avec les nouveaut√©s PostgreSQL 18, notamment le mode asynchrone qui peut am√©liorer les performances jusqu'√† 3√ó !

‚è≠Ô∏è [Nouveaut√© PG 18 : Configuration du sous-syst√®me I/O (io_method='sync' vs 'async')](/16-administration-configuration-securite/13.2-configuration-io-pg18.md)
