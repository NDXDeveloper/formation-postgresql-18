ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 16.13.6. Connection Pooling avec PgBouncer (Transaction vs Session)

## Introduction

Imaginez un restaurant oÃ¹ chaque client exige sa propre table, mÃªme s'il ne commande qu'un cafÃ© et reste 5 minutes. Avec 1000 clients par jour, vous auriez besoin de 1000 tables ! C'est exactement le problÃ¨me que PostgreSQL rencontre avec les connexions : chaque connexion consomme des ressources prÃ©cieuses (mÃ©moire, processus systÃ¨me).

Le **connection pooling** (mutualisation de connexions) est la solution : au lieu de crÃ©er une nouvelle connexion pour chaque requÃªte, on rÃ©utilise un pool de connexions existantes. **PgBouncer** est l'outil de rÃ©fÃ©rence pour implÃ©menter cette stratÃ©gie avec PostgreSQL.

Dans cette section, nous allons explorer :
- Pourquoi le connection pooling est essentiel
- Comment fonctionne PgBouncer
- La diffÃ©rence cruciale entre les modes **transaction** et **session**
- Quand utiliser quel mode
- Installation, configuration et monitoring

> **ğŸ¯ Objectif** : Comprendre comment gÃ©rer efficacement des milliers de connexions applicatives avec seulement quelques dizaines de connexions PostgreSQL rÃ©elles.

---

## Le ProblÃ¨me : CoÃ»t des Connexions PostgreSQL

### Architecture PostgreSQL : Un Processus par Connexion

PostgreSQL utilise une architecture **multi-processus** :

```
Application A se connecte â†’ PostgreSQL crÃ©e un processus backend dÃ©diÃ©
Application B se connecte â†’ PostgreSQL crÃ©e un autre processus backend
Application C se connecte â†’ PostgreSQL crÃ©e encore un autre processus
...
```

**SchÃ©ma** :
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Application Aâ”‚â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
                      â”œâ”€â”€â†’ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚    â”‚  Processus A    â”‚
â”‚ Application Bâ”‚â”€â”€â”€â”€â”€â”€â”¼â”€â”€â†’ â”‚  Processus B    â”‚â”€â”€â†’ PostgreSQL
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚    â”‚  Processus C    â”‚    (Shared Memory,
                      â”œâ”€â”€â†’ â”‚  Processus D    â”‚     Disque, etc.)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚    â”‚  ...            â”‚
â”‚ Application Câ”‚â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Chaque processus backend consomme :
- **~10 MB de RAM** minimum (peut monter Ã  100+ MB avec work_mem)
- **Descripteurs de fichiers** systÃ¨me
- **CPU** pour la gestion du processus
- **Overhead de crÃ©ation/destruction**

### Calcul du CoÃ»t

**Exemple : Application web avec 1000 utilisateurs**

```
ScÃ©nario sans pooling :
- 1000 utilisateurs simultanÃ©s = 1000 connexions PostgreSQL
- 1000 processus Ã— 10 MB = 10 GB RAM minimum
- CrÃ©ation/destruction constante de processus â†’ CPU Ã©levÃ©
- max_connections doit Ãªtre â‰¥ 1000 â†’ Configuration complexe
```

**Avec connection pooling** :
```
- 1000 utilisateurs â†’ PgBouncer â†’ 50 connexions PostgreSQL
- 50 processus Ã— 10 MB = 500 MB RAM
- Connexions rÃ©utilisÃ©es â†’ Pas de crÃ©ation/destruction
- max_connections = 50 â†’ Configuration simple
```

**Gain** : Division par **20** de la consommation RAM et du nombre de processus !

> **ğŸ’¡ Analogie** : C'est comme un parking avec voiturier. Au lieu que chaque client garde sa voiture devant l'entrÃ©e (connexion dÃ©diÃ©e), le voiturier gare toutes les voitures dans un parking commun (pool) et les ramÃ¨ne quand nÃ©cessaire. Vous avez besoin de beaucoup moins de places.

### Le ProblÃ¨me du "Connection Spike"

**ScÃ©nario typique** :
```
08h00 : 10 utilisateurs â†’ 10 connexions
09h00 : 100 utilisateurs â†’ 100 connexions
12h00 : 2000 utilisateurs (pic) â†’ 2000 connexions âŒ CRASH
13h00 : 50 utilisateurs â†’ 50 connexions
```

Sans pooling, PostgreSQL peut :
- Atteindre `max_connections` â†’ Refuser nouvelles connexions
- Saturer la RAM â†’ Swap â†’ Performances catastrophiques
- Devenir instable ou crasher

**Avec pooling** :
```
12h00 : 2000 utilisateurs â†’ File d'attente â†’ 100 connexions PostgreSQL
â†’ DÃ©gradation gracieuse, pas de crash
```

---

## PgBouncer : Le Connection Pooler de RÃ©fÃ©rence

### Qu'est-ce que PgBouncer ?

**PgBouncer** est un **proxy lÃ©ger** qui se place entre votre application et PostgreSQL :

```
Application â†’ PgBouncer (Pooling) â†’ PostgreSQL
```

**CaractÃ©ristiques** :
- ğŸš€ **Ultra-lÃ©ger** : ~2 MB de RAM, Ã©crit en C
- âš¡ **TrÃ¨s performant** : Overhead < 1 ms par requÃªte
- ğŸ”„ **RÃ©utilisation intelligente** des connexions
- ğŸ“Š **Monitoring intÃ©grÃ©** : Statistiques dÃ©taillÃ©es
- ğŸ›¡ï¸ **Protection** contre les pics de charge

### Architecture avec PgBouncer

**Sans PgBouncer** :
```
[App 1] â”€â”
[App 2] â”€â”¤
[App 3] â”€â”¼â”€â”€â†’ [PostgreSQL]
[App 4] â”€â”¤    max_connections = 1000
[App 5] â”€â”˜    (1000 processus backend)
...
```

**Avec PgBouncer** :
```
[App 1] â”€â”
[App 2] â”€â”¤
[App 3] â”€â”¼â”€â”€â†’ [PgBouncer] â”€â”€â†’ [PostgreSQL]
[App 4] â”€â”¤    (Pool)           max_connections = 50
[App 5] â”€â”˜                     (50 processus backend)
...
```

---

## Les Trois Modes de Pooling

PgBouncer propose trois modes de fonctionnement :

| Mode | DurÃ©e de Vie Connexion | GranularitÃ© | Performance | CompatibilitÃ© |
|------|------------------------|-------------|-------------|---------------|
| **Session** | Toute la session client | Session complÃ¨te | â­â­â­ | â­â­â­â­â­ |
| **Transaction** | Une transaction | Transaction | â­â­â­â­â­ | â­â­â­ |
| **Statement** | Une requÃªte SQL | RequÃªte unique | â­â­â­â­â­â­ | â­ |

### AperÃ§u Rapide

**Session Mode** (Le plus compatible)
```
Client se connecte â†’ Obtient connexion PostgreSQL dÃ©diÃ©e
Client exÃ©cute 100 requÃªtes â†’ MÃªme connexion
Client se dÃ©connecte â†’ Connexion retourne au pool
```

**Transaction Mode** (Le plus courant)
```
Client BEGIN â†’ Obtient connexion PostgreSQL
Client exÃ©cute requÃªtes dans transaction â†’ MÃªme connexion
Client COMMIT â†’ Connexion retourne immÃ©diatement au pool
Client fait autre requÃªte â†’ Obtient nouvelle connexion du pool
```

**Statement Mode** (Le plus agressif, rarement utilisÃ©)
```
Client envoie SELECT â†’ Obtient connexion
RequÃªte terminÃ©e â†’ Connexion retourne au pool
Client envoie UPDATE â†’ Obtient nouvelle connexion
```

---

## Mode Session : La CompatibilitÃ© Maximale

### Principe de Fonctionnement

En mode **session**, une connexion PostgreSQL est assignÃ©e Ã  un client pour **toute la durÃ©e de sa session**, du CONNECT au DISCONNECT.

**Timeline** :
```
Client A:
â”œâ”€ CONNECT Ã  PgBouncer
â”œâ”€ PgBouncer assigne Connexion PostgreSQL #1
â”œâ”€ RequÃªte 1 via Connexion #1
â”œâ”€ RequÃªte 2 via Connexion #1
â”œâ”€ RequÃªte 3 via Connexion #1
â”œâ”€ ...
â”œâ”€ DISCONNECT
â””â”€ Connexion #1 retourne au pool

Client B:
â”œâ”€ CONNECT Ã  PgBouncer
â”œâ”€ PgBouncer assigne Connexion PostgreSQL #1 (recyclÃ©e)
â””â”€ ...
```

### Avantages du Mode Session

âœ… **CompatibilitÃ© Maximale**
```sql
-- Toutes ces fonctionnalitÃ©s fonctionnent en mode session :

-- 1. Tables temporaires
CREATE TEMP TABLE session_data (id INT, value TEXT);
INSERT INTO session_data VALUES (1, 'test');
SELECT * FROM session_data;  -- âœ… Fonctionne

-- 2. Prepared statements
PREPARE get_user (INT) AS SELECT * FROM users WHERE id = $1;
EXECUTE get_user(123);  -- âœ… Fonctionne

-- 3. Curseurs (DECLARE CURSOR)
BEGIN;
DECLARE user_cursor CURSOR FOR SELECT * FROM users;
FETCH 10 FROM user_cursor;  -- âœ… Fonctionne
COMMIT;

-- 4. LISTEN/NOTIFY
LISTEN my_channel;
NOTIFY my_channel, 'message';  -- âœ… Fonctionne

-- 5. SET LOCAL / SET SESSION
SET SESSION work_mem = '50MB';
SET LOCAL statement_timeout = '30s';  -- âœ… Fonctionne

-- 6. Variables de session personnalisÃ©es
SET app.current_user_id = '12345';
SELECT current_setting('app.current_user_id');  -- âœ… Fonctionne
```

âœ… **Comportement Transparent**
- L'application ne voit aucune diffÃ©rence avec une connexion directe
- Migrations sans changement de code
- Debugging plus simple

âœ… **Ã‰tat de Session PrÃ©servÃ©**
- Variables de configuration maintenues
- Transactions implicites possibles
- Comportement identique Ã  PostgreSQL natif

### InconvÃ©nients du Mode Session

âŒ **Moins de Mutualisation**
```
Si 200 clients sont connectÃ©s mais inactifs (idle) :
â†’ 200 connexions PostgreSQL occupÃ©es
â†’ Peu de gain par rapport Ã  connexion directe
```

âŒ **Moins Efficace avec Connexions Longues**
```
Client se connecte Ã  9h00, fait 1 requÃªte, reste idle jusqu'Ã  17h00
â†’ Connexion PostgreSQL bloquÃ©e pendant 8 heures
â†’ Gaspillage de ressources
```

âŒ **Scaling LimitÃ©**
```
Pool de 50 connexions PostgreSQL
â†’ Maximum 50 clients simultanÃ©s en mode session
â†’ Clients 51+ doivent attendre
```

### Cas d'Usage IdÃ©aux pour Mode Session

**1. Applications avec Logique Complexe**
```python
# Application utilisant des prepared statements
import psycopg2

conn = pgbouncer_connect()  # Mode session
cursor = conn.cursor()

# PrÃ©paration (une fois)
cursor.execute("PREPARE get_orders AS SELECT * FROM orders WHERE user_id = $1")

# RÃ©utilisation (multiple)
for user_id in [123, 456, 789]:
    cursor.execute("EXECUTE get_orders(%s)", (user_id,))
    results = cursor.fetchall()
```

**2. Applications Utilisant des Tables Temporaires**
```python
conn = pgbouncer_connect()  # Mode session

# CrÃ©er table temporaire
conn.execute("CREATE TEMP TABLE calc_results (id INT, result FLOAT)")

# Utiliser dans plusieurs requÃªtes
conn.execute("INSERT INTO calc_results SELECT id, calculate(value) FROM data")
conn.execute("UPDATE calc_results SET result = result * 1.1 WHERE id > 100")
results = conn.execute("SELECT * FROM calc_results").fetchall()

# Table temporaire dÃ©truite Ã  la dÃ©connexion
```

**3. SystÃ¨mes Legacy ou Migrations**
```
Contexte : Migrer une application existante vers PgBouncer
Contrainte : Pas de temps pour refactoriser le code
Solution : Mode session â†’ Migration transparente
```

**4. Applications Desktop/CLI**
```python
# Application desktop avec connexion longue durÃ©e
conn = pgbouncer_connect()  # Mode session
while True:
    user_action = input("Action: ")
    conn.execute(user_action)
    # Connexion reste ouverte entre les actions
```

---

## Mode Transaction : L'Ã‰quilibre Performance/CompatibilitÃ©

### Principe de Fonctionnement

En mode **transaction**, une connexion PostgreSQL est assignÃ©e Ã  un client **uniquement pendant une transaction**.

**Timeline** :
```
Client A:
â”œâ”€ RequÃªte simple (auto-commit)
â”‚  â”œâ”€ Obtient Connexion #1
â”‚  â”œâ”€ ExÃ©cute requÃªte
â”‚  â””â”€ Connexion #1 retourne au pool
â”‚
â”œâ”€ BEGIN
â”‚  â”œâ”€ Obtient Connexion #2
â”‚  â”œâ”€ RequÃªte 1
â”‚  â”œâ”€ RequÃªte 2
â”‚  â”œâ”€ COMMIT
â”‚  â””â”€ Connexion #2 retourne au pool
â”‚
â””â”€ RequÃªte simple
   â”œâ”€ Obtient Connexion #3 (peut Ãªtre #1 ou #2 recyclÃ©e)
   â””â”€ ...
```

**DiffÃ©rence clÃ©** : Entre deux transactions, le client n'a **pas** de connexion PostgreSQL assignÃ©e.

### Avantages du Mode Transaction

âœ… **Mutualisation Maximale**
```
200 clients connectÃ©s, mais seulement 20 en transaction active :
â†’ 20 connexions PostgreSQL utilisÃ©es
â†’ Ratio 10:1 (10Ã— plus efficace que mode session)
```

âœ… **Gestion des Pics de Charge**
```
ScÃ©nario : Black Friday, 5000 utilisateurs simultanÃ©s
Mode session : 5000 connexions PostgreSQL nÃ©cessaires âŒ
Mode transaction : 100-200 connexions PostgreSQL suffisent âœ…
```

âœ… **Protection Contre les Connexions Idle**
```
Client ouvre connexion, fait 1 requÃªte, puis oublie de fermer
Mode session : Connexion PostgreSQL bloquÃ©e indÃ©finiment âŒ
Mode transaction : Connexion retourne au pool aprÃ¨s transaction âœ…
```

âœ… **Meilleure Utilisation des Ressources**
```
Pool de 50 connexions PostgreSQL peut servir :
Mode session : ~50 clients maximum
Mode transaction : ~500-1000 clients (selon pattern d'usage)
```

### InconvÃ©nients du Mode Transaction

âŒ **Ã‰tat de Session Non PrÃ©servÃ©**
```sql
-- âŒ Ces fonctionnalitÃ©s NE FONCTIONNENT PAS :

-- 1. Tables temporaires
CREATE TEMP TABLE data (id INT);
-- Connexion retourne au pool
SELECT * FROM data;  -- âŒ ERREUR : table n'existe plus

-- 2. Prepared statements non nommÃ©s
PREPARE my_stmt AS SELECT * FROM users WHERE id = $1;
-- Connexion retourne au pool
EXECUTE my_stmt(123);  -- âŒ ERREUR : prepared statement inconnu

-- 3. Curseurs en dehors de transaction
DECLARE cursor1 CURSOR FOR SELECT * FROM large_table;
FETCH 10 FROM cursor1;  -- âŒ ERREUR : pas possible hors transaction

-- 4. LISTEN/NOTIFY
LISTEN events;  -- âŒ Ne fonctionne pas (Ã©tat session)

-- 5. Variables session personnalisÃ©es
SET app.user_id = '123';
-- Connexion retourne au pool
SELECT current_setting('app.user_id');  -- âŒ Variable perdue
```

âŒ **Restrictions sur SET**
```sql
-- âŒ SET SESSION ne fonctionne pas
SET SESSION work_mem = '100MB';  -- âŒ Perdu aprÃ¨s transaction

-- âœ… SET LOCAL dans transaction fonctionne
BEGIN;
SET LOCAL work_mem = '100MB';  -- âœ… OK pour cette transaction
-- ... requÃªtes ...
COMMIT;
```

âŒ **Transactions Implicites ProblÃ©matiques**
```sql
-- Certains frameworks/ORMs utilisent transactions implicites
-- Peut causer des comportements inattendus en mode transaction
```

### Cas d'Usage IdÃ©aux pour Mode Transaction

**1. Applications Web Modernes (REST APIs)**
```python
# Exemple : API Flask/FastAPI
@app.get("/users/{user_id}")
def get_user(user_id: int):
    # RequÃªte simple (auto-commit)
    conn = pgbouncer_connect()  # Mode transaction
    user = conn.execute("SELECT * FROM users WHERE id = %s", (user_id,)).fetchone()
    # Connexion retourne au pool immÃ©diatement
    return user

@app.post("/orders")
def create_order(order_data: dict):
    conn = pgbouncer_connect()  # Mode transaction
    with conn.begin():  # Transaction explicite
        order_id = conn.execute("INSERT INTO orders (...) RETURNING id").fetchone()[0]
        conn.execute("INSERT INTO order_items (...)")
        conn.execute("UPDATE inventory ...")
    # COMMIT â†’ Connexion retourne au pool
    return {"order_id": order_id}
```

**2. Microservices**
```javascript
// Node.js avec pg
const { Pool } = require('pg');
const pool = new Pool({ /* PgBouncer config */ });

async function handleRequest(req, res) {
    // Chaque requÃªte = transaction courte
    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        const result = await client.query('SELECT ...');
        await client.query('INSERT ...');
        await client.query('COMMIT');
        // Connexion libÃ©rÃ©e immÃ©diatement
        res.json(result.rows);
    } finally {
        client.release();
    }
}
```

**3. Applications Serverless (AWS Lambda, Cloud Functions)**
```python
# AWS Lambda handler
def lambda_handler(event, context):
    # Connexion de courte durÃ©e
    conn = get_pgbouncer_connection()  # Mode transaction

    result = conn.execute("SELECT * FROM data WHERE id = %s", (event['id'],))

    # Lambda termine â†’ Connexion retourne au pool
    return {
        'statusCode': 200,
        'body': json.dumps(result)
    }
```

**4. Applications Haute Concurrence**
```
Contexte : E-commerce avec 10,000 requÃªtes/sec
Pattern : RequÃªtes courtes, nombreuses connexions simultanÃ©es
Solution : Mode transaction avec pool de 100 connexions PostgreSQL
RÃ©sultat : 100 connexions servent 10,000 requÃªtes/sec efficacement
```

**5. Batch Processing / Workers**
```python
# Worker traitant une queue de messages
while True:
    message = queue.get()
    conn = pgbouncer_connect()  # Mode transaction

    conn.execute("BEGIN")
    process_message(conn, message)
    conn.execute("COMMIT")
    # Connexion libÃ©rÃ©e pour le prochain worker
```

---

## Mode Statement : L'ExtrÃªme (Rarement UtilisÃ©)

### Principe de Fonctionnement

En mode **statement**, une connexion PostgreSQL est assignÃ©e **pour une seule requÃªte SQL**, puis immÃ©diatement retournÃ©e au pool.

```
Client:
â”œâ”€ SELECT * FROM users â†’ Connexion #1 â†’ Retour au pool
â”œâ”€ UPDATE users SET ... â†’ Connexion #2 â†’ Retour au pool
â”œâ”€ DELETE FROM ... â†’ Connexion #3 â†’ Retour au pool
```

### Restrictions Majeures

âŒ **Pas de Transactions**
```sql
BEGIN;  -- âŒ IMPOSSIBLE en mode statement
UPDATE ...;
COMMIT;
```

âŒ **Pas d'Ã‰tat**
- Aucun Ã©tat prÃ©servÃ© entre requÃªtes
- Chaque requÃªte est complÃ¨tement isolÃ©e

### Cas d'Usage (TrÃ¨s Rares)

**Uniquement pour** :
- RequÃªtes totalement indÃ©pendantes
- Charge extrÃªmement Ã©levÃ©e
- Aucun besoin de transactions

**En pratique** : Presque jamais utilisÃ©. PrÃ©fÃ©rer le mode transaction.

---

## Comparaison DÃ©taillÃ©e : Transaction vs Session

### Tableau Comparatif Complet

| CritÃ¨re | Mode Session | Mode Transaction |
|---------|--------------|------------------|
| **DurÃ©e connexion** | Toute la session client | DurÃ©e de la transaction |
| **CompatibilitÃ©** | â­â­â­â­â­ Totale | â­â­â­ Bonne |
| **Performance** | â­â­â­ Bonne | â­â­â­â­â­ Excellente |
| **ScalabilitÃ©** | â­â­ LimitÃ©e | â­â­â­â­â­ Excellente |
| **Tables temporaires** | âœ… Oui | âŒ Non |
| **Prepared statements** | âœ… Oui | âŒ Non (sauf nommÃ©s) |
| **Curseurs hors transaction** | âœ… Oui | âŒ Non |
| **LISTEN/NOTIFY** | âœ… Oui | âŒ Non |
| **SET SESSION** | âœ… Oui | âŒ Non |
| **SET LOCAL (dans TX)** | âœ… Oui | âœ… Oui |
| **Transactions explicites** | âœ… Oui | âœ… Oui |
| **Ratio clients/connexions** | 1:1 | 10:1 Ã  50:1 |
| **Gestion connexions idle** | âŒ BloquÃ©es | âœ… LibÃ©rÃ©es |
| **ComplexitÃ© migration** | â­ Facile | â­â­â­ Moyenne |

### FonctionnalitÃ©s DÃ©taillÃ©es

#### Tables Temporaires

**Mode Session** :
```sql
-- âœ… Fonctionne parfaitement
CREATE TEMP TABLE session_cache (key TEXT, value TEXT);
INSERT INTO session_cache VALUES ('user_id', '123');

-- Plusieurs requÃªtes plus tard...
SELECT value FROM session_cache WHERE key = 'user_id';  -- âœ… OK
```

**Mode Transaction** :
```sql
-- âŒ Ne fonctionne pas
CREATE TEMP TABLE session_cache (key TEXT, value TEXT);
-- Connexion retourne au pool

SELECT * FROM session_cache;  -- âŒ ERREUR : relation n'existe pas
```

**Workaround en mode transaction** :
```sql
-- Utiliser des tables permanentes avec cleanup
CREATE TABLE temp_data (
    session_id TEXT,
    key TEXT,
    value TEXT,
    created_at TIMESTAMP DEFAULT now()
);

-- Cleanup rÃ©gulier (cron job)
DELETE FROM temp_data WHERE created_at < now() - interval '1 hour';
```

#### Prepared Statements

**Mode Session** :
```sql
-- âœ… Prepared statements classiques fonctionnent
PREPARE get_user (INT) AS SELECT * FROM users WHERE id = $1;
EXECUTE get_user(123);
EXECUTE get_user(456);  -- âœ… RÃ©utilisable
```

**Mode Transaction** :
```sql
-- âŒ Prepared statements simples ne fonctionnent pas
PREPARE get_user (INT) AS SELECT * FROM users WHERE id = $1;
-- Connexion retourne au pool
EXECUTE get_user(123);  -- âŒ ERREUR : prepared statement inconnu

-- âœ… Mais les paramÃ¨tres de requÃªte fonctionnent
-- (gÃ©rÃ©s par le driver, pas PostgreSQL)
cursor.execute("SELECT * FROM users WHERE id = %s", (123,))  -- âœ… OK
```

#### Curseurs (CURSOR)

**Mode Session** :
```sql
-- âœ… Curseurs fonctionnent
BEGIN;
DECLARE large_data_cursor CURSOR FOR SELECT * FROM large_table;
FETCH 100 FROM large_data_cursor;
-- Peut faire d'autres choses
FETCH 100 FROM large_data_cursor;
CLOSE large_data_cursor;
COMMIT;
```

**Mode Transaction** :
```sql
-- âœ… Curseurs fonctionnent DANS une transaction
BEGIN;
DECLARE large_data_cursor CURSOR FOR SELECT * FROM large_table;
FETCH 100 FROM large_data_cursor;
FETCH 100 FROM large_data_cursor;
COMMIT;  -- Curseur fermÃ© automatiquement

-- âŒ Mais curseurs HORS transaction ne fonctionnent pas
DECLARE cursor1 CURSOR FOR SELECT * FROM table1;  -- âŒ ERREUR
```

#### LISTEN/NOTIFY

**Mode Session** :
```sql
-- âœ… Fonctionne
LISTEN order_events;

-- Application attend les notifications
-- (connexion reste assignÃ©e)

NOTIFY order_events, 'New order #123';
```

**Mode Transaction** :
```sql
-- âŒ Ne fonctionne pas
LISTEN order_events;
-- Connexion retourne au pool â†’ LISTEN perdu

-- Alternative : Polling ou systÃ¨me externe (Redis Pub/Sub, etc.)
```

#### Variables de Configuration

**Mode Session** :
```sql
-- âœ… SET SESSION fonctionne
SET SESSION work_mem = '100MB';
SET SESSION statement_timeout = '60s';

-- RequÃªtes suivantes utilisent ces valeurs
SELECT * FROM large_table ORDER BY id;  -- Utilise work_mem=100MB
```

**Mode Transaction** :
```sql
-- âŒ SET SESSION ne persiste pas
SET SESSION work_mem = '100MB';
-- Connexion retourne au pool â†’ Valeur perdue

-- âœ… SET LOCAL dans transaction fonctionne
BEGIN;
SET LOCAL work_mem = '100MB';
SELECT * FROM large_table ORDER BY id;  -- Utilise work_mem=100MB
COMMIT;  -- work_mem revient Ã  la valeur par dÃ©faut
```

---

## Installation et Configuration de PgBouncer

### Installation

#### Ubuntu/Debian

```bash
# Installer PgBouncer
sudo apt update
sudo apt install pgbouncer

# VÃ©rifier l'installation
pgbouncer --version
```

#### RHEL/CentOS

```bash
# Installer depuis EPEL
sudo yum install epel-release
sudo yum install pgbouncer

# Ou depuis PostgreSQL repos
sudo yum install https://download.postgresql.org/pub/repos/yum/reporpms/EL-8-x86_64/pgdg-redhat-repo-latest.noarch.rpm
sudo yum install pgbouncer
```

#### Docker

```bash
# Utiliser l'image officielle
docker pull pgbouncer/pgbouncer

# Ou construire avec config custom
docker run -d \
    --name pgbouncer \
    -p 6432:6432 \
    -v /path/to/pgbouncer.ini:/etc/pgbouncer/pgbouncer.ini \
    -v /path/to/userlist.txt:/etc/pgbouncer/userlist.txt \
    pgbouncer/pgbouncer
```

### Configuration Basique

#### Fichier pgbouncer.ini

**Localisation** : `/etc/pgbouncer/pgbouncer.ini`

```ini
[databases]
# Format: database_name = host=... port=... dbname=...
myapp = host=127.0.0.1 port=5432 dbname=myapp_production

# Wildcard: toutes les bases du serveur PostgreSQL
* = host=127.0.0.1 port=5432

[pgbouncer]
# === MODE DE POOLING ===
# transaction | session | statement
pool_mode = transaction

# === Ã‰COUTE ===
listen_addr = 0.0.0.0
listen_port = 6432

# === AUTHENTIFICATION ===
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt

# === LIMITES DE POOL ===
# Nombre max de connexions PostgreSQL par base
default_pool_size = 25

# Nombre min de connexions maintenues
min_pool_size = 5

# Nombre max de connexions PostgreSQL au total
max_db_connections = 100

# Nombre max de clients pouvant se connecter
max_client_conn = 1000

# === TIMEOUTS ===
# Timeout si serveur ne rÃ©pond pas
server_idle_timeout = 600

# Timeout si client idle
client_idle_timeout = 0

# Timeout connexion au serveur PostgreSQL
server_connect_timeout = 15

# === LOGS ===
logfile = /var/log/postgresql/pgbouncer.log
pidfile = /var/run/pgbouncer/pgbouncer.pid

# Niveau de log : 0=quiet, 1=critical, 2=error, 3=warning, 4=info, 5=debug
log_connections = 1
log_disconnections = 1
log_pooler_errors = 1

# === ADMIN ===
admin_users = postgres
stats_users = monitoring_user
```

#### Fichier userlist.txt

**Localisation** : `/etc/pgbouncer/userlist.txt`

```txt
# Format: "username" "password_hash"
# Hash MD5 : md5 + md5(password + username)

"myapp_user" "md5d8578edf8458ce06fbc5bb76a58c5ca4"
"admin" "md5c93ccd78b2076528346216b3b2f701e6"
"readonly_user" "md5a029d0df84eb5549c641e04a9ef389e5"
```

**GÃ©nÃ©rer un hash MD5** :
```bash
# MÃ©thode 1 : Script Python
python3 -c "import hashlib; print('md5' + hashlib.md5(('password' + 'username').encode()).hexdigest())"

# MÃ©thode 2 : PostgreSQL
psql -c "SELECT 'md5' || md5('password' || 'username');"

# Exemple pour user=myapp password=secretpass
# md5(secretpassmyapp) = d8578edf8458ce06fbc5bb76a58c5ca4
# RÃ©sultat : "myapp" "md5d8578edf8458ce06fbc5bb76a58c5ca4"
```

### DÃ©marrage et Gestion

```bash
# DÃ©marrer PgBouncer
sudo systemctl start pgbouncer

# Activer au dÃ©marrage
sudo systemctl enable pgbouncer

# VÃ©rifier le statut
sudo systemctl status pgbouncer

# Recharger la configuration (sans interrompre les connexions)
sudo systemctl reload pgbouncer

# RedÃ©marrer
sudo systemctl restart pgbouncer

# Voir les logs
sudo tail -f /var/log/postgresql/pgbouncer.log
```

### Configuration AvancÃ©e par Mode

#### Configuration Mode Transaction (RecommandÃ©)

```ini
[pgbouncer]
pool_mode = transaction

# Pool size agressif (ratio Ã©levÃ©)
default_pool_size = 25
max_db_connections = 100
max_client_conn = 2000  # Ratio 20:1

# LibÃ©rer rapidement les connexions idle
server_idle_timeout = 60

# Timeout court pour Ã©viter blocages
query_timeout = 30
query_wait_timeout = 120

# RÃ©utilisation rapide
server_check_delay = 30
```

#### Configuration Mode Session

```ini
[pgbouncer]
pool_mode = session

# Pool size conservateur (ratio proche de 1:1)
default_pool_size = 100
max_db_connections = 200
max_client_conn = 200

# Garder connexions plus longtemps
server_idle_timeout = 600

# Pas de timeout de requÃªte (sessions longues)
query_timeout = 0
query_wait_timeout = 120
```

---

## Connexion Ã  PgBouncer depuis l'Application

### Modification de la ChaÃ®ne de Connexion

**Avant (Connexion directe PostgreSQL)** :
```
host=postgres-server.example.com port=5432 dbname=myapp user=myapp_user password=secret
```

**AprÃ¨s (Via PgBouncer)** :
```
host=pgbouncer-server.example.com port=6432 dbname=myapp user=myapp_user password=secret
```

**Changement** : Seulement `host` et `port` !

### Exemples par Langage

#### Python (psycopg2/psycopg3)

```python
import psycopg2

# Connexion via PgBouncer
conn = psycopg2.connect(
    host="localhost",
    port=6432,  # Port PgBouncer
    dbname="myapp",
    user="myapp_user",
    password="secret"
)

# Utilisation normale
cursor = conn.cursor()
cursor.execute("SELECT * FROM users WHERE id = %s", (123,))
results = cursor.fetchall()

# IMPORTANT en mode transaction : pas de tables temporaires
# âŒ cursor.execute("CREATE TEMP TABLE ...")  # Ne fonctionnera pas
```

#### Node.js (pg)

```javascript
const { Pool } = require('pg');

// Pool configurÃ© pour PgBouncer
const pool = new Pool({
    host: 'localhost',
    port: 6432,  // Port PgBouncer
    database: 'myapp',
    user: 'myapp_user',
    password: 'secret',
    max: 100,  // Pool cÃ´tÃ© application (diffÃ©rent du pool PgBouncer)
});

// Utilisation
async function getUser(userId) {
    const client = await pool.connect();
    try {
        const result = await client.query('SELECT * FROM users WHERE id = $1', [userId]);
        return result.rows[0];
    } finally {
        client.release();  // Important !
    }
}
```

#### Java (JDBC)

```java
import java.sql.*;

public class DatabaseConnection {
    public static Connection getConnection() throws SQLException {
        String url = "jdbc:postgresql://localhost:6432/myapp";  // Port PgBouncer
        String user = "myapp_user";
        String password = "secret";

        return DriverManager.getConnection(url, user, password);
    }

    public static void main(String[] args) {
        try (Connection conn = getConnection()) {
            PreparedStatement stmt = conn.prepareStatement(
                "SELECT * FROM users WHERE id = ?"
            );
            stmt.setInt(1, 123);
            ResultSet rs = stmt.executeQuery();

            while (rs.next()) {
                System.out.println("User: " + rs.getString("name"));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

#### Go (pgx)

```go
package main

import (
    "context"
    "fmt"
    "github.com/jackc/pgx/v5/pgxpool"
)

func main() {
    // Connexion via PgBouncer
    connString := "postgres://myapp_user:secret@localhost:6432/myapp"

    pool, err := pgxpool.New(context.Background(), connString)
    if err != nil {
        panic(err)
    }
    defer pool.Close()

    // Utilisation
    var name string
    err = pool.QueryRow(context.Background(),
        "SELECT name FROM users WHERE id = $1", 123).Scan(&name)

    if err != nil {
        panic(err)
    }

    fmt.Printf("User: %s\n", name)
}
```

#### Ruby (pg gem)

```ruby
require 'pg'

# Connexion via PgBouncer
conn = PG.connect(
  host: 'localhost',
  port: 6432,  # Port PgBouncer
  dbname: 'myapp',
  user: 'myapp_user',
  password: 'secret'
)

# Utilisation
result = conn.exec_params('SELECT * FROM users WHERE id = $1', [123])
result.each do |row|
  puts "User: #{row['name']}"
end

conn.close
```

---

## Monitoring et Administration

### Console d'Administration PgBouncer

PgBouncer expose une **base de donnÃ©es virtuelle** `pgbouncer` pour l'administration.

```bash
# Se connecter Ã  la console admin
psql -h localhost -p 6432 -U admin pgbouncer

# Ou avec mot de passe
PGPASSWORD=adminpass psql -h localhost -p 6432 -U admin pgbouncer
```

### Commandes Essentielles

#### SHOW POOLS - Ã‰tat des Pools

```sql
pgbouncer=# SHOW POOLS;

 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait | pool_mode
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------+-----------
 myapp     | myapp_user|        15 |          0 |        10 |       5 |       0 |         0 |        0 |       0 | transaction
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0 | statement
```

**Colonnes importantes** :
- `cl_active` : Clients actifs (connexions applicatives)
- `cl_waiting` : Clients en attente (pool saturÃ©)
- `sv_active` : Connexions PostgreSQL actives
- `sv_idle` : Connexions PostgreSQL idle dans le pool
- `maxwait` : Temps d'attente max en secondes (si > 0 â†’ problÃ¨me)

**InterprÃ©tation** :
```
cl_active = 15, sv_active = 10
â†’ Bon ratio, pooling fonctionne (15 clients partagent 10 connexions)

cl_waiting > 0
â†’ âš ï¸ Pool saturÃ©, augmenter default_pool_size

sv_active + sv_idle proche de default_pool_size Ã— nb_databases
â†’ Utilisation normale du pool
```

#### SHOW DATABASES - Configuration Bases

```sql
pgbouncer=# SHOW DATABASES;

   name    |  host   | port | database  | force_user | pool_size | reserve_pool | pool_mode  | max_connections
-----------+---------+------+-----------+------------+-----------+--------------+------------+----------------
 myapp     | 127.0.0.1 | 5432 | myapp_production |            |        25 |            0 | transaction |             100
 pgbouncer | 127.0.0.1 |    0 | pgbouncer |            |         2 |            0 | statement   |               0
```

#### SHOW CLIENTS - Connexions Clientes

```sql
pgbouncer=# SHOW CLIENTS;

 type |   user    | database | state  |      addr      | port  | local_addr | local_port |    connect_time     |    request_time     |    ptr
------+-----------+----------+--------+----------------+-------+------------+------------+---------------------+---------------------+--------------
 C    | myapp_user| myapp    | active | 192.168.1.100  | 54321 | 10.0.0.5   |       6432 | 2024-11-22 10:15:23 | 2024-11-22 10:15:24 | 0x55a8b2c3d4e0
 C    | myapp_user| myapp    | idle   | 192.168.1.101  | 54322 | 10.0.0.5   |       6432 | 2024-11-22 10:14:05 | 2024-11-22 10:15:10 | 0x55a8b2c3d5f0
```

**Ã‰tats possibles** :
- `active` : Client exÃ©cute une requÃªte
- `idle` : Client connectÃ© mais inactif
- `waiting` : Client attend une connexion du pool

#### SHOW SERVERS - Connexions Serveur

```sql
pgbouncer=# SHOW SERVERS;

 type |   user    | database |  state  |      addr      | port  |    connect_time     |    request_time     |    ptr
------+-----------+----------+---------+----------------+-------+---------------------+---------------------+--------------
 S    | myapp_user| myapp    | active  | 127.0.0.1      | 5432  | 2024-11-22 10:10:00 | 2024-11-22 10:15:24 | 0x55a8b2c3d700
 S    | myapp_user| myapp    | idle    | 127.0.0.1      | 5432  | 2024-11-22 10:10:01 | 2024-11-22 10:14:50 | 0x55a8b2c3d800
```

**Ã‰tats** :
- `active` : Connexion PostgreSQL traite une requÃªte
- `idle` : Connexion PostgreSQL disponible dans le pool
- `used` : Connexion utilisÃ©e rÃ©cemment, pas encore retournÃ©e au pool

#### SHOW STATS - Statistiques Globales

```sql
pgbouncer=# SHOW STATS;

 database  | total_xact_count | total_query_count | total_received | total_sent | total_xact_time | total_query_time | avg_xact_count | avg_query_count | avg_recv | avg_sent | avg_xact_time | avg_query_time
-----------+------------------+-------------------+----------------+------------+-----------------+------------------+----------------+-----------------+----------+----------+---------------+---------------
 myapp     |          1234567 |           1234567 |      987654321 |  876543210 |       123456789 |        123456789 |           1234 |            1234 |    98765 |    87654 |           100 |            100
 pgbouncer |                5 |                 5 |            500 |        400 |             100 |              100 |              0 |               0 |       50 |       40 |            20 |             20
```

**MÃ©triques clÃ©s** :
- `total_xact_count` : Nombre total de transactions
- `avg_xact_time` : Temps moyen de transaction (microsecondes)
- `avg_query_time` : Temps moyen de requÃªte

#### SHOW STATS_TOTALS - AgrÃ©gations

```sql
pgbouncer=# SHOW STATS_TOTALS;

 database  | xact_count | query_count | bytes_received | bytes_sent | xact_time | query_time
-----------+------------+-------------+----------------+------------+-----------+-----------
 myapp     |     123456 |      123456 |       12345678 |   12345678 |    123456 |    123456
```

### Commandes de Gestion

#### PAUSE - Pause Temporaire

```sql
-- Pause toutes les bases (connexions existantes continuent, nouvelles en attente)
pgbouncer=# PAUSE;

-- Pause une base spÃ©cifique
pgbouncer=# PAUSE myapp;
```

**Cas d'usage** : Maintenance PostgreSQL (upgrade mineur, VACUUM FULL, etc.)

#### RESUME - Reprendre

```sql
-- Reprendre toutes les bases
pgbouncer=# RESUME;

-- Reprendre une base spÃ©cifique
pgbouncer=# RESUME myapp;
```

#### RELOAD - Recharger Configuration

```sql
-- Recharge pgbouncer.ini sans interrompre les connexions
pgbouncer=# RELOAD;
```

**Utile pour** : Changer pool_size, ajouter bases, modifier timeouts, etc.

#### SHUTDOWN - ArrÃªt

```sql
-- ArrÃªt gracieux (attend fin des transactions)
pgbouncer=# SHUTDOWN;

-- ArrÃªt immÃ©diat (coupe les connexions)
pgbouncer=# SHUTDOWN IMMEDIATE;
```

### MÃ©triques Ã  Surveiller

#### 1. Ratio Clients/Serveurs

```sql
-- Calcul du ratio de pooling
SELECT
    database,
    cl_active,
    sv_active,
    ROUND(cl_active::numeric / NULLIF(sv_active, 0), 2) AS ratio
FROM pgbouncer.pools
WHERE database != 'pgbouncer';
```

**InterprÃ©tation** :
- Ratio > 5 : âœ… Bon pooling
- Ratio 2-5 : ğŸŸ¡ Pooling modÃ©rÃ©
- Ratio < 2 : ğŸŸ  Peu de bÃ©nÃ©fice du pooling

#### 2. Clients en Attente (Saturation)

```sql
-- VÃ©rifier si le pool est saturÃ©
SELECT
    database,
    cl_waiting,
    maxwait
FROM pgbouncer.pools
WHERE cl_waiting > 0;
```

**Action si cl_waiting > 0** :
```ini
# Augmenter dans pgbouncer.ini
default_pool_size = 50  # Au lieu de 25
```

#### 3. Temps Moyen de Transaction

```sql
-- Surveiller la latence
SELECT
    database,
    avg_xact_time / 1000000.0 AS avg_xact_time_sec,
    avg_query_time / 1000000.0 AS avg_query_time_sec
FROM pgbouncer.stats;
```

**InterprÃ©tation** :
- < 0.1s : âœ… Excellent
- 0.1-1s : ğŸŸ¡ Acceptable
- > 1s : ğŸ”´ ProblÃ¨me (requÃªtes lentes ou pool trop petit)

### Scripts de Monitoring

#### Script Bash de Monitoring

```bash
#!/bin/bash
# monitor_pgbouncer.sh

PGBOUNCER_HOST="localhost"
PGBOUNCER_PORT="6432"
PGBOUNCER_USER="admin"
PGBOUNCER_PASS="adminpass"

echo "=== PgBouncer Health Check ==="
echo "Date: $(date)"
echo ""

# Pools status
echo "--- Pools Status ---"
PGPASSWORD=$PGBOUNCER_PASS psql -h $PGBOUNCER_HOST -p $PGBOUNCER_PORT -U $PGBOUNCER_USER pgbouncer -t -c "
SELECT
    database,
    cl_active AS clients_active,
    cl_waiting AS clients_waiting,
    sv_active AS servers_active,
    sv_idle AS servers_idle,
    maxwait AS max_wait_sec
FROM pgbouncer.pools
WHERE database != 'pgbouncer';
"

# Alertes
echo ""
echo "--- Alerts ---"
WAITING=$(PGPASSWORD=$PGBOUNCER_PASS psql -h $PGBOUNCER_HOST -p $PGBOUNCER_PORT -U $PGBOUNCER_USER pgbouncer -t -c "
SELECT COALESCE(SUM(cl_waiting), 0) FROM pgbouncer.pools WHERE database != 'pgbouncer';
")

if [ "$WAITING" -gt 0 ]; then
    echo "âš ï¸  WARNING: $WAITING clients waiting (pool saturated)"
else
    echo "âœ… No clients waiting"
fi

# Stats
echo ""
echo "--- Statistics (last period) ---"
PGPASSWORD=$PGBOUNCER_PASS psql -h $PGBOUNCER_HOST -p $PGBOUNCER_PORT -U $PGBOUNCER_USER pgbouncer -t -c "
SELECT
    database,
    total_xact_count AS transactions,
    ROUND(avg_xact_time / 1000.0, 2) AS avg_xact_ms
FROM pgbouncer.stats
WHERE database != 'pgbouncer';
"
```

#### Prometheus Exporter

```python
# pgbouncer_exporter.py
from prometheus_client import start_http_server, Gauge
import psycopg2
import time

# MÃ©triques
clients_active = Gauge('pgbouncer_clients_active', 'Active clients', ['database'])
clients_waiting = Gauge('pgbouncer_clients_waiting', 'Waiting clients', ['database'])
servers_active = Gauge('pgbouncer_servers_active', 'Active servers', ['database'])
servers_idle = Gauge('pgbouncer_servers_idle', 'Idle servers', ['database'])

def collect_metrics():
    conn = psycopg2.connect(
        host='localhost',
        port=6432,
        user='admin',
        password='adminpass',
        dbname='pgbouncer'
    )

    cursor = conn.cursor()
    cursor.execute("SHOW POOLS")

    for row in cursor.fetchall():
        database = row[0]
        if database == 'pgbouncer':
            continue

        clients_active.labels(database=database).set(row[2])
        clients_waiting.labels(database=database).set(row[3])
        servers_active.labels(database=database).set(row[4])
        servers_idle.labels(database=database).set(row[5])

    conn.close()

if __name__ == '__main__':
    start_http_server(9127)
    while True:
        collect_metrics()
        time.sleep(15)
```

---

## Troubleshooting : ProblÃ¨mes Courants

### ProblÃ¨me 1 : "sorry, too many clients already"

**SymptÃ´me** :
```
ERROR: sorry, too many clients already
```

**Cause** : `max_client_conn` atteint.

**Solution** :
```ini
# Dans pgbouncer.ini
max_client_conn = 2000  # Au lieu de 1000
```

```bash
# Recharger
sudo systemctl reload pgbouncer
```

### ProblÃ¨me 2 : Clients en Attente (cl_waiting > 0)

**SymptÃ´me** :
```sql
SHOW POOLS;
-- cl_waiting = 50
```

**Cause** : Pool saturÃ©, pas assez de connexions PostgreSQL.

**Solutions** :

**Option 1** : Augmenter pool size
```ini
default_pool_size = 50  # Au lieu de 25
max_db_connections = 200  # Au lieu de 100
```

**Option 2** : Optimiser requÃªtes (si transactions trop longues)
```sql
-- Identifier requÃªtes lentes sur PostgreSQL
SELECT * FROM pg_stat_statements ORDER BY mean_exec_time DESC LIMIT 10;
```

### ProblÃ¨me 3 : "prepared statement does not exist"

**SymptÃ´me** :
```
ERROR: prepared statement "stmt_123" does not exist
```

**Cause** : Mode transaction + utilisation de prepared statements.

**Solution** : Utiliser paramÃ¨tres de requÃªte au lieu de prepared statements
```python
# âŒ Mauvais (prepared statement)
cursor.execute("PREPARE stmt AS SELECT * FROM users WHERE id = $1")
cursor.execute("EXECUTE stmt", (123,))

# âœ… Bon (paramÃ¨tres de requÃªte)
cursor.execute("SELECT * FROM users WHERE id = %s", (123,))
```

### ProblÃ¨me 4 : "relation does not exist" (table temporaire)

**SymptÃ´me** :
```
ERROR: relation "temp_table" does not exist
```

**Cause** : Mode transaction + table temporaire.

**Solutions** :

**Option 1** : Passer en mode session
```ini
pool_mode = session
```

**Option 2** : Utiliser tables permanentes avec cleanup
```sql
CREATE TABLE app_temp_data (
    session_id TEXT,
    data JSONB,
    created_at TIMESTAMP DEFAULT now()
);

-- Cleanup automatique (trigger ou cron)
DELETE FROM app_temp_data WHERE created_at < now() - interval '1 hour';
```

### ProblÃ¨me 5 : Connexions PostgreSQL Non LibÃ©rÃ©es

**SymptÃ´me** : `sv_active` reste Ã©levÃ© mÃªme quand `cl_active` est faible.

**Cause** : Transactions non fermÃ©es, connexions leaked.

**Diagnostic** :
```sql
-- Sur PostgreSQL
SELECT pid, state, state_change, query
FROM pg_stat_activity
WHERE datname = 'myapp'
  AND state IN ('idle in transaction', 'idle in transaction (aborted)')
ORDER BY state_change;
```

**Solution** : Corriger l'application pour toujours fermer les transactions
```python
# âœ… Bon pattern
try:
    conn.begin()
    # ... requÃªtes ...
    conn.commit()
except Exception as e:
    conn.rollback()  # Important !
finally:
    conn.close()
```

### ProblÃ¨me 6 : Performances DÃ©gradÃ©es AprÃ¨s Migration

**SymptÃ´me** : Application plus lente avec PgBouncer qu'en direct.

**Causes possibles** :

1. **Pool trop petit**
```ini
default_pool_size = 10  # Trop petit
```
**Solution** : Augmenter Ã  25-50

2. **Timeout trop agressif**
```ini
query_timeout = 5  # 5 secondes trop court
```
**Solution** : Augmenter ou dÃ©sactiver (0)

3. **Mode session au lieu de transaction**
```ini
pool_mode = session  # Peu de bÃ©nÃ©fice du pooling
```
**Solution** : Passer en mode transaction si compatible

---

## Bonnes Pratiques

### âœ… Ã€ Faire

1. **Commencer avec Mode Transaction**
   - 90% des applications modernes sont compatibles
   - Meilleures performances et scalabilitÃ©

2. **Dimensionner le Pool Correctement**
   ```
   RÃ¨gle empirique :
   default_pool_size = (Nombre de CPU PostgreSQL) Ã— 2 Ã  4

   Exemple : Serveur 8 CPUs
   â†’ default_pool_size = 16-32
   ```

3. **Monitorer RÃ©guliÃ¨rement**
   ```bash
   # VÃ©rifier quotidiennement
   psql -h localhost -p 6432 -U admin pgbouncer -c "SHOW POOLS"
   ```

4. **Configurer Timeouts AppropriÃ©s**
   ```ini
   # Production
   server_idle_timeout = 300  # 5 minutes
   query_timeout = 30  # 30 secondes
   query_wait_timeout = 120  # 2 minutes
   ```

5. **Utiliser SSL si RÃ©seau Non SÃ©curisÃ©**
   ```ini
   client_tls_sslmode = require
   client_tls_ca_file = /path/to/ca.crt
   client_tls_cert_file = /path/to/client.crt
   client_tls_key_file = /path/to/client.key
   ```

6. **SÃ©parer PgBouncer par Environnement**
   ```
   Production : pgbouncer-prod (port 6432)
   Staging : pgbouncer-staging (port 6433)
   Dev : Connexion directe (pas de PgBouncer nÃ©cessaire)
   ```

7. **Fermer Proprement les Connexions**
   ```python
   # Toujours dans un finally
   try:
       conn = pool.getconn()
       # ... utilisation ...
   finally:
       pool.putconn(conn)  # LibÃ©rer au pool
   ```

### âŒ Ã€ Ã‰viter

1. **Ne Pas Utiliser Mode Transaction pour des Cas Incompatibles**
   ```python
   # âŒ En mode transaction
   conn.execute("CREATE TEMP TABLE ...")  # Ne fonctionnera pas
   ```

2. **Pool Trop Grand**
   ```ini
   # âŒ Mauvais
   default_pool_size = 500  # Bien trop Ã©levÃ©, pas de limite PostgreSQL
   ```
   **Risque** : Saturation PostgreSQL

3. **max_client_conn Trop Bas**
   ```ini
   # âŒ Mauvais
   max_client_conn = 50  # Avec 1000 utilisateurs attendus
   ```

4. **Oublier de Recharger AprÃ¨s Changement**
   ```bash
   # AprÃ¨s modification pgbouncer.ini
   sudo systemctl reload pgbouncer  # Ne pas oublier !
   ```

5. **Ignorer les Clients en Attente**
   ```sql
   -- Si cl_waiting > 0 pendant longtemps
   â†’ Action requise (augmenter pool ou optimiser requÃªtes)
   ```

6. **Connection Pooling CÃ´tÃ© Application ET PgBouncer**
   ```python
   # âš ï¸ Attention : Double pooling
   app_pool = Pool(min=50, max=200)  # Pool applicatif
   â†’ PgBouncer (25 connexions)
   â†’ PostgreSQL

   # Risque : 200 connexions app pour 25 connexions PostgreSQL
   # â†’ Beaucoup d'attente
   ```
   **Solution** : Soit pool applicatif, soit PgBouncer, pas les deux avec des limites mal calibrÃ©es.

---

## Architectures AvancÃ©es

### 1. PgBouncer sur Chaque Serveur d'Application

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ App Server 1    â”‚
â”‚ â”œâ”€ Application  â”‚
â”‚ â””â”€ PgBouncer    â”‚â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                     â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”œâ”€â”€â”€â†’â”‚ PostgreSQL   â”‚
â”‚ App Server 2    â”‚  â”‚    â”‚ Primary      â”‚
â”‚ â”œâ”€ Application  â”‚  â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ â””â”€ PgBouncer    â”‚â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Avantages** :
- Latence minimale (PgBouncer local)
- Pas de SPOF (Single Point of Failure)
- Scaling horizontal simple

**Configuration** :
```ini
# Sur chaque serveur app
[pgbouncer]
listen_addr = 127.0.0.1  # Local seulement
pool_mode = transaction
default_pool_size = 10  # Petit pool par serveur
```

### 2. PgBouncer CentralisÃ©

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ App Server 1â”‚â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                 â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”œâ”€â”€â”€â†’â”‚ PgBouncer    â”‚â”€â”€â”€â†’â”‚ PostgreSQL   â”‚
â”‚ App Server 2â”‚â”€â”€â”¤    â”‚ (Centralized)â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ App Server 3â”‚â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Avantages** :
- Configuration centralisÃ©e
- Monitoring unique
- Pool global optimisÃ©

**InconvÃ©nients** :
- Point unique de dÃ©faillance
- Latence rÃ©seau supplÃ©mentaire

**Mitigation SPOF** :
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ App Servers       â”‚
â”‚ (Load Balanced)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚ HAProxy â”‚  # Load balance sur plusieurs PgBouncer
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚             â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
â”‚PgBouncerâ”‚  â”‚PgBouncerâ”‚
â”‚   #1    â”‚  â”‚   #2    â”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
    â”‚ PostgreSQL â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. PgBouncer avec RÃ©plication

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   PgBouncer     â”‚
                    â”‚   (Writes)      â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Applicationâ”œâ”€â”€â”€â”€â”€â†’â”‚  PostgreSQL     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚  Primary        â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚ Replication
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  PostgreSQL     â”‚
                    â”‚  Replica        â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   PgBouncer     â”‚
                    â”‚   (Reads)       â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Configuration** :
```ini
# pgbouncer-write.ini (vers Primary)
[databases]
myapp_write = host=postgres-primary port=5432 dbname=myapp

[pgbouncer]
pool_mode = transaction

# pgbouncer-read.ini (vers Replica)
[databases]
myapp_read = host=postgres-replica port=5432 dbname=myapp

[pgbouncer]
pool_mode = transaction
```

**Application** :
```python
# SÃ©paration lecture/Ã©criture
write_pool = get_pool('pgbouncer-write', 6432)
read_pool = get_pool('pgbouncer-read', 6433)

def create_user(name):
    conn = write_pool.getconn()  # Ã‰criture sur Primary
    conn.execute("INSERT INTO users (name) VALUES (%s)", (name,))
    write_pool.putconn(conn)

def get_users():
    conn = read_pool.getconn()  # Lecture sur Replica
    results = conn.execute("SELECT * FROM users").fetchall()
    read_pool.putconn(conn)
    return results
```

---

## RÃ©sumÃ© et Points ClÃ©s

### ğŸ¯ L'Essentiel Ã  Retenir

1. **PgBouncer est Essentiel pour les Applications Scalables**
   - RÃ©duit consommation mÃ©moire et CPU
   - ProtÃ¨ge contre les pics de charge
   - AmÃ©liore utilisation des ressources

2. **Mode Transaction vs Session : Le Choix Crucial**
   ```
   Mode Transaction (90% des cas) :
   âœ… Performance maximale
   âœ… ScalabilitÃ© excellente
   âŒ Pas de tables temporaires
   âŒ Pas de prepared statements classiques

   Mode Session (10% des cas) :
   âœ… CompatibilitÃ© totale
   âœ… Comportement transparent
   âŒ Moins de mutualisation
   âŒ Scaling limitÃ©
   ```

3. **Dimensionnement du Pool**
   ```
   default_pool_size = (CPU PostgreSQL) Ã— 2-4
   max_client_conn = 10-20 Ã— default_pool_size

   Exemple : Serveur 8 CPUs
   â†’ default_pool_size = 25
   â†’ max_client_conn = 500
   ```

4. **Monitoring Continu**
   ```sql
   -- VÃ©rifier quotidiennement
   SHOW POOLS;

   âš ï¸ Si cl_waiting > 0 : Pool saturÃ©, augmenter default_pool_size
   ```

5. **Quand Utiliser Quel Mode ?**
   ```
   Mode Transaction :
   â†’ APIs REST/GraphQL
   â†’ Microservices
   â†’ Applications web modernes
   â†’ Serverless (Lambda, Cloud Functions)

   Mode Session :
   â†’ Applications legacy
   â†’ Utilisation de tables temporaires
   â†’ Prepared statements requis
   â†’ Curseurs hors transaction
   â†’ LISTEN/NOTIFY
   ```

6. **Configuration Minimale de Production**
   ```ini
   [pgbouncer]
   pool_mode = transaction
   default_pool_size = 25
   max_db_connections = 100
   max_client_conn = 1000
   server_idle_timeout = 600
   log_connections = 1
   log_disconnections = 1
   ```

### ğŸ“‹ Checklist de DÃ©ploiement

```
Phase 1 : Installation
[ ] Installer PgBouncer
[ ] CrÃ©er pgbouncer.ini
[ ] CrÃ©er userlist.txt avec hashes MD5
[ ] Tester connexion admin

Phase 2 : Configuration
[ ] Choisir pool_mode (transaction recommandÃ©)
[ ] DÃ©finir default_pool_size selon CPU
[ ] Configurer max_client_conn
[ ] Configurer timeouts appropriÃ©s
[ ] Activer logs

Phase 3 : Migration Application
[ ] Modifier connection string (port 6432)
[ ] Tester en dev/staging
[ ] VÃ©rifier compatibilitÃ© (tables temp, prepared statements)
[ ] Ajuster code si nÃ©cessaire

Phase 4 : Production
[ ] DÃ©ployer en fenÃªtre de maintenance
[ ] Monitorer SHOW POOLS
[ ] VÃ©rifier aucun cl_waiting
[ ] Surveiller logs erreurs

Phase 5 : Optimisation
[ ] Analyser ratio clients/serveurs
[ ] Ajuster pool_size si nÃ©cessaire
[ ] Benchmarker avant/aprÃ¨s
[ ] Documenter configuration finale
```

---

## Conclusion

PgBouncer est un outil **indispensable** pour toute application PostgreSQL en production gÃ©rant plus de 50 connexions simultanÃ©es. Il permet de :

- âœ… **Multiplier par 10-50Ã— le nombre de clients gÃ©rables** avec la mÃªme infrastructure PostgreSQL
- âœ… **RÃ©duire drastiquement** la consommation mÃ©moire et CPU
- âœ… **ProtÃ©ger PostgreSQL** contre les pics de charge et les connection storms
- âœ… **AmÃ©liorer la rÃ©silience** globale de votre architecture

Le choix entre **mode transaction** et **mode session** dÃ©pend de votre application :
- **Mode transaction** : 90% des cas (applications web/API modernes)
- **Mode session** : 10% des cas (applications legacy, besoins spÃ©cifiques)

Avec une configuration appropriÃ©e, un monitoring attentif et une comprÃ©hension des limitations de chaque mode, PgBouncer devient un alliÃ© de taille pour faire Ã©voluer votre application PostgreSQL de 100 Ã  10,000+ utilisateurs simultanÃ©s sans changement d'infrastructure majeur.

**Prochaine Ã©tape** : Dans la section suivante, nous explorerons les stratÃ©gies de **haute disponibilitÃ© et rÃ©plication** pour garantir la continuitÃ© de service et la tolÃ©rance aux pannes !

---


â­ï¸ [Haute DisponibilitÃ© et RÃ©plication](/17-haute-disponibilite-et-replication/README.md)
