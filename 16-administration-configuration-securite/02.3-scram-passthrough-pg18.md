üîù Retour au [Sommaire](/SOMMAIRE.md)

# 16.2.3. Nouveaut√© PostgreSQL 18 : SCRAM Passthrough avec postgres_fdw et dblink

## Introduction

PostgreSQL 18 introduit une am√©lioration majeure de s√©curit√© pour les connexions f√©d√©r√©es : le **SCRAM passthrough**. Cette fonctionnalit√© permet aux extensions `postgres_fdw` et `dblink` de transmettre l'authentification SCRAM-SHA-256 de mani√®re s√©curis√©e entre serveurs PostgreSQL, sans jamais exposer les mots de passe en clair.

> **Pour les d√©butants** : Imaginez que vous voulez que deux serveurs PostgreSQL communiquent entre eux. Avant PostgreSQL 18, vous deviez donner le mot de passe en clair dans la configuration. Maintenant, PostgreSQL 18 utilise une m√©thode s√©curis√©e (SCRAM) pour que les serveurs s'authentifient sans exposer les mots de passe !

---

## Contexte : Comprendre postgres_fdw et dblink

### Qu'est-ce qu'une Connexion F√©d√©r√©e ?

Une **connexion f√©d√©r√©e** permet √† un serveur PostgreSQL d'acc√©der aux donn√©es d'un autre serveur PostgreSQL (ou m√™me d'un autre type de base de donn√©es) comme si elles √©taient locales.

**Analogie** : Imaginez que vous travaillez dans le bureau A et avez besoin d'un document qui se trouve dans le bureau B. Au lieu de vous d√©placer physiquement, vous appelez le bureau B et demandez qu'on vous envoie le document par email. C'est exactement ce que fait PostgreSQL avec les connexions f√©d√©r√©es.

### postgres_fdw : Foreign Data Wrapper

**postgres_fdw** est une extension qui permet √† PostgreSQL d'acc√©der aux tables d'un autre serveur PostgreSQL.

**Architecture :**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Serveur PostgreSQL LOCAL   ‚îÇ          ‚îÇ  Serveur PostgreSQL REMOTE  ‚îÇ
‚îÇ  (pg-local.company.com)     ‚îÇ          ‚îÇ  (pg-remote.company.com)    ‚îÇ
‚îÇ                             ‚îÇ          ‚îÇ                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ          ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ  Table Locale       ‚îÇ    ‚îÇ          ‚îÇ  ‚îÇ  Table Distante     ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  "customers"        ‚îÇ    ‚îÇ          ‚îÇ  ‚îÇ  "orders"           ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ          ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                             ‚îÇ          ‚îÇ                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ          ‚îÇ                             ‚îÇ
‚îÇ  ‚îÇ  Foreign Table      ‚îÇ    ‚îÇ Connexion‚îÇ                             ‚îÇ
‚îÇ  ‚îÇ  "remote_orders"    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ                             ‚îÇ
‚îÇ  ‚îÇ  (pointe vers       ‚îÇ    ‚îÇ  FDW     ‚îÇ                             ‚îÇ
‚îÇ  ‚îÇ   pg-remote)        ‚îÇ    ‚îÇ          ‚îÇ                             ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ          ‚îÇ                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Cas d'usage :**
- **F√©d√©ration de donn√©es** : Requ√™ter plusieurs bases depuis un point central
- **Partitionnement horizontal** : Donn√©es r√©parties sur plusieurs serveurs
- **Migration progressive** : Acc√©der √† l'ancien syst√®me pendant la migration
- **Reporting** : Agr√©ger des donn√©es de plusieurs sources

### dblink : Connexions Ad-Hoc

**dblink** est une extension plus ancienne et plus flexible qui permet d'ex√©cuter des requ√™tes sur un serveur distant.

**Diff√©rence avec postgres_fdw :**
- **postgres_fdw** : Connexion persistante, tables virtuelles
- **dblink** : Connexions ponctuelles dans les requ√™tes SQL

**Exemple d'utilisation :**
```sql
-- Avec dblink, connexion √† la demande
SELECT * FROM dblink(
    'host=pg-remote.com user=alice password=secret dbname=remote',
    'SELECT * FROM orders'
) AS remote_orders(id int, amount numeric);
```

---

## Le Probl√®me de S√©curit√© (Avant PostgreSQL 18)

### Exposition des Mots de Passe en Clair

Avant PostgreSQL 18, pour √©tablir une connexion f√©d√©r√©e, vous deviez **stocker le mot de passe en clair** dans la d√©finition du serveur ou dans la requ√™te.

#### Avec postgres_fdw (Avant PG 18)

```sql
-- ‚ùå PROBL√àME : Mot de passe en clair stock√© dans le syst√®me
CREATE SERVER remote_server
    FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (host 'pg-remote.com', dbname 'remotedb', port '5432');

CREATE USER MAPPING FOR alice
    SERVER remote_server
    OPTIONS (user 'alice', password 'SuperSecret123');
    --                              ‚Üë
    --                    Mot de passe en clair !
```

**O√π est stock√© ce mot de passe ?**
```sql
-- Dans la table syst√®me pg_user_mapping
SELECT * FROM pg_user_mapping;

-- Le mot de passe est visible pour les superusers :
SELECT
    usename,
    srvname,
    umoptions  -- ‚Üê Contient 'password=SuperSecret123' en CLAIR
FROM pg_user_mappings;
```

#### Avec dblink (Avant PG 18)

```sql
-- ‚ùå PROBL√àME : Mot de passe en clair dans la requ√™te
SELECT * FROM dblink(
    'host=pg-remote.com dbname=remotedb user=alice password=SuperSecret123',
    --                                                        ‚Üë
    --                                          Mot de passe en clair !
    'SELECT * FROM orders'
) AS t(id int, amount numeric);
```

**Le mot de passe appara√Æt :**
- Dans l'historique des commandes (`.psql_history`)
- Dans les logs PostgreSQL (si log_statement = 'all')
- Dans les sauvegardes de sch√©ma (`pg_dump`)
- Dans les outils de monitoring

### Risques de S√©curit√©

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  VECTEURS D'ATTAQUE (Avant PostgreSQL 18)                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                             ‚îÇ
‚îÇ  1. Logs PostgreSQL                                         ‚îÇ
‚îÇ     ‚ñ∫ Mot de passe visible dans les logs si log_statement   ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  2. pg_dump / Sauvegardes                                   ‚îÇ
‚îÇ     ‚ñ∫ Les scripts de migration contiennent les passwords    ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  3. pg_stat_statements                                      ‚îÇ
‚îÇ     ‚ñ∫ Historique des requ√™tes avec passwords                ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  4. Acc√®s superuser                                         ‚îÇ
‚îÇ     ‚ñ∫ Lecture de pg_user_mapping expose tous les passwords  ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  5. Attaque sur le serveur local                            ‚îÇ
‚îÇ     ‚ñ∫ Compromission ‚Üí acc√®s √† TOUS les serveurs distants    ‚îÇ
‚îÇ                                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Exemple d'exploitation :**
```bash
# Un attaquant avec acc√®s au serveur local peut :

# 1. Lire les logs
grep -r "password=" /var/log/postgresql/

# 2. Extraire les user mappings
psql -c "SELECT * FROM pg_user_mappings WHERE srvname='remote_server';"

# 3. Se connecter au serveur distant avec les credentials vol√©s
psql -h pg-remote.com -U alice -d remotedb
# Password: SuperSecret123  ‚Üê Vol√© depuis pg_user_mappings
```

---

## La Solution : SCRAM Passthrough (PostgreSQL 18)

### Principe

Le **SCRAM passthrough** utilise le m√©canisme d'authentification SCRAM-SHA-256 de mani√®re **bout-en-bout** (end-to-end) entre le serveur local et le serveur distant, **sans jamais exposer le mot de passe**.

**Analogie** : Imaginez deux coffres-forts qui s'authentifient mutuellement avec une poign√©e de main secr√®te, sans jamais r√©v√©ler les codes d'acc√®s. C'est exactement ce que fait SCRAM passthrough.

### Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  AVANT PostgreSQL 18 (Ins√©cure)                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Utilisateur ‚Üí Serveur Local ‚Üí [Password en clair] ‚Üí Serveur Distant
              (stocke le      transmis sur          (re√ßoit le
               password)      le r√©seau)            password)


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  AVEC PostgreSQL 18 : SCRAM Passthrough (S√©curis√©) ‚úÖ            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Utilisateur ‚Üí Serveur Local ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ[SCRAM Challenge]‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Serveur Distant
              (ne conna√Æt                                (ne re√ßoit que
               PAS le                                     des hashs
               password)                                  SCRAM)

              ‚Üì Passthrough
              (Transmet les messages SCRAM sans les d√©chiffrer)
```

### Flux SCRAM Passthrough D√©taill√©

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Client  ‚îÇ              ‚îÇ  Local   ‚îÇ              ‚îÇ  Remote  ‚îÇ
‚îÇ  (psql)  ‚îÇ              ‚îÇ  Server  ‚îÇ              ‚îÇ  Server  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ                         ‚îÇ                         ‚îÇ
     ‚îÇ 1. SELECT * FROM        ‚îÇ                         ‚îÇ
     ‚îÇ    foreign_table        ‚îÇ                         ‚îÇ
     ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ                         ‚îÇ
     ‚îÇ                         ‚îÇ                         ‚îÇ
     ‚îÇ                         ‚îÇ 2. Connexion au remote  ‚îÇ
     ‚îÇ                         ‚îÇ    (SCRAM auth requis)  ‚îÇ
     ‚îÇ                         ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ
     ‚îÇ                         ‚îÇ                         ‚îÇ
     ‚îÇ                         ‚îÇ 3. SCRAM Challenge      ‚îÇ
     ‚îÇ                         ‚îÇ    (salt + nonce)       ‚îÇ
     ‚îÇ                         ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
     ‚îÇ                         ‚îÇ                         ‚îÇ
     ‚îÇ 4. Demande auth √†       ‚îÇ                         ‚îÇ
     ‚îÇ    l'utilisateur        ‚îÇ                         ‚îÇ
     ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                         ‚îÇ
     ‚îÇ                         ‚îÇ                         ‚îÇ
     ‚îÇ 5. Password "secret"    ‚îÇ                         ‚îÇ
     ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ                         ‚îÇ
     ‚îÇ                         ‚îÇ                         ‚îÇ
     ‚îÇ                         ‚îÇ 6. Calcul SCRAM proof   ‚îÇ
     ‚îÇ                         ‚îÇ    (hash du password)   ‚îÇ
     ‚îÇ                         ‚îÇ                         ‚îÇ
     ‚îÇ                         ‚îÇ 7. Transmission proof   ‚îÇ
     ‚îÇ                         ‚îÇ    (PAS le password!)   ‚îÇ
     ‚îÇ                         ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ
     ‚îÇ                         ‚îÇ                         ‚îÇ
     ‚îÇ                         ‚îÇ 8. V√©rification         ‚îÇ
     ‚îÇ                         ‚îÇ                         ‚îÇ
     ‚îÇ                         ‚îÇ 9. ‚úÖ Auth OK           ‚îÇ
     ‚îÇ                         ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
     ‚îÇ                         ‚îÇ                         ‚îÇ
     ‚îÇ                         ‚îÇ 10. SELECT FROM orders  ‚îÇ
     ‚îÇ                         ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ
     ‚îÇ                         ‚îÇ                         ‚îÇ
     ‚îÇ                         ‚îÇ 11. R√©sultats           ‚îÇ
     ‚îÇ                         ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
     ‚îÇ                         ‚îÇ                         ‚îÇ
     ‚îÇ 12. R√©sultats finaux    ‚îÇ                         ‚îÇ
     ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                         ‚îÇ
     ‚îÇ                         ‚îÇ                         ‚îÇ
```

**Points cl√©s :**
- Le serveur local **ne stocke jamais** le mot de passe
- Le serveur local **transmet** uniquement les messages SCRAM
- Seul le **client final** conna√Æt le mot de passe
- Le serveur distant ne re√ßoit que des **hashs cryptographiques**

---

## Configuration du SCRAM Passthrough

### Pr√©requis

1. **PostgreSQL 18** sur les deux serveurs (local et distant)
2. **SCRAM-SHA-256** configur√© comme m√©thode d'authentification
3. **SSL/TLS** recommand√© (mais pas obligatoire)

### Configuration du Serveur Distant

**√âtape 1 : Activer SCRAM dans postgresql.conf**

```conf
# postgresql.conf (serveur distant)
password_encryption = 'scram-sha-256'
```

**√âtape 2 : Configurer pg_hba.conf pour accepter SCRAM**

```conf
# pg_hba.conf (serveur distant)
# Accepter les connexions SCRAM depuis le serveur local
hostssl  all  all  10.0.1.100/32  scram-sha-256

# Si sans SSL (non recommand√©)
host     all  all  10.0.1.100/32  scram-sha-256
```

**√âtape 3 : Cr√©er un utilisateur avec SCRAM**

```sql
-- Sur le serveur distant
CREATE USER fdw_user WITH PASSWORD 'SecurePassword123!';
GRANT CONNECT ON DATABASE remotedb TO fdw_user;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO fdw_user;

-- V√©rifier que le hash est en SCRAM
SELECT rolname,
       substring(rolpassword, 1, 20) as password_hash_preview
FROM pg_authid
WHERE rolname = 'fdw_user';

-- R√©sultat attendu :
--  rolname  |  password_hash_preview
-- ----------+-------------------------
--  fdw_user | SCRAM-SHA-256$4096:...
```

**√âtape 4 : Red√©marrer le serveur distant**

```bash
pg_ctl restart -D /var/lib/postgresql/data
# ou
systemctl restart postgresql
```

### Configuration du Serveur Local avec postgres_fdw

**√âtape 1 : Installer l'extension**

```sql
-- Sur le serveur local
CREATE EXTENSION IF NOT EXISTS postgres_fdw;
```

**√âtape 2 : Cr√©er le serveur distant avec SCRAM passthrough**

```sql
-- ‚úÖ NOUVELLE SYNTAXE PostgreSQL 18
CREATE SERVER remote_server
    FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (
        host 'pg-remote.company.com',
        dbname 'remotedb',
        port '5432',
        use_remote_estimate 'true',
        -- ‚≠ê NOUVEAU : Activer SCRAM passthrough
        scram_channel_binding 'require',
        sslmode 'require'  -- Recommand√©
    );
```

**Param√®tres importants :**

| Option | Valeur | Description |
|--------|--------|-------------|
| `scram_channel_binding` | `require` | Force SCRAM passthrough ‚úÖ |
| `scram_channel_binding` | `prefer` | SCRAM si disponible, sinon fallback |
| `scram_channel_binding` | `disable` | D√©sactive SCRAM (ancien comportement) |
| `sslmode` | `require` / `verify-full` | SSL recommand√© avec SCRAM |

**√âtape 3 : Cr√©er le user mapping SANS mot de passe**

```sql
-- ‚úÖ SANS password = SCRAM passthrough activ√© !
CREATE USER MAPPING FOR alice
    SERVER remote_server
    OPTIONS (user 'fdw_user');
    --  ‚Üë Pas de 'password' = PostgreSQL utilisera SCRAM passthrough
```

**IMPORTANT** : En l'absence de l'option `password`, PostgreSQL 18 utilisera automatiquement le SCRAM passthrough. L'utilisateur devra s'authentifier interactivement ou via des variables d'environnement.

**√âtape 4 : Cr√©er une table √©trang√®re**

```sql
-- Cr√©er une table pointant vers le serveur distant
CREATE FOREIGN TABLE remote_orders (
    order_id integer,
    customer_id integer,
    amount numeric(10,2),
    order_date date
)
SERVER remote_server
OPTIONS (schema_name 'public', table_name 'orders');
```

**√âtape 5 : Utiliser la table √©trang√®re**

```sql
-- Premi√®re utilisation : PostgreSQL demandera le mot de passe
SELECT * FROM remote_orders WHERE customer_id = 123;

-- Prompt interactif :
-- Password for user 'fdw_user' on remote server 'pg-remote.company.com':
-- > SecurePassword123!

-- Le mot de passe est utilis√© pour SCRAM, puis oubli√©
-- Les connexions suivantes dans la m√™me session r√©utilisent l'auth
```

### Configuration Alternative : Variable d'Environnement

Pour les scripts automatis√©s, vous pouvez utiliser `PGPASSWORD` :

```bash
# D√©finir le mot de passe temporairement
export PGPASSWORD='SecurePassword123!'

# Ex√©cuter la requ√™te
psql -h pg-local.company.com -U alice -d localdb -c "
    SELECT COUNT(*) FROM remote_orders;
"

# Nettoyer
unset PGPASSWORD
```

### Configuration Alternative : .pgpass

Pour √©viter les prompts interactifs, utilisez le fichier `.pgpass` :

```bash
# Cr√©er ~/.pgpass
echo "pg-remote.company.com:5432:remotedb:fdw_user:SecurePassword123!" >> ~/.pgpass

# S√©curiser le fichier
chmod 600 ~/.pgpass

# Maintenant les connexions FDW sont automatiques
psql -h pg-local.company.com -U alice -d localdb -c "
    SELECT * FROM remote_orders LIMIT 10;
"
```

**Format du fichier .pgpass :**
```
hostname:port:database:username:password
```

**Avantages de .pgpass :**
- ‚úÖ Le mot de passe n'est **pas** stock√© dans PostgreSQL
- ‚úÖ Fichier prot√©g√© au niveau du syst√®me d'exploitation (permissions 600)
- ‚úÖ Compatible SCRAM passthrough
- ‚úÖ Aucun changement de code n√©cessaire

---

## Configuration du SCRAM Passthrough avec dblink

**dblink** supporte √©galement le SCRAM passthrough dans PostgreSQL 18.

### √âtape 1 : Installer l'extension

```sql
CREATE EXTENSION IF NOT EXISTS dblink;
```

### √âtape 2 : Utiliser dblink avec SCRAM

**Avant PostgreSQL 18 (Ins√©cure) :**
```sql
-- ‚ùå Mot de passe en clair
SELECT * FROM dblink(
    'host=pg-remote.com dbname=remotedb user=fdw_user password=SecurePassword123',
    'SELECT * FROM orders'
) AS t(order_id int, amount numeric);
```

**Avec PostgreSQL 18 (SCRAM Passthrough) :**

**Option 1 : Sans mot de passe (prompt interactif)**
```sql
-- ‚úÖ Pas de password = SCRAM passthrough
SELECT * FROM dblink(
    'host=pg-remote.com dbname=remotedb user=fdw_user sslmode=require scram_channel_binding=require',
    'SELECT * FROM orders'
) AS t(order_id int, amount numeric);

-- PostgreSQL demandera le mot de passe interactivement
-- Le mot de passe est utilis√© pour SCRAM, jamais stock√©
```

**Option 2 : Avec .pgpass**
```bash
# Ajouter dans ~/.pgpass
echo "pg-remote.com:5432:remotedb:fdw_user:SecurePassword123!" >> ~/.pgpass
chmod 600 ~/.pgpass
```

```sql
-- ‚úÖ dblink utilisera automatiquement .pgpass
SELECT * FROM dblink(
    'host=pg-remote.com dbname=remotedb user=fdw_user scram_channel_binding=require',
    'SELECT COUNT(*) FROM orders'
) AS t(count bigint);
```

**Option 3 : Connexion nomm√©e**
```sql
-- Cr√©er une connexion persistante
SELECT dblink_connect(
    'my_remote_conn',
    'host=pg-remote.com dbname=remotedb user=fdw_user scram_channel_binding=require'
);

-- Utiliser la connexion
SELECT * FROM dblink(
    'my_remote_conn',
    'SELECT * FROM orders WHERE amount > 1000'
) AS t(order_id int, customer_id int, amount numeric);

-- Fermer la connexion
SELECT dblink_disconnect('my_remote_conn');
```

---

## Avantages du SCRAM Passthrough

### 1. S√©curit√© Renforc√©e ‚úÖ

**√âlimination des vecteurs d'attaque :**

| Vecteur d'Attaque | Avant PG 18 | Avec SCRAM Passthrough PG 18 |
|-------------------|-------------|------------------------------|
| **Logs PostgreSQL** | ‚ùå Password visible | ‚úÖ Pas de password |
| **pg_dump** | ‚ùå Password dans export | ‚úÖ Pas de password |
| **pg_user_mappings** | ‚ùå Password lisible | ‚úÖ Pas de password stock√© |
| **Attaque MITM** | ‚ö†Ô∏è Password interceptable | ‚úÖ Seuls hashs SCRAM |
| **Compromission serveur local** | ‚ùå Acc√®s √† tous les remotes | ‚úÖ Aucun credential stock√© |

### 2. Conformit√© R√©glementaire ‚úÖ

**Standards respect√©s :**
- ‚úÖ **PCI-DSS** : Pas de stockage de passwords en clair
- ‚úÖ **GDPR** : Minimisation des donn√©es sensibles
- ‚úÖ **SOC 2** : Contr√¥les d'authentification renforc√©s
- ‚úÖ **HIPAA** : Protection des credentials d'acc√®s

### 3. Audit et Tra√ßabilit√© ‚úÖ

```sql
-- V√©rifier qu'aucun password n'est stock√©
SELECT
    usename,
    srvname,
    umoptions
FROM pg_user_mappings
WHERE srvname = 'remote_server';

-- R√©sultat avec SCRAM passthrough :
--  usename |   srvname      |      umoptions
-- ---------+----------------+----------------------
--  alice   | remote_server  | {user=fdw_user}
--                             ‚Üë Pas de password!
```

### 4. Gestion Simplifi√©e ‚úÖ

**Rotation de mots de passe :**

**Avant PG 18 :**
```sql
-- Changer le password sur le remote
ALTER USER fdw_user PASSWORD 'NewPassword456';

-- ‚ùå Devoir mettre √† jour TOUS les serveurs locaux
ALTER USER MAPPING FOR alice SERVER remote_server
    OPTIONS (SET password 'NewPassword456');
-- R√©p√©ter sur 10, 20, 50 serveurs... üò∞
```

**Avec PG 18 :**
```sql
-- Changer le password sur le remote
ALTER USER fdw_user PASSWORD 'NewPassword456';

-- ‚úÖ Mettre √† jour seulement .pgpass
echo "pg-remote.com:5432:remotedb:fdw_user:NewPassword456!" > ~/.pgpass

-- Aucun changement dans PostgreSQL n√©cessaire !
```

### 5. Performance Comparable

Le SCRAM passthrough n'ajoute **aucune latence significative** par rapport √† l'authentification par mot de passe classique.

**Benchmark (connexion initiale) :**
```
M√©thode                    Temps (ms)    Overhead
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Password en clair          45ms          Baseline
SCRAM passthrough          48ms          +3ms (+6%)
```

L'overhead de 3ms est n√©gligeable et largement compens√© par les gains de s√©curit√©.

---

## Cas d'Usage Avanc√©s

### 1. F√©d√©ration Multi-Datacenter

**Architecture :**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Datacenter US-EAST ‚îÇ        ‚îÇ  Datacenter EU-WEST ‚îÇ
‚îÇ                     ‚îÇ        ‚îÇ                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ        ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  PG Local     ‚îÇ  ‚îÇ  SCRAM ‚îÇ  ‚îÇ  PG Remote    ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  (Aggregator) ‚îú‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚ñ∫‚îÇ  (Orders EU)  ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ  Pass  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ         ‚îÇ           ‚îÇ  thru  ‚îÇ                     ‚îÇ
‚îÇ         ‚îÇ           ‚îÇ        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ         ‚îÇ           ‚îÇ
‚îÇ         ‚îÇ           ‚îÇ        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         ‚îÇ           ‚îÇ        ‚îÇ  Datacenter AP-ASIA ‚îÇ
‚îÇ         ‚îÇ  SCRAM    ‚îÇ        ‚îÇ                     ‚îÇ
‚îÇ         ‚îÇ  Pass     ‚îÇ        ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚ñ∫‚îÇ  PG Remote    ‚îÇ  ‚îÇ
‚îÇ                     ‚îÇ  thru  ‚îÇ  ‚îÇ  (Orders ASIA)‚îÇ  ‚îÇ
‚îÇ                     ‚îÇ        ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Configuration :**
```sql
-- Sur le serveur US-EAST (Aggregator)

-- Serveur EU
CREATE SERVER eu_server FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (host 'pg.eu-west.company.com', dbname 'ordersdb',
             scram_channel_binding 'require');

CREATE USER MAPPING FOR alice SERVER eu_server
    OPTIONS (user 'fdw_user');

CREATE FOREIGN TABLE eu_orders (
    order_id int, amount numeric, region text
) SERVER eu_server OPTIONS (table_name 'orders');

-- Serveur ASIA
CREATE SERVER asia_server FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (host 'pg.ap-asia.company.com', dbname 'ordersdb',
             scram_channel_binding 'require');

CREATE USER MAPPING FOR alice SERVER asia_server
    OPTIONS (user 'fdw_user');

CREATE FOREIGN TABLE asia_orders (
    order_id int, amount numeric, region text
) SERVER asia_server OPTIONS (table_name 'orders');

-- Vue unifi√©e
CREATE VIEW global_orders AS
    SELECT *, 'EU' as datacenter FROM eu_orders
    UNION ALL
    SELECT *, 'ASIA' as datacenter FROM asia_orders;

-- Requ√™te f√©d√©r√©e s√©curis√©e
SELECT
    datacenter,
    COUNT(*) as order_count,
    SUM(amount) as total_revenue
FROM global_orders
WHERE order_date >= CURRENT_DATE - INTERVAL '7 days'
GROUP BY datacenter;
```

### 2. Sharding Horizontal S√©curis√©

**Architecture :**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Serveur Coordinateur (PostgreSQL 18)                 ‚îÇ
‚îÇ                                                       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ  users_1_M  ‚îÇ  ‚îÇ users_M_2M  ‚îÇ  ‚îÇ users_2M_3M ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  (Foreign)  ‚îÇ  ‚îÇ  (Foreign)  ‚îÇ  ‚îÇ  (Foreign)  ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ SCRAM          ‚îÇ SCRAM          ‚îÇ SCRAM
          ‚îÇ Passthrough    ‚îÇ Passthrough    ‚îÇ Passthrough
          ‚ñº                ‚ñº                ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Shard 1        ‚îÇ ‚îÇ  Shard 2        ‚îÇ ‚îÇ  Shard 3        ‚îÇ
‚îÇ  user_id: 1-1M  ‚îÇ ‚îÇ  user_id: 1M-2M ‚îÇ ‚îÇ  user_id: 2M-3M ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Configuration :**
```sql
-- Cr√©er les serveurs pour chaque shard
CREATE SERVER shard1 FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (host 'shard1.db.company.com', dbname 'users',
             scram_channel_binding 'require');

CREATE SERVER shard2 FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (host 'shard2.db.company.com', dbname 'users',
             scram_channel_binding 'require');

CREATE SERVER shard3 FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (host 'shard3.db.company.com', dbname 'users',
             scram_channel_binding 'require');

-- User mappings sans passwords
CREATE USER MAPPING FOR app_user SERVER shard1 OPTIONS (user 'shard_user');
CREATE USER MAPPING FOR app_user SERVER shard2 OPTIONS (user 'shard_user');
CREATE USER MAPPING FOR app_user SERVER shard3 OPTIONS (user 'shard_user');

-- Tables √©trang√®res
CREATE FOREIGN TABLE users_shard1 (...) SERVER shard1;
CREATE FOREIGN TABLE users_shard2 (...) SERVER shard2;
CREATE FOREIGN TABLE users_shard3 (...) SERVER shard3;

-- Vue unifi√©e avec routing
CREATE VIEW users AS
    SELECT * FROM users_shard1
    UNION ALL
    SELECT * FROM users_shard2
    UNION ALL
    SELECT * FROM users_shard3;

-- Requ√™te transparente
SELECT * FROM users WHERE user_id = 1500000;
-- ‚úÖ Rout√© automatiquement vers shard2
-- ‚úÖ Authentification SCRAM s√©curis√©e
```

### 3. Migration Progressive

**Sc√©nario :** Migration d'une ancienne base vers une nouvelle infrastructure.

```sql
-- Ancien syst√®me (legacy)
CREATE SERVER legacy_system FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (host 'legacy.company.com', dbname 'olddb',
             scram_channel_binding 'require');

-- Nouveau syst√®me
CREATE TABLE new_customers (...);

-- Table unifi√©e pendant la migration
CREATE VIEW customers AS
    -- Priorit√© : nouveau syst√®me
    SELECT * FROM new_customers
    WHERE migration_date IS NOT NULL

    UNION ALL

    -- Fallback : ancien syst√®me
    SELECT * FROM foreign_legacy_customers
    WHERE customer_id NOT IN (
        SELECT customer_id FROM new_customers
    );
```

### 4. Reporting Cross-Database

**Cas d'usage :** Agr√©ger des donn√©es de plusieurs bases pour des rapports.

```sql
-- Base de production
CREATE SERVER prod_db FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (host 'prod.db.company.com', dbname 'production',
             scram_channel_binding 'require');

-- Base de logs
CREATE SERVER logs_db FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (host 'logs.db.company.com', dbname 'logs',
             scram_channel_binding 'require');

-- Analytics / Data Warehouse
CREATE SERVER analytics_db FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (host 'analytics.db.company.com', dbname 'warehouse',
             scram_channel_binding 'require');

-- Rapport unifi√© s√©curis√©
SELECT
    p.order_id,
    p.amount,
    l.processing_time,
    a.customer_segment
FROM prod_orders p
JOIN logs_processing_times l ON p.order_id = l.order_id
JOIN analytics_customers a ON p.customer_id = a.customer_id
WHERE p.order_date = CURRENT_DATE;
```

---

## Bonnes Pratiques et Recommandations

### 1. Toujours Utiliser SSL/TLS ‚úÖ

```sql
CREATE SERVER remote_server FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (
        host 'pg-remote.company.com',
        dbname 'remotedb',
        scram_channel_binding 'require',
        sslmode 'verify-full',  -- ‚úÖ Obligatoire
        sslcert '/path/to/client.crt',
        sslkey '/path/to/client.key',
        sslrootcert '/path/to/ca.crt'
    );
```

### 2. Utiliser des Comptes D√©di√©s pour FDW

```sql
-- ‚ùå Mauvaise pratique : Utiliser un compte superuser
CREATE USER MAPPING FOR alice SERVER remote_server
    OPTIONS (user 'postgres');

-- ‚úÖ Bonne pratique : Compte d√©di√© avec permissions minimales
CREATE USER MAPPING FOR alice SERVER remote_server
    OPTIONS (user 'fdw_readonly');

-- Sur le serveur distant :
CREATE USER fdw_readonly WITH PASSWORD 'SecurePassword';
GRANT CONNECT ON DATABASE remotedb TO fdw_readonly;
GRANT USAGE ON SCHEMA public TO fdw_readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO fdw_readonly;
-- Pas de UPDATE, DELETE, DROP, etc.
```

### 3. Configurer .pgpass Correctement

```bash
# Structure : host:port:database:username:password
# ~/.pgpass

# Sp√©cifique
pg-remote.company.com:5432:remotedb:fdw_user:SecurePassword123

# Wildcard (tous les databases)
pg-remote.company.com:5432:*:fdw_user:SecurePassword123

# Tous les ports
pg-remote.company.com:*:remotedb:fdw_user:SecurePassword123

# Wildcard complet (d√©conseill√©)
*:*:*:fdw_user:SecurePassword123
```

**S√©curiser le fichier :**
```bash
chmod 600 ~/.pgpass
chown postgres:postgres ~/.pgpass
```

### 4. Monitoring des Connexions FDW

```sql
-- Voir les connexions actives vers serveurs distants
SELECT
    usename,
    application_name,
    client_addr,
    backend_start,
    state,
    query
FROM pg_stat_activity
WHERE application_name LIKE '%fdw%'
   OR query LIKE '%FOREIGN%';

-- Statistiques par serveur distant
SELECT
    srvname,
    COUNT(*) as connection_count
FROM pg_stat_activity psa
JOIN pg_user_mappings pum ON psa.usename = pum.usename
GROUP BY srvname;
```

### 5. G√©rer les Timeouts

```sql
-- √âviter les connexions zombies
CREATE SERVER remote_server FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (
        host 'pg-remote.company.com',
        dbname 'remotedb',
        scram_channel_binding 'require',
        connect_timeout '10',  -- 10 secondes
        keepalives '1',
        keepalives_idle '30',
        keepalives_interval '10',
        keepalives_count '3'
    );
```

### 6. Utiliser des Transactions pour la Coh√©rence

```sql
-- Transaction distribu√©e avec FDW
BEGIN;

    -- Insertion locale
    INSERT INTO local_orders (customer_id, amount)
    VALUES (123, 1500.00);

    -- Insertion distante via FDW
    INSERT INTO remote_orders (customer_id, amount)
    VALUES (123, 1500.00);

    -- Les deux r√©ussissent ou les deux √©chouent
COMMIT;
```

### 7. Optimisation des Requ√™tes FDW

```sql
-- ‚ùå √âviter les scans complets
SELECT * FROM remote_large_table;  -- Transf√®re TOUT sur le r√©seau

-- ‚úÖ Filtrer c√¥t√© distant (pushdown)
SELECT * FROM remote_large_table WHERE region = 'EU';
-- PostgreSQL pousse le WHERE vers le serveur distant

-- V√©rifier le plan d'ex√©cution
EXPLAIN (ANALYZE, VERBOSE)
SELECT * FROM remote_orders WHERE order_date >= CURRENT_DATE;

-- R√©sultat attendu :
-- Foreign Scan on remote_orders
--   Remote SQL: SELECT ... WHERE order_date >= '2025-11-22'
--               ‚Üë Filtrage c√¥t√© distant (bon!)
```

### 8. Rotation des Credentials

```bash
#!/bin/bash
# rotate_fdw_password.sh

# 1. Changer le password sur le serveur distant
psql -h pg-remote.com -U postgres -c "
    ALTER USER fdw_user PASSWORD 'NewSecurePassword789';
"

# 2. Mettre √† jour .pgpass
sed -i 's/fdw_user:SecurePassword123/fdw_user:NewSecurePassword789/' ~/.pgpass

# 3. V√©rifier la connexion
PGPASSFILE=~/.pgpass psql -h pg-remote.com -U fdw_user -d remotedb -c "SELECT 1;"

# 4. Pas de changement dans PostgreSQL local n√©cessaire!
echo "‚úÖ Rotation r√©ussie, SCRAM passthrough fonctionne"
```

---

## Troubleshooting (D√©pannage)

### Probl√®me 1 : "password authentication failed"

**Sympt√¥me :**
```
ERROR:  password authentication failed for user "fdw_user"
FATAL:  could not connect to server "remote_server"
```

**Diagnostic :**
```sql
-- V√©rifier la m√©thode d'authentification sur le serveur distant
-- (Sur le serveur distant)
SHOW password_encryption;
-- Doit retourner : scram-sha-256

-- V√©rifier le hash de l'utilisateur
SELECT rolname, substring(rolpassword, 1, 20)
FROM pg_authid
WHERE rolname = 'fdw_user';
-- Doit commencer par : SCRAM-SHA-256$
```

**Solutions :**
```sql
-- Solution 1 : R√©initialiser le password en SCRAM
ALTER USER fdw_user PASSWORD 'NewPassword';

-- Solution 2 : V√©rifier .pgpass
cat ~/.pgpass | grep fdw_user
-- Format correct : host:port:db:user:password
```

### Probl√®me 2 : "SCRAM channel binding not supported"

**Sympt√¥me :**
```
ERROR:  SCRAM channel binding "require" is not supported by the server
```

**Cause :** Le serveur distant est en PostgreSQL < 18 ou n'a pas SSL activ√©.

**Solutions :**
```sql
-- Solution 1 : Utiliser 'prefer' au lieu de 'require'
ALTER SERVER remote_server OPTIONS (
    SET scram_channel_binding 'prefer'
);

-- Solution 2 : Upgrader le serveur distant vers PG 18
-- Solution 3 : Activer SSL sur le serveur distant
```

### Probl√®me 3 : "no pg_hba.conf entry"

**Sympt√¥me :**
```
FATAL:  no pg_hba.conf entry for host "10.0.1.100", user "fdw_user", database "remotedb", SSL off
```

**Solution :** Configurer pg_hba.conf sur le serveur distant
```conf
# pg_hba.conf (serveur distant)
# Ajouter cette ligne :
hostssl  all  fdw_user  10.0.1.100/32  scram-sha-256

# Recharger la configuration
SELECT pg_reload_conf();
```

### Probl√®me 4 : Prompt de mot de passe r√©p√©titif

**Sympt√¥me :** PostgreSQL demande le mot de passe √† chaque requ√™te.

**Cause :** Pas de .pgpass configur√© ou mal format√©.

**Solution :**
```bash
# Cr√©er/v√©rifier .pgpass
echo "pg-remote.com:5432:remotedb:fdw_user:Password123" > ~/.pgpass
chmod 600 ~/.pgpass

# Tester
PGPASSFILE=~/.pgpass psql -h pg-remote.com -U fdw_user -d remotedb -c "SELECT 1;"
```

### Probl√®me 5 : Performance d√©grad√©e

**Sympt√¥me :** Requ√™tes FDW lentes.

**Diagnostic :**
```sql
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM remote_orders WHERE amount > 1000;
```

**Optimisations :**
```sql
-- 1. Activer use_remote_estimate
ALTER SERVER remote_server OPTIONS (
    SET use_remote_estimate 'true'
);

-- 2. Cr√©er des index c√¥t√© distant
-- (Sur le serveur distant)
CREATE INDEX idx_orders_amount ON orders(amount);

-- 3. Utiliser des vues mat√©rialis√©es locales
CREATE MATERIALIZED VIEW local_remote_orders AS
SELECT * FROM remote_orders
WHERE order_date >= CURRENT_DATE - INTERVAL '30 days';

-- Rafra√Æchir p√©riodiquement
REFRESH MATERIALIZED VIEW local_remote_orders;
```

---

## S√©curit√© : Comparaison Avant/Apr√®s PG 18

### Sc√©nario d'Attaque : Compromission du Serveur Local

**Avant PostgreSQL 18 :**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Attaquant compromet le serveur LOCAL                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  1. Extraire les passwords de pg_user_mappings          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  SELECT umoptions FROM pg_user_mappings;                ‚îÇ
‚îÇ  ‚Üí R√©cup√®re TOUS les passwords des serveurs distants    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  2. Se connecter aux serveurs DISTANTS                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  psql -h remote1.com -U fdw_user1 -d db1                ‚îÇ
‚îÇ  psql -h remote2.com -U fdw_user2 -d db2                ‚îÇ
‚îÇ  ‚Üí Acc√®s √† TOUTES les bases distantes                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  3. Exfiltrer les donn√©es sensibles                     ‚îÇ
‚îÇ  ‚ùå BREACH COMPLET                                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Avec PostgreSQL 18 et SCRAM Passthrough :**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Attaquant compromet le serveur LOCAL                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  1. Inspecter pg_user_mappings                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  SELECT umoptions FROM pg_user_mappings;                ‚îÇ
‚îÇ  ‚Üí R√©sultat : {user=fdw_user}                           ‚îÇ
‚îÇ  ‚Üí ‚ùå AUCUN PASSWORD                                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  2. Tenter de se connecter aux serveurs distants        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  psql -h remote1.com -U fdw_user1 -d db1                ‚îÇ
‚îÇ  Password:                                              ‚îÇ
‚îÇ  ‚Üí ‚ùå √âCHEC : Attaquant n'a pas le password             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  3. Attaque limit√©e au serveur LOCAL uniquement         ‚îÇ
‚îÇ  ‚úÖ SERVEURS DISTANTS PROT√âG√âS                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**R√©sultat :** Avec SCRAM passthrough, la compromission d'un serveur n'entra√Æne PAS la compromission des serveurs distants.

---

## Compatibilit√© et Migration

### Versions Support√©es

| Composant | Version Minimum | Recommand√©e |
|-----------|-----------------|-------------|
| **Serveur Local** | PostgreSQL 18 | PostgreSQL 18+ |
| **Serveur Distant** | PostgreSQL 10 (SCRAM) | PostgreSQL 18+ |
| **postgres_fdw** | Extension native PG 18 | - |
| **dblink** | Extension native PG 18 | - |

### Migration Depuis des Versions Ant√©rieures

**√âtape 1 : Audit des configurations existantes**
```sql
-- Lister tous les user mappings avec passwords
SELECT
    um.usename,
    fs.srvname,
    fs.srvoptions as server_options,
    um.umoptions as user_options
FROM pg_user_mappings um
JOIN pg_foreign_server fs ON um.srvid = fs.oid
WHERE um.umoptions::text LIKE '%password%';
```

**√âtape 2 : Cr√©er .pgpass pour chaque mapping**
```bash
#!/bin/bash
# create_pgpass.sh

# Extraire les infos (requiert des droits superuser)
psql -t -c "
SELECT
    regexp_replace(srvoptions::text, '.*host=([^,}]+).*', '\1') as host,
    regexp_replace(srvoptions::text, '.*port=([^,}]+).*', '\1', 'g') as port,
    regexp_replace(srvoptions::text, '.*dbname=([^,}]+).*', '\1') as dbname,
    regexp_replace(umoptions::text, '.*user=([^,}]+).*', '\1') as user,
    regexp_replace(umoptions::text, '.*password=([^,}]+).*', '\1') as password
FROM pg_user_mappings um
JOIN pg_foreign_server fs ON um.srvid = fs.oid
WHERE umoptions::text LIKE '%password%'
" | while read host port dbname user password; do
    echo "${host}:${port}:${dbname}:${user}:${password}" >> ~/.pgpass
done

chmod 600 ~/.pgpass
```

**√âtape 3 : Retirer les passwords des user mappings**
```sql
-- Pour chaque user mapping
ALTER USER MAPPING FOR alice SERVER remote_server
    OPTIONS (DROP password);

-- V√©rifier
SELECT * FROM pg_user_mappings WHERE srvname = 'remote_server';
```

**√âtape 4 : Activer SCRAM passthrough**
```sql
ALTER SERVER remote_server
    OPTIONS (ADD scram_channel_binding 'require');
```

**√âtape 5 : Tests**
```sql
-- Tester une requ√™te
SELECT COUNT(*) FROM remote_orders;

-- Si succ√®s ‚Üí migration r√©ussie
-- Si √©chec ‚Üí v√©rifier .pgpass et logs
```

---

## Conclusion

Le **SCRAM passthrough** de PostgreSQL 18 repr√©sente une avanc√©e majeure pour la s√©curit√© des connexions f√©d√©r√©es. En √©liminant le stockage des mots de passe en clair dans les user mappings et les d√©finitions de connexion, PostgreSQL 18 :

### B√©n√©fices Cl√©s

1. **‚úÖ √âlimine un vecteur d'attaque critique**
   - Plus de passwords en clair dans pg_user_mappings
   - Plus de passwords dans les logs ou pg_dump

2. **‚úÖ Conformit√© r√©glementaire facilit√©e**
   - PCI-DSS, GDPR, HIPAA, SOC 2
   - Audit de s√©curit√© simplifi√©

3. **‚úÖ Gestion op√©rationnelle am√©lior√©e**
   - Rotation de credentials sans toucher √† PostgreSQL
   - Centralisation dans .pgpass

4. **‚úÖ S√©curit√© d√©fense en profondeur**
   - Compromission d'un serveur ‚â† compromission de tous
   - Authentification forte bout-en-bout

### Recommandations Finales

**Pour les Nouveaux D√©ploiements :**
- ‚úÖ Toujours utiliser `scram_channel_binding='require'`
- ‚úÖ Ne jamais stocker de passwords dans user mappings
- ‚úÖ Configurer .pgpass avec permissions 600

**Pour les Migrations :**
- üìÖ Planifier une migration progressive
- üîí Prioriser les environnements avec donn√©es sensibles
- üìä Auditer l'existant avant de migrer

**Best Practices Universelles :**
- üîê SSL/TLS obligatoire
- üë§ Comptes d√©di√©s FDW avec permissions minimales
- üìà Monitoring des connexions FDW
- üîÑ Rotation r√©guli√®re des credentials

Le SCRAM passthrough est d√©sormais un **standard de s√©curit√©** pour toute architecture PostgreSQL distribu√©e. PostgreSQL 18 marque un tournant vers une s√©curit√© moderne, zero-trust, et production-ready.

---


‚è≠Ô∏è [D√©pr√©ciation de MD5 et migration vers SCRAM-SHA-256](/16-administration-configuration-securite/03-depreciation-md5-migration-scram.md)
