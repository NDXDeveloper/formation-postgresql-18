üîù Retour au [Sommaire](/SOMMAIRE.md)

# 16.2.1. M√©thodes d'Authentification PostgreSQL

## Introduction

L'authentification est le processus par lequel PostgreSQL v√©rifie l'identit√© d'un utilisateur qui tente de se connecter √† la base de donn√©es. C'est une √©tape cruciale de la s√©curit√© qui pr√©c√®de l'autorisation (ce que l'utilisateur peut faire une fois connect√©).

PostgreSQL offre plusieurs m√©thodes d'authentification, chacune adapt√©e √† des contextes et des niveaux de s√©curit√© diff√©rents. Ces m√©thodes sont configur√©es dans le fichier `pg_hba.conf` (Host-Based Authentication).

> **Note pour d√©butants** : Le fichier `pg_hba.conf` est le "gardien" de votre base de donn√©es. Chaque ligne d√©finit une r√®gle qui dit : "Pour tel type de connexion, depuis telle origine, vers telle base, par tel utilisateur, utilise telle m√©thode d'authentification."

---

## Vue d'ensemble des m√©thodes

| M√©thode | S√©curit√© | Complexit√© | Usage typique |
|---------|----------|------------|---------------|
| **trust** | ‚ö†Ô∏è Aucune | Tr√®s simple | D√©veloppement local uniquement |
| **password** | ‚ö†Ô∏è Faible | Simple | **Obsol√®te - Ne pas utiliser** |
| **md5** | ‚ö†Ô∏è Moyenne | Simple | **D√©pr√©ci√© depuis PG 14** |
| **scram-sha-256** | ‚úÖ Forte | Simple | **Standard recommand√©** |
| **cert** | ‚úÖ Tr√®s forte | Complexe | Environnements haute s√©curit√© |
| **ldap** | ‚úÖ Forte | Complexe | Int√©gration entreprise (Active Directory) |

---

## 1. La m√©thode `trust` : Confiance Aveugle

### Concept

La m√©thode `trust` est la plus permissive : **elle n'effectue aucune v√©rification**. Si la connexion correspond aux crit√®res (adresse IP, base de donn√©es, utilisateur), PostgreSQL accorde l'acc√®s imm√©diatement, sans demander de mot de passe.

### Fonctionnement

```
# Exemple dans pg_hba.conf
# TYPE  DATABASE    USER        ADDRESS         METHOD
local   all         all                         trust
host    all         all         127.0.0.1/32    trust
```

Avec cette configuration :
1. L'utilisateur se connecte depuis localhost
2. PostgreSQL v√©rifie que la connexion vient bien de localhost
3. **Aucun mot de passe n'est demand√©**
4. Connexion accord√©e imm√©diatement

### Quand l'utiliser ?

**‚úÖ Cas d'usage l√©gitimes :**
- D√©veloppement local sur votre machine personnelle
- Tests rapides en environnement isol√© (Docker, VM sans r√©seau)
- Scripts administratifs locaux sur un serveur s√©curis√©

**‚ùå Ne JAMAIS utiliser :**
- En production
- Sur un r√©seau accessible depuis Internet
- Sur des serveurs partag√©s
- Pour des bases contenant des donn√©es sensibles

### Exemple pratique

```bash
# Connexion sans mot de passe avec trust
psql -U postgres -d mydb
# ‚úÖ Connexion imm√©diate, aucun mot de passe demand√©
```

### Risques

- **S√©curit√© nulle** : Toute personne ayant acc√®s au syst√®me peut se connecter
- **Usurpation d'identit√© facile** : Un attaquant peut se faire passer pour n'importe quel utilisateur
- **Audit impossible** : Difficile de tracer qui fait quoi r√©ellement

> **üí° Astuce de s√©curit√©** : Si vous utilisez `trust`, limitez-la √† `local` (connexions Unix socket) sur des syst√®mes o√π seuls des utilisateurs de confiance ont acc√®s.

---

## 2. La m√©thode `password` : Mot de Passe en Clair

### Concept

La m√©thode `password` demande un mot de passe, mais le transmet **en clair** (non chiffr√©) sur le r√©seau entre le client et le serveur.

### Fonctionnement

```
# Exemple dans pg_hba.conf
host    all         all         192.168.1.0/24    password
```

1. Le client se connecte
2. PostgreSQL demande le mot de passe
3. Le client envoie le mot de passe **en texte clair** sur le r√©seau
4. PostgreSQL compare avec le hash stock√©
5. Connexion accord√©e ou refus√©e

### Pourquoi est-elle obsol√®te ?

**üö® Probl√®me majeur : Sniffing r√©seau**

Imaginez que le mot de passe est une lettre envoy√©e par la poste dans une enveloppe transparente. N'importe qui interceptant la lettre (le trafic r√©seau) peut lire le mot de passe.

```
# Ce qui transite sur le r√©seau :
Username: alice
Password: SuperSecret123  ‚Üê üëÅÔ∏è Visible en clair !
```

### Statut actuel

- **Obsol√®te** depuis plusieurs ann√©es
- Remplac√©e par `md5` (elle-m√™me d√©pr√©ci√©e) puis `scram-sha-256`
- Maintenue uniquement pour compatibilit√© avec d'anciens syst√®mes

### ‚ùå Ne l'utilisez jamais

Il n'existe **aucun cas d'usage l√©gitime** pour `password` dans un syst√®me moderne. Utilisez au minimum `scram-sha-256`.

---

## 3. La m√©thode `md5` : Le Hachage (D√©pr√©ci√©)

### Concept

La m√©thode `md5` repr√©sente une am√©lioration par rapport √† `password` : le mot de passe est hach√© avant d'√™tre transmis sur le r√©seau, rendant l'interception moins dangereuse.

### Fonctionnement

```
# Exemple dans pg_hba.conf
host    all         all         192.168.1.0/24    md5
```

**Processus :**

1. Le serveur envoie un "salt" (grain de sel al√©atoire) au client
2. Le client calcule : `MD5(MD5(password + username) + salt)`
3. Le client envoie ce hash au serveur
4. Le serveur effectue le m√™me calcul et compare
5. Si les hashs correspondent, connexion accord√©e

### Analogie pour d√©butants

Imaginez que votre mot de passe est transform√© en un puzzle unique. Au lieu d'envoyer le mot de passe, vous envoyez l'image du puzzle. M√™me si quelqu'un intercepte l'image, il ne peut pas facilement retrouver le mot de passe original.

### Pourquoi est-elle d√©pr√©ci√©e ?

**Faiblesses de MD5 :**

1. **Algorithme obsol√®te** : MD5 est cass√© cryptographiquement depuis les ann√©es 2000
2. **Vuln√©rable aux attaques par dictionnaire** : Avec des bases de hashs pr√©calcul√©s (rainbow tables)
3. **Pas de r√©sistance aux attaques par force brute** : Trop rapide √† calculer (des milliards de hashs/seconde)
4. **Challenge-response faible** : Un attaquant capturant le trafic peut tenter des attaques offline

### Exemple d'attaque

```
# Un attaquant capture le trafic r√©seau
Hash captur√©: 5f4dcc3b5aa765d61d8327deb882cf99

# Il utilise une rainbow table
5f4dcc3b5aa765d61d8327deb882cf99 = "password"
# ‚úÖ Mot de passe d√©couvert !
```

### Statut actuel (PostgreSQL 18)

- **D√©pr√©ci√©** depuis PostgreSQL 14 (2021)
- Toujours support√© pour compatibilit√© ascendante
- **Migration fortement recommand√©e** vers `scram-sha-256`
- Peut g√©n√©rer des avertissements dans les logs

### Migration de md5 vers scram-sha-256

```sql
-- V√©rifier les utilisateurs en md5
SELECT rolname
FROM pg_authid
WHERE rolpassword LIKE 'md5%';

-- Forcer la r√©initialisation des mots de passe
ALTER USER alice PASSWORD 'NewSecurePassword123!';
-- Le nouveau hash sera en SCRAM si configur√©
```

---

## 4. La m√©thode `scram-sha-256` : Le Standard Moderne ‚úÖ

### Concept

`scram-sha-256` (Salted Challenge Response Authentication Mechanism) est la m√©thode d'authentification par mot de passe **recommand√©e** depuis PostgreSQL 10 et **par d√©faut** depuis PostgreSQL 14.

C'est l'√©quivalent moderne et s√©curis√© de `md5`, utilisant des algorithmes cryptographiques robustes.

### Fonctionnement

```
# Exemple dans pg_hba.conf
host    all         all         0.0.0.0/0         scram-sha-256
```

**Processus (simplifi√©) :**

1. **Handshake initial** : Le client annonce qu'il supporte SCRAM
2. **Challenge du serveur** : Le serveur envoie un nonce (nombre al√©atoire) et un salt
3. **R√©ponse du client** : Le client calcule une preuve cryptographique bas√©e sur :
   - Son mot de passe
   - Le salt du serveur
   - Le nonce
   - Un nombre √©lev√© d'it√©rations (4096 par d√©faut)
4. **V√©rification mutuelle** : Le serveur v√©rifie la preuve ET envoie sa propre preuve
5. **Connexion s√©curis√©e** √©tablie

### Pourquoi est-elle sup√©rieure ?

#### 1. **R√©sistance aux attaques par force brute**

```
Temps pour tester 1 milliard de mots de passe :
- MD5     : ~2 secondes   ‚ö†Ô∏è
- SCRAM   : ~8 heures     ‚úÖ (gr√¢ce aux 4096 it√©rations)
```

#### 2. **Protection contre le rejeu (replay attacks)**

Chaque session utilise un nonce unique. Un attaquant capturant le trafic ne peut pas le r√©utiliser.

#### 3. **Authentification mutuelle**

Le client v√©rifie aussi l'identit√© du serveur, prot√©geant contre les serveurs malveillants.

#### 4. **Salt unique par utilisateur**

Rend les attaques par rainbow tables inefficaces.

#### 5. **Compatibilit√© avec les normes**

Bas√© sur RFC 5802 et RFC 7677, standards de l'industrie.

### Configuration

**Dans postgresql.conf :**

```conf
# D√©finir SCRAM comme m√©thode par d√©faut pour les nouveaux mots de passe
password_encryption = 'scram-sha-256'  # D√©faut depuis PG 14
```

**Dans pg_hba.conf :**

```conf
# Connexions locales
local   all             all                                     scram-sha-256

# Connexions r√©seau (avec SSL recommand√©)
hostssl all             all             0.0.0.0/0               scram-sha-256
```

### Cr√©ation d'utilisateur avec SCRAM

```sql
-- La m√©thode moderne (PostgreSQL 14+)
CREATE USER alice WITH PASSWORD 'SecurePass123!';
-- Hash SCRAM automatiquement g√©n√©r√©

-- V√©rification du type de hash
SELECT rolname,
       CASE
           WHEN rolpassword LIKE 'SCRAM-SHA-256%' THEN 'SCRAM-SHA-256'
           WHEN rolpassword LIKE 'md5%' THEN 'md5'
           ELSE 'Aucun'
       END AS password_type
FROM pg_authid
WHERE rolname = 'alice';

-- R√©sultat attendu :
--  rolname |  password_type
-- ---------+-----------------
--  alice   | SCRAM-SHA-256
```

### Migration compl√®te vers SCRAM

**√âtape 1 : Configurer le serveur**

```conf
# postgresql.conf
password_encryption = 'scram-sha-256'
```

**√âtape 2 : Mettre √† jour pg_hba.conf**

```conf
# Avant
host    all    all    0.0.0.0/0    md5

# Apr√®s
host    all    all    0.0.0.0/0    scram-sha-256
```

**√âtape 3 : R√©initialiser les mots de passe**

```sql
-- Option 1 : R√©initialisation manuelle
ALTER USER alice PASSWORD 'NewSecurePassword';

-- Option 2 : Forcer les utilisateurs √† changer leur mot de passe
-- (Implique de communiquer avec les utilisateurs)
```

**√âtape 4 : Red√©marrer PostgreSQL**

```bash
pg_ctl reload -D /var/lib/postgresql/data
# ou
systemctl reload postgresql
```

### Compatibilit√© clients

La plupart des drivers modernes supportent SCRAM :

- ‚úÖ **psql** (PostgreSQL 10+)
- ‚úÖ **psycopg3/psycopg2** (Python, version 2.8+)
- ‚úÖ **node-postgres** (Node.js)
- ‚úÖ **pgx** (Go)
- ‚úÖ **Npgsql** (.NET)
- ‚úÖ **JDBC** (Java)

**‚ö†Ô∏è Attention** : Les tr√®s vieux clients (<2017) peuvent ne pas supporter SCRAM.

### Bonnes pratiques

1. **Toujours utiliser avec SSL/TLS** :
   ```conf
   hostssl all all 0.0.0.0/0 scram-sha-256
   ```

2. **Politique de mots de passe robuste** :
   ```sql
   -- Extension pour validation de mots de passe
   CREATE EXTENSION IF NOT EXISTS passwordcheck;
   ```

3. **Surveiller les tentatives √©chou√©es** :
   ```conf
   # postgresql.conf
   log_connections = on
   log_disconnections = on
   ```

4. **Rotation r√©guli√®re des mots de passe** :
   - Tous les 90 jours minimum pour les comptes critiques
   - Utiliser des gestionnaires de mots de passe

---

## 5. La m√©thode `cert` : Authentification par Certificat

### Concept

La m√©thode `cert` utilise des **certificats X.509** (comme ceux de HTTPS) pour authentifier les utilisateurs. C'est l'une des m√©thodes les plus s√©curis√©es, mais aussi les plus complexes √† mettre en place.

### Principe de fonctionnement

**Analogie** : Imaginez que votre mot de passe est remplac√© par une carte d'identit√© √©lectronique cryptographique. Le serveur v√©rifie que :
1. La carte est authentique (sign√©e par une autorit√© de confiance)
2. La carte n'a pas expir√©
3. La carte n'a pas √©t√© r√©voqu√©e
4. La carte appartient bien √† l'utilisateur qui se connecte

### Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Client    ‚îÇ                     ‚îÇ  PostgreSQL     ‚îÇ
‚îÇ             ‚îÇ                     ‚îÇ   Serveur       ‚îÇ
‚îÇ - Cert.crt  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄSSL/TLS‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  - CA.crt       ‚îÇ
‚îÇ - Key.key   ‚îÇ   (Chiffr√©)         ‚îÇ  - server.crt   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                     ‚îÇ  - server.key   ‚îÇ
                                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Configuration

**1. Pr√©requis : G√©n√©ration des certificats**

```bash
# Sur le serveur (simplifi√© - production n√©cessite une PKI)

# 1. Cr√©er une Autorit√© de Certification (CA)
openssl req -new -x509 -days 3650 -nodes -text \
    -out ca.crt -keyout ca.key \
    -subj "/CN=PostgreSQL-CA"

# 2. Cr√©er le certificat serveur
openssl req -new -nodes -text \
    -out server.csr -keyout server.key \
    -subj "/CN=pg.example.com"

openssl x509 -req -in server.csr -days 365 \
    -CA ca.crt -CAkey ca.key -CAcreateserial \
    -out server.crt

# 3. Cr√©er un certificat client pour l'utilisateur 'alice'
openssl req -new -nodes -text \
    -out alice.csr -keyout alice.key \
    -subj "/CN=alice"

openssl x509 -req -in alice.csr -days 365 \
    -CA ca.crt -CAkey ca.key -CAcreateserial \
    -out alice.crt
```

**2. Configuration PostgreSQL (postgresql.conf)**

```conf
# Activer SSL
ssl = on
ssl_cert_file = 'server.crt'
ssl_key_file = 'server.key'
ssl_ca_file = 'ca.crt'  # Pour v√©rifier les certificats clients

# Optionnel : Niveau de s√©curit√© TLS
ssl_min_protocol_version = 'TLSv1.3'  # PostgreSQL 18
```

**3. Configuration pg_hba.conf**

```conf
# TYPE  DATABASE    USER    ADDRESS           METHOD                  OPTIONS
hostssl all         alice   192.168.1.0/24    cert                    clientcert=verify-full
hostssl all         bob     0.0.0.0/0         cert                    clientcert=verify-full
```

**Options importantes :**
- `clientcert=verify-full` : V√©rifie le certificat ET que le CN correspond √† l'utilisateur PostgreSQL
- `clientcert=verify-ca` : V√©rifie seulement que le certificat est sign√© par la CA

### Connexion c√¥t√© client

```bash
# Placer les fichiers clients dans ~/.postgresql/
mkdir -p ~/.postgresql
cp alice.crt ~/.postgresql/postgresql.crt
cp alice.key ~/.postgresql/postgresql.key
cp ca.crt ~/.postgresql/root.crt
chmod 600 ~/.postgresql/postgresql.key

# Connexion (aucun mot de passe demand√©)
psql "host=pg.example.com user=alice dbname=mydb sslmode=verify-full"
# ‚úÖ Authentification automatique via certificat
```

### Avantages

1. **S√©curit√© maximale** :
   - Pas de mot de passe √† g√©rer ou √† compromettre
   - Impossible de deviner ou craquer (pas de force brute)

2. **Authentification mutuelle** :
   - Le client v√©rifie le serveur
   - Le serveur v√©rifie le client

3. **Audit et non-r√©pudiation** :
   - Chaque certificat est unique et tra√ßable
   - R√©vocation centralis√©e via CRL (Certificate Revocation List)

4. **Int√©gration avec PKI d'entreprise** :
   - Utilisation de certificats existants
   - Gestion centralis√©e

### Inconv√©nients et d√©fis

1. **Complexit√© de mise en place** :
   - Infrastructure PKI n√©cessaire
   - Gestion du cycle de vie des certificats (expiration, renouvellement)
   - Courbe d'apprentissage

2. **Gestion op√©rationnelle** :
   - D√©ploiement des certificats clients
   - R√©vocation en cas de compromission
   - Monitoring des expirations

3. **Mobilit√© r√©duite** :
   - Les certificats doivent √™tre pr√©sents sur le client
   - Moins pratique pour connexions ad-hoc

### Cas d'usage typiques

**‚úÖ Id√©al pour :**
- Applications serveur-√†-serveur (microservices)
- Environnements haute s√©curit√© (finance, sant√©, d√©fense)
- Connexions automatis√©es (scripts, CI/CD)
- Conformit√© r√©glementaire (PCI-DSS, HIPAA)

**‚ùå Moins adapt√© pour :**
- Utilisateurs finaux humains (lourdeur)
- Environnements de d√©veloppement rapides
- Petites √©quipes sans comp√©tence PKI

### Combinaison avec SCRAM

Il est possible de combiner les deux :

```conf
# pg_hba.conf
hostssl all  admin   0.0.0.0/0  cert                    clientcert=verify-full
hostssl all  users   0.0.0.0/0  scram-sha-256
```

Cela permet :
- Certificats pour les connexions critiques (admin, applications)
- SCRAM pour les utilisateurs standards

---

## 6. La m√©thode `ldap` : Int√©gration Entreprise

### Concept

La m√©thode `ldap` permet √† PostgreSQL de d√©l√©guer l'authentification √† un annuaire LDAP externe, typiquement **Active Directory** (Microsoft) ou **OpenLDAP**.

**Avantage principal** : Centralisation. Les utilisateurs utilisent le m√™me mot de passe pour PostgreSQL, Windows, Email, VPN, etc.

### Fonctionnement

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Client    ‚îÇ‚îÄ‚îÄ‚îÄ1. Login‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ   PostgreSQL    ‚îÇ‚îÄ‚îÄ2. Verify‚îÄ‚îÄ‚ñ∫ ‚îÇ   LDAP     ‚îÇ
‚îÇ  (alice)    ‚îÇ                ‚îÇ                 ‚îÇ   (alice)     ‚îÇ  Server    ‚îÇ
‚îÇ             ‚îÇ‚óÑ‚îÄ‚îÄ4. OK/Fail‚îÄ‚îÄ‚îÄ‚îÇ                 ‚îÇ‚óÑ‚îÄ3. OK/Fail‚îÄ‚îÄ ‚îÇ   (AD)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**√âtapes :**

1. L'utilisateur Alice se connecte avec son login/password
2. PostgreSQL intercepte la tentative
3. PostgreSQL envoie les credentials au serveur LDAP
4. Le serveur LDAP v√©rifie et r√©pond OK/Fail
5. PostgreSQL autorise ou refuse la connexion

### Configuration

**1. Dans pg_hba.conf**

```conf
# Simple LDAP bind
host    all    all    0.0.0.0/0    ldap ldapserver=ldap.company.com ldapbasedn="dc=company,dc=com"

# Avec pr√©fixe/suffixe (pour Active Directory)
host    all    all    0.0.0.0/0    ldap ldapserver=ad.company.com ldapprefix="COMPANY\" ldapsuffix="@company.com"

# LDAP over SSL (recommand√©)
host    all    all    0.0.0.0/0    ldap ldapserver=ldap.company.com ldapport=636 ldaptls=1 ldapbasedn="ou=users,dc=company,dc=com"
```

**Param√®tres principaux :**

| Param√®tre | Description | Exemple |
|-----------|-------------|---------|
| `ldapserver` | Adresse du serveur LDAP | `ldap.company.com` |
| `ldapport` | Port (389 standard, 636 SSL) | `636` |
| `ldapbasedn` | Base DN de recherche | `dc=company,dc=com` |
| `ldapbinddn` | DN pour la connexion au LDAP | `cn=pgadmin,dc=company,dc=com` |
| `ldapbindpasswd` | Mot de passe pour ldapbinddn | `SecretPassword` |
| `ldapsearchattribute` | Attribut de recherche | `uid` (d√©faut) ou `sAMAccountName` (AD) |
| `ldaptls` | Activer TLS | `1` (recommand√©) |
| `ldapprefix` | Pr√©fixe du login | `COMPANY\` (pour AD) |
| `ldapsuffix` | Suffixe du login | `@company.com` |

### Modes d'authentification LDAP

#### Mode 1 : Simple Bind (Recommand√©)

Le plus simple et le plus s√©curis√©.

```conf
host all all 0.0.0.0/0 ldap ldapserver=ldap.company.com ldapbasedn="dc=company,dc=com"
```

**Fonctionnement :**
1. L'utilisateur tape : username = `alice`, password = `secret123`
2. PostgreSQL tente un bind LDAP avec `uid=alice,ou=users,dc=company,dc=com`
3. Si le bind r√©ussit ‚áí authentification OK

#### Mode 2 : Search + Bind

Plus flexible, permet de rechercher l'utilisateur d'abord.

```conf
host all all 0.0.0.0/0 ldap \
    ldapserver=ldap.company.com \
    ldapbasedn="dc=company,dc=com" \
    ldapbinddn="cn=pgadmin,dc=company,dc=com" \
    ldapbindpasswd="AdminSecret" \
    ldapsearchattribute="sAMAccountName"
```

**Fonctionnement :**
1. PostgreSQL se connecte au LDAP avec le compte de service (`ldapbinddn`)
2. Recherche l'utilisateur par attribut (`sAMAccountName=alice`)
3. R√©cup√®re le DN complet : `CN=Alice Smith,OU=Users,DC=company,DC=com`
4. Tente un bind avec ce DN et le password fourni par l'utilisateur

### Exemple avec Active Directory

**Configuration typique :**

```conf
# pg_hba.conf pour Active Directory
host    all    all    10.0.0.0/8    ldap \
    ldapserver=ad.company.com \
    ldapport=636 \
    ldaptls=1 \
    ldapbasedn="DC=company,DC=com" \
    ldapbinddn="CN=PostgreSQL Service,OU=ServiceAccounts,DC=company,DC=com" \
    ldapbindpasswd="ServiceAccountPassword" \
    ldapsearchattribute="sAMAccountName" \
    ldapsearchfilter="(&(objectClass=user)(memberOf=CN=DBUsers,OU=Groups,DC=company,DC=com))"
```

**Explication :**
- `ldapserver=ad.company.com` : Contr√¥leur de domaine Active Directory
- `ldapport=636` + `ldaptls=1` : Connexion s√©curis√©e (LDAPS)
- `ldapsearchattribute="sAMAccountName"` : Attribut username Windows
- `ldapsearchfilter` : Filtre pour n'autoriser que les membres du groupe `DBUsers`

### Cr√©ation automatique d'utilisateurs

**‚ö†Ô∏è Point important** : LDAP authentifie mais ne cr√©e pas l'utilisateur dans PostgreSQL.

**Vous devez :**

1. **Cr√©er manuellement les utilisateurs** :
   ```sql
   CREATE USER alice;
   GRANT CONNECT ON DATABASE mydb TO alice;
   GRANT SELECT ON ALL TABLES IN SCHEMA public TO alice;
   ```

2. **Ou utiliser un script de synchronisation** :
   ```bash
   #!/bin/bash
   # Synchroniser les utilisateurs LDAP vers PostgreSQL
   ldapsearch -x -H ldap://ldap.company.com -b "ou=users,dc=company,dc=com" \
       -s sub "(objectClass=user)" uid | \
   grep "^uid:" | \
   awk '{print $2}' | \
   while read user; do
       psql -c "CREATE USER IF NOT EXISTS $user;"
       psql -c "GRANT pg_read_all_data TO $user;"
   done
   ```

### Avantages de LDAP

1. **Centralisation** :
   - Un seul mot de passe pour tous les services
   - D√©sactivation d'un compte ‚áí r√©vocation imm√©diate partout

2. **Conformit√©** :
   - Politique de mots de passe centralis√©e
   - Audit unifi√©

3. **Gestion simplifi√©e** :
   - Pas besoin de g√©rer les mots de passe dans PostgreSQL
   - Rotation automatique via AD

4. **Int√©gration avec IAM** :
   - SSO possible (avec Kerberos)
   - MFA via AD

### Inconv√©nients

1. **D√©pendance externe** :
   - Si le LDAP est down, plus de connexions possibles
   - Latence r√©seau sur chaque authentification

2. **Complexit√©** :
   - Configuration plus technique
   - D√©pannage plus difficile

3. **Performance** :
   - Chaque connexion fait une requ√™te LDAP
   - Utiliser un connection pooler (PgBouncer) pour mitiger

### Bonnes pratiques

1. **Toujours utiliser LDAPS (port 636)** :
   ```conf
   ldapport=636 ldaptls=1
   ```

2. **Utiliser un compte de service d√©di√©** pour les recherches :
   ```conf
   ldapbinddn="CN=PG Service,OU=Services,DC=company,DC=com"
   ```

3. **Filtrer par groupe de s√©curit√©** :
   ```conf
   ldapsearchfilter="(memberOf=CN=DatabaseUsers,OU=Groups,DC=company,DC=com)"
   ```

4. **Connection pooling obligatoire** :
   - PgBouncer ou PgPool pour limiter les requ√™tes LDAP

5. **Compte de secours local** :
   ```conf
   # pg_hba.conf
   local   all   postgres   peer              # Admin local
   host    all   all        0.0.0.0/0  ldap   # Utilisateurs LDAP
   ```

6. **Monitoring des √©checs** :
   ```conf
   # postgresql.conf
   log_connections = on
   log_failed_connections = on
   ```

---

## Comparatif et Recommandations

### Matrice de d√©cision

| Contexte | M√©thode recommand√©e | Justification |
|----------|---------------------|---------------|
| **D√©veloppement local** | `trust` (local only) | Simplicit√© |
| **D√©veloppement partag√©** | `scram-sha-256` | S√©curit√© de base |
| **Production standard** | `scram-sha-256` + SSL | Standard industriel |
| **Haute s√©curit√©** | `cert` | Pas de mot de passe |
| **Applications M2M** | `cert` | Automatisation |
| **Entreprise avec AD** | `ldap` (+ MFA) | Centralisation |
| **Environnement r√©gul√©** | `cert` ou `ldap` + audit | Conformit√© |

### Chemins de migration recommand√©s

**Migration 1 : md5 ‚Üí scram-sha-256** (Prioritaire)

```
1. postgresql.conf : password_encryption = 'scram-sha-256'
2. Restart PostgreSQL
3. pg_hba.conf : md5 ‚Üí scram-sha-256
4. Reload configuration
5. R√©initialiser les mots de passe utilisateurs
6. V√©rifier les logs pour √©checs d'authentification
```

**Migration 2 : password/trust ‚Üí scram-sha-256**

```
1. Identifier tous les usages de trust/password
2. Cr√©er des utilisateurs avec mots de passe
3. Tester la connexion avec scram-sha-256
4. Remplacer progressivement dans pg_hba.conf
5. Reload et surveiller
```

**Migration 3 : Aucune auth ‚Üí LDAP** (Grandes entreprises)

```
1. Auditer l'existant
2. D√©finir le mapping utilisateurs LDAP ‚Üî PostgreSQL
3. Configurer LDAPS sur un serveur de test
4. Cr√©er les utilisateurs PostgreSQL
5. Tester l'authentification
6. D√©ploiement progressif (par application)
7. Migration compl√®te
8. D√©sactivation des anciennes m√©thodes
```

### S√©curisation multi-niveaux (Approche d√©fense en profondeur)

```conf
# pg_hba.conf - Exemple production s√©curis√©

# 1. Admin local uniquement (peer = utilisateur syst√®me)
local   all   postgres   peer

# 2. Comptes applicatifs M2M avec certificats
hostssl myapp appuser   10.0.1.0/24   cert   clientcert=verify-full

# 3. Utilisateurs entreprise via LDAP (r√©seau interne)
hostssl all   all        10.0.0.0/8    ldap   ldapserver=ad.company.com ldapport=636 ldaptls=1

# 4. Utilisateurs externes avec SCRAM + SSL (VPN)
hostssl all   external   192.168.100.0/24   scram-sha-256

# 5. Deny all (explicite)
host    all   all        0.0.0.0/0     reject
```

---

## D√©pannage et Diagnostics

### Probl√®mes courants

#### 1. "FATAL: password authentication failed"

**Causes possibles :**
- Mauvais mot de passe
- Utilisateur n'existe pas
- Hash de mot de passe incompatible (md5 vs scram)

**Diagnostic :**
```sql
-- V√©rifier l'utilisateur existe
SELECT * FROM pg_authid WHERE rolname = 'alice';

-- V√©rifier le type de hash
SELECT rolname,
       substring(rolpassword, 1, 10) as hash_prefix
FROM pg_authid
WHERE rolname = 'alice';
```

#### 2. "FATAL: no pg_hba.conf entry for host"

**Cause :** La connexion ne correspond √† aucune r√®gle dans `pg_hba.conf`

**Diagnostic :**
```bash
# V√©rifier la configuration
cat /var/lib/postgresql/data/pg_hba.conf | grep -v "^#" | grep -v "^$"

# Tester depuis le client
psql -h pg.example.com -U alice -d mydb
```

**Solution :**
Ajouter une r√®gle correspondante et recharger :
```bash
pg_ctl reload
```

#### 3. LDAP : "LDAP authentication failed"

**Causes :**
- Serveur LDAP inaccessible
- DN incorrect
- Attributs de recherche mal configur√©s

**Diagnostic :**
```bash
# Tester la connexion LDAP manuellement
ldapsearch -x -H ldap://ldap.company.com \
           -D "cn=admin,dc=company,dc=com" \
           -w AdminPassword \
           -b "dc=company,dc=com" \
           "(uid=alice)"

# V√©rifier les logs PostgreSQL
tail -f /var/log/postgresql/postgresql-16-main.log | grep -i ldap
```

#### 4. Certificats : "certificate verify failed"

**Causes :**
- Certificat expir√©
- CA non reconnue
- Nom (CN) ne correspond pas

**Diagnostic :**
```bash
# V√©rifier la validit√© du certificat
openssl x509 -in alice.crt -noout -dates -subject

# Tester la connexion SSL
openssl s_client -connect pg.example.com:5432 -starttls postgres

# V√©rifier les permissions
ls -la ~/.postgresql/
# postgresql.key doit √™tre 600 (rw-------)
```

---

## Tests et Validation

### Script de test d'authentification

```bash
#!/bin/bash
# test_auth.sh - Tester les diff√©rentes m√©thodes

echo "=== Test SCRAM-SHA-256 ==="
PGPASSWORD=SecurePass psql -h localhost -U alice -d postgres -c "SELECT current_user;"

echo "=== Test avec certificat ==="
psql "host=localhost user=bob dbname=postgres sslmode=verify-full sslcert=~/.postgresql/bob.crt sslkey=~/.postgresql/bob.key" -c "SELECT current_user;"

echo "=== Test trust (local) ==="
psql -U postgres -d postgres -c "SELECT current_user;"

echo "=== Test LDAP (simul√© avec compte) ==="
PGPASSWORD=LDAPPassword psql -h ldap-pg.example.com -U charlie -d postgres -c "SELECT current_user;"
```

### V√©rification de la configuration

```sql
-- Lister les utilisateurs et leur type d'auth
SELECT
    rolname,
    CASE
        WHEN rolpassword IS NULL THEN 'No password'
        WHEN rolpassword LIKE 'SCRAM-SHA-256%' THEN 'SCRAM-SHA-256'
        WHEN rolpassword LIKE 'md5%' THEN 'MD5 (deprecated)'
        ELSE 'Unknown'
    END as auth_method,
    rolcanlogin as can_login,
    rolvaliduntil as valid_until
FROM pg_authid
WHERE rolcanlogin = true
ORDER BY rolname;
```

---

## Nouveaut√©s PostgreSQL 18 (Septembre 2025)

### 1. Support OAuth 2.0

PostgreSQL 18 introduit le support exp√©rimental d'OAuth 2.0 pour l'authentification.

```conf
# Nouveau dans pg_hba.conf
host    all    all    0.0.0.0/0    oauth \
    oauth_issuer_url="https://auth.company.com" \
    oauth_audience="postgresql-cluster" \
    oauth_scope="openid profile email"
```

**Avantages :**
- SSO moderne (Google, Azure AD, Okta)
- Tokens JWT au lieu de mots de passe
- R√©vocation centralis√©e

### 2. SCRAM Passthrough (postgres_fdw, dblink)

Possibilit√© de passer l'authentification SCRAM √† travers les connexions f√©d√©r√©es.

```sql
-- Avant PG 18 : Fallback sur password en clair
-- Apr√®s PG 18 : SCRAM pr√©serv√©

CREATE SERVER remote_pg FOREIGN DATA WRAPPER postgres_fdw
OPTIONS (host 'remote.pg.com', dbname 'remotedb',
         scram_channel_binding 'require');
```

### 3. Configuration TLS 1.3 avanc√©e

Nouveau param√®tre `ssl_tls13_ciphers` pour contr√¥ler finement les ciphers TLS 1.3.

```conf
# postgresql.conf
ssl_min_protocol_version = 'TLSv1.3'
ssl_tls13_ciphers = 'TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256'
```

### 4. Mode FIPS (Federal Information Processing Standards)

Support du mode FIPS pour conformit√© gouvernementale US.

```conf
# postgresql.conf
ssl_fips_mode = 'on'  # Nouveau param√®tre
```

---

## Ressources et Documentation

### Documentation officielle

- **PostgreSQL Authentication** : https://www.postgresql.org/docs/18/auth-methods.html
- **pg_hba.conf** : https://www.postgresql.org/docs/18/auth-pg-hba-conf.html
- **SSL/TLS** : https://www.postgresql.org/docs/18/ssl-tcp.html

### Outils

- **pgAdmin** : Interface graphique avec gestion des connexions
- **DBeaver** : Client universel supportant tous les types d'auth
- **pgBouncer** : Connection pooler essentiel avec LDAP

### Communaut√©

- **Mailing list pgsql-general** : Aide sur les probl√®mes d'authentification
- **Stack Overflow** : Tag `postgresql` + `authentication`
- **PostgreSQL Wiki** : https://wiki.postgresql.org/wiki/Client_Certificate_Authentication

---

## Conclusion

Le choix de la m√©thode d'authentification est une d√©cision critique qui impacte la s√©curit√©, la facilit√© de gestion, et la conformit√© de votre syst√®me PostgreSQL.

**R√©capitulatif des recommandations :**

- ‚úÖ **Pour 90% des cas** : `scram-sha-256` + SSL/TLS
- ‚úÖ **Pour les applications** : `cert` (certificats clients)
- ‚úÖ **Pour les grandes entreprises** : `ldap` (Active Directory)
- ‚ùå **√Ä √©viter absolument** : `trust` (hors dev local), `password`, `md5`

**Prochaine √©tape recommand√©e** : Si vous utilisez encore `md5`, planifiez d√®s maintenant la migration vers `scram-sha-256`. La s√©curit√© de vos donn√©es en d√©pend.

---


‚è≠Ô∏è [Nouveaut√© PG 18 : Authentification OAuth 2.0](/16-administration-configuration-securite/02.2-authentification-oauth-pg18.md)
