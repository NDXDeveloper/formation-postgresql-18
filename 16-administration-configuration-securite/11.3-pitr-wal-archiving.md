üîù Retour au [Sommaire](/SOMMAIRE.md)

# 16.11.3. Point-In-Time Recovery (PITR) et WAL Archiving

## Introduction au Concept

Imaginez que vous travaillez sur un document important et que votre traitement de texte sauvegarde automatiquement toutes vos modifications, seconde par seconde. Si vous faites une erreur √† 14h37, vous pouvez revenir exactement √† l'√©tat de 14h36, pas seulement √† la derni√®re sauvegarde de la nuit pr√©c√©dente.

Le **Point-In-Time Recovery (PITR)** fait exactement cela pour votre base de donn√©es PostgreSQL : il vous permet de restaurer votre base de donn√©es √† n'importe quel moment pr√©cis dans le pass√©, √† la seconde pr√®s.

### Le Probl√®me que PITR R√©sout

**Sc√©nario sans PITR** :
```
Lundi 23h00 : Sauvegarde compl√®te
Mardi 14h30 : Un d√©veloppeur ex√©cute accidentellement "DELETE FROM clients WHERE 1=1"
Mardi 14h31 : Panique ! üö®
```

**Options limit√©es** :
- ‚ùå Restaurer la sauvegarde de lundi 23h00 ‚Üí Perte de 15h30 de donn√©es
- ‚ùå Essayer de reconstituer les donn√©es manuellement ‚Üí Risqu√© et long

**Avec PITR** :
- ‚úÖ Restaurer √† mardi 14h29:59 (1 seconde avant l'erreur)
- ‚úÖ Perte de donn√©es : 1 seconde seulement
- ‚úÖ Temps de r√©cup√©ration : Minutes

### Les Composants du PITR

Le PITR repose sur deux √©l√©ments essentiels :

1. **Une sauvegarde de base (Base Backup)** : Un snapshot complet du cluster √† un moment T
2. **Les archives WAL (Write-Ahead Logs)** : L'enregistrement continu de toutes les modifications depuis cette sauvegarde

**Analogie** :
- **Sauvegarde de base** = Une photo de votre maison prise il y a 1 mois
- **Archives WAL** = Une vid√©o enregistrant chaque modification depuis (repeindre un mur, d√©placer un meuble, etc.)
- **PITR** = Regarder la vid√©o jusqu'√† un moment pr√©cis pour recr√©er l'√©tat exact de votre maison √† cet instant

---

## Comprendre le WAL (Write-Ahead Log)

### Qu'est-ce que le WAL ?

Le **Write-Ahead Log** (journal de transactions) est le m√©canisme fondamental qui garantit la durabilit√© et l'int√©grit√© des donn√©es dans PostgreSQL.

### Principe de Fonctionnement

**R√®gle d'or du WAL** : Toute modification de donn√©es est **d'abord** √©crite dans le WAL **avant** d'√™tre appliqu√©e aux fichiers de donn√©es r√©els.

**S√©quence d'une transaction** :

```
1. BEGIN TRANSACTION
   ‚Üì
2. Modification en m√©moire (shared buffers)
   ‚Üì
3. ‚úçÔ∏è √âcriture dans le WAL (sur disque)
   ‚Üì
4. COMMIT confirm√© √† l'utilisateur
   ‚Üì
5. (Plus tard) √âcriture dans les fichiers de donn√©es
```

**Pourquoi cet ordre ?**

Si le serveur crashe entre l'√©tape 4 et 5 :
- ‚úÖ Le WAL contient la transaction compl√®te
- ‚úÖ Au red√©marrage, PostgreSQL "rejoue" le WAL
- ‚úÖ Les donn√©es sont restaur√©es correctement

### Structure des Fichiers WAL

Les fichiers WAL sont stock√©s dans le r√©pertoire `pg_wal/` (anciennement `pg_xlog/` avant PostgreSQL 10).

**Caract√©ristiques** :
- **Taille fixe** : 16 MB par fichier (par d√©faut)
- **Nommage** : 24 caract√®res hexad√©cimaux (ex: `000000010000000000000001`)
- **Rotation** : Cr√©ation continue de nouveaux fichiers
- **Recyclage** : Les anciens fichiers sont r√©utilis√©s

**Exemple** :
```bash
$ ls -lh /var/lib/postgresql/data/pg_wal/
-rw------- 1 postgres postgres 16M Nov 22 10:15 000000010000000000000042
-rw------- 1 postgres postgres 16M Nov 22 10:20 000000010000000000000043
-rw------- 1 postgres postgres 16M Nov 22 10:25 000000010000000000000044
```

### Contenu du WAL

Le WAL enregistre :
- **Modifications de donn√©es** : INSERT, UPDATE, DELETE
- **Modifications de structure** : CREATE TABLE, ALTER TABLE
- **Transactions** : BEGIN, COMMIT, ROLLBACK
- **Checkpoints** : Points de synchronisation

**Format** : Binaire, non lisible directement (utilisez `pg_waldump` pour inspecter).

### Niveaux de WAL (wal_level)

PostgreSQL propose trois niveaux de WAL :

| Niveau | Description | Cas d'usage |
|--------|-------------|-------------|
| **minimal** | Minimum pour crash recovery | Standalone, pas de r√©plication |
| **replica** | Suffisant pour r√©plication physique | Production standard |
| **logical** | Inclut infos pour r√©plication logique | R√©plication s√©lective, CDC |

**Configuration** :
```conf
# postgresql.conf
wal_level = replica  # Recommand√© pour PITR
```

---

## WAL Archiving : Archivage Continu

### Qu'est-ce que le WAL Archiving ?

Le **WAL archiving** consiste √† copier automatiquement chaque fichier WAL compl√©t√© dans un emplacement d'archivage s√©curis√© **avant** qu'il ne soit recycl√© ou supprim√©.

**Sans archivage** :
```
WAL cr√©√© ‚Üí WAL utilis√© ‚Üí WAL recycl√© ‚Üí ‚ùå Perdu
```

**Avec archivage** :
```
WAL cr√©√© ‚Üí WAL utilis√© ‚Üí üì¶ WAL copi√© vers archive ‚Üí WAL recycl√©
```

### Pourquoi Archiver les WAL ?

1. **PITR** : Restauration √† n'importe quel moment
2. **R√©plication** : Serveurs standby √©loign√©s
3. **Disaster Recovery** : Reconstruction compl√®te apr√®s sinistre
4. **Audit** : Tra√ßabilit√© compl√®te des modifications

### Configuration de l'Archivage

#### √âtape 1 : Cr√©er un R√©pertoire d'Archive

```bash
# Cr√©er le r√©pertoire
sudo mkdir -p /mnt/wal_archive

# Permissions appropri√©es
sudo chown postgres:postgres /mnt/wal_archive
sudo chmod 700 /mnt/wal_archive
```

**Recommandations** :
- Utiliser un disque/partition s√©par√©
- Pr√©f√©rer un montage NFS ou stockage r√©seau
- √âviter le m√™me disque que le data directory

#### √âtape 2 : Configurer postgresql.conf

```conf
# Activer l'archivage
archive_mode = on

# Commande d'archivage (exemples ci-dessous)
archive_command = 'cp %p /mnt/wal_archive/%f'

# Timeout pour l'archivage (optionnel)
archive_timeout = 300  # Forcer archivage toutes les 5 minutes
```

**Param√®tres** :
- `%p` : Chemin complet du fichier WAL √† archiver
- `%f` : Nom du fichier WAL seulement

#### √âtape 3 : Red√©marrer PostgreSQL

```bash
sudo systemctl restart postgresql
```

‚ö†Ô∏è **Important** : Le changement de `archive_mode` n√©cessite un red√©marrage complet (pas juste un reload).

### Commandes d'Archivage Courantes

#### 1. Copie Locale Simple

```conf
archive_command = 'test ! -f /mnt/wal_archive/%f && cp %p /mnt/wal_archive/%f'
```

**Explication** :
- `test ! -f /mnt/wal_archive/%f` : V√©rifie que le fichier n'existe pas d√©j√†
- `&&` : Continue si le test r√©ussit
- `cp %p /mnt/wal_archive/%f` : Copie le fichier

**Avantages** : Simple, rapide
**Inconv√©nients** : Aucune redondance, vuln√©rable aux pannes disque

#### 2. Archivage Distant avec rsync

```conf
archive_command = 'rsync -a %p backup-server:/wal_archive/%f'
```

**Avantages** : Stockage hors-site, s√©curis√©
**Inconv√©nients** : D√©pend du r√©seau

#### 3. Archivage avec V√©rification

```conf
archive_command = 'cp %p /mnt/wal_archive/%f && md5sum %p > /mnt/wal_archive/%f.md5'
```

**Avantages** : V√©rifie l'int√©grit√© du fichier
**Inconv√©nients** : L√©g√®rement plus lent

#### 4. Archivage Redondant

```bash
#!/bin/bash
# /usr/local/bin/archive_wal.sh
cp "$1" /mnt/wal_archive/"$2"
rsync -a "$1" backup-server:/wal_archive/"$2"
aws s3 cp "$1" s3://company-backups/wal/"$2"
```

```conf
archive_command = '/usr/local/bin/archive_wal.sh %p %f'
```

**Avantages** : Triple redondance (local, distant, cloud)
**Inconv√©nients** : Plus lent, plus complexe

#### 5. Archivage vers S3 (AWS)

```conf
archive_command = 'aws s3 cp %p s3://my-bucket/wal_archive/%f'
```

**Pr√©requis** : AWS CLI configur√©

#### 6. Archivage avec Compression

```conf
archive_command = 'gzip < %p > /mnt/wal_archive/%f.gz'
```

**Avantages** : √âconomie d'espace disque (~80% compression)
**Inconv√©nients** : Plus lent, n√©cessite d√©compression √† la restauration

### V√©rifier le Fonctionnement de l'Archivage

#### M√©thode 1 : Forcer un Switch de WAL

```sql
-- Forcer PostgreSQL √† cr√©er un nouveau fichier WAL
SELECT pg_switch_wal();

-- Attendre quelques secondes, puis v√©rifier
SELECT * FROM pg_stat_archiver;
```

**Colonnes importantes de pg_stat_archiver** :
- `archived_count` : Nombre de WAL archiv√©s avec succ√®s
- `failed_count` : Nombre d'√©checs (devrait √™tre 0)
- `last_archived_wal` : Dernier WAL archiv√©
- `last_archived_time` : Horodatage du dernier archivage
- `last_failed_wal` : Dernier WAL √©chou√© (si failed_count > 0)

#### M√©thode 2 : V√©rifier les Logs

```bash
tail -f /var/log/postgresql/postgresql-18-main.log | grep archive
```

**Messages attendus** :
```
archived write-ahead log file "000000010000000000000042"
```

**Messages d'erreur** :
```
could not execute archive command: ...
archive command failed with exit code 1
```

#### M√©thode 3 : Inspecter le R√©pertoire d'Archive

```bash
ls -lh /mnt/wal_archive/ | tail
```

Vous devriez voir de nouveaux fichiers WAL appara√Ætre r√©guli√®rement.

### Gestion des Archives WAL

#### Taille des Archives

Les archives WAL croissent ind√©finiment si non nettoy√©es.

**Calcul de la croissance** :
```
Taille par jour = (Activit√© d'√©criture) / 16 MB

Exemple : Base tr√®s active g√©n√©rant 10 GB/jour de WAL
‚Üí ~640 fichiers WAL par jour
‚Üí ~4.5 TB par an
```

#### Strat√©gies de R√©tention

**Option 1 : R√©tention par Dur√©e**
```bash
# Conserver 30 jours de WAL
find /mnt/wal_archive -name "*.wal" -mtime +30 -delete
```

**Option 2 : R√©tention par Taille**
```bash
#!/bin/bash
# Garder seulement 500 GB de WAL
TARGET_SIZE=500  # GB
ARCHIVE_DIR="/mnt/wal_archive"

CURRENT_SIZE=$(du -s --block-size=1G ${ARCHIVE_DIR} | cut -f1)

if [ ${CURRENT_SIZE} -gt ${TARGET_SIZE} ]; then
    # Supprimer les plus anciens
    ls -t ${ARCHIVE_DIR}/*.wal | tail -n +1000 | xargs rm -f
fi
```

**Option 3 : R√©tention Coordonn√©e avec Sauvegardes**
```bash
# Conserver les WAL uniquement pour les sauvegardes existantes
# (Barman, pgBackRest font cela automatiquement)
```

**Automatisation avec Cron** :
```bash
# Nettoyage quotidien √† 4h du matin
0 4 * * * find /mnt/wal_archive -mtime +30 -delete
```

‚ö†Ô∏è **Attention** : Ne supprimez jamais un WAL n√©cessaire √† une restauration PITR !

---

## Configuration Compl√®te du PITR

### Vue d'Ensemble

Le PITR complet n√©cessite :

1. **Configuration de l'archivage WAL** (d√©j√† vu)
2. **Sauvegarde de base r√©guli√®re** (pg_basebackup)
3. **Configuration de restauration** (recovery.conf / recovery.signal)
4. **Restauration et replay des WAL**

### Sch√©ma du Processus

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Production DB   ‚îÇ
‚îÇ                 ‚îÇ
‚îÇ [WAL archiving] ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> [Archive WAL] (/mnt/wal_archive)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îÇ
        ‚îÇ                        ‚îÇ
        ‚îÇ pg_basebackup          ‚îÇ
        ‚Üì                        ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ
‚îÇ Base Backup     ‚îÇ              ‚îÇ
‚îÇ (Snapshot T0)   ‚îÇ              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îÇ
        ‚îÇ                        ‚îÇ
        ‚îÇ  En cas d'incident     ‚îÇ
        ‚Üì                        ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Restauration                    ‚îÇ
‚îÇ 1. Copier base backup           ‚îÇ
‚îÇ 2. Configurer recovery          ‚îÇ
‚îÇ 3. Replay WAL jusqu'au point T  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### √âtape par √âtape : Configuration Compl√®te

#### Phase 1 : Pr√©paration (√Ä faire UNE FOIS)

**1. Configuration PostgreSQL (postgresql.conf)** :
```conf
# Niveau WAL pour r√©plication/archivage
wal_level = replica

# Nombre de processus WAL sender
max_wal_senders = 5

# Taille minimale de WAL √† conserver
wal_keep_size = 1GB

# Activer l'archivage
archive_mode = on

# Commande d'archivage
archive_command = 'test ! -f /mnt/wal_archive/%f && cp %p /mnt/wal_archive/%f'

# Timeout d'archivage (optionnel)
archive_timeout = 300  # 5 minutes
```

**2. Red√©marrer PostgreSQL** :
```bash
sudo systemctl restart postgresql
```

**3. V√©rifier la configuration** :
```sql
SHOW wal_level;
SHOW archive_mode;
SHOW archive_command;

-- V√©rifier l'√©tat de l'archivage
SELECT * FROM pg_stat_archiver;
```

#### Phase 2 : Sauvegarde de Base (√Ä faire R√âGULI√àREMENT)

**Script de sauvegarde** :
```bash
#!/bin/bash
# /usr/local/bin/pitr_base_backup.sh

DATE=$(date +%Y%m%d_%H%M)
BACKUP_DIR="/backups/pitr"
BASE_BACKUP="${BACKUP_DIR}/base_${DATE}"

# Cr√©er le r√©pertoire
mkdir -p ${BASE_BACKUP}

# Ex√©cuter pg_basebackup
pg_basebackup \
    -D ${BASE_BACKUP} \
    -U backup_user \
    -X stream \
    -c fast \
    -P -v

# Enregistrer le timestamp pour r√©f√©rence
echo ${DATE} > ${BACKUP_DIR}/last_backup_timestamp.txt

echo "Base backup completed: ${BASE_BACKUP}"
```

**Cron (hebdomadaire, dimanche √† 1h)** :
```bash
0 1 * * 0 /usr/local/bin/pitr_base_backup.sh
```

#### Phase 3 : Archivage Continu

L'archivage WAL se fait **automatiquement** et **continuellement** gr√¢ce √† `archive_command`.

**Monitoring recommand√©** :
```sql
-- V√©rifier toutes les heures
SELECT
    archived_count,
    failed_count,
    last_archived_time,
    now() - last_archived_time AS time_since_last_archive
FROM pg_stat_archiver;
```

**Alerte si** :
- `failed_count` augmente
- `time_since_last_archive` > 1 heure (sur base active)

---

## Sc√©narios de Restauration PITR

### Sc√©nario 1 : Restauration √† un Point Pr√©cis (Timestamp)

**Contexte** :
- Incident : Suppression accidentelle de donn√©es √† 14h37
- Objectif : Restaurer √† 14h36:59

**Proc√©dure** :

#### √âtape 1 : Arr√™ter PostgreSQL

```bash
sudo systemctl stop postgresql
```

#### √âtape 2 : Sauvegarder les Donn√©es Actuelles (S√©curit√©)

```bash
sudo mv /var/lib/postgresql/18/main /var/lib/postgresql/18/main.corrupted
```

#### √âtape 3 : Restaurer la Sauvegarde de Base

```bash
# Copier la derni√®re sauvegarde de base
sudo cp -a /backups/pitr/base_20251122_0100 /var/lib/postgresql/18/main

# Permissions
sudo chown -R postgres:postgres /var/lib/postgresql/18/main
sudo chmod 700 /var/lib/postgresql/18/main
```

#### √âtape 4 : Cr√©er le Fichier recovery.signal

```bash
# PostgreSQL 12+ utilise recovery.signal
sudo touch /var/lib/postgresql/18/main/recovery.signal
```

#### √âtape 5 : Configurer les Param√®tres de R√©cup√©ration

```bash
# √âditer postgresql.conf ou postgresql.auto.conf
sudo tee -a /var/lib/postgresql/18/main/postgresql.auto.conf << EOF

# Configuration PITR
restore_command = 'cp /mnt/wal_archive/%f %p'
recovery_target_time = '2025-11-22 14:36:59'
recovery_target_action = 'promote'
EOF
```

**Param√®tres** :
- `restore_command` : Comment r√©cup√©rer les WAL archiv√©s
- `recovery_target_time` : Moment pr√©cis de restauration
- `recovery_target_action` : Que faire apr√®s la r√©cup√©ration
  - `pause` : Arr√™ter en mode pause (inspection possible)
  - `promote` : Passer en mode production
  - `shutdown` : Arr√™ter PostgreSQL

#### √âtape 6 : Permissions et D√©marrage

```bash
sudo chown postgres:postgres /var/lib/postgresql/18/main/recovery.signal
sudo systemctl start postgresql
```

#### √âtape 7 : Observer le Processus de R√©cup√©ration

```bash
# Logs en temps r√©el
sudo tail -f /var/log/postgresql/postgresql-18-main.log
```

**Messages attendus** :
```
starting point-in-time recovery to 2025-11-22 14:36:59+00
restored log file "000000010000000000000042" from archive
redo starts at 0/42000028
recovery stopping before commit of transaction 1234, time 2025-11-22 14:37:01+00
recovery has paused
database system is ready to accept read-only connections
```

#### √âtape 8 : V√©rification

```bash
psql -U postgres -d production

-- V√©rifier l'heure de r√©cup√©ration
SELECT pg_last_wal_replay_lsn();

-- V√©rifier vos donn√©es
SELECT count(*) FROM clients;
```

#### √âtape 9 : Promouvoir (si en mode pause)

Si `recovery_target_action = 'pause'` :
```sql
SELECT pg_wal_replay_resume();
-- Ou
SELECT pg_promote();
```

### Sc√©nario 2 : Restauration au Dernier Point Coh√©rent

**Contexte** : Perte totale du serveur, restaurer le maximum de donn√©es.

**Configuration** :
```conf
restore_command = 'cp /mnt/wal_archive/%f %p'
# Pas de recovery_target_* = restaurer jusqu'au dernier WAL disponible
recovery_target_action = 'promote'
```

### Sc√©nario 3 : Restauration Avant une Transaction Sp√©cifique

**Contexte** : Une transaction probl√©matique identifi√©e (XID).

#### Trouver le XID

```sql
-- Sur la base corrompue (si accessible)
SELECT txid_current();

-- Ou dans les logs
grep "transaction" /var/log/postgresql/*.log
```

**Configuration** :
```conf
restore_command = 'cp /mnt/wal_archive/%f %p'
recovery_target_xid = '12345678'  # XID √† √©viter
recovery_target_inclusive = false  # Exclure cette transaction
recovery_target_action = 'promote'
```

### Sc√©nario 4 : Restauration jusqu'√† un Point de Sauvegarde Nomm√©

**Contexte** : Vous avez cr√©√© des points de sauvegarde avant des op√©rations risqu√©es.

#### Cr√©er un Point de Sauvegarde

```sql
-- Avant une op√©ration risqu√©e
BEGIN;
SAVEPOINT before_migration;

-- Op√©ration risqu√©e
UPDATE ...;

-- Si tout va bien
COMMIT;
```

Ou au niveau base de donn√©es :
```sql
SELECT pg_create_restore_point('before_major_update');
```

**Configuration de restauration** :
```conf
restore_command = 'cp /mnt/wal_archive/%f %p'
recovery_target_name = 'before_major_update'
recovery_target_action = 'promote'
```

### Sc√©nario 5 : Restauration en Mode Pause pour Investigation

**Contexte** : Vous voulez inspecter la base avant de la promouvoir.

**Configuration** :
```conf
restore_command = 'cp /mnt/wal_archive/%f %p'
recovery_target_time = '2025-11-22 14:36:59'
recovery_target_action = 'pause'
```

**Apr√®s d√©marrage** :
```sql
-- Connexion en lecture seule possible
SELECT * FROM clients WHERE id = 123;

-- Si satisfait, promouvoir
SELECT pg_wal_replay_resume();
SELECT pg_promote();

-- Si pas satisfait, arr√™ter et r√©essayer avec autre timestamp
```

---

## Param√®tres Avanc√©s de R√©cup√©ration

### Param√®tres de Ciblage

```conf
# Restaurer jusqu'√† un timestamp
recovery_target_time = '2025-11-22 14:30:00'

# Restaurer jusqu'√† une transaction ID
recovery_target_xid = '12345678'

# Restaurer jusqu'√† un point nomm√©
recovery_target_name = 'before_migration'

# Restaurer jusqu'√† un LSN (Log Sequence Number)
recovery_target_lsn = '0/42000028'

# Restaurer jusqu'√† la fin disponible (d√©faut si aucun target)
# (Pas de param√®tre = restaurer tout ce qui est possible)

# Mode "immediate" : S'arr√™ter d√®s que consistant
recovery_target = 'immediate'
```

### Contr√¥le d'Inclusion

```conf
# Inclure ou exclure la transaction/point cible
recovery_target_inclusive = true   # Inclure (d√©faut)
recovery_target_inclusive = false  # Exclure
```

**Exemple d'usage** :
```conf
# Arr√™ter AVANT une transaction probl√©matique
recovery_target_xid = '12345678'
recovery_target_inclusive = false
```

### Actions Post-R√©cup√©ration

```conf
# Promouvoir automatiquement
recovery_target_action = 'promote'

# Mettre en pause (inspection possible)
recovery_target_action = 'pause'

# Arr√™ter PostgreSQL
recovery_target_action = 'shutdown'
```

### Timeline

PostgreSQL utilise le concept de **timeline** pour g√©rer les divergences apr√®s PITR.

```conf
# Suivre une timeline sp√©cifique
recovery_target_timeline = '2'

# Suivre la timeline la plus r√©cente (d√©faut)
recovery_target_timeline = 'latest'
```

**Explication** :
- Chaque fois que vous faites un PITR, une nouvelle timeline est cr√©√©e
- Cela √©vite de "m√©langer" les WAL d'une ancienne r√©alit√© avec une nouvelle

**Exemple** :
```
Timeline 1 : Production normale
    ‚îú‚îÄ Incident √† 14h37
    ‚îî‚îÄ PITR vers 14h36 ‚Üí Cr√©e Timeline 2
         ‚îî‚îÄ Nouvelles transactions sur Timeline 2
```

---

## Outils et Commandes Utiles

### Inspection des WAL

#### pg_waldump : Lire le Contenu d'un WAL

```bash
# Lire un fichier WAL sp√©cifique
pg_waldump /var/lib/postgresql/18/main/pg_wal/000000010000000000000042

# Lire avec filtre sur une table
pg_waldump -r heap 000000010000000000000042

# Chercher des transactions sp√©cifiques
pg_waldump 000000010000000000000042 | grep "COMMIT"

# Statistiques
pg_waldump -z 000000010000000000000042
```

**Exemple de sortie** :
```
rmgr: Heap        len (rec/tot):     59/    59, tx:       1234, lsn: 0/42001A78, prev 0/42001A40, desc: INSERT off 3, blkref #0: rel 1663/16384/16385 blk 0
rmgr: Transaction len (rec/tot):     34/    34, tx:       1234, lsn: 0/42001AB8, prev 0/42001A78, desc: COMMIT 2025-11-22 14:35:42.123456 CET
```

#### pg_controldata : Informations de Contr√¥le

```bash
pg_controldata /var/lib/postgresql/18/main
```

**Informations utiles** :
- Latest checkpoint location (LSN)
- Latest checkpoint's REDO location
- Latest checkpoint's TimeLineID
- Min recovery ending location

### Commandes SQL Utiles

#### Forcer un Switch de WAL

```sql
-- Forcer PostgreSQL √† fermer le WAL actuel et en cr√©er un nouveau
SELECT pg_switch_wal();
```

**Usage** : Avant une sauvegarde ou pour tester l'archivage.

#### Cr√©er un Point de Restauration

```sql
SELECT pg_create_restore_point('before_risky_operation');
```

#### Obtenir la Position WAL Actuelle

```sql
-- Position actuelle d'√©criture
SELECT pg_current_wal_lsn();

-- Position de replay (sur un standby ou en recovery)
SELECT pg_last_wal_replay_lsn();

-- Diff√©rence entre deux LSN
SELECT pg_wal_lsn_diff('0/43000000', '0/42000000');
-- Retourne : 16777216 (16 MB)
```

#### Informations sur l'Archivage

```sql
-- Statistiques d'archivage
SELECT * FROM pg_stat_archiver;

-- Fichiers WAL en attente d'archivage
SELECT * FROM pg_stat_wal;

-- Configuration actuelle
SHOW archive_mode;
SHOW archive_command;
```

### Timeline Management

```sql
-- Voir les timelines disponibles
SELECT * FROM pg_controldata_timeline();

-- Informations sur la timeline actuelle
SHOW timeline_id;
```

---

## Automatisation et Scripts

### Script Complet de Configuration PITR

```bash
#!/bin/bash
# setup_pitr.sh - Configuration compl√®te PITR

set -e  # Arr√™t en cas d'erreur

# Configuration
WAL_ARCHIVE_DIR="/mnt/wal_archive"
BACKUP_DIR="/backups/pitr"
PG_DATA="/var/lib/postgresql/18/main"
PG_CONF="${PG_DATA}/postgresql.conf"

echo "=== Configuration PostgreSQL PITR ==="

# 1. Cr√©er les r√©pertoires
echo "Cr√©ation des r√©pertoires..."
sudo mkdir -p ${WAL_ARCHIVE_DIR}
sudo mkdir -p ${BACKUP_DIR}

sudo chown postgres:postgres ${WAL_ARCHIVE_DIR}
sudo chown postgres:postgres ${BACKUP_DIR}
sudo chmod 700 ${WAL_ARCHIVE_DIR}
sudo chmod 700 ${BACKUP_DIR}

# 2. Configurer postgresql.conf
echo "Configuration de postgresql.conf..."
sudo tee -a ${PG_CONF} << EOF

# === PITR Configuration ===
wal_level = replica
max_wal_senders = 5
wal_keep_size = 1GB
archive_mode = on
archive_command = 'test ! -f ${WAL_ARCHIVE_DIR}/%f && cp %p ${WAL_ARCHIVE_DIR}/%f'
archive_timeout = 300
EOF

# 3. Red√©marrer PostgreSQL
echo "Red√©marrage de PostgreSQL..."
sudo systemctl restart postgresql

# 4. V√©rifier la configuration
echo "V√©rification..."
sleep 3
psql -U postgres -c "SHOW wal_level;"
psql -U postgres -c "SHOW archive_mode;"
psql -U postgres -c "SELECT pg_switch_wal();"
sleep 2
psql -U postgres -c "SELECT * FROM pg_stat_archiver;"

# 5. Cr√©er la premi√®re sauvegarde de base
echo "Cr√©ation de la premi√®re sauvegarde de base..."
DATE=$(date +%Y%m%d_%H%M)
pg_basebackup -D ${BACKUP_DIR}/base_${DATE} -U postgres -X stream -c fast -P

echo "‚úÖ Configuration PITR termin√©e avec succ√®s !"
echo "Archive WAL : ${WAL_ARCHIVE_DIR}"
echo "Sauvegardes : ${BACKUP_DIR}"
echo "Premi√®re sauvegarde : ${BACKUP_DIR}/base_${DATE}"
```

### Script de Restauration PITR

```bash
#!/bin/bash
# restore_pitr.sh - Restauration PITR automatis√©e

set -e

# Configuration
PG_DATA="/var/lib/postgresql/18/main"
WAL_ARCHIVE_DIR="/mnt/wal_archive"
BACKUP_DIR="/backups/pitr"
TARGET_TIME=""

# Aide
usage() {
    echo "Usage: $0 -t 'YYYY-MM-DD HH:MM:SS' [-b backup_path]"
    echo "Exemple: $0 -t '2025-11-22 14:36:59'"
    exit 1
}

# Parse arguments
while getopts "t:b:h" opt; do
    case ${opt} in
        t) TARGET_TIME=$OPTARG ;;
        b) BACKUP_PATH=$OPTARG ;;
        h) usage ;;
        *) usage ;;
    esac
done

if [ -z "${TARGET_TIME}" ]; then
    echo "Erreur: Target time requis"
    usage
fi

# Trouver la derni√®re sauvegarde si non sp√©cifi√©e
if [ -z "${BACKUP_PATH}" ]; then
    BACKUP_PATH=$(ls -td ${BACKUP_DIR}/base_* | head -1)
    echo "Utilisation de la derni√®re sauvegarde: ${BACKUP_PATH}"
fi

if [ ! -d "${BACKUP_PATH}" ]; then
    echo "Erreur: Backup path invalide: ${BACKUP_PATH}"
    exit 1
fi

# Confirmation
echo "=== Restauration PITR ==="
echo "Backup source: ${BACKUP_PATH}"
echo "Target time: ${TARGET_TIME}"
echo "WAL archive: ${WAL_ARCHIVE_DIR}"
read -p "Continuer? (yes/no): " CONFIRM

if [ "${CONFIRM}" != "yes" ]; then
    echo "Annul√©"
    exit 0
fi

# 1. Arr√™ter PostgreSQL
echo "Arr√™t de PostgreSQL..."
sudo systemctl stop postgresql

# 2. Sauvegarder les donn√©es actuelles
echo "Sauvegarde des donn√©es actuelles..."
sudo mv ${PG_DATA} ${PG_DATA}.before_pitr_$(date +%Y%m%d_%H%M%S)

# 3. Restaurer la sauvegarde de base
echo "Restauration de la sauvegarde de base..."
sudo cp -a ${BACKUP_PATH} ${PG_DATA}

# 4. Cr√©er recovery.signal
echo "Configuration de la r√©cup√©ration..."
sudo touch ${PG_DATA}/recovery.signal

# 5. Configurer les param√®tres de r√©cup√©ration
sudo tee ${PG_DATA}/recovery.conf << EOF
restore_command = 'cp ${WAL_ARCHIVE_DIR}/%f %p'
recovery_target_time = '${TARGET_TIME}'
recovery_target_action = 'promote'
EOF

# 6. Permissions
sudo chown -R postgres:postgres ${PG_DATA}
sudo chmod 700 ${PG_DATA}

# 7. D√©marrer PostgreSQL
echo "D√©marrage de PostgreSQL en mode recovery..."
sudo systemctl start postgresql

# 8. Monitoring
echo "=== Surveillance de la r√©cup√©ration ==="
echo "Logs: sudo tail -f /var/log/postgresql/postgresql-18-main.log"
echo "√âtat: psql -U postgres -c \"SELECT pg_is_in_recovery();\""
```

### Script de Monitoring PITR

```bash
#!/bin/bash
# monitor_pitr.sh - Surveillance continue du syst√®me PITR

# Configuration
WAL_ARCHIVE_DIR="/mnt/wal_archive"
ALERT_EMAIL="admin@company.com"

# Fonction d'alerte
alert() {
    local MESSAGE=$1
    echo "[ALERT] ${MESSAGE}"
    echo "${MESSAGE}" | mail -s "PostgreSQL PITR Alert" ${ALERT_EMAIL}
}

# 1. V√©rifier l'archivage WAL
echo "V√©rification de l'archivage WAL..."
FAILED_COUNT=$(psql -U postgres -t -c "SELECT failed_count FROM pg_stat_archiver;" | tr -d ' ')
LAST_ARCHIVE=$(psql -U postgres -t -c "SELECT EXTRACT(EPOCH FROM (now() - last_archived_time)) FROM pg_stat_archiver;" | tr -d ' ')

if [ ${FAILED_COUNT} -gt 0 ]; then
    alert "Archivage WAL √©chou√©: ${FAILED_COUNT} √©checs"
fi

if (( $(echo "${LAST_ARCHIVE} > 3600" | bc -l) )); then
    alert "Aucun archivage depuis ${LAST_ARCHIVE} secondes"
fi

# 2. V√©rifier l'espace disque archive
echo "V√©rification de l'espace disque..."
DISK_USAGE=$(df ${WAL_ARCHIVE_DIR} | tail -1 | awk '{print $5}' | sed 's/%//')
if [ ${DISK_USAGE} -gt 80 ]; then
    alert "Espace disque archive faible: ${DISK_USAGE}%"
fi

# 3. V√©rifier l'anciennet√© de la derni√®re sauvegarde
LAST_BACKUP=$(find /backups/pitr -name "base_*" -type d | sort | tail -1)
if [ -n "${LAST_BACKUP}" ]; then
    BACKUP_AGE=$(( ($(date +%s) - $(stat -c %Y ${LAST_BACKUP})) / 86400 ))
    if [ ${BACKUP_AGE} -gt 7 ]; then
        alert "Derni√®re sauvegarde de base trop ancienne: ${BACKUP_AGE} jours"
    fi
fi

# 4. V√©rifier le taux de g√©n√©ration WAL
WAL_SIZE=$(du -s --block-size=1M ${WAL_ARCHIVE_DIR} | cut -f1)
echo "Taille archive WAL: ${WAL_SIZE} MB"

echo "‚úÖ Monitoring termin√©"
```

**Cron (toutes les heures)** :
```bash
0 * * * * /usr/local/bin/monitor_pitr.sh
```

---

## Bonnes Pratiques et Recommandations

### ‚úÖ Configuration

1. **Toujours utiliser wal_level = replica minimum**
   - Permet r√©plication et PITR
   - Surco√ªt n√©gligeable

2. **archive_timeout appropri√©**
   - Bases tr√®s actives : 60-300 secondes
   - Bases peu actives : 600-1800 secondes
   - Balance entre RPO et nombre de fichiers

3. **Commande d'archivage robuste**
   ```bash
   # Mauvais : peut √©craser des fichiers
   archive_command = 'cp %p /archive/%f'

   # Bon : v√©rifie l'existence
   archive_command = 'test ! -f /archive/%f && cp %p /archive/%f'
   ```

4. **Redondance de l'archivage**
   - Local + distant
   - Plusieurs copies (3-2-1 rule)

### ‚úÖ Sauvegardes

1. **Fr√©quence adapt√©e**
   - Production critique : Quotidienne
   - Base volumineuse : Hebdomadaire + WAL
   - Compromis : Temps de restauration vs espace

2. **Validation des sauvegardes**
   - Tester la restauration r√©guli√®rement
   - Automatiser les tests (environnement de staging)

3. **Documentation**
   - Proc√©dures de restauration claires
   - Runbook accessible 24/7
   - Temps de restauration estim√©

### ‚úÖ Monitoring

1. **Surveiller pg_stat_archiver**
   - `failed_count` doit rester √† 0
   - `last_archived_time` < 1 heure

2. **Alertes essentielles**
   - √âchec d'archivage
   - Espace disque faible (archive et backup)
   - Sauvegarde de base trop ancienne

3. **M√©triques √† suivre**
   - Taux de g√©n√©ration WAL
   - Taille de l'archive
   - Dur√©e des sauvegardes

### ‚úÖ Op√©rations

1. **Tests r√©guliers**
   - Restauration compl√®te : Mensuelle
   - Restauration PITR : Trimestrielle
   - Drill de disaster recovery : Annuel

2. **Gestion de l'espace**
   - Nettoyer les anciennes archives
   - Coordonner avec les sauvegardes de base
   - Utiliser pgBackRest/Barman pour automatisation

3. **Documentation des incidents**
   - Enregistrer chaque utilisation de PITR
   - Documenter les le√ßons apprises
   - Am√©liorer les proc√©dures

### ‚ùå Pi√®ges √† √âviter

1. **Ne jamais supprimer manuellement des WAL**
   - Utiliser des outils (pgBackRest, Barman)
   - Ou scripts coordonn√©s avec sauvegardes

2. **Ne pas n√©gliger l'espace disque**
   - WAL archives croissent vite
   - Monitoring proactif essentiel

3. **Ne pas oublier les objets globaux**
   - pg_basebackup ne sauvegarde pas les r√¥les
   - Faire aussi `pg_dumpall --globals-only`

4. **Ne pas tester uniquement en th√©orie**
   - La premi√®re restauration en production n'est pas le bon moment pour apprendre

5. **Ne pas m√©langer les timelines**
   - Comprendre le concept de timeline
   - Utiliser `recovery_target_timeline` correctement

---

## D√©pannage et Erreurs Courantes

### Erreur 1 : Archive Command Failed

```
archive command failed with exit code 1
```

**Causes** :
- Permissions insuffisantes
- Espace disque plein
- R√©pertoire d'archive inexistant
- Erreur r√©seau (archivage distant)

**Diagnostic** :
```bash
# Tester la commande manuellement
sudo -u postgres bash -c "cp /var/lib/postgresql/18/main/pg_wal/000000010000000000000001 /mnt/wal_archive/"

# V√©rifier les permissions
ls -ld /mnt/wal_archive/
ls -l /mnt/wal_archive/

# V√©rifier l'espace disque
df -h /mnt/wal_archive/
```

**Solutions** :
```bash
# Corriger les permissions
sudo chown postgres:postgres /mnt/wal_archive/
sudo chmod 700 /mnt/wal_archive/

# Lib√©rer de l'espace
sudo find /mnt/wal_archive/ -mtime +30 -delete
```

### Erreur 2 : Could Not Restore File from Archive

Durant la restauration :
```
could not restore file "000000010000000000000042" from archive: return code 1
```

**Causes** :
- Fichier WAL manquant
- Chemin incorrect dans restore_command
- Permissions

**Solutions** :
```bash
# V√©rifier la pr√©sence du fichier
ls -l /mnt/wal_archive/000000010000000000000042

# Tester restore_command manuellement
sudo -u postgres bash -c "cp /mnt/wal_archive/000000010000000000000042 /tmp/test"

# V√©rifier le contenu de recovery.conf/postgresql.conf
cat /var/lib/postgresql/18/main/recovery.conf
```

### Erreur 3 : Timeline Mismatch

```
requested timeline 2 does not contain minimum recovery point
```

**Cause** : Tentative de restauration sur une timeline incompatible.

**Solution** :
```conf
# Sp√©cifier la bonne timeline
recovery_target_timeline = '1'

# Ou utiliser la plus r√©cente
recovery_target_timeline = 'latest'
```

### Erreur 4 : Recovery End Before Minimum Point

```
recovery ended before reaching consistency
```

**Cause** : Fichiers WAL manquants, sauvegarde incompl√®te.

**Solutions** :
- Utiliser une sauvegarde de base plus r√©cente
- V√©rifier que tous les WAL n√©cessaires sont disponibles
- Utiliser `recovery_target = 'immediate'` si vous acceptez une perte de donn√©es

### Erreur 5 : Requested WAL Segment Already Removed

```
requested WAL segment has already been removed
```

**Cause** : `wal_keep_size` trop petit, WAL recycl√© avant archivage.

**Solutions** :
```conf
# Augmenter wal_keep_size
wal_keep_size = 2GB

# Utiliser un slot de r√©plication
SELECT pg_create_physical_replication_slot('backup_slot');
```

### Erreur 6 : Backup Label Not Found

```
backup label not found
```

**Cause** : La sauvegarde de base est incompl√®te ou corrompue.

**Solution** :
- Utiliser une autre sauvegarde de base
- Refaire une sauvegarde avec pg_basebackup

---

## Cas d'Usage Avanc√©s

### 1. Restauration en Cascade

**Sc√©nario** : Tester plusieurs points de restauration sans refaire la base backup.

```bash
# Restauration √† T1
./restore_pitr.sh -t '2025-11-22 14:00:00'

# Sauvegarder cet √©tat
cp -a /var/lib/postgresql/18/main /backups/test_T1

# Restauration √† T2 (√† partir de T1)
./restore_pitr.sh -t '2025-11-22 15:00:00'
```

### 2. Clone de Production pour D√©veloppement

**Sc√©nario** : Cr√©er un environnement de dev avec donn√©es r√©centes.

```bash
# Sur le serveur de production
pg_basebackup -D /tmp/prod_snapshot -X stream

# Transf√©rer
rsync -avz /tmp/prod_snapshot/ dev-server:/var/lib/postgresql/18/main

# Sur le serveur de dev
cat > /var/lib/postgresql/18/main/recovery.conf << EOF
restore_command = 'cp /mnt/wal_archive/%f %p'
recovery_target_time = '2025-11-22 08:00:00'  # D√©but de journ√©e
recovery_target_action = 'promote'
EOF

touch /var/lib/postgresql/18/main/recovery.signal
systemctl start postgresql
```

### 3. Audit Trail Complet

**Sc√©nario** : Investiguer qui a fait quoi et quand.

```bash
# Examiner les WAL pour une p√©riode sp√©cifique
pg_waldump /mnt/wal_archive/000000010000000000000042 | \
    grep -A 5 "COMMIT" | \
    grep "2025-11-22 14:3"

# Restaurer √† diff√©rents points pour comparer
for TIME in "14:35:00" "14:36:00" "14:37:00"; do
    ./restore_pitr.sh -t "2025-11-22 ${TIME}"
    psql -c "SELECT count(*) FROM clients;" > count_${TIME}.txt
done
```

### 4. Fork de Base de Donn√©es

**Sc√©nario** : Cr√©er deux versions divergentes pour A/B testing.

```bash
# Sauvegarde commune
pg_basebackup -D /backups/common_base

# Version A
cp -a /backups/common_base /var/lib/postgresql/18/variant_a
# Configuration sp√©cifique...

# Version B
cp -a /backups/common_base /var/lib/postgresql/18/variant_b
# Configuration diff√©rente...
```

---

## Comparaison avec Autres Solutions

### PITR vs Streaming Replication

| Aspect | PITR | Streaming Replication |
|--------|------|----------------------|
| **Usage principal** | Disaster recovery | Haute disponibilit√© |
| **R√©cup√©ration** | Minutes √† heures | Secondes (promotion) |
| **Complexit√©** | Moyenne | Moyenne √† √©lev√©e |
| **Co√ªt** | Stockage archive | Serveur standby |
| **Point de restauration** | N'importe quand | Moment actuel ou dernier checkpoint |
| **Combinaison** | ‚úÖ Recommand√© ensemble | ‚úÖ Recommand√© ensemble |

**Recommandation** : Utiliser les deux !
- R√©plication streaming pour HA (failover rapide)
- PITR pour erreurs logiques (suppression accidentelle)

### PITR vs Logical Replication

| Aspect | PITR | Logical Replication |
|--------|------|---------------------|
| **Granularit√©** | Cluster entier | Tables s√©lectionn√©es |
| **Compatibilit√© version** | M√™me majeure | Cross-version possible |
| **Cas d'usage** | Disaster recovery | Migration, consolidation |
| **Complexit√©** | Moyenne | √âlev√©e |

### PITR vs Outils Tiers (Barman, pgBackRest)

**Avantages des outils tiers** :
- ‚úÖ Gestion centralis√©e de multiples serveurs
- ‚úÖ Sauvegardes incr√©mentales
- ‚úÖ Compression avanc√©e
- ‚úÖ Interface de gestion
- ‚úÖ Automatisation compl√®te

**Avantages PITR natif** :
- ‚úÖ Int√©gr√© √† PostgreSQL
- ‚úÖ Pas de d√©pendance externe
- ‚úÖ Simplicit√© pour commencer
- ‚úÖ Bien document√©

**Recommandation** :
- D√©butants / petits environnements : PITR natif
- Environnements complexes : pgBackRest ou Barman

---

## Checklist de Mise en Production

### Configuration Initiale

- [ ] wal_level = replica configur√©
- [ ] max_wal_senders >= 3
- [ ] archive_mode = on
- [ ] archive_command test√© et valid√©
- [ ] R√©pertoire d'archive cr√©√© avec bonnes permissions
- [ ] archive_timeout configur√© selon l'activit√©
- [ ] PostgreSQL red√©marr√©
- [ ] V√©rification pg_stat_archiver

### Sauvegarde et Archivage

- [ ] Premi√®re sauvegarde de base r√©ussie
- [ ] Script de sauvegarde automatique cr√©√©
- [ ] Cron/scheduler configur√©
- [ ] Archives WAL g√©n√©r√©es et stock√©es
- [ ] Redondance des archives (local + distant)
- [ ] Espace disque suffisant (3√ó taille cluster minimum)

### Monitoring

- [ ] Alertes configur√©es (archivage √©chou√©)
- [ ] Alertes configur√©es (espace disque)
- [ ] Alertes configur√©es (sauvegarde ancienne)
- [ ] Monitoring pg_stat_archiver actif
- [ ] Dashboard de surveillance (Grafana/autre)

### Documentation

- [ ] Proc√©dure de restauration document√©e
- [ ] Runbook accessible 24/7
- [ ] Contacts escalade d√©finis
- [ ] RPO/RTO document√©s
- [ ] Emplacements backup/archive document√©s

### Tests

- [ ] Restauration compl√®te test√©e
- [ ] Restauration PITR √† un timestamp test√©e
- [ ] Proc√©dure chronom√©tr√©e (RTO)
- [ ] Tests planifi√©s r√©guli√®rement
- [ ] Drill de disaster recovery planifi√©

### S√©curit√©

- [ ] Permissions restrictives (700)
- [ ] Chiffrement des archives (si requis)
- [ ] Stockage hors-site configur√©
- [ ] R√®gle 3-2-1 appliqu√©e
- [ ] Acc√®s backup/restore restreint

---

## Conclusion

Le Point-In-Time Recovery (PITR) avec WAL archiving est une capacit√© essentielle pour toute installation PostgreSQL en production. Il offre :

- ‚úÖ **Protection contre les erreurs logiques** : Suppression accidentelle, mauvaise mise √† jour
- ‚úÖ **R√©cup√©ration granulaire** : Restauration √† la seconde pr√®s
- ‚úÖ **Flexibilit√©** : Multiples points de restauration possibles
- ‚úÖ **Compl√©ment √† la HA** : Fonctionne avec la r√©plication streaming
- ‚úÖ **Audit trail** : Historique complet des modifications

**Configuration minimale viable** :
```conf
wal_level = replica
archive_mode = on
archive_command = 'test ! -f /archive/%f && cp %p /archive/%f'
```

**Processus de base** :
1. Configurer l'archivage WAL
2. Faire des sauvegardes de base r√©guli√®res (pg_basebackup)
3. Conserver les archives WAL
4. En cas de besoin, restaurer base + replay WAL

**Recommandation finale** :

Pour un syst√®me de production robuste, combinez :
- **PITR** (ce chapitre) : Protection contre erreurs logiques
- **R√©plication Streaming** : Haute disponibilit√©
- **Sauvegardes logiques** (pg_dump) : Portabilit√©
- **Monitoring** : D√©tection proactive des probl√®mes

Cette approche multi-couches offre la meilleure protection possible contre tous les types de pannes et d'erreurs.

---

## Ressources Compl√©mentaires

### Documentation Officielle

- [Continuous Archiving and PITR](https://www.postgresql.org/docs/current/continuous-archiving.html)
- [Write-Ahead Logging (WAL)](https://www.postgresql.org/docs/current/wal-intro.html)
- [Recovery Configuration](https://www.postgresql.org/docs/current/recovery-config.html)

### Outils Recommand√©s

- [pgBackRest](https://pgbackrest.org/) - Backup/restore avec PITR simplifi√©
- [Barman](https://www.pgbarman.org/) - Backup manager avec PITR
- [WAL-G](https://github.com/wal-g/wal-g) - Archival vers cloud

### Articles et Guides

- PostgreSQL Wiki: Point-In-Time Recovery
- 2ndQuadrant Blog: PITR Best Practices
- Percona Blog: Understanding WAL Archiving

### Commandes de R√©f√©rence Rapide

```bash
# Configuration PITR
wal_level = replica
archive_mode = on
archive_command = 'test ! -f /archive/%f && cp %p /archive/%f'

# Sauvegarde de base
pg_basebackup -D /backup -X stream -c fast

# Restauration PITR
# 1. Copier base backup
# 2. Cr√©er recovery.signal
# 3. Configurer postgresql.conf/recovery.conf:
restore_command = 'cp /archive/%f %p'
recovery_target_time = '2025-11-22 14:36:59'
recovery_target_action = 'promote'

# Monitoring
SELECT * FROM pg_stat_archiver;
SELECT pg_current_wal_lsn();
SELECT pg_switch_wal();

# Outils
pg_waldump /path/to/wal/file
pg_controldata /path/to/data/directory
```

---


‚è≠Ô∏è [Strat√©gies de sauvegarde 3-2-1](/16-administration-configuration-securite/11.4-strategies-sauvegarde-321.md)
