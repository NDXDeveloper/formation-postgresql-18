üîù Retour au [Sommaire](/SOMMAIRE.md)

# 16.4.2. Permissions de Sch√©ma et Database

## Introduction

Dans PostgreSQL, la hi√©rarchie des objets suit une structure √† plusieurs niveaux : **Instance ‚Üí Database ‚Üí Schema ‚Üí Objets (Tables, Fonctions, etc.)**. Avant m√™me de pouvoir acc√©der aux tables ou fonctions, un utilisateur doit avoir les permissions appropri√©es au niveau de la **base de donn√©es** et du **sch√©ma**.

Cette section explique comment g√©rer les permissions √† ces deux niveaux essentiels, qui sont souvent n√©glig√©s par les d√©butants mais cruciaux pour une configuration s√©curis√©e.

---

## 1. Comprendre la Hi√©rarchie PostgreSQL

### 1.1. Structure Logique

```
Instance PostgreSQL (Cluster)
    ‚îú‚îÄ‚îÄ Database 1 (ex: production)
    ‚îÇ   ‚îú‚îÄ‚îÄ Schema public
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Table clients
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Table commandes
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Function calculer_tva()
    ‚îÇ   ‚îú‚îÄ‚îÄ Schema marketing
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Table campagnes
    ‚îÇ   ‚îî‚îÄ‚îÄ Schema finance
    ‚îÇ       ‚îî‚îÄ‚îÄ Table factures
    ‚îú‚îÄ‚îÄ Database 2 (ex: dev)
    ‚îî‚îÄ‚îÄ Database 3 (ex: test)
```

### 1.2. Pourquoi Cette Hi√©rarchie Importe ?

Pour qu'un utilisateur puisse acc√©der √† une table, il doit avoir :

1. ‚úÖ **Permission CONNECT** sur la database
2. ‚úÖ **Permission USAGE** sur le schema
3. ‚úÖ **Permission appropri√©e** sur l'objet (SELECT, INSERT, etc.)

Si l'un de ces trois niveaux est manquant, l'acc√®s sera refus√©, m√™me si les autres permissions sont accord√©es.

---

## 2. Permissions sur les DATABASES

### 2.1. Les Diff√©rents Types de Permissions

| Permission | Description | Cas d'usage |
|------------|-------------|-------------|
| **CONNECT** | Se connecter √† la base de donn√©es | N√©cessaire pour tout acc√®s |
| **CREATE** | Cr√©er de nouveaux sch√©mas dans la database | D√©veloppeurs, DBAs |
| **TEMP/TEMPORARY** | Cr√©er des tables temporaires | Sessions de travail, analyses |
| **ALL PRIVILEGES** | Toutes les permissions ci-dessus | Propri√©taire ou administrateur |

### 2.2. La Permission CONNECT

C'est la permission la **plus fondamentale**. Sans elle, impossible de se connecter √† la base de donn√©es.

#### Comportement par D√©faut

Par d√©faut, PostgreSQL accorde **CONNECT √† PUBLIC** sur les nouvelles bases de donn√©es. Cela signifie que **tous les utilisateurs** peuvent se connecter √† toutes les bases.

```sql
-- V√©rifier les permissions par d√©faut
\l+

-- Ou via SQL
SELECT datname, datacl
FROM pg_database
WHERE datname = 'production';
```

R√©sultat typique :
```
  datname    |          datacl
-------------+---------------------------
 production  | {=Tc/postgres,postgres=CTc/postgres}
```

Le `=Tc` signifie que PUBLIC a les permissions TEMP et CONNECT.

#### Exemple 1 : Probl√®me Courant - Utilisateur Sans CONNECT

Cr√©ons un utilisateur qui ne peut pas se connecter :

```sql
-- Cr√©er un utilisateur
CREATE ROLE user_bloque LOGIN PASSWORD 'mot_de_passe';

-- R√©voquer CONNECT pour tout le monde sur la database
REVOKE CONNECT ON DATABASE production FROM PUBLIC;

-- L'utilisateur essaie de se connecter
psql -U user_bloque -d production
-- ‚ùå Erreur : FATAL: permission denied for database "production"
```

#### Exemple 2 : Solution - Accorder CONNECT

```sql
-- Accorder explicitement CONNECT
GRANT CONNECT ON DATABASE production TO user_bloque;

-- Maintenant la connexion fonctionne
psql -U user_bloque -d production  -- ‚úÖ OK
```

#### Exemple 3 : S√©curiser une Base de Donn√©es

Pour une base de donn√©es de production, il est recommand√© de r√©voquer l'acc√®s public et d'accorder explicitement les permissions :

```sql
-- R√©voquer l'acc√®s public
REVOKE ALL ON DATABASE production FROM PUBLIC;

-- Cr√©er des r√¥les sp√©cifiques
CREATE ROLE app_production LOGIN PASSWORD 'secure_password';
CREATE ROLE lecteur_production LOGIN PASSWORD 'secure_password';

-- Accorder CONNECT uniquement aux r√¥les autoris√©s
GRANT CONNECT ON DATABASE production TO app_production;
GRANT CONNECT ON DATABASE production TO lecteur_production;
```

### 2.3. La Permission CREATE

Cette permission permet de cr√©er de nouveaux sch√©mas dans la base de donn√©es.

#### Exemple 1 : Cr√©er un Sch√©ma

```sql
-- Accorder CREATE sur la database
GRANT CREATE ON DATABASE production TO developpeur;

-- Le d√©veloppeur peut maintenant cr√©er des sch√©mas
CREATE SCHEMA mon_nouveau_schema;  -- ‚úÖ OK
```

‚ö†Ô∏è **Attention** : Cette permission est puissante. Un utilisateur avec CREATE peut cr√©er des sch√©mas et y placer des objets. R√©servez-la aux d√©veloppeurs et DBAs.

#### Exemple 2 : Environnement de D√©veloppement

Dans un environnement de d√©veloppement, vous pouvez √™tre plus permissif :

```sql
-- Base de donn√©es de dev
CREATE DATABASE dev;

-- Cr√©er un r√¥le d√©veloppeur
CREATE ROLE developpeurs;

-- Accorder CREATE pour exp√©rimenter
GRANT CREATE ON DATABASE dev TO developpeurs;

-- Ajouter des utilisateurs au groupe
CREATE ROLE dev1 LOGIN PASSWORD 'pass';
GRANT developpeurs TO dev1;
```

### 2.4. La Permission TEMPORARY

Cette permission permet de cr√©er des tables temporaires durant une session.

#### Utilit√© des Tables Temporaires

Les tables temporaires sont utiles pour :
- Stocker des r√©sultats interm√©diaires
- Analyser des donn√©es sans modifier la base
- Effectuer des calculs complexes

#### Exemple

```sql
-- Accorder la permission TEMP
GRANT TEMP ON DATABASE production TO analyste;

-- L'analyste peut cr√©er des tables temporaires
CREATE TEMP TABLE calculs_intermediaires (
    id INTEGER,
    resultat NUMERIC
);

-- La table est automatiquement supprim√©e √† la fin de la session
```

### 2.5. R√©voquer des Permissions sur Database

```sql
-- R√©voquer CONNECT
REVOKE CONNECT ON DATABASE production FROM utilisateur;

-- R√©voquer CREATE
REVOKE CREATE ON DATABASE production FROM developpeur;

-- R√©voquer toutes les permissions
REVOKE ALL PRIVILEGES ON DATABASE production FROM utilisateur;
```

### 2.6. V√©rifier les Permissions sur Database

#### Via psql

```sql
-- Lister les databases et leurs permissions
\l

-- Avec d√©tails
\l+
```

#### Via SQL

```sql
-- Permissions sur une database sp√©cifique
SELECT
    datname AS database,
    datacl AS permissions
FROM pg_database
WHERE datname = 'production';

-- D√©coder les permissions (plus lisible)
SELECT
    datname,
    (aclexplode(datacl)).grantee::regrole AS role,
    (aclexplode(datacl)).privilege_type AS privilege
FROM pg_database
WHERE datname = 'production';
```

---

## 3. Permissions sur les SCHEMAS

### 3.1. Qu'est-ce qu'un Sch√©ma ?

Un sch√©ma est un **namespace** (espace de noms) qui contient des objets de base de donn√©es (tables, vues, fonctions, etc.). Il sert √† :

- **Organiser** les objets logiquement
- **Isoler** diff√©rentes applications ou modules
- **G√©rer** les permissions de mani√®re granulaire
- **√âviter** les conflits de noms

#### Le Sch√©ma "public"

Par d√©faut, PostgreSQL cr√©e un sch√©ma nomm√© `public` dans chaque base de donn√©es. Si vous ne sp√©cifiez pas de sch√©ma, les objets sont cr√©√©s dans `public`.

```sql
-- Ces deux commandes sont √©quivalentes
CREATE TABLE clients (id SERIAL);
CREATE TABLE public.clients (id SERIAL);
```

### 3.2. Le Concept de search_path

Le `search_path` d√©termine l'ordre dans lequel PostgreSQL cherche les objets lorsqu'ils ne sont pas qualifi√©s par un sch√©ma.

```sql
-- Voir le search_path actuel
SHOW search_path;
-- R√©sultat typique : "$user", public

-- Modifier le search_path
SET search_path TO mon_schema, public;
```

**Explication** :
- PostgreSQL cherche d'abord dans `mon_schema`
- Puis dans `public` si l'objet n'est pas trouv√© dans `mon_schema`

### 3.3. Les Diff√©rents Types de Permissions

| Permission | Description | Cas d'usage |
|------------|-------------|-------------|
| **USAGE** | Acc√©der aux objets du sch√©ma | N√©cessaire pour tout acc√®s aux objets |
| **CREATE** | Cr√©er de nouveaux objets dans le sch√©ma | D√©veloppeurs qui doivent cr√©er tables/fonctions |
| **ALL PRIVILEGES** | USAGE + CREATE | Propri√©taire ou administrateur du sch√©ma |

### 3.4. La Permission USAGE

C'est la permission **essentielle** pour acc√©der aux objets d'un sch√©ma. Sans elle, m√™me si vous avez SELECT sur une table, vous ne pourrez pas y acc√©der.

#### Exemple 1 : Probl√®me Courant - USAGE Manquant

Cr√©ons un sch√©ma et une table :

```sql
-- Cr√©er un sch√©ma
CREATE SCHEMA marketing;

-- Cr√©er une table dans ce sch√©ma
CREATE TABLE marketing.campagnes (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    budget NUMERIC
);

-- Cr√©er un utilisateur
CREATE ROLE utilisateur_marketing LOGIN PASSWORD 'pass';

-- Accorder SELECT sur la table
GRANT SELECT ON TABLE marketing.campagnes TO utilisateur_marketing;

-- L'utilisateur essaie d'acc√©der
SELECT * FROM marketing.campagnes;
-- ‚ùå Erreur : permission denied for schema marketing
```

**Pourquoi ?** L'utilisateur a SELECT sur la table, mais **pas USAGE sur le sch√©ma**.

#### Exemple 2 : Solution - Accorder USAGE

```sql
-- Accorder USAGE sur le sch√©ma
GRANT USAGE ON SCHEMA marketing TO utilisateur_marketing;

-- Maintenant √ßa fonctionne
SELECT * FROM marketing.campagnes;  -- ‚úÖ OK
```

#### Exemple 3 : Configuration Standard pour une Application

```sql
-- Cr√©er des sch√©mas pour diff√©rents modules
CREATE SCHEMA app_public;   -- Donn√©es publiques
CREATE SCHEMA app_internal; -- Donn√©es internes
CREATE SCHEMA app_admin;    -- Donn√©es d'administration

-- Cr√©er un r√¥le pour l'application
CREATE ROLE app_backend LOGIN PASSWORD 'secure_password';

-- Accorder USAGE sur les sch√©mas n√©cessaires
GRANT USAGE ON SCHEMA app_public TO app_backend;
GRANT USAGE ON SCHEMA app_internal TO app_backend;
-- Pas d'acc√®s √† app_admin

-- Puis accorder les permissions sur les objets
GRANT SELECT, INSERT, UPDATE ON ALL TABLES IN SCHEMA app_public TO app_backend;
GRANT SELECT, INSERT, UPDATE ON ALL TABLES IN SCHEMA app_internal TO app_backend;
```

### 3.5. La Permission CREATE

Cette permission permet de cr√©er de nouveaux objets (tables, fonctions, etc.) dans le sch√©ma.

#### Exemple 1 : D√©veloppeur qui Cr√©e des Tables

```sql
-- Cr√©er un sch√©ma de d√©veloppement
CREATE SCHEMA dev_workspace;

-- Accorder USAGE et CREATE
GRANT USAGE, CREATE ON SCHEMA dev_workspace TO developpeur;

-- Le d√©veloppeur peut maintenant cr√©er des objets
CREATE TABLE dev_workspace.test_table (id INTEGER);  -- ‚úÖ OK
CREATE FUNCTION dev_workspace.test_func() RETURNS INTEGER AS $$ ... $$;  -- ‚úÖ OK
```

#### Exemple 2 : S√©paration D√©veloppement / Production

```sql
-- Sch√©ma de production (restrictif)
CREATE SCHEMA production;
GRANT USAGE ON SCHEMA production TO app_backend;
-- Pas de CREATE : les objets sont cr√©√©s par migration

-- Sch√©ma de d√©veloppement (permissif)
CREATE SCHEMA dev;
GRANT USAGE, CREATE ON SCHEMA dev TO developpeur;
-- Les d√©veloppeurs peuvent exp√©rimenter librement
```

### 3.6. Comportement par D√©faut du Sch√©ma "public"

‚ö†Ô∏è **Attention** : Par d√©faut, PostgreSQL accorde **CREATE sur le sch√©ma public √† PUBLIC** (tous les utilisateurs). C'est un risque de s√©curit√© !

```sql
-- V√©rifier les permissions par d√©faut
\dn+ public
```

R√©sultat typique :
```
  Name  |  Owner   |  Access privileges
--------+----------+---------------------
 public | postgres | postgres=UC/postgres+
        |          | =UC/postgres
```

Le `=UC` signifie que PUBLIC a USAGE et CREATE sur le sch√©ma public.

#### S√©curiser le Sch√©ma Public

**Bonne pratique** : R√©voquer CREATE du sch√©ma public pour √©viter que n'importe qui puisse cr√©er des objets :

```sql
-- R√©voquer CREATE sur public pour tout le monde
REVOKE CREATE ON SCHEMA public FROM PUBLIC;

-- Garder USAGE pour que les utilisateurs puissent acc√©der aux objets existants
-- (USAGE est d√©j√† accord√© par d√©faut, mais on peut le rendre explicite)
GRANT USAGE ON SCHEMA public TO PUBLIC;
```

Maintenant :
- Tous les utilisateurs peuvent **acc√©der** aux objets dans public (USAGE)
- Mais seuls les utilisateurs autoris√©s peuvent **cr√©er** de nouveaux objets

### 3.7. R√©voquer des Permissions sur Sch√©ma

```sql
-- R√©voquer USAGE
REVOKE USAGE ON SCHEMA marketing FROM utilisateur;

-- R√©voquer CREATE
REVOKE CREATE ON SCHEMA dev FROM developpeur;

-- R√©voquer toutes les permissions
REVOKE ALL PRIVILEGES ON SCHEMA marketing FROM utilisateur;
```

### 3.8. V√©rifier les Permissions sur Sch√©ma

#### Via psql

```sql
-- Lister les sch√©mas et leurs permissions
\dn+
```

#### Via SQL

```sql
-- Permissions sur un sch√©ma sp√©cifique
SELECT
    nspname AS schema_name,
    nspacl AS permissions
FROM pg_namespace
WHERE nspname = 'marketing';

-- D√©coder les permissions (plus lisible)
SELECT
    n.nspname AS schema_name,
    r.rolname AS grantee,
    p.privilege_type
FROM pg_namespace n
CROSS JOIN LATERAL aclexplode(n.nspacl) AS acl
JOIN pg_roles r ON acl.grantee = r.oid
CROSS JOIN LATERAL (
    SELECT
        CASE acl.privilege_type
            WHEN 'CREATE' THEN 'CREATE'
            WHEN 'USAGE' THEN 'USAGE'
        END AS privilege_type
) p
WHERE n.nspname = 'marketing';
```

---

## 4. Workflow Complet : Database ‚Üí Schema ‚Üí Objets

Pour qu'un utilisateur puisse r√©ellement travailler avec des donn√©es, voici le workflow complet des permissions √† accorder.

### 4.1. Exemple Complet : Application Web

```sql
-- 1. Cr√©er la base de donn√©es
CREATE DATABASE app_production;

-- 2. Se connecter √† la base
\c app_production

-- 3. S√©curiser la base de donn√©es
REVOKE ALL ON DATABASE app_production FROM PUBLIC;
REVOKE CREATE ON SCHEMA public FROM PUBLIC;

-- 4. Cr√©er des sch√©mas
CREATE SCHEMA app_data;
CREATE SCHEMA app_logs;

-- 5. Cr√©er des tables
CREATE TABLE app_data.users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100)
);

CREATE TABLE app_logs.access_logs (
    id SERIAL PRIMARY KEY,
    user_id INTEGER,
    timestamp TIMESTAMPTZ,
    action VARCHAR(50)
);

-- 6. Cr√©er un r√¥le pour l'application
CREATE ROLE app_backend LOGIN PASSWORD 'secure_password_here';

-- 7. Accorder les permissions (dans l'ordre !)

-- 7a. Niveau DATABASE
GRANT CONNECT ON DATABASE app_production TO app_backend;

-- 7b. Niveau SCHEMA
GRANT USAGE ON SCHEMA app_data TO app_backend;
GRANT USAGE ON SCHEMA app_logs TO app_backend;

-- 7c. Niveau OBJETS
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE app_data.users TO app_backend;
GRANT INSERT ON TABLE app_logs.access_logs TO app_backend;

-- 7d. Niveau SEQUENCES (pour les SERIAL)
GRANT USAGE ON ALL SEQUENCES IN SCHEMA app_data TO app_backend;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA app_logs TO app_backend;
```

Maintenant, `app_backend` peut :
- ‚úÖ Se connecter √† `app_production`
- ‚úÖ Acc√©der aux sch√©mas `app_data` et `app_logs`
- ‚úÖ Lire/modifier les donn√©es dans `users`
- ‚úÖ Ins√©rer des logs dans `access_logs`

### 4.2. Exemple : Utilisateur en Lecture Seule

```sql
-- Cr√©er un r√¥le pour les analystes
CREATE ROLE analyste LOGIN PASSWORD 'secure_password';

-- Permissions minimales pour lecture seule
GRANT CONNECT ON DATABASE app_production TO analyste;
GRANT USAGE ON SCHEMA app_data TO analyste;
GRANT SELECT ON ALL TABLES IN SCHEMA app_data TO analyste;
```

### 4.3. Exemple : Plusieurs √âquipes, Plusieurs Sch√©mas

```sql
-- √âquipe Marketing
CREATE SCHEMA marketing;
CREATE ROLE equipe_marketing;
GRANT USAGE, CREATE ON SCHEMA marketing TO equipe_marketing;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA marketing TO equipe_marketing;

-- √âquipe Finance
CREATE SCHEMA finance;
CREATE ROLE equipe_finance;
GRANT USAGE, CREATE ON SCHEMA finance TO equipe_finance;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA finance TO equipe_finance;

-- √âquipe Marketing ne peut PAS acc√©der au sch√©ma Finance, et vice versa
-- (pas de USAGE accord√© sur le sch√©ma de l'autre √©quipe)
```

---

## 5. Bonnes Pratiques

### 5.1. Toujours S√©curiser les Nouvelles Databases

Lors de la cr√©ation d'une nouvelle base de donn√©es :

```sql
-- Template pour nouvelle database s√©curis√©e
CREATE DATABASE nouvelle_base;
\c nouvelle_base

-- S√©curisation imm√©diate
REVOKE ALL ON DATABASE nouvelle_base FROM PUBLIC;
REVOKE CREATE ON SCHEMA public FROM PUBLIC;

-- Puis accorder explicitement selon les besoins
```

### 5.2. Utiliser des Sch√©mas pour Isoler

Au lieu de tout mettre dans `public`, cr√©ez des sch√©mas logiques :

```sql
-- Mauvaise pratique : tout dans public
CREATE TABLE public.users (...);
CREATE TABLE public.products (...);
CREATE TABLE public.orders (...);
CREATE TABLE public.admin_settings (...);

-- Bonne pratique : sch√©mas logiques
CREATE SCHEMA app;
CREATE TABLE app.users (...);
CREATE TABLE app.products (...);
CREATE TABLE app.orders (...);

CREATE SCHEMA admin;
CREATE TABLE admin.settings (...);
CREATE TABLE admin.audit_logs (...);
```

Avantages :
- üîí Isolation des permissions
- üìÅ Organisation claire
- üéØ Contr√¥le granulaire

### 5.3. Ne Pas Oublier les S√©quences

Lorsque vous accordez des permissions sur des sch√©mas, n'oubliez pas les s√©quences :

```sql
-- Accorder les permissions sur le sch√©ma
GRANT USAGE ON SCHEMA app_data TO app_backend;

-- Accorder sur les tables
GRANT SELECT, INSERT, UPDATE ON ALL TABLES IN SCHEMA app_data TO app_backend;

-- ‚ö†Ô∏è NE PAS OUBLIER les s√©quences !
GRANT USAGE ON ALL SEQUENCES IN SCHEMA app_data TO app_backend;
```

### 5.4. Ordre Logique des Permissions

Accordez toujours les permissions dans cet ordre :

1. **Database** (CONNECT)
2. **Schema** (USAGE)
3. **Objets** (SELECT, INSERT, etc.)
4. **S√©quences** (USAGE)

Ne sautez pas d'√©tapes !

### 5.5. Documenter l'Architecture des Sch√©mas

```sql
-- Commentaires sur les sch√©mas pour documentation
COMMENT ON SCHEMA app_data IS 'Donn√©es de l''application principale';
COMMENT ON SCHEMA app_logs IS 'Logs d''audit et de tra√ßabilit√©';
COMMENT ON SCHEMA app_cache IS 'Tables de cache temporaire';

-- Consulter les commentaires
SELECT
    schemaname,
    obj_description(oid, 'pg_namespace') AS description
FROM pg_namespace n
JOIN pg_class c ON n.oid = c.relnamespace
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
GROUP BY schemaname, n.oid;
```

### 5.6. Tester les Permissions

Apr√®s avoir configur√© les permissions, testez avec chaque r√¥le :

```sql
-- Se connecter en tant que l'utilisateur
\c app_production app_backend

-- Tester l'acc√®s
SELECT * FROM app_data.users LIMIT 1;
INSERT INTO app_logs.access_logs (user_id, action) VALUES (1, 'test');

-- Si erreur, v√©rifier les permissions √† chaque niveau
```

### 5.7. Automatiser avec des Scripts

Cr√©ez des scripts de gestion des permissions :

```sql
-- Script : grant_app_permissions.sql
-- Usage : Accorder les permissions standard pour l'application

BEGIN;

GRANT CONNECT ON DATABASE app_production TO :username;
GRANT USAGE ON SCHEMA app_data TO :username;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA app_data TO :username;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA app_data TO :username;

COMMIT;

-- Utilisation :
-- psql -v username=nouveau_user -f grant_app_permissions.sql
```

---

## 6. Sc√©narios Pratiques

### Sc√©nario 1 : Migration d'une Application Monolithique

Vous avez une application monolithique avec tout dans `public`. Vous souhaitez migrer vers une architecture multi-sch√©mas.

```sql
-- √âtat initial : tout dans public
-- public.users, public.orders, public.products, etc.

-- 1. Cr√©er les nouveaux sch√©mas
CREATE SCHEMA app_users;
CREATE SCHEMA app_commerce;
CREATE SCHEMA app_reports;

-- 2. Migrer les tables (exemple simplifi√©)
ALTER TABLE public.users SET SCHEMA app_users;
ALTER TABLE public.orders SET SCHEMA app_commerce;
ALTER TABLE public.products SET SCHEMA app_commerce;

-- 3. Mettre √† jour les permissions
GRANT USAGE ON SCHEMA app_users TO app_backend;
GRANT USAGE ON SCHEMA app_commerce TO app_backend;
GRANT USAGE ON SCHEMA app_reports TO app_reporting;

-- 4. Mettre √† jour le search_path pour compatibilit√© temporaire
ALTER ROLE app_backend SET search_path TO app_users, app_commerce, public;
```

### Sc√©nario 2 : Base de Donn√©es Partag√©e entre Plusieurs Applications

Plusieurs applications partagent la m√™me instance PostgreSQL mais doivent √™tre isol√©es.

```sql
-- Database partag√©e
CREATE DATABASE shared_db;
\c shared_db

-- S√©curisation
REVOKE ALL ON DATABASE shared_db FROM PUBLIC;

-- Application 1
CREATE SCHEMA app1;
CREATE ROLE app1_user LOGIN PASSWORD 'pass1';
GRANT CONNECT ON DATABASE shared_db TO app1_user;
GRANT USAGE, CREATE ON SCHEMA app1 TO app1_user;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA app1 TO app1_user;

-- Application 2
CREATE SCHEMA app2;
CREATE ROLE app2_user LOGIN PASSWORD 'pass2';
GRANT CONNECT ON DATABASE shared_db TO app2_user;
GRANT USAGE, CREATE ON SCHEMA app2 TO app2_user;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA app2 TO app2_user;

-- R√©sultat : Isolation compl√®te
-- app1_user ne peut PAS acc√©der au sch√©ma app2
-- app2_user ne peut PAS acc√©der au sch√©ma app1
```

### Sc√©nario 3 : Environnement Multi-Tenant

Chaque client (tenant) a son propre sch√©ma avec une isolation totale.

```sql
-- Fonction pour cr√©er un nouveau tenant
CREATE OR REPLACE FUNCTION creer_tenant(nom_tenant TEXT)
RETURNS VOID AS $$
DECLARE
    schema_name TEXT;
    role_name TEXT;
BEGIN
    schema_name := 'tenant_' || nom_tenant;
    role_name := 'user_' || nom_tenant;

    -- Cr√©er le sch√©ma
    EXECUTE format('CREATE SCHEMA %I', schema_name);

    -- Cr√©er le r√¥le
    EXECUTE format('CREATE ROLE %I LOGIN PASSWORD ''changeme''', role_name);

    -- Accorder les permissions
    EXECUTE format('GRANT USAGE, CREATE ON SCHEMA %I TO %I', schema_name, role_name);

    -- Cr√©er les tables standard
    EXECUTE format('CREATE TABLE %I.users (id SERIAL PRIMARY KEY, name VARCHAR(100))', schema_name);

    -- Accorder les permissions sur les tables
    EXECUTE format('GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA %I TO %I', schema_name, role_name);
    EXECUTE format('GRANT USAGE ON ALL SEQUENCES IN SCHEMA %I TO %I', schema_name, role_name);
END;
$$ LANGUAGE plpgsql;

-- Utilisation
SELECT creer_tenant('client_a');
SELECT creer_tenant('client_b');

-- R√©sultat :
-- Sch√©ma tenant_client_a avec user_client_a
-- Sch√©ma tenant_client_b avec user_client_b
-- Isolation totale entre les clients
```

---

## 7. Diagnostic et Troubleshooting

### 7.1. Erreur : "permission denied for database"

**Cause** : L'utilisateur n'a pas CONNECT sur la database.

**Solution** :
```sql
GRANT CONNECT ON DATABASE ma_base TO mon_utilisateur;
```

### 7.2. Erreur : "permission denied for schema"

**Cause** : L'utilisateur n'a pas USAGE sur le sch√©ma.

**Solution** :
```sql
GRANT USAGE ON SCHEMA mon_schema TO mon_utilisateur;
```

### 7.3. Erreur : "permission denied for table"

Mais l'utilisateur a SELECT sur la table !

**Cause probable** : USAGE manquant sur le sch√©ma.

**V√©rification** :
```sql
-- V√©rifier les permissions sur le sch√©ma
SELECT
    nspname,
    nspacl
FROM pg_namespace
WHERE nspname = 'mon_schema';

-- Si NULL ou pas le bon r√¥le, accorder USAGE
GRANT USAGE ON SCHEMA mon_schema TO mon_utilisateur;
```

### 7.4. Script de Diagnostic Complet

```sql
-- V√©rifier toutes les permissions pour un utilisateur
DO $$
DECLARE
    v_role TEXT := 'mon_utilisateur';  -- Remplacer par le nom du r√¥le
BEGIN
    RAISE NOTICE '=== DIAGNOSTIC PERMISSIONS POUR % ===', v_role;

    -- Database
    RAISE NOTICE 'Database: %', current_database();
    PERFORM 1 FROM pg_database d
    WHERE d.datname = current_database()
    AND has_database_privilege(v_role, d.datname, 'CONNECT');
    IF FOUND THEN
        RAISE NOTICE '  ‚úì CONNECT: OUI';
    ELSE
        RAISE NOTICE '  ‚úó CONNECT: NON';
    END IF;

    -- Schemas
    RAISE NOTICE 'Schemas avec USAGE:';
    FOR rec IN
        SELECT nspname
        FROM pg_namespace
        WHERE has_schema_privilege(v_role, nspname, 'USAGE')
        AND nspname NOT IN ('pg_catalog', 'information_schema')
    LOOP
        RAISE NOTICE '  ‚úì %', rec.nspname;
    END LOOP;
END $$;
```

---

## 8. R√©sum√© et Checklist

### 8.1. Checklist de Configuration

Pour configurer correctement les permissions pour un nouvel utilisateur :

‚úÖ **Niveau Database**
- [ ] CONNECT accord√©
- [ ] TEMP accord√© si n√©cessaire
- [ ] CREATE refus√© (sauf si d√©veloppeur)

‚úÖ **Niveau Schema**
- [ ] USAGE accord√© sur tous les sch√©mas n√©cessaires
- [ ] CREATE accord√© uniquement si n√©cessaire
- [ ] Sch√©ma public s√©curis√© (CREATE r√©voqu√© de PUBLIC)

‚úÖ **Niveau Objets**
- [ ] Permissions accord√©es sur les tables
- [ ] Permissions accord√©es sur les fonctions
- [ ] USAGE accord√© sur les s√©quences

‚úÖ **V√©rification**
- [ ] Tester la connexion avec le r√¥le
- [ ] Tester l'acc√®s aux objets
- [ ] V√©rifier qu'aucun acc√®s non souhait√© n'existe

### 8.2. Points Cl√©s √† Retenir

1. **Hi√©rarchie stricte** : Database ‚Üí Schema ‚Üí Objets
2. **CONNECT est obligatoire** pour acc√©der √† une database
3. **USAGE est obligatoire** pour acc√©der aux objets d'un sch√©ma
4. **S√©curiser le sch√©ma public** en r√©voquant CREATE de PUBLIC
5. **Utiliser des sch√©mas** pour isoler et organiser
6. **Ne pas oublier les s√©quences** lors de l'attribution des permissions
7. **Tester syst√©matiquement** avec chaque r√¥le apr√®s configuration

---

## Conclusion

La gestion des permissions au niveau database et schema est **fondamentale** pour la s√©curit√© de PostgreSQL. Elle constitue les deux premiers niveaux de contr√¥le d'acc√®s, avant m√™me d'arriver aux objets.

Une configuration correcte √† ces niveaux permet de :
- üîí **S√©curiser** : Isolation entre applications et utilisateurs
- üéØ **Organiser** : Structure logique claire
- üõ°Ô∏è **Contr√¥ler** : Acc√®s granulaire et tra√ßable
- üöÄ **Scalabilit√©** : Architecture multi-tenant possible

En ma√Ætrisant ces concepts, vous posez les bases d'une architecture PostgreSQL robuste et s√©curis√©e.

---


‚è≠Ô∏è [Default privileges (ALTER DEFAULT PRIVILEGES)](/16-administration-configuration-securite/04.3-default-privileges.md)
