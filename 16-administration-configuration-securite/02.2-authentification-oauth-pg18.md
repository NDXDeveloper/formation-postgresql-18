üîù Retour au [Sommaire](/SOMMAIRE.md)

# 16.2.2. Nouveaut√© PostgreSQL 18 : Authentification OAuth 2.0

## Introduction

PostgreSQL 18, publi√© en septembre 2025, introduit une fonctionnalit√© majeure attendue depuis longtemps : le **support natif d'OAuth 2.0** pour l'authentification des utilisateurs. Cette nouveaut√© r√©volutionnaire permet √† PostgreSQL de s'int√©grer dans les architectures modernes de gestion d'identit√© (IAM - Identity and Access Management).

> **Pour les d√©butants** : OAuth 2.0 est le syst√®me utilis√© par Google, Microsoft, Facebook, etc. pour vous permettre de vous connecter √† des applications sans partager votre mot de passe. PostgreSQL 18 adopte enfin ce standard moderne !

---

## Qu'est-ce qu'OAuth 2.0 ? (Explication pour D√©butants)

### L'analogie du valet

Imaginez que vous s√©journez dans un h√¥tel (le **serveur d'authentification**) et que vous souhaitez utiliser la salle de sport (PostgreSQL). Au lieu de donner votre cl√© de chambre √† l'accueil de la salle de sport (ce qui serait dangereux), l'h√¥tel vous d√©livre un **badge temporaire** qui :

- ‚úÖ Permet d'acc√©der uniquement √† la salle de sport (pas √† votre chambre)
- ‚úÖ Expire apr√®s quelques heures
- ‚úÖ Peut √™tre r√©voqu√© √† tout moment
- ‚úÖ Ne contient pas vos informations sensibles

**C'est exactement ce qu'OAuth 2.0 fait** : il vous donne un "badge d'acc√®s temporaire" (appel√© **token**) au lieu de partager votre mot de passe.

### Le probl√®me r√©solu par OAuth 2.0

#### Avant OAuth (l'ancien monde) ‚ùå

```
Application Web ‚Üí PostgreSQL
    "Voici le mot de passe de l'utilisateur : SuperSecret123"

Probl√®mes :
- Le mot de passe transite partout
- L'application conna√Æt le mot de passe
- Impossible de r√©voquer l'acc√®s sans changer le mot de passe
- Pas de granularit√© (tout ou rien)
```

#### Avec OAuth 2.0 (le monde moderne) ‚úÖ

```
Utilisateur ‚Üí Serveur OAuth (Google, Azure AD, Okta)
    "Je veux acc√©der √† PostgreSQL"

Serveur OAuth ‚Üí Utilisateur
    "Voici un token temporaire : eyJhbGc..."

Utilisateur ‚Üí PostgreSQL
    "Voici mon token"

PostgreSQL ‚Üí Serveur OAuth
    "Ce token est-il valide ?"

Serveur OAuth ‚Üí PostgreSQL
    "Oui, c'est Alice, elle peut se connecter"
```

---

## Concepts Fondamentaux d'OAuth 2.0

### 1. Les Acteurs (R√¥les)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Resource    ‚îÇ  Vous, l'utilisateur qui veut acc√©der √† PostgreSQL
‚îÇ   Owner      ‚îÇ  (Alice)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îÇ 1. Demande d'acc√®s
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Authorization‚îÇ  Le serveur qui g√®re les identit√©s
‚îÇ   Server     ‚îÇ  (Google, Azure AD, Keycloak, Okta)
‚îÇ   (OAuth)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îÇ 2. D√©livre un token
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Client    ‚îÇ  Votre application ou client PostgreSQL
‚îÇ (Application)‚îÇ  (psql, pgAdmin, votre app web)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îÇ 3. Utilise le token
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Resource   ‚îÇ  PostgreSQL (la ressource prot√©g√©e)
‚îÇ    Server    ‚îÇ
‚îÇ (PostgreSQL) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îÇ 4. Valide le token
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Authorization‚îÇ  Retour au serveur OAuth pour validation
‚îÇ   Server     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2. Les Tokens

#### Access Token (Token d'Acc√®s)

Le "badge" qui donne acc√®s √† PostgreSQL.

**Caract√©ristiques :**
- **√âph√©m√®re** : Expire rapidement (15 min - 1 heure)
- **Opaque ou JWT** : Peut contenir des informations ou √™tre une r√©f√©rence
- **Limit√© en scope** : N'accorde que certaines permissions

**Exemple de token JWT** :
```
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhbGljZSIsIm5hbWUiOiJBbGljZSBTbWl0aCIsImlhdCI6MTYzNjM3ODg5OCwiZXhwIjoxNjM2MzgyNDk4LCJhdWQiOiJwb3N0Z3Jlc3FsLWNsdXN0ZXIifQ.signature
```

**D√©cod√©, il contient** :
```json
{
  "sub": "alice",           // Sujet (identit√©)
  "name": "Alice Smith",    // Nom complet
  "email": "alice@company.com",
  "iat": 1636378898,        // √âmis le (timestamp)
  "exp": 1636382498,        // Expire le (timestamp)
  "aud": "postgresql-cluster", // Audience (pour qui)
  "scope": "openid profile db:read" // Permissions
}
```

#### Refresh Token (Token de Rafra√Æchissement)

Un "badge sp√©cial" permettant d'obtenir de nouveaux access tokens.

**Caract√©ristiques :**
- **Longue dur√©e** : Jours, semaines, voire mois
- **Stock√© de mani√®re ultra-s√©curis√©e**
- **Utilis√© uniquement avec le serveur OAuth**
- **Peut √™tre r√©voqu√©**

### 3. Les Scopes (Port√©es)

Les scopes d√©finissent **ce que le token autorise**.

**Exemples de scopes** :
```
openid              ‚Üí Authentification basique
profile             ‚Üí Acc√®s au profil utilisateur
email               ‚Üí Acc√®s √† l'email
db:read             ‚Üí Lecture seule sur la base
db:write            ‚Üí √âcriture dans la base
db:admin            ‚Üí Administration compl√®te
```

**Exemple de demande** :
```
"Je demande un token avec les scopes : openid, profile, db:read"
```

Le serveur OAuth demandera alors √† l'utilisateur :
```
L'application "MyApp" demande √† :
‚úì Conna√Ætre votre identit√© (openid)
‚úì Voir votre profil (profile)
‚úì Lire la base de donn√©es PostgreSQL (db:read)

Accepter | Refuser
```

---

## Architecture OAuth 2.0 avec PostgreSQL 18

### Flux Complet (Authorization Code Flow)

C'est le flux le plus s√©curis√© et recommand√© pour les applications web.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  User   ‚îÇ                                         ‚îÇ  OAuth   ‚îÇ
‚îÇ (Alice) ‚îÇ                                         ‚îÇ  Server  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                         ‚îÇ (Okta)   ‚îÇ
     ‚îÇ                                              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ 1. "Je veux acc√©der √† MyApp"                       ‚îÇ
     ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
     ‚îÇ                               ‚îÇ  MyApp  ‚îÇ          ‚îÇ
     ‚îÇ                               ‚îÇ (Client)‚îÇ          ‚îÇ
     ‚îÇ                               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
     ‚îÇ                                    ‚îÇ               ‚îÇ
     ‚îÇ 2. Redirection vers OAuth          ‚îÇ               ‚îÇ
     ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§               ‚îÇ
     ‚îÇ                                    ‚îÇ               ‚îÇ
     ‚îÇ 3. "Alice, connecte-toi"           ‚îÇ               ‚îÇ
     ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ
     ‚îÇ    Email: alice@company.com        ‚îÇ               ‚îÇ
     ‚îÇ    Password: ********              ‚îÇ               ‚îÇ
     ‚îÇ                                    ‚îÇ               ‚îÇ
     ‚îÇ 4. "Autorises-tu MyApp ?"          ‚îÇ               ‚îÇ
     ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
     ‚îÇ    [Accepter] [Refuser]            ‚îÇ               ‚îÇ
     ‚îÇ                                    ‚îÇ               ‚îÇ
     ‚îÇ 5. "Oui, j'accepte"                ‚îÇ               ‚îÇ
     ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ
     ‚îÇ                                    ‚îÇ               ‚îÇ
     ‚îÇ 6. Redirection avec code           ‚îÇ               ‚îÇ
     ‚îÇ    (http://myapp.com?code=ABC123)  ‚îÇ               ‚îÇ
     ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
     ‚îÇ                                    ‚îÇ               ‚îÇ
     ‚îÇ 7. Retour sur MyApp                ‚îÇ               ‚îÇ
     ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫     ‚îÇ               ‚îÇ
     ‚îÇ                               ‚îÇ    ‚îÇ               ‚îÇ
     ‚îÇ                               ‚îÇ 8. √âchange code‚Üítoken
     ‚îÇ                               ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ
     ‚îÇ                               ‚îÇ    ‚îÇ               ‚îÇ
     ‚îÇ                               ‚îÇ 9. Access Token    ‚îÇ
     ‚îÇ                               ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚î§
     ‚îÇ                               ‚îÇ    ‚îÇ               ‚îÇ
     ‚îÇ                               ‚îÇ 10. Connexion PG   ‚îÇ
     ‚îÇ                               ‚îÇ    ‚îÇ  avec token   ‚îÇ
     ‚îÇ                               ‚îÇ    ‚ñº               ‚îÇ
     ‚îÇ                               ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
     ‚îÇ                               ‚îÇ ‚îÇPostgreSQL‚îÇ       ‚îÇ
     ‚îÇ                               ‚îÇ ‚îÇ    18    ‚îÇ       ‚îÇ
     ‚îÇ                               ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
     ‚îÇ                               ‚îÇ      ‚îÇ             ‚îÇ
     ‚îÇ                               ‚îÇ 11. Validation     ‚îÇ
     ‚îÇ                               ‚îÇ      ‚îÇ  du token   ‚îÇ
     ‚îÇ                               ‚îÇ      ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ
     ‚îÇ                               ‚îÇ      ‚îÇ             ‚îÇ
     ‚îÇ                               ‚îÇ 12. Token valide   ‚îÇ
     ‚îÇ                               ‚îÇ      ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
     ‚îÇ                               ‚îÇ      ‚îÇ             ‚îÇ
     ‚îÇ 13. Donn√©es de la requ√™te     ‚îÇ ‚úÖ Connexion       ‚îÇ
     ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    √©tablie         ‚îÇ
     ‚îÇ                               ‚îÇ                    ‚îÇ
```

**Explication √©tape par √©tape :**

1. **Initiation** : Alice clique sur "Se connecter" dans MyApp
2. **Redirection** : MyApp redirige vers le serveur OAuth (Okta)
3. **Authentification** : Alice s'authentifie sur Okta (login/password, MFA...)
4. **Consentement** : Okta demande si Alice autorise MyApp √† acc√©der √† ses ressources
5. **Accord** : Alice accepte
6. **Code d'autorisation** : Okta redirige vers MyApp avec un code temporaire
7. **Retour** : MyApp re√ßoit le code
8. **√âchange** : MyApp √©change le code contre un access token (en backend, s√©curis√©)
9. **Token re√ßu** : Okta envoie l'access token (+ refresh token optionnel)
10. **Connexion PostgreSQL** : MyApp utilise le token pour se connecter √† PostgreSQL
11. **Validation** : PostgreSQL valide le token aupr√®s d'Okta
12. **Confirmation** : Okta confirme que le token est valide
13. **Acc√®s** : PostgreSQL accorde l'acc√®s, MyApp peut ex√©cuter des requ√™tes

---

## Configuration d'OAuth 2.0 dans PostgreSQL 18

### Pr√©requis

Avant de configurer PostgreSQL, vous devez avoir :

1. **Un serveur OAuth 2.0** configur√© :
   - Google Identity Platform
   - Microsoft Azure AD (Entra ID)
   - Okta
   - Auth0
   - Keycloak (open-source)
   - AWS Cognito

2. **Une application OAuth enregistr√©e** avec :
   - Client ID
   - Client Secret (pour certains flux)
   - Redirect URIs
   - Scopes autoris√©s

3. **Les URLs du serveur OAuth** :
   - Issuer URL (base)
   - Authorization endpoint
   - Token endpoint
   - JWKS URI (pour validation des tokens)

### Configuration PostgreSQL (pg_hba.conf)

#### Configuration Basique

```conf
# TYPE  DATABASE  USER    ADDRESS       METHOD    OPTIONS
host    all       all     0.0.0.0/0     oauth     oauth_issuer_url="https://oauth.company.com" \
                                                  oauth_audience="postgresql-prod-cluster"
```

**Param√®tres obligatoires :**

| Param√®tre | Description | Exemple |
|-----------|-------------|---------|
| `oauth_issuer_url` | URL de base du serveur OAuth | `https://oauth.company.com` |
| `oauth_audience` | Identifiant de votre cluster PostgreSQL | `postgresql-prod-cluster` |

#### Configuration Compl√®te (Recommand√©e)

```conf
# Authentification OAuth 2.0 pour tous les utilisateurs
host    all    all    0.0.0.0/0    oauth \
    oauth_issuer_url="https://login.microsoftonline.com/tenant-id/v2.0" \
    oauth_audience="api://postgresql-cluster" \
    oauth_scope="openid profile email db:connect" \
    oauth_claim_username="preferred_username" \
    oauth_claim_groups="groups" \
    oauth_jwks_uri="https://login.microsoftonline.com/tenant-id/discovery/v2.0/keys" \
    oauth_token_validation="introspection" \
    oauth_introspection_endpoint="https://login.microsoftonline.com/oauth2/v2.0/introspect" \
    oauth_client_id="postgresql-client-id" \
    oauth_client_secret="super-secret-key"
```

**Param√®tres avanc√©s :**

| Param√®tre | Description | Valeur par d√©faut |
|-----------|-------------|-------------------|
| `oauth_scope` | Scopes requis (s√©par√©s par espaces) | `openid` |
| `oauth_claim_username` | Claim JWT contenant le username | `sub` |
| `oauth_claim_groups` | Claim JWT contenant les groupes | (aucun) |
| `oauth_jwks_uri` | URL des cl√©s publiques pour validation | Auto-d√©couvert |
| `oauth_token_validation` | M√©thode de validation (`local` ou `introspection`) | `local` |
| `oauth_introspection_endpoint` | URL d'introspection du token | (aucun) |
| `oauth_client_id` | ID client pour introspection | (aucun) |
| `oauth_client_secret` | Secret client pour introspection | (aucun) |

### M√©thodes de Validation de Token

#### 1. Validation Locale (Recommand√©e)

PostgreSQL v√©rifie le token JWT localement en utilisant les cl√©s publiques du serveur OAuth.

**Avantages :**
- ‚úÖ Rapide (pas d'appel r√©seau)
- ‚úÖ Pas de surcharge sur le serveur OAuth
- ‚úÖ Fonctionne m√™me si le serveur OAuth est temporairement indisponible

**Configuration :**
```conf
oauth_token_validation="local"
oauth_jwks_uri="https://oauth.company.com/.well-known/jwks.json"
```

**Processus :**
1. PostgreSQL t√©l√©charge les cl√©s publiques depuis `jwks_uri` (mise en cache)
2. Pour chaque connexion, v√©rifie la signature du token avec ces cl√©s
3. Valide les claims (`exp`, `aud`, `iss`, etc.)
4. Extrait l'identit√© de l'utilisateur

#### 2. Validation par Introspection

PostgreSQL demande au serveur OAuth si le token est valide.

**Avantages :**
- ‚úÖ G√®re les tokens opaques (non-JWT)
- ‚úÖ V√©rifie la r√©vocation en temps r√©el

**Inconv√©nients :**
- ‚ö†Ô∏è Requ√™te r√©seau √† chaque connexion
- ‚ö†Ô∏è Point de d√©faillance unique

**Configuration :**
```conf
oauth_token_validation="introspection"
oauth_introspection_endpoint="https://oauth.company.com/oauth/introspect"
oauth_client_id="postgresql-service"
oauth_client_secret="secret-key"
```

**Processus :**
1. PostgreSQL envoie le token au endpoint d'introspection
2. Le serveur OAuth r√©pond avec les d√©tails (actif/inactif, username, scopes)
3. PostgreSQL autorise ou refuse la connexion

---

## Exemples de Configuration par Fournisseur OAuth

### 1. Google Identity Platform

```conf
# pg_hba.conf
host    all    all    0.0.0.0/0    oauth \
    oauth_issuer_url="https://accounts.google.com" \
    oauth_audience="123456789-abc.apps.googleusercontent.com" \
    oauth_scope="openid email profile" \
    oauth_claim_username="email"
```

**√âtapes pr√©alables :**
1. Cr√©er un projet dans Google Cloud Console
2. Activer Google Identity API
3. Cr√©er des credentials OAuth 2.0
4. Configurer les redirect URIs

### 2. Microsoft Azure AD (Entra ID)

```conf
# pg_hba.conf
host    all    all    0.0.0.0/0    oauth \
    oauth_issuer_url="https://login.microsoftonline.com/{tenant-id}/v2.0" \
    oauth_audience="api://postgresql-cluster" \
    oauth_scope="openid profile User.Read" \
    oauth_claim_username="preferred_username" \
    oauth_claim_groups="groups"
```

**Remplacer `{tenant-id}`** par votre Tenant ID Azure.

**Configuration Azure :**
1. Cr√©er une App Registration dans Azure AD
2. Ajouter l'API "PostgreSQL Cluster" dans "Expose an API"
3. D√©finir les scopes (db:read, db:write)
4. Configurer les claims optionnels (`groups`, `preferred_username`)

### 3. Okta

```conf
# pg_hba.conf
host    all    all    0.0.0.0/0    oauth \
    oauth_issuer_url="https://dev-123456.okta.com/oauth2/default" \
    oauth_audience="api://postgresql" \
    oauth_scope="openid profile email groups" \
    oauth_claim_username="preferred_username" \
    oauth_claim_groups="groups"
```

**Configuration Okta :**
1. Cr√©er une Application (Type: Web)
2. Configurer l'Authorization Server (custom ou default)
3. Cr√©er des scopes custom pour PostgreSQL
4. Mapper les groupes Okta dans les tokens

### 4. Keycloak (Open Source)

```conf
# pg_hba.conf
host    all    all    0.0.0.0/0    oauth \
    oauth_issuer_url="https://keycloak.company.com/realms/master" \
    oauth_audience="postgresql-client" \
    oauth_scope="openid profile email" \
    oauth_claim_username="preferred_username" \
    oauth_claim_groups="realm_roles"
```

**Configuration Keycloak :**
1. Cr√©er un Realm (ou utiliser master)
2. Cr√©er un Client "postgresql-client" (Public ou Confidential)
3. Configurer les Mappers pour inclure les r√¥les dans le token
4. Activer "Include in Token Scope" pour les r√¥les

### 5. Auth0

```conf
# pg_hba.conf
host    all    all    0.0.0.0/0    oauth \
    oauth_issuer_url="https://company.auth0.com/" \
    oauth_audience="https://api.company.com/postgresql" \
    oauth_scope="openid profile email" \
    oauth_claim_username="email"
```

**Configuration Auth0 :**
1. Cr√©er une API "PostgreSQL" dans Auth0
2. D√©finir l'identifier (audience)
3. Cr√©er des permissions (scopes)
4. Cr√©er une Application et autoriser l'API

---

## Mapping Utilisateurs et R√¥les

### Principe de Base

**‚ö†Ô∏è Important** : OAuth 2.0 **authentifie** l'utilisateur mais ne cr√©e PAS automatiquement de compte PostgreSQL. Vous devez mapper les identit√©s OAuth aux utilisateurs PostgreSQL.

### Strat√©gie 1 : Mapping Manuel (Petites √âquipes)

**√âtape 1 : Cr√©er les utilisateurs PostgreSQL**

```sql
-- Cr√©er un utilisateur correspondant √† l'email OAuth
CREATE USER "alice@company.com" WITH NOLOGIN;
GRANT CONNECT ON DATABASE mydb TO "alice@company.com";
GRANT pg_read_all_data TO "alice@company.com";

CREATE USER "bob@company.com" WITH NOLOGIN;
GRANT CONNECT ON DATABASE mydb TO "bob@company.com";
GRANT pg_write_all_data TO "bob@company.com";
```

**Note** : `NOLOGIN` emp√™che la connexion par mot de passe, seul OAuth fonctionnera.

**√âtape 2 : Configuration du claim**

```conf
# pg_hba.conf
oauth_claim_username="email"
```

Quand Alice se connecte avec son token OAuth contenant `"email": "alice@company.com"`, PostgreSQL cherchera l'utilisateur `alice@company.com`.

### Strat√©gie 2 : Mapping par Groupes (Entreprises)

**√âtape 1 : Cr√©er des r√¥les PostgreSQL correspondant aux groupes OAuth**

```sql
-- Cr√©er des r√¥les bas√©s sur les groupes OAuth/AD
CREATE ROLE developers;
GRANT CONNECT ON DATABASE mydb TO developers;
GRANT SELECT, INSERT, UPDATE ON ALL TABLES IN SCHEMA public TO developers;

CREATE ROLE data_analysts;
GRANT CONNECT ON DATABASE mydb TO data_analysts;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO data_analysts;

CREATE ROLE admins;
GRANT ALL PRIVILEGES ON DATABASE mydb TO admins;

-- Cr√©er des utilisateurs et les ajouter aux groupes
CREATE USER "alice@company.com" WITH NOLOGIN;
GRANT developers TO "alice@company.com";

CREATE USER "charlie@company.com" WITH NOLOGIN;
GRANT data_analysts TO "charlie@company.com";
```

**√âtape 2 : Configuration des claims de groupes**

```conf
# pg_hba.conf
oauth_claim_username="email"
oauth_claim_groups="groups"
```

**√âtape 3 : Configurer le serveur OAuth pour inclure les groupes**

**Exemple avec Azure AD** :
```json
// Token JWT contient
{
  "email": "alice@company.com",
  "groups": [
    "Developers",
    "DatabaseUsers"
  ]
}
```

**√âtape 4 : Script de synchronisation automatique (optionnel)**

```python
# sync_oauth_users.py
import psycopg
import requests

# R√©cup√©rer les utilisateurs du serveur OAuth
oauth_users = get_users_from_oauth_api()

# Connexion PostgreSQL (avec compte admin)
conn = psycopg.connect("host=localhost user=postgres")

for user in oauth_users:
    email = user['email']
    groups = user['groups']

    # Cr√©er l'utilisateur s'il n'existe pas
    conn.execute(f"""
        DO $$
        BEGIN
            IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = '{email}') THEN
                CREATE USER "{email}" WITH NOLOGIN;
            END IF;
        END $$;
    """)

    # Ajouter aux groupes
    for group in groups:
        if group in ['Developers', 'Admins', 'DataAnalysts']:
            conn.execute(f'GRANT {group.lower()} TO "{email}"')

conn.commit()
```

### Strat√©gie 3 : Auto-Provisioning (Avanc√©)

PostgreSQL 18 ne supporte pas nativement l'auto-provisioning, mais vous pouvez utiliser un **Event Trigger** combin√© √† une extension personnalis√©e.

**Concept** :
```sql
-- Pseudo-code (n√©cessite une extension custom)
CREATE EVENT TRIGGER auto_provision_user
ON oauth_login
EXECUTE FUNCTION auto_create_user_from_token();
```

**Alternative : Utiliser un Proxy**

Un reverse proxy (comme Supabase GoTrue, ou custom) intercepte les connexions, cr√©e les utilisateurs √† la vol√©e, puis transmet la connexion √† PostgreSQL.

---

## Connexion C√¥t√© Client

### 1. Avec psql (PostgreSQL 18)

```bash
# Obtenir un token OAuth d'abord (via votre fournisseur)
TOKEN=$(curl -X POST https://oauth.company.com/token \
  -d "grant_type=password" \
  -d "username=alice@company.com" \
  -d "password=MyPassword" \
  -d "client_id=postgresql-client" \
  -d "scope=openid profile db:connect" | jq -r .access_token)

# Connexion avec le token
PGOAUTHTOKEN=$TOKEN psql -h pg.example.com -U alice@company.com -d mydb

# Ou via la variable d'environnement
export PGOAUTHTOKEN=$TOKEN
psql -h pg.example.com -U alice@company.com -d mydb
```

**Alternative : Connexion interactive**

```bash
# Si le client supporte le flux interactif (Device Flow)
psql -h pg.example.com -U alice@company.com -d mydb --oauth-interactive

# Affichera :
# Please visit: https://oauth.company.com/device?code=ABC123
# Et entrez le code: ABC123
```

### 2. Avec un Driver Python (psycopg3)

```python
import psycopg
import requests

# 1. Obtenir un token OAuth
def get_oauth_token():
    response = requests.post(
        'https://oauth.company.com/token',
        data={
            'grant_type': 'client_credentials',
            'client_id': 'my-app',
            'client_secret': 'my-secret',
            'scope': 'openid db:connect'
        }
    )
    return response.json()['access_token']

# 2. Connexion PostgreSQL avec le token
token = get_oauth_token()

conn = psycopg.connect(
    host='pg.example.com',
    user='alice@company.com',
    password=token,  # Le token est pass√© comme "password"
    dbname='mydb',
    sslmode='require'
)

# 3. Utilisation normale
with conn.cursor() as cur:
    cur.execute("SELECT current_user;")
    print(cur.fetchone())

conn.close()
```

### 3. Avec Node.js (node-postgres)

```javascript
const { Client } = require('pg');
const axios = require('axios');

// 1. Obtenir le token OAuth
async function getOAuthToken() {
  const response = await axios.post('https://oauth.company.com/token', {
    grant_type: 'client_credentials',
    client_id: 'my-app',
    client_secret: 'my-secret',
    scope: 'openid db:connect'
  });
  return response.data.access_token;
}

// 2. Connexion PostgreSQL
async function connectWithOAuth() {
  const token = await getOAuthToken();

  const client = new Client({
    host: 'pg.example.com',
    user: 'alice@company.com',
    password: token,  // Token pass√© comme password
    database: 'mydb',
    ssl: { rejectUnauthorized: true }
  });

  await client.connect();

  const res = await client.query('SELECT current_user');
  console.log('Connected as:', res.rows[0].current_user);

  await client.end();
}

connectWithOAuth();
```

### 4. Gestion du Refresh Token

Les access tokens expirant rapidement, il faut g√©rer le renouvellement :

```python
import psycopg
import requests
import time

class OAuthPostgresConnection:
    def __init__(self, oauth_config, pg_config):
        self.oauth_config = oauth_config
        self.pg_config = pg_config
        self.access_token = None
        self.refresh_token = None
        self.token_expires_at = 0
        self.conn = None

    def get_tokens(self):
        """Obtenir les tokens initiaux"""
        response = requests.post(
            self.oauth_config['token_url'],
            data={
                'grant_type': 'password',
                'username': self.oauth_config['username'],
                'password': self.oauth_config['password'],
                'client_id': self.oauth_config['client_id'],
                'scope': 'openid profile db:connect'
            }
        )
        data = response.json()
        self.access_token = data['access_token']
        self.refresh_token = data['refresh_token']
        # Token expire dans X secondes (avec marge de s√©curit√©)
        self.token_expires_at = time.time() + data['expires_in'] - 60

    def refresh_access_token(self):
        """Renouveler le token avec le refresh token"""
        response = requests.post(
            self.oauth_config['token_url'],
            data={
                'grant_type': 'refresh_token',
                'refresh_token': self.refresh_token,
                'client_id': self.oauth_config['client_id']
            }
        )
        data = response.json()
        self.access_token = data['access_token']
        # Nouveau refresh token potentiellement fourni
        if 'refresh_token' in data:
            self.refresh_token = data['refresh_token']
        self.token_expires_at = time.time() + data['expires_in'] - 60

    def connect(self):
        """Se connecter √† PostgreSQL"""
        if time.time() >= self.token_expires_at:
            if self.refresh_token:
                self.refresh_access_token()
            else:
                self.get_tokens()

        self.conn = psycopg.connect(
            host=self.pg_config['host'],
            user=self.pg_config['user'],
            password=self.access_token,
            dbname=self.pg_config['dbname'],
            sslmode='require'
        )
        return self.conn

    def execute(self, query):
        """Ex√©cuter une requ√™te (avec reconnexion si n√©cessaire)"""
        try:
            cur = self.conn.cursor()
            cur.execute(query)
            return cur.fetchall()
        except psycopg.OperationalError:
            # Token expir√©, renouveler et r√©essayer
            self.connect()
            cur = self.conn.cursor()
            cur.execute(query)
            return cur.fetchall()

# Utilisation
oauth_config = {
    'token_url': 'https://oauth.company.com/token',
    'username': 'alice@company.com',
    'password': 'MyPassword',
    'client_id': 'my-app'
}

pg_config = {
    'host': 'pg.example.com',
    'user': 'alice@company.com',
    'dbname': 'mydb'
}

pg = OAuthPostgresConnection(oauth_config, pg_config)
pg.connect()

# Les requ√™tes g√©reront automatiquement le renouvellement
results = pg.execute("SELECT * FROM users LIMIT 10")
```

---

## S√©curit√© et Bonnes Pratiques

### 1. Toujours Utiliser SSL/TLS ‚úÖ

```conf
# pg_hba.conf - Utiliser hostssl au lieu de host
hostssl    all    all    0.0.0.0/0    oauth    oauth_issuer_url="..."
```

**Pourquoi ?** Le token OAuth transite sur le r√©seau. Sans SSL, il peut √™tre intercept√©.

### 2. Validation Stricte de l'Audience

```conf
oauth_audience="api://postgresql-prod-cluster"
```

**√âvite** : Qu'un token destin√© √† une autre API soit utilis√© pour PostgreSQL.

### 3. Scopes Minimaux (Principe du Moindre Privil√®ge)

```conf
oauth_scope="openid profile db:read"  # Pas db:admin !
```

Ne demandez que les scopes n√©cessaires.

### 4. Expiration Courte des Tokens

**Configuration c√¥t√© OAuth** :
```json
{
  "access_token_lifetime": 900,  // 15 minutes
  "refresh_token_lifetime": 2592000  // 30 jours
}
```

### 5. R√©vocation de Tokens

**Processus :**
1. D√©tecter un token compromis
2. R√©voquer via le serveur OAuth
3. PostgreSQL refusera le token √† la prochaine validation

**Avec introspection** :
```bash
# R√©voquer un token dans Keycloak
curl -X POST https://keycloak.company.com/realms/master/protocol/openid-connect/revoke \
  -d "token=$ACCESS_TOKEN" \
  -d "client_id=postgresql-client" \
  -d "client_secret=secret"
```

### 6. Monitoring et Audit

```sql
-- Voir les connexions OAuth actives
SELECT
    usename,
    application_name,
    client_addr,
    backend_start,
    state
FROM pg_stat_activity
WHERE usename LIKE '%@%';  -- Emails OAuth

-- Logs d'authentification
-- postgresql.conf
log_connections = on
log_disconnections = on
```

### 7. Rotation des Secrets

**Si vous utilisez `oauth_client_secret`** :
```bash
# 1. Cr√©er un nouveau secret dans le serveur OAuth
# 2. Mettre √† jour pg_hba.conf
oauth_client_secret="new-secret-key"
# 3. Recharger PostgreSQL
pg_ctl reload
# 4. R√©voquer l'ancien secret dans OAuth
```

### 8. Connection Pooling avec OAuth

**‚ö†Ô∏è D√©fi** : Les tokens expirent, mais les pools maintiennent les connexions ouvertes.

**Solution : PgBouncer en mode Transaction**
```ini
# pgbouncer.ini
[databases]
mydb = host=pg.example.com

[pgbouncer]
pool_mode = transaction
max_client_conn = 1000
default_pool_size = 25

# R√©initialiser les connexions r√©guli√®rement
server_lifetime = 3600  # 1 heure
```

**Alternative : Middleware applicatif**
```python
# Renouveler le token avant chaque utilisation de la connexion du pool
def get_connection():
    conn = pool.get_connection()
    if token_expired():
        conn.close()
        refresh_token()
        conn = pool.new_connection(new_token)
    return conn
```

---

## Cas d'Usage et Architecture

### 1. Application Web avec OAuth SSO

**Architecture :**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  User    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  WebApp  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ   OAuth   ‚îÇ       ‚îÇPostgreSQL‚îÇ
‚îÇ (Browser)‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ (React)  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ  (Auth0)  ‚îÇ       ‚îÇ    18    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ                                      ‚îÇ
                         ‚îÇ  1. User login ‚Üí OAuth token         ‚îÇ
                         ‚îÇ  2. Store token in session/cookie    ‚îÇ
                         ‚îÇ  3. Backend uses token for DB        ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Flux :**
1. Utilisateur se connecte via OAuth (Google, Azure AD...)
2. Le frontend re√ßoit un access token
3. Le backend utilise ce token pour se connecter √† PostgreSQL
4. Chaque requ√™te SQL utilise l'identit√© r√©elle de l'utilisateur (audit trail)

**Avantage** : Audit parfait - chaque requ√™te est associ√©e √† un utilisateur identifi√©.

### 2. Microservices avec Service-to-Service Auth

**Architecture :**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Service A  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ   OAuth     ‚îÇ       ‚îÇPostgreSQL‚îÇ
‚îÇ  (Orders)   ‚îÇ       ‚îÇ  (Client    ‚îÇ       ‚îÇ    18    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ Credentials)‚îÇ       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ                    ‚îÇ
‚îÇ  Service B  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îÇ
‚îÇ (Inventory) ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Chaque service obtient son propre token avec des scopes limit√©s
```

**Configuration OAuth** :
```json
{
  "service_orders": {
    "scopes": ["db:read", "db:write:orders"]
  },
  "service_inventory": {
    "scopes": ["db:read", "db:write:inventory"]
  }
}
```

### 3. Applications Mobiles

**Architecture :**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Mobile  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  OAuth   ‚îÇ       ‚îÇ Backend   ‚îÇ
‚îÇ   App    ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ (PKCE)   ‚îÇ       ‚îÇ   API     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                             ‚îÇ
                                      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                      ‚îÇPostgreSQL  ‚îÇ
                                      ‚îÇ     18     ‚îÇ
                                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Flux PKCE (Proof Key for Code Exchange)** :
1. App mobile initie le flux OAuth avec PKCE (plus s√©curis√©)
2. Utilisateur s'authentifie via navigateur mobile
3. App re√ßoit un token
4. App envoie requ√™tes au backend avec le token
5. Backend utilise le token pour PostgreSQL

### 4. Data Science / BI Tools

**Objectif** : Permettre aux analystes d'acc√©der √† PostgreSQL avec leurs credentials d'entreprise (SSO).

**Tools supportant OAuth** :
- Tableau
- Power BI
- Looker
- Metabase (via plugin)

**Configuration Tableau** :
```
Server: pg.example.com
Port: 5432
Database: analytics_db
Authentication: OAuth 2.0
OAuth Provider: Azure AD
```

**Avantage** : Les analystes utilisent leur compte entreprise, pas de mots de passe PostgreSQL √† g√©rer.

---

## Migration et Coexistence

### Strat√©gie de Migration Progressive

**Phase 1 : Configuration Hybride**

Permettre √† la fois SCRAM et OAuth pendant la transition.

```conf
# pg_hba.conf
# Admins : SCRAM (existant)
hostssl all  postgres         10.0.1.0/24   scram-sha-256

# Applications critiques : Certificats (existant)
hostssl all  app_critical     10.0.2.0/24   cert

# Nouveaux utilisateurs : OAuth
hostssl all  all              10.0.3.0/24   oauth oauth_issuer_url="..."

# VPN users : OAuth ou SCRAM
hostssl all  all              192.168.0.0/16 oauth oauth_issuer_url="..."
hostssl all  all              192.168.0.0/16 scram-sha-256
```

**Phase 2 : Migration Progressive par √âquipe**

```conf
# √âquipe Dev (early adopters) : OAuth
hostssl all  @developers      0.0.0.0/0     oauth

# √âquipe Data : SCRAM (legacy)
hostssl all  @data_team       0.0.0.0/0     scram-sha-256

# Nouveaux utilisateurs : OAuth uniquement
hostssl all  all              0.0.0.0/0     oauth
```

**Phase 3 : OAuth Complet**

Apr√®s validation compl√®te (6-12 mois) :
```conf
# Tout le monde en OAuth
hostssl all  all              0.0.0.0/0     oauth

# Compte de secours local (peer)
local  all   postgres                        peer
```

### Script de Validation de Migration

```bash
#!/bin/bash
# validate_oauth_migration.sh

echo "=== Test de Connexion OAuth ==="

# 1. Obtenir un token
TOKEN=$(curl -s -X POST https://oauth.company.com/token \
  -d "grant_type=client_credentials" \
  -d "client_id=test-client" \
  -d "client_secret=test-secret" \
  -d "scope=openid db:connect" | jq -r .access_token)

if [ -z "$TOKEN" ]; then
  echo "‚ùå √âchec obtention token OAuth"
  exit 1
fi

echo "‚úÖ Token OAuth obtenu"

# 2. Tester la connexion
PGOAUTHTOKEN=$TOKEN psql -h pg.example.com -U test@company.com -d testdb -c "SELECT current_user;" > /dev/null 2>&1

if [ $? -eq 0 ]; then
  echo "‚úÖ Connexion PostgreSQL avec OAuth r√©ussie"
else
  echo "‚ùå √âchec connexion PostgreSQL"
  exit 1
fi

# 3. V√©rifier l'identit√©
CURRENT_USER=$(PGOAUTHTOKEN=$TOKEN psql -h pg.example.com -U test@company.com -d testdb -t -c "SELECT current_user;")

if [ "$CURRENT_USER" == "test@company.com" ]; then
  echo "‚úÖ Identit√© correcte : $CURRENT_USER"
else
  echo "‚ùå Identit√© incorrecte : $CURRENT_USER"
  exit 1
fi

echo "=== ‚úÖ Tous les tests r√©ussis ==="
```

---

## Troubleshooting (D√©pannage)

### Probl√®me 1 : "FATAL: OAuth authentication failed"

**Causes possibles :**
1. Token expir√©
2. Signature invalide
3. Audience incorrecte
4. Issuer non reconnu

**Diagnostic :**
```bash
# D√©coder le token JWT (sans valider la signature)
echo $TOKEN | cut -d. -f2 | base64 -d | jq

# V√©rifier :
# - "exp": timestamp d'expiration (convertir en date)
# - "aud": doit correspondre √† oauth_audience
# - "iss": doit correspondre √† oauth_issuer_url
```

**V√©rifier les logs PostgreSQL :**
```bash
tail -f /var/log/postgresql/postgresql-18-main.log | grep -i oauth
```

**Messages typiques :**
```
ERROR:  OAuth token validation failed: invalid signature
ERROR:  OAuth token expired
ERROR:  OAuth audience mismatch: expected "pg-cluster", got "other-service"
```

### Probl√®me 2 : "User does not exist"

**Cause** : L'utilisateur OAuth n'a pas de compte PostgreSQL.

**Solution :**
```sql
-- Cr√©er l'utilisateur correspondant au claim username
CREATE USER "alice@company.com" WITH NOLOGIN;
GRANT CONNECT ON DATABASE mydb TO "alice@company.com";
```

**V√©rifier le mapping** :
```conf
# Dans pg_hba.conf, v√©rifier :
oauth_claim_username="email"  # ou "preferred_username", "sub"...
```

### Probl√®me 3 : Impossible de r√©cup√©rer JWKS

**Erreur :**
```
ERROR: Could not fetch JWKS from https://oauth.company.com/.well-known/jwks.json
```

**Causes :**
1. URL incorrecte
2. Firewall bloquant
3. Certificat SSL invalide

**Diagnostic :**
```bash
# Tester manuellement
curl https://oauth.company.com/.well-known/jwks.json

# V√©rifier la connectivit√© depuis le serveur PostgreSQL
sudo -u postgres curl -v https://oauth.company.com/.well-known/jwks.json

# V√©rifier le certificat SSL
openssl s_client -connect oauth.company.com:443 -servername oauth.company.com
```

**Solution temporaire (non recommand√© en production) :**
```conf
# D√©sactiver la v√©rification SSL (DANGER)
oauth_ssl_verify="false"
```

### Probl√®me 4 : Performance d√©grad√©e

**Sympt√¥me** : Connexions lentes avec OAuth vs SCRAM.

**Cause** : Validation du token (introspection ou JWKS fetch).

**Solutions :**

1. **Utiliser la validation locale** :
   ```conf
   oauth_token_validation="local"
   ```

2. **Cacher les cl√©s JWKS** :
   PostgreSQL 18 cache automatiquement, mais v√©rifier :
   ```sql
   -- V√©rifier le cache
   SELECT * FROM pg_oauth_jwks_cache;
   ```

3. **Connection pooling** :
   ```ini
   # PgBouncer
   pool_mode = transaction
   server_lifetime = 3600
   ```

4. **Monitoring** :
   ```sql
   -- Temps d'authentification moyen
   SELECT
       usename,
       AVG(EXTRACT(EPOCH FROM (backend_start - query_start))) as avg_auth_time_sec
   FROM pg_stat_activity
   WHERE usename LIKE '%@%'
   GROUP BY usename;
   ```

### Probl√®me 5 : Token trop gros

**Sympt√¥me** : Erreur "Token size exceeds maximum".

**Cause** : Token JWT avec beaucoup de claims (groupes, permissions...).

**Solution :**
1. **Filtrer les claims c√¥t√© OAuth** :
   Ne pas inclure tous les groupes dans le token.

2. **Utiliser des r√©f√©rences** :
   ```json
   {
     "groups_ref": "https://api.company.com/users/alice/groups"
   }
   ```

3. **Introspection au lieu de JWT** :
   ```conf
   oauth_token_validation="introspection"
   ```

---

## Comparaison OAuth vs Autres M√©thodes

| Crit√®re | OAuth 2.0 | SCRAM-SHA-256 | LDAP | Certificats |
|---------|-----------|---------------|------|-------------|
| **S√©curit√©** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **Complexit√©** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **SSO** | ‚úÖ Natif | ‚ùå | ‚úÖ Possible | ‚ùå |
| **R√©vocation** | ‚úÖ Temps r√©el | ‚ùå (change password) | ‚úÖ D√©sactiver compte | ‚ö†Ô∏è CRL/OCSP |
| **MFA** | ‚úÖ D√©l√©gu√© √† OAuth | ‚ùå | ‚úÖ Possible | ‚ùå |
| **Mobilit√©** | ‚úÖ Tokens portables | ‚ö†Ô∏è Password storage | ‚ö†Ô∏è Password storage | ‚ùå Certificat requis |
| **Audit** | ‚úÖ Centralis√© | ‚ö†Ô∏è Local | ‚úÖ Centralis√© | ‚úÖ Bon |
| **Performance** | ‚ö†Ô∏è Validation externe | ‚úÖ Rapide | ‚ö†Ô∏è Requ√™te LDAP | ‚úÖ Rapide |
| **Cas d'usage** | Apps modernes, SSO | Standard, simple | Entreprise, AD | M2M, haute s√©curit√© |

---

## Avantages et Limitations d'OAuth dans PostgreSQL 18

### ‚úÖ Avantages

1. **Single Sign-On (SSO)** :
   - Un seul login pour tous les services
   - Meilleure exp√©rience utilisateur

2. **S√©curit√© Moderne** :
   - Pas de mots de passe stock√©s dans PostgreSQL
   - MFA int√©gr√© (via le fournisseur OAuth)
   - Tokens √† courte dur√©e de vie

3. **Gestion Centralis√©e** :
   - D√©sactivation d'un compte = r√©vocation imm√©diate partout
   - Politique de s√©curit√© unifi√©e
   - Audit centralis√©

4. **Int√©gration Cloud Native** :
   - Compatible avec Kubernetes, microservices
   - Service-to-service authentication
   - Support des identit√©s manag√©es (Azure MI, AWS IAM Roles)

5. **Conformit√©** :
   - Standards de l'industrie (OAuth 2.0, OpenID Connect)
   - Facilite les audits de s√©curit√©
   - Tra√ßabilit√© compl√®te

### ‚ö†Ô∏è Limitations

1. **D√©pendance Externe** :
   - Si le serveur OAuth est down, pas d'authentification possible
   - Besoin de haute disponibilit√© du serveur OAuth

2. **Complexit√© Initiale** :
   - Configuration plus lourde que SCRAM
   - Courbe d'apprentissage pour les √©quipes

3. **Performance** :
   - Validation du token ajoute de la latence
   - N√©cessite connection pooling agressif

4. **Compatibilit√©** :
   - Tous les clients ne supportent pas OAuth (anciens outils)
   - N√©cessite PostgreSQL 18+

5. **Mapping Utilisateurs** :
   - Pas d'auto-provisioning natif
   - N√©cessite synchronisation manuelle ou automatis√©e

---

## Ressources Compl√©mentaires

### Documentation Officielle

- **PostgreSQL 18 Authentication** : https://www.postgresql.org/docs/18/auth-oauth.html
- **RFC 6749 (OAuth 2.0)** : https://datatracker.ietf.org/doc/html/rfc6749
- **OpenID Connect** : https://openid.net/connect/

### Fournisseurs OAuth Recommand√©s

- **Keycloak** (Open Source) : https://www.keycloak.org/
- **Auth0** : https://auth0.com/
- **Okta** : https://www.okta.com/
- **Azure AD** : https://azure.microsoft.com/en-us/services/active-directory/
- **Google Identity** : https://developers.google.com/identity

### Outils et Biblioth√®ques

- **jwt.io** : D√©coder et inspecter les tokens JWT
- **oauth2-proxy** : Reverse proxy OAuth 2.0
- **Supabase** : PostgreSQL avec OAuth int√©gr√©
- **PostgREST** : API REST avec support OAuth

### Articles et Tutoriels

- "Implementing OAuth 2.0 in PostgreSQL 18" (blog officiel)
- "Zero Trust Architecture with PostgreSQL" (Crunchy Data)
- "OAuth 2.0 Best Practices" (RFC 8252)

---

## Conclusion

L'introduction d'OAuth 2.0 dans PostgreSQL 18 marque une **√©volution majeure** vers une authentification moderne, s√©curis√©e et cloud-native. Cette fonctionnalit√© permet √† PostgreSQL de s'int√©grer parfaitement dans les architectures contemporaines o√π l'identit√© est g√©r√©e de mani√®re centralis√©e.

### Points Cl√©s √† Retenir

1. **OAuth 2.0 = Authentification par tokens** au lieu de mots de passe
2. **SSO natif** : Les utilisateurs utilisent leur identit√© d'entreprise
3. **S√©curit√© renforc√©e** : MFA, r√©vocation instantan√©e, tokens temporaires
4. **Migration progressive** : Coexistence possible avec SCRAM et autres m√©thodes
5. **Production-ready** : Validation locale, performance acceptable avec pooling

### Recommandations

**‚úÖ Adoptez OAuth 2.0 si :**
- Vous d√©ployez dans le cloud (AWS, Azure, GCP)
- Vous avez d√©j√† un fournisseur OAuth (Azure AD, Okta...)
- Vous construisez des microservices
- La conformit√© exige un SSO

**‚ö†Ô∏è Restez prudent si :**
- Environnement on-premise sans infrastructure OAuth
- Petite √©quipe sans comp√©tence IAM
- Outils legacy ne supportant pas OAuth
- Besoins de simplicit√© maximale (SCRAM suffit)

### Prochaines √âtapes

1. **√âvaluer** votre infrastructure OAuth actuelle
2. **Planifier** une migration progressive (6-12 mois)
3. **Former** les √©quipes sur OAuth et JWT
4. **Tester** en environnement de dev/staging
5. **D√©ployer** progressivement en production

OAuth 2.0 dans PostgreSQL 18 n'est pas qu'une fonctionnalit√© technique, c'est un **pas vers l'avenir** de la gestion d'identit√© dans les bases de donn√©es.

---


‚è≠Ô∏è [Nouveaut√© PG 18 : SCRAM passthrough avec postgres_fdw et dblink](/16-administration-configuration-securite/02.3-scram-passthrough-pg18.md)
