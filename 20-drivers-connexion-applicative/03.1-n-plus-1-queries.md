üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.3.1. N+1 Queries : D√©tection et Correction (JOIN, LATERAL)

## Introduction

Le probl√®me des **N+1 queries** est l'un des pi√®ges de performance les plus courants dans le d√©veloppement d'applications avec bases de donn√©es. Ce probl√®me survient souvent de mani√®re invisible et peut transformer une application rapide en cauchemar de performance une fois en production.

**Objectif de ce chapitre :** Comprendre le probl√®me N+1, savoir le d√©tecter et ma√Ætriser les techniques pour le corriger avec PostgreSQL.

---

## 1. Qu'est-ce que le Probl√®me N+1 ?

### 1.1. D√©finition

Le probl√®me N+1 se produit lorsqu'une application ex√©cute :
- **1 requ√™te** pour r√©cup√©rer une liste d'entit√©s principales
- Puis **N requ√™tes suppl√©mentaires** (une pour chaque entit√©) pour r√©cup√©rer des donn√©es li√©es

Si vous avez 100 entit√©s, vous ex√©cutez donc **101 requ√™tes** au lieu d'une seule requ√™te optimis√©e.

### 1.2. Exemple Concret

Imaginons un blog avec des articles et leurs auteurs.

**Sch√©ma de base :**
```sql
-- Table des auteurs
CREATE TABLE authors (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100)
);

-- Table des articles
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT,
    author_id INTEGER REFERENCES authors(id),
    published_at TIMESTAMP DEFAULT NOW()
);
```

**Sc√©nario probl√©matique :**

Vous voulez afficher une liste d'articles avec le nom de leur auteur.

```sql
-- Requ√™te 1 : R√©cup√©rer tous les articles
SELECT id, title, author_id FROM articles LIMIT 100;
```

Cette requ√™te retourne 100 articles. Ensuite, pour chaque article, l'application ex√©cute :

```sql
-- Requ√™te 2 (pour article 1)
SELECT name FROM authors WHERE id = 1;

-- Requ√™te 3 (pour article 2)
SELECT name FROM authors WHERE id = 2;

-- Requ√™te 4 (pour article 3)
SELECT name FROM authors WHERE id = 3;

-- ... et ainsi de suite jusqu'√† 100 !
```

**R√©sultat :** 101 requ√™tes au lieu d'une seule !

### 1.3. Pourquoi est-ce un Probl√®me ?

Chaque requ√™te vers la base de donn√©es a un co√ªt :
- **Latence r√©seau** (m√™me minime)
- **Overhead de connexion** et de parsing SQL
- **Changements de contexte** sur le serveur PostgreSQL
- **Locks et concurrence**

M√™me si chaque requ√™te individuelle prend 1ms, 100 requ√™tes = 100ms au minimum, contre potentiellement 5-10ms pour une requ√™te optimis√©e avec JOIN.

**En production :**
- 1 utilisateur = 101 requ√™tes
- 100 utilisateurs simultan√©s = 10,100 requ√™tes
- Saturation rapide de la base de donn√©es

---

## 2. Comment D√©tecter le Probl√®me N+1

### 2.1. Observation des Logs d'Application

**Sympt√¥mes caract√©ristiques :**
- De nombreuses requ√™tes SQL identiques avec seulement les param√®tres qui changent
- Temps de r√©ponse qui augmente proportionnellement au nombre d'entit√©s
- Patterns r√©p√©titifs dans les logs

**Exemple de logs probl√©matiques :**
```
[SQL] SELECT * FROM articles LIMIT 100;
[SQL] SELECT * FROM authors WHERE id = 1;
[SQL] SELECT * FROM authors WHERE id = 2;
[SQL] SELECT * FROM authors WHERE id = 3;
[SQL] SELECT * FROM authors WHERE id = 4;
...
```

### 2.2. Utilisation de pg_stat_statements

PostgreSQL fournit l'extension `pg_stat_statements` qui enregistre les statistiques d'ex√©cution de toutes les requ√™tes.

```sql
-- Activer l'extension (√† faire une seule fois)
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- Identifier les requ√™tes ex√©cut√©es tr√®s fr√©quemment
SELECT
    calls,
    mean_exec_time,
    query
FROM pg_stat_statements
WHERE query LIKE '%authors%'
ORDER BY calls DESC
LIMIT 10;
```

**Ce qu'on recherche :**
- Requ√™tes avec un tr√®s grand nombre d'appels (`calls`)
- Temps d'ex√©cution individuel faible mais multipli√© par le nombre d'appels
- Patterns de requ√™tes `SELECT ... WHERE id = ?` r√©p√©titives

### 2.3. Outils de Monitoring ORM

La plupart des ORM (Object-Relational Mapping) modernes offrent des outils de d√©tection :

**Django (Python) :**
```python
# Activer le logging SQL en d√©veloppement
LOGGING = {
    'loggers': {
        'django.db.backends': {
            'level': 'DEBUG',
        }
    }
}
```

**SQLAlchemy (Python) :**
```python
import logging
logging.basicConfig()
logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)
```

**Hibernate (Java) :**
```properties
# application.properties
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
```

### 2.4. Mesure des Performances en D√©veloppement

**Technique simple :**
1. Activer le logging SQL
2. Ex√©cuter une fonctionnalit√© qui affiche une liste
3. Compter manuellement les requ√™tes SQL g√©n√©r√©es
4. Si le nombre de requ√™tes = 1 + nombre d'√©l√©ments ‚Üí Vous avez un N+1

---

## 3. Solution 1 : Les Jointures (JOIN)

### 3.1. Principe

Au lieu d'ex√©cuter plusieurs requ√™tes, on **combine les donn√©es** de plusieurs tables en une seule requ√™te gr√¢ce aux jointures.

### 3.2. Correction avec INNER JOIN

**Version probl√©matique (N+1) :**
```sql
-- Requ√™te 1
SELECT id, title, author_id FROM articles;

-- Puis N requ√™tes
SELECT name FROM authors WHERE id = ?;
```

**Version optimis√©e (1 requ√™te) :**
```sql
SELECT
    a.id,
    a.title,
    a.published_at,
    au.name AS author_name,
    au.email AS author_email
FROM articles a
INNER JOIN authors au ON a.author_id = au.id
ORDER BY a.published_at DESC;
```

**R√©sultat :** Toutes les donn√©es sont r√©cup√©r√©es en une seule requ√™te !

### 3.3. LEFT JOIN pour G√©rer les Valeurs Manquantes

Si certains articles n'ont **pas d'auteur** (author_id NULL), `INNER JOIN` les exclura.

**Solution :** Utiliser `LEFT JOIN`

```sql
SELECT
    a.id,
    a.title,
    COALESCE(au.name, 'Auteur inconnu') AS author_name
FROM articles a
LEFT JOIN authors au ON a.author_id = au.id;
```

**Explication :**
- `LEFT JOIN` conserve tous les articles, m√™me sans auteur
- `COALESCE` fournit une valeur par d√©faut si l'auteur est NULL

### 3.4. Cas avec Plusieurs Relations

Imaginons un article avec un auteur **et** une cat√©gorie :

```sql
CREATE TABLE categories (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL
);

ALTER TABLE articles ADD COLUMN category_id INTEGER REFERENCES categories(id);
```

**Requ√™te optimis√©e avec plusieurs JOIN :**
```sql
SELECT
    a.id,
    a.title,
    au.name AS author_name,
    c.name AS category_name
FROM articles a
LEFT JOIN authors au ON a.author_id = au.id
LEFT JOIN categories c ON a.category_id = c.id
ORDER BY a.published_at DESC;
```

**R√©sultat :** Une seule requ√™te r√©cup√®re articles, auteurs ET cat√©gories.

### 3.5. Performance des JOIN

**Conditions pour de bonnes performances :**
1. **Index sur les cl√©s √©trang√®res**
   ```sql
   CREATE INDEX idx_articles_author_id ON articles(author_id);
   CREATE INDEX idx_articles_category_id ON articles(category_id);
   ```

2. **Statistiques √† jour**
   ```sql
   ANALYZE articles;
   ANALYZE authors;
   ANALYZE categories;
   ```

3. **V√©rifier le plan d'ex√©cution**
   ```sql
   EXPLAIN ANALYZE
   SELECT a.*, au.name
   FROM articles a
   LEFT JOIN authors au ON a.author_id = au.id;
   ```

---

## 4. Solution 2 : LATERAL JOIN (Corr√©lation Avanc√©e)

### 4.1. Qu'est-ce qu'un LATERAL JOIN ?

`LATERAL` est une fonctionnalit√© avanc√©e de PostgreSQL qui permet √† une sous-requ√™te de **r√©f√©rencer des colonnes** de la requ√™te principale.

**Analogie :** C'est comme une boucle FOR EACH en SQL, mais optimis√©e par PostgreSQL.

### 4.2. Cas d'Usage : Relations 1-√†-N Complexes

Imaginons que vous voulez r√©cup√©rer chaque auteur avec ses **3 derniers articles**.

**Probl√®me avec JOIN classique :**
```sql
-- Cette requ√™te ne fonctionne pas correctement
SELECT
    au.name,
    a.title,
    a.published_at
FROM authors au
LEFT JOIN articles a ON au.id = a.author_id
ORDER BY a.published_at DESC
LIMIT 3; -- ‚ùå Limite globale, pas par auteur !
```

### 4.3. Solution avec LATERAL

```sql
SELECT
    au.id,
    au.name,
    recent_articles.title,
    recent_articles.published_at
FROM authors au
LEFT JOIN LATERAL (
    SELECT title, published_at
    FROM articles
    WHERE author_id = au.id  -- ‚úÖ R√©f√©rence √† la table externe !
    ORDER BY published_at DESC
    LIMIT 3  -- Les 3 derniers articles PAR AUTEUR
) AS recent_articles ON true;
```

**Explication :**
- La sous-requ√™te `LATERAL` peut acc√©der √† `au.id` de la requ√™te principale
- Pour chaque auteur, PostgreSQL ex√©cute la sous-requ√™te
- Mais PostgreSQL optimise cela intelligemment (pas un vrai N+1)

### 4.4. LATERAL vs N+1 : Quelle Diff√©rence ?

**Pourquoi LATERAL n'est pas un N+1 :**
1. **Planification unique :** PostgreSQL compile une seule fois la requ√™te
2. **Optimisations possibles :** Index scan, batch fetching
3. **Pas d'overhead r√©seau :** Tout se passe c√¥t√© serveur
4. **Transactions coh√©rentes :** Tout dans la m√™me transaction

**Un vrai N+1 :**
- N+1 connexions r√©seau
- N+1 compilations SQL
- N+1 changements de contexte

### 4.5. Cas Pratique : Top N par Groupe

**Objectif :** Les 5 articles les plus r√©cents dans chaque cat√©gorie.

```sql
SELECT
    c.name AS category_name,
    top_articles.title,
    top_articles.published_at
FROM categories c
LEFT JOIN LATERAL (
    SELECT title, published_at
    FROM articles
    WHERE category_id = c.id
    ORDER BY published_at DESC
    LIMIT 5
) AS top_articles ON true
ORDER BY c.name, top_articles.published_at DESC;
```

### 4.6. LATERAL avec Fonctions d'Agr√©gation

**Exemple :** Pour chaque auteur, compter ses articles ET r√©cup√©rer le titre du plus r√©cent.

```sql
SELECT
    au.name,
    article_stats.total_articles,
    article_stats.latest_title
FROM authors au
LEFT JOIN LATERAL (
    SELECT
        COUNT(*) AS total_articles,
        (SELECT title
         FROM articles
         WHERE author_id = au.id
         ORDER BY published_at DESC
         LIMIT 1) AS latest_title
    FROM articles
    WHERE author_id = au.id
) AS article_stats ON true;
```

### 4.7. Performance de LATERAL

**Quand utiliser LATERAL :**
- ‚úÖ Relations 1-√†-N avec limite par groupe (Top N)
- ‚úÖ Calculs complexes d√©pendant de la ligne parente
- ‚úÖ Besoin de corr√©lation avanc√©e

**Quand pr√©f√©rer JOIN classique :**
- ‚úÖ Relations simples 1-√†-1 ou N-√†-1
- ‚úÖ Pas besoin de LIMIT par groupe
- ‚úÖ Meilleure lisibilit√©

**Optimisation LATERAL :**
```sql
-- Index sur la colonne de jointure et de tri
CREATE INDEX idx_articles_author_published
ON articles(author_id, published_at DESC);
```

---

## 5. Comparaison des Solutions

### 5.1. Tableau R√©capitulatif

| Crit√®re | N+1 (Probl√®me) | JOIN Classique | LATERAL JOIN |
|---------|----------------|----------------|--------------|
| **Nombre de requ√™tes** | 1 + N | 1 | 1 |
| **Performance** | ‚ùå Tr√®s mauvaise | ‚úÖ Excellente | ‚úÖ Bonne √† excellente |
| **Complexit√©** | Simple (mais mauvais) | Simple | Moyenne |
| **Top N par groupe** | ‚ùå Impossible | ‚ùå Difficile | ‚úÖ Facile |
| **Relations 1-1 ou N-1** | ‚ùå | ‚úÖ Optimal | ‚ö†Ô∏è Overkill |
| **Relations 1-N** | ‚ùå | ‚úÖ Si on veut tout | ‚úÖ Si limite par parent |

### 5.2. Arbre de D√©cision

```
Vous avez une relation entre tables ?
‚îÇ
‚îú‚îÄ Relation 1-1 ou N-1 (ex: article ‚Üí auteur)
‚îÇ  ‚îî‚îÄ‚Üí Utiliser INNER JOIN ou LEFT JOIN
‚îÇ
‚îú‚îÄ Relation 1-N simple (ex: auteur ‚Üí tous ses articles)
‚îÇ  ‚îú‚îÄ Vous voulez TOUS les articles ?
‚îÇ  ‚îÇ  ‚îî‚îÄ‚Üí JOIN classique
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ Vous voulez un TOP N par parent (ex: 5 derniers) ?
‚îÇ     ‚îî‚îÄ‚Üí LATERAL JOIN
‚îÇ
‚îî‚îÄ Calculs complexes d√©pendant du parent ?
   ‚îî‚îÄ‚Üí LATERAL JOIN
```

---

## 6. Int√©gration dans le Code Applicatif

### 6.1. Avec les ORM (Eager Loading)

La plupart des ORM offrent des m√©canismes pour √©viter le N+1.

#### Python - Django
```python
# ‚ùå Probl√®me N+1
articles = Article.objects.all()
for article in articles:
    print(article.author.name)  # 1 requ√™te par it√©ration !

# ‚úÖ Solution : select_related (pour FK et OneToOne)
articles = Article.objects.select_related('author').all()
for article in articles:
    print(article.author.name)  # Tout en 1 requ√™te (JOIN)
```

#### Python - SQLAlchemy
```python
from sqlalchemy.orm import joinedload

# ‚ùå N+1
articles = session.query(Article).all()

# ‚úÖ Solution
articles = session.query(Article).options(
    joinedload(Article.author)
).all()
```

#### JavaScript - Prisma
```javascript
// ‚ùå N+1
const articles = await prisma.article.findMany();
for (const article of articles) {
  const author = await prisma.author.findUnique({
    where: { id: article.authorId }
  });
}

// ‚úÖ Solution : include
const articles = await prisma.article.findMany({
  include: {
    author: true
  }
});
```

#### Java - Hibernate
```java
// ‚ùå N+1 (lazy loading par d√©faut)
List<Article> articles = session.createQuery("FROM Article", Article.class).list();
for (Article article : articles) {
    System.out.println(article.getAuthor().getName()); // N requ√™tes !
}

// ‚úÖ Solution : JOIN FETCH
List<Article> articles = session.createQuery(
    "SELECT a FROM Article a JOIN FETCH a.author",
    Article.class
).list();
```

### 6.2. Quand Ne PAS √âviter le N+1

**Cas rares o√π N+1 peut √™tre acceptable :**

1. **Tr√®s petit N (< 5)** et requ√™tes en cache
2. **Connexion ultra-rapide** (localhost) et donn√©es complexes
3. **Donn√©es d√©j√† charg√©es** dans un cache applicatif

**Mais en g√©n√©ral :** Toujours optimiser, m√™me pour un petit N.

---

## 7. Outils de D√©tection Automatique

### 7.1. Bullet (Ruby on Rails)
D√©tecte automatiquement les N+1 en d√©veloppement.

### 7.2. Django Debug Toolbar (Python)
Affiche toutes les requ√™tes SQL avec warnings pour les N+1.

### 7.3. Hibernate Statistics (Java)
```java
SessionFactory sessionFactory = ...;
Statistics stats = sessionFactory.getStatistics();
stats.setStatisticsEnabled(true);

// Apr√®s ex√©cution
System.out.println("Queries executed: " + stats.getQueryExecutionCount());
```

### 7.4. Outils de Profiling SQL G√©n√©riques
- **pgBadger** : Analyse des logs PostgreSQL
- **pg_stat_statements** : Extension PostgreSQL native
- **New Relic / DataDog** : APM avec d√©tection N+1

---

## 8. Exercice Mental (Sans Code)

### Sc√©nario

Vous d√©veloppez une API qui doit retourner :
- Une liste de commandes (orders)
- Pour chaque commande : le client (customer)
- Pour chaque commande : les produits command√©s (order_items ‚Üí products)

**Sch√©ma :**
```
orders ‚Üí customer (N-1)
orders ‚Üí order_items (1-N) ‚Üí products (N-1)
```

### Questions de R√©flexion

1. **Combien de requ√™tes si on fait du N+1 pur pour 10 commandes avec 5 produits chacune ?**
   - R√©ponse : 1 (orders) + 10 (customers) + 10 (order_items) + 50 (products) = 71 requ√™tes

2. **Comment optimiser avec JOIN ?**
   - R√©ponse :
   ```sql
   SELECT o.*, c.*, oi.*, p.*
   FROM orders o
   JOIN customers c ON o.customer_id = c.id
   JOIN order_items oi ON o.id = oi.order_id
   JOIN products p ON oi.product_id = p.id
   ```

3. **Probl√®me potentiel de cette requ√™te ?**
   - R√©ponse : Explosion cart√©sienne. Si 1 commande = 5 produits, vous aurez 5 lignes pour cette commande.
   - Solution : Grouper c√¥t√© application ou utiliser des agr√©gations JSON.

---

## 9. Techniques Avanc√©es de Correction

### 9.1. Agr√©gation JSON pour Relations 1-N

Au lieu d'avoir plusieurs lignes par commande, on peut **agr√©ger** les produits en JSON.

```sql
SELECT
    o.id AS order_id,
    o.total_amount,
    c.name AS customer_name,
    json_agg(
        json_build_object(
            'product_name', p.name,
            'quantity', oi.quantity,
            'price', oi.price
        )
    ) AS products
FROM orders o
JOIN customers c ON o.customer_id = c.id
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
GROUP BY o.id, o.total_amount, c.name;
```

**R√©sultat :**
```json
{
  "order_id": 1,
  "total_amount": 150.00,
  "customer_name": "John Doe",
  "products": [
    {"product_name": "Laptop", "quantity": 1, "price": 100.00},
    {"product_name": "Mouse", "quantity": 2, "price": 25.00}
  ]
}
```

**Avantages :**
- ‚úÖ Une seule ligne par commande
- ‚úÖ Pas de duplication de donn√©es
- ‚úÖ Facile √† parser c√¥t√© application

### 9.2. Subqueries Corr√©l√©es (Alternative √† LATERAL)

```sql
SELECT
    au.name,
    (SELECT COUNT(*)
     FROM articles
     WHERE author_id = au.id) AS article_count,
    (SELECT title
     FROM articles
     WHERE author_id = au.id
     ORDER BY published_at DESC
     LIMIT 1) AS latest_article
FROM authors au;
```

**Attention :** Peut √™tre moins performant que LATERAL si plusieurs sous-requ√™tes.

### 9.3. Window Functions pour Top N

Pour r√©cup√©rer le top N par groupe sans LATERAL :

```sql
WITH ranked_articles AS (
    SELECT
        a.*,
        au.name AS author_name,
        ROW_NUMBER() OVER (
            PARTITION BY a.author_id
            ORDER BY a.published_at DESC
        ) AS rn
    FROM articles a
    JOIN authors au ON a.author_id = au.id
)
SELECT *
FROM ranked_articles
WHERE rn <= 3;  -- Top 3 par auteur
```

---

## 10. R√©sum√© et Bonnes Pratiques

### 10.1. Points Cl√©s √† Retenir

1. **Le N+1 est un probl√®me de performance majeur** qui multiplie le nombre de requ√™tes inutilement
2. **Toujours utiliser JOIN** pour les relations simples (1-1, N-1)
3. **LATERAL est parfait** pour les Top N par groupe ou corr√©lations complexes
4. **Les ORM ne sont pas magiques** : conna√Ætre SQL est essentiel
5. **Mesurer et monitorer** avec pg_stat_statements et les logs

### 10.2. Checklist de Pr√©vention

- [ ] **En d√©veloppement :** Activer le logging SQL d√©taill√©
- [ ] **En code review :** V√©rifier les boucles avec requ√™tes
- [ ] **En test :** Compter les requ√™tes g√©n√©r√©es pour chaque endpoint
- [ ] **En production :** Monitorer pg_stat_statements
- [ ] **Sur les ORM :** Utiliser eager loading (select_related, joinedload, include)
- [ ] **Sur les index :** Cr√©er des index sur toutes les cl√©s √©trang√®res

### 10.3. R√®gles d'Or

1. **"1 op√©ration = 1 requ√™te"** : Si vous affichez une liste, une seule requ√™te devrait suffire
2. **"Joindre, pas boucler"** : Pr√©f√©rer JOIN √† des boucles applicatives
3. **"Mesurer avant d'optimiser"** : Mais le N+1 est presque toujours √† corriger
4. **"L'ORM ne remplace pas SQL"** : Comprendre ce qui est g√©n√©r√©

---

## 11. Pour Aller Plus Loin

### 11.1. Lectures Recommand√©es

- Documentation PostgreSQL : [LATERAL Subqueries](https://www.postgresql.org/docs/current/queries-table-expressions.html#QUERIES-LATERAL)
- Article : "Use The Index, Luke" - Markus Winand
- Livre : "SQL Performance Explained" - Markus Winand

### 11.2. Prochaines √âtapes

Maintenant que vous ma√Ætrisez les N+1 queries, explorez :
- **ORM vs SQL brut** : Quand utiliser quoi
- **Lazy loading vs Eager loading** : Strat√©gies de chargement
- **Batching et bulk operations** : Optimiser les insertions/updates en masse

### 11.3. Questions de Validation

Avant de passer √† la suite, assurez-vous de pouvoir r√©pondre :
1. Qu'est-ce qu'un probl√®me N+1 et pourquoi est-il nuisible ?
2. Comment d√©tecter un N+1 dans vos logs ou votre code ?
3. Quelle est la diff√©rence entre JOIN et LATERAL ?
4. Quand utiliser LATERAL plut√¥t qu'un JOIN classique ?
5. Comment votre ORM g√®re-t-il le N+1 ?

---

## Conclusion

Le probl√®me N+1 est l'un des anti-patterns les plus courants et les plus d√©vastateurs en termes de performance. Avec PostgreSQL, vous disposez d'outils puissants comme **JOIN** et **LATERAL** pour le corriger √©l√©gamment.

**Retenez :** Une application bien con√ßue doit **minimiser le nombre de requ√™tes** tout en **maximisant la quantit√© de donn√©es utiles** r√©cup√©r√©es en une seule fois. C'est l'essence m√™me de l'optimisation SQL.

---

**Prochaine section recommand√©e :** 20.3.2. ORM vs SQL brut : Quand utiliser quoi


‚è≠Ô∏è [ORM vs SQL brut : Quand utiliser quoi](/20-drivers-connexion-applicative/03.2-orm-vs-sql-brut.md)
