üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.3.3. Lazy loading vs Eager loading

## Introduction

Lorsque vous travaillez avec des bases de donn√©es et des ORM, une question fondamentale se pose : **quand et comment charger les donn√©es li√©es ?** Les strat√©gies de **lazy loading** (chargement paresseux) et **eager loading** (chargement anticip√©) sont deux approches oppos√©es pour r√©pondre √† cette question.

**Objectif de ce chapitre :** Comprendre ces deux strat√©gies, identifier leurs avantages et pi√®ges, et savoir instinctivement laquelle utiliser selon votre contexte.

---

## 1. Qu'est-ce que le Lazy Loading ?

### 1.1. D√©finition Simple

Le **lazy loading** (chargement paresseux) est une strat√©gie o√π les donn√©es li√©es ne sont charg√©es que **lorsqu'on en a besoin**, et **pas avant**.

**Analogie :** C'est comme un livre avec des notes de bas de page. Vous ne lisez les notes que si vous cliquez dessus, pas automatiquement en lisant la page.

### 1.2. Exemple Concret

Imaginons un blog avec des articles et leurs auteurs :

```python
# Django ORM avec lazy loading (comportement par d√©faut)
article = Article.objects.get(id=1)

# √Ä ce stade : 1 requ√™te SQL ex√©cut√©e
# SELECT * FROM articles WHERE id = 1

print(article.title)  # Pas de requ√™te suppl√©mentaire
print(article.content)  # Pas de requ√™te suppl√©mentaire

# Mais quand on acc√®de √† l'auteur...
print(article.author.name)  # ‚Üê NOUVELLE requ√™te SQL ici !
# SELECT * FROM authors WHERE id = ?
```

**Ce qui se passe :**
1. Premi√®re requ√™te : R√©cup√®re l'article
2. Deuxi√®me requ√™te : R√©cup√®re l'auteur (seulement quand on y acc√®de)

### 1.3. Comment √ßa Marche Techniquement ?

L'ORM utilise un m√©canisme de **proxy** ou **lazy proxy** :

```python
article = Article.objects.get(id=1)

# article.author n'est PAS un objet Author complet
# C'est un "proxy" qui attend qu'on l'utilise

print(type(article.author))
# <class 'django.db.models.fields.related_descriptors.ForwardManyToOneDescriptor'>

# D√®s qu'on acc√®de √† un attribut...
name = article.author.name  # ‚Üê D√©clenche la requ√™te SQL
```

**Le proxy :**
- Sait quelle cl√© √©trang√®re charger (author_id dans articles)
- Attend qu'on acc√®de √† l'objet
- Ex√©cute la requ√™te SQL √† ce moment pr√©cis
- Met en cache le r√©sultat pour les acc√®s suivants

### 1.4. Avantages du Lazy Loading

#### ‚úÖ 1. √âconomie de Ressources

Si vous ne consultez **jamais** les donn√©es li√©es, elles ne seront **jamais** charg√©es.

```python
# Je veux juste le titre, pas l'auteur
articles = Article.objects.all()

for article in articles:
    print(article.title)  # Aucune requ√™te sur authors !
```

**R√©sultat :** 1 requ√™te au lieu de potentiellement N+1.

#### ‚úÖ 2. Simplicit√© de Code

Pas besoin de sp√©cifier √† l'avance ce qui sera charg√©.

```python
# Code simple et intuitif
article = Article.objects.get(id=1)
if some_condition:
    print(article.author.name)  # Charg√© seulement si condition vraie
```

#### ‚úÖ 3. Flexibilit√©

Utile quand vous ne savez pas √† l'avance quelles relations seront consult√©es.

```python
def display_article(article, show_author=False, show_category=False):
    print(article.title)

    if show_author:
        print(article.author.name)  # Charg√© seulement si n√©cessaire

    if show_category:
        print(article.category.name)  # Charg√© seulement si n√©cessaire
```

### 1.5. Le Pi√®ge Mortel : Le Probl√®me N+1

**Le lazy loading est la cause n¬∞1 du probl√®me N+1 !**

```python
# ‚ùå DANGEREUX : G√©n√®re N+1 requ√™tes
articles = Article.objects.all()  # 1 requ√™te

for article in articles:  # N it√©rations
    print(f"{article.title} par {article.author.name}")
    # ‚Üê 1 requ√™te par it√©ration pour charger l'auteur
```

**R√©sultat avec 100 articles :**
- 1 requ√™te pour les articles
- 100 requ√™tes pour les auteurs
- **Total : 101 requ√™tes** üò±

**Pourquoi c'est terrible :**
- Latence r√©seau multipli√©e par 100
- Overhead de parsing SQL √ó 100
- Saturation des connexions en production

---

## 2. Qu'est-ce que l'Eager Loading ?

### 2.1. D√©finition Simple

Le **eager loading** (chargement anticip√©) est une strat√©gie o√π les donn√©es li√©es sont charg√©es **imm√©diatement**, en m√™me temps que les donn√©es principales, m√™me si vous ne les utilisez pas forc√©ment.

**Analogie :** C'est comme t√©l√©charger un article de blog complet avec toutes ses images et commentaires d'un coup, plut√¥t que de les charger un par un quand on scroll.

### 2.2. Exemple Concret

```python
# Django ORM avec eager loading explicite
article = Article.objects.select_related('author').get(id=1)

# UNE SEULE requ√™te SQL avec JOIN
# SELECT articles.*, authors.*
# FROM articles
# INNER JOIN authors ON articles.author_id = authors.id
# WHERE articles.id = 1

print(article.title)  # Pas de requ√™te
print(article.author.name)  # Pas de requ√™te suppl√©mentaire !
```

**Ce qui se passe :**
- L'ORM fait un JOIN en une seule requ√™te
- Les donn√©es de l'article ET de l'auteur sont charg√©es ensemble
- Acc√©der √† `article.author` ne d√©clenche AUCUNE requ√™te suppl√©mentaire

### 2.3. Comment √ßa Marche ?

L'ORM utilise des **JOIN** SQL pour r√©cup√©rer plusieurs tables en une seule requ√™te.

**SQL g√©n√©r√© :**
```sql
SELECT
    articles.id,
    articles.title,
    articles.content,
    articles.author_id,
    authors.id AS author_id_bis,
    authors.name AS author_name,
    authors.email AS author_email
FROM articles
INNER JOIN authors ON articles.author_id = authors.id
WHERE articles.id = 1;
```

L'ORM re√ßoit une seule ligne avec toutes les colonnes et reconstruit les objets Python.

### 2.4. Avantages de l'Eager Loading

#### ‚úÖ 1. Performance : √âviter le N+1

**Le cas d'usage principal : les listes !**

```python
# ‚úÖ OPTIMAL : 1 seule requ√™te avec JOIN
articles = Article.objects.select_related('author').all()

for article in articles:
    print(f"{article.title} par {article.author.name}")
    # Aucune requ√™te suppl√©mentaire !
```

**R√©sultat avec 100 articles :**
- 1 requ√™te avec JOIN
- **Total : 1 requ√™te** üéâ

**Gain : 100√ó moins de requ√™tes !**

#### ‚úÖ 2. Pr√©visibilit√©

Vous savez **exactement** combien de requ√™tes seront ex√©cut√©es.

```python
# Facile √† raisonner : toujours 1 requ√™te
def get_article_with_author(article_id):
    return Article.objects.select_related('author').get(id=article_id)
```

#### ‚úÖ 3. Meilleure Utilisation du Cache

Une seule requ√™te = une seule mise en cache PostgreSQL.

### 2.5. Inconv√©nients de l'Eager Loading

#### ‚ùå 1. Sur-chargement de Donn√©es

Si vous n'utilisez pas les donn√©es charg√©es, c'est du gaspillage.

```python
# ‚ùå On charge l'auteur mais on ne l'utilise jamais
articles = Article.objects.select_related('author').all()

for article in articles:
    print(article.title)  # On n'utilise pas article.author
```

**R√©sultat :** Donn√©es et bande passante gaspill√©es.

#### ‚ùå 2. Complexit√© Croissante

Plus vous chargez de relations, plus la requ√™te SQL devient complexe.

```python
# Requ√™te avec 4 JOIN
articles = Article.objects.select_related(
    'author',
    'category',
    'author__profile',
    'category__parent'
).all()
```

**Probl√®me :** Le plan d'ex√©cution devient difficile √† optimiser.

#### ‚ùå 3. Explosion Cart√©sienne

Avec des relations 1-N, les donn√©es sont dupliqu√©es.

```python
# Si un auteur a √©crit 10 articles
authors = Author.objects.select_related('articles').all()

# SQL g√©n√®re une ligne par article ‚Üí Duplication des donn√©es auteur
```

---

## 3. Lazy vs Eager : Comparaison Directe

### 3.1. Tableau R√©capitulatif

| Crit√®re | Lazy Loading | Eager Loading |
|---------|--------------|---------------|
| **Quand les donn√©es sont charg√©es** | √Ä l'acc√®s | Imm√©diatement |
| **Nombre de requ√™tes** | 1 + N (risque N+1) | 1 (avec JOIN) |
| **Performance (listes)** | ‚ùå Mauvaise | ‚úÖ Excellente |
| **Performance (donn√©es inutilis√©es)** | ‚úÖ Bonne | ‚ùå Gaspillage |
| **Complexit√© du code** | ‚úÖ Simple | ‚ö†Ô∏è Moyenne |
| **Pr√©visibilit√©** | ‚ö†Ô∏è Difficile | ‚úÖ Facile |
| **D√©faut par d√©faut** | ‚úÖ Oui (la plupart des ORM) | ‚ùå Non (opt-in) |

### 3.2. Exemple Comparatif Complet

**Sch√©ma :**
```sql
CREATE TABLE authors (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200),
    author_id INTEGER REFERENCES authors(id)
);
```

#### Sc√©nario 1 : Afficher une liste d'articles avec auteurs

**Lazy Loading :**
```python
articles = Article.objects.all()  # SELECT * FROM articles

for article in articles:
    print(f"{article.title} - {article.author.name}")
    # SELECT * FROM authors WHERE id = ? (√ó N fois)

# Total : 1 + N requ√™tes (N+1)
# Temps : ~150ms pour 100 articles
```

**Eager Loading :**
```python
articles = Article.objects.select_related('author').all()
# SELECT articles.*, authors.*
# FROM articles
# INNER JOIN authors ON articles.author_id = authors.id

for article in articles:
    print(f"{article.title} - {article.author.name}")
    # Aucune requ√™te suppl√©mentaire

# Total : 1 requ√™te
# Temps : ~15ms pour 100 articles
```

**Verdict :** Eager loading 10√ó plus rapide.

#### Sc√©nario 2 : Afficher juste les titres

**Lazy Loading :**
```python
articles = Article.objects.all()  # SELECT * FROM articles

for article in articles:
    print(article.title)  # Pas d'acc√®s √† author

# Total : 1 requ√™te
# Temps : ~10ms
```

**Eager Loading :**
```python
articles = Article.objects.select_related('author').all()
# SELECT articles.*, authors.* FROM articles JOIN authors ...

for article in articles:
    print(article.title)  # On n'utilise pas author (gaspillage)

# Total : 1 requ√™te (mais plus lourde)
# Temps : ~12ms
```

**Verdict :** Lazy loading l√©g√®rement meilleur (pas de donn√©es inutiles).

---

## 4. Strat√©gies de Chargement dans les ORM

### 4.1. Relations 1-√†-1 et N-√†-1 : select_related

**Cas d'usage :** Jointures simples (INNER/LEFT JOIN).

#### Python - Django
```python
# Charger article avec auteur (N-1)
article = Article.objects.select_related('author').get(id=1)

# Charger plusieurs relations
articles = Article.objects.select_related('author', 'category').all()

# Relations imbriqu√©es (author ‚Üí profile)
articles = Article.objects.select_related('author__profile').all()
```

#### Python - SQLAlchemy
```python
from sqlalchemy.orm import joinedload

# Charger article avec auteur
article = session.query(Article).options(
    joinedload(Article.author)
).filter(Article.id == 1).one()

# Plusieurs relations
articles = session.query(Article).options(
    joinedload(Article.author),
    joinedload(Article.category)
).all()
```

#### JavaScript - Prisma
```javascript
// Charger article avec auteur
const article = await prisma.article.findUnique({
  where: { id: 1 },
  include: {
    author: true,
  }
});

// Plusieurs relations
const articles = await prisma.article.findMany({
  include: {
    author: true,
    category: true,
  }
});
```

#### Java - Hibernate
```java
// JPQL avec JOIN FETCH
String jpql = "SELECT a FROM Article a JOIN FETCH a.author WHERE a.id = :id";
Article article = entityManager.createQuery(jpql, Article.class)
    .setParameter("id", 1)
    .getSingleResult();

// Criteria API
CriteriaBuilder cb = entityManager.getCriteriaBuilder();
CriteriaQuery<Article> query = cb.createQuery(Article.class);
Root<Article> root = query.from(Article.class);
root.fetch("author", JoinType.LEFT);
```

### 4.2. Relations 1-√†-N : prefetch_related

**Probl√®me avec select_related pour 1-N :**
- Cr√©e un JOIN qui duplique les lignes
- Inefficace et complexe

**Solution : prefetch_related**
- Ex√©cute 2 requ√™tes s√©par√©es
- Fait le JOIN en m√©moire (c√¥t√© application)

#### Python - Django
```python
# Charger auteurs avec leurs articles (1-N)
authors = Author.objects.prefetch_related('articles').all()

# SQL g√©n√©r√© :
# 1. SELECT * FROM authors
# 2. SELECT * FROM articles WHERE author_id IN (1, 2, 3, ...)

for author in authors:
    print(f"{author.name} a √©crit:")
    for article in author.articles.all():  # Pas de requ√™te !
        print(f"  - {article.title}")
```

**Comment √ßa marche :**
1. R√©cup√®re tous les auteurs
2. R√©cup√®re tous les articles de ces auteurs (via IN clause)
3. Groupe les articles par auteur en m√©moire

#### Python - SQLAlchemy
```python
from sqlalchemy.orm import selectinload

# Charger auteurs avec articles
authors = session.query(Author).options(
    selectinload(Author.articles)
).all()
```

#### JavaScript - Prisma
```javascript
// Charger auteurs avec articles
const authors = await prisma.author.findMany({
  include: {
    articles: true,
  }
});
```

### 4.3. Combinaison des Strat√©gies

```python
# Charger articles avec auteur (N-1) ET commentaires (1-N)
articles = Article.objects \
    .select_related('author') \      # JOIN pour author
    .prefetch_related('comments') \  # 2 requ√™tes pour comments
    .all()

# Total : 3 requ√™tes
# 1. SELECT articles.*, authors.* FROM articles JOIN authors
# 2. SELECT * FROM comments WHERE article_id IN (...)
```

---

## 5. Quand Utiliser Quoi ? Arbre de D√©cision

### 5.1. Guide de D√©cision Rapide

```
Vous affichez une LISTE d'objets ?
‚îÇ
‚îú‚îÄ OUI ‚Üí Vous utilisez les relations ?
‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ OUI ‚Üí Relations N-1 ou 1-1 ?
‚îÇ  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îú‚îÄ OUI ‚Üí select_related (eager loading)
‚îÇ  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ NON (1-N ou N-N) ‚Üí prefetch_related
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ NON ‚Üí Lazy loading OK (pas de chargement)
‚îÇ
‚îî‚îÄ NON (objet unique) ‚Üí Vous utilisez les relations ?
   ‚îÇ
   ‚îú‚îÄ OUI ‚Üí select_related ou prefetch_related
   ‚îÇ        (moins critique mais toujours mieux)
   ‚îÇ
   ‚îî‚îÄ NON ‚Üí Lazy loading OK
```

### 5.2. R√®gles d'Or

#### R√®gle 1 : Listes = Eager Loading

**Toujours utiliser eager loading pour les listes !**

```python
# ‚ùå JAMAIS √ßa en production
articles = Article.objects.all()
for article in articles:
    print(article.author.name)  # N+1 !

# ‚úÖ TOUJOURS √ßa
articles = Article.objects.select_related('author').all()
for article in articles:
    print(article.author.name)
```

#### R√®gle 2 : Objet Unique = Flexible

Pour un seul objet, le co√ªt du N+1 est n√©gligeable.

```python
# Acceptable (2 requ√™tes)
article = Article.objects.get(id=1)
author_name = article.author.name

# Mieux (1 requ√™te)
article = Article.objects.select_related('author').get(id=1)
author_name = article.author.name
```

**Mais :** Si cette fonction est appel√©e souvent, pr√©f√©rez eager loading.

#### R√®gle 3 : Ne Charger Que Ce Qui Est Utilis√©

```python
# ‚ùå Sur-optimisation inutile
articles = Article.objects.select_related('author', 'category', 'tags').all()
for article in articles:
    print(article.title)  # N'utilise rien d'autre !

# ‚úÖ Juste ce qui est n√©cessaire
articles = Article.objects.all()
for article in articles:
    print(article.title)
```

#### R√®gle 4 : Profiler Avant d'Optimiser

```python
# En d√©veloppement : activer le logging SQL
LOGGING = {
    'loggers': {
        'django.db.backends': {
            'level': 'DEBUG',
        },
    },
}

# Compter les requ√™tes
from django.test.utils import override_settings
from django.db import connection

with override_settings(DEBUG=True):
    articles = Article.objects.all()
    for article in articles:
        print(article.author.name)

    print(f"Requ√™tes ex√©cut√©es : {len(connection.queries)}")
```

---

## 6. Patterns et Anti-Patterns

### 6.1. Anti-Pattern 1 : Lazy Loading dans les Boucles

```python
# ‚ùå ANTI-PATTERN : N+1 garanti
def display_articles():
    articles = Article.objects.all()  # Lazy loading par d√©faut
    for article in articles:
        print(f"{article.title} par {article.author.name}")
        print(f"Cat√©gorie : {article.category.name}")
        # 2 requ√™tes suppl√©mentaires par article !
```

**Solution :**
```python
# ‚úÖ PATTERN : Eager loading
def display_articles():
    articles = Article.objects.select_related('author', 'category').all()
    for article in articles:
        print(f"{article.title} par {article.author.name}")
        print(f"Cat√©gorie : {article.category.name}")
        # Aucune requ√™te suppl√©mentaire
```

### 6.2. Anti-Pattern 2 : Eager Loading Excessif

```python
# ‚ùå ANTI-PATTERN : Sur-chargement
def get_article_titles():
    articles = Article.objects.select_related(
        'author',
        'category',
        'author__profile',
        'author__profile__country',
        'category__parent'
    ).all()

    return [article.title for article in articles]
    # On n'utilise AUCUNE des relations charg√©es !
```

**Solution :**
```python
# ‚úÖ PATTERN : Charger seulement ce qui est n√©cessaire
def get_article_titles():
    articles = Article.objects.all()
    return [article.title for article in articles]
```

Ou mieux encore :
```python
# ‚úÖ OPTIMAL : S√©lectionner seulement la colonne n√©cessaire
def get_article_titles():
    return Article.objects.values_list('title', flat=True)
    # SELECT title FROM articles (pas de JOIN, pas de colonnes inutiles)
```

### 6.3. Anti-Pattern 3 : Eager Loading Oubli√©

```python
# ‚ùå ANTI-PATTERN : Oublier d'ajouter eager loading apr√®s refactoring
def get_article_details(article_id):
    # Code initial : on utilisait juste le titre
    article = Article.objects.get(id=article_id)
    return article.title

# Apr√®s refactoring : on ajoute l'auteur (OUPS, lazy loading !)
def get_article_details(article_id):
    article = Article.objects.get(id=article_id)
    return f"{article.title} par {article.author.name}"  # Requ√™te suppl√©mentaire
```

**Solution :**
```python
# ‚úÖ PATTERN : Ajouter select_related
def get_article_details(article_id):
    article = Article.objects.select_related('author').get(id=article_id)
    return f"{article.title} par {article.author.name}"
```

### 6.4. Pattern : Eager Loading Conditionnel

```python
# ‚úÖ PATTERN : Charger seulement si n√©cessaire
def get_articles(include_author=False, include_comments=False):
    queryset = Article.objects.all()

    if include_author:
        queryset = queryset.select_related('author')

    if include_comments:
        queryset = queryset.prefetch_related('comments')

    return queryset
```

---

## 7. Cas Avanc√©s et Optimisations

### 7.1. Prefetch Personnalis√©

**Probl√®me :** Vous voulez seulement les commentaires r√©cents, pas tous.

```python
from django.db.models import Prefetch

# Prefetch avec filtrage
articles = Article.objects.prefetch_related(
    Prefetch(
        'comments',
        queryset=Comment.objects.filter(is_approved=True).order_by('-created_at')[:5],
        to_attr='recent_comments'
    )
).all()

for article in articles:
    print(f"{article.title}")
    for comment in article.recent_comments:  # Seulement les 5 derniers approuv√©s
        print(f"  - {comment.text}")
```

**SQL g√©n√©r√© :**
```sql
-- 1. Articles
SELECT * FROM articles;

-- 2. Commentaires filtr√©s
SELECT * FROM comments
WHERE is_approved = true
  AND article_id IN (1, 2, 3, ...)
ORDER BY created_at DESC;
```

### 7.2. only() et defer() : Charger Moins de Colonnes

**only() : Charger seulement certaines colonnes**
```python
# Charger seulement id et title
articles = Article.objects.only('id', 'title').all()

# SELECT id, title FROM articles (pas content, pas created_at, etc.)
```

**defer() : Exclure certaines colonnes**
```python
# Charger tout sauf content (peut √™tre tr√®s gros)
articles = Article.objects.defer('content').all()

# SELECT id, title, author_id, created_at FROM articles
# (pas content)
```

**Combinaison avec select_related :**
```python
articles = Article.objects \
    .select_related('author') \
    .only('title', 'author__name') \
    .all()

# SELECT articles.title, authors.name
# FROM articles JOIN authors ...
```

### 7.3. Gestion des Relations N-N

**Sch√©ma :**
```sql
CREATE TABLE tags (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50)
);

CREATE TABLE article_tags (
    article_id INTEGER REFERENCES articles(id),
    tag_id INTEGER REFERENCES tags(id),
    PRIMARY KEY (article_id, tag_id)
);
```

**Eager Loading pour N-N :**
```python
# Charger articles avec leurs tags
articles = Article.objects.prefetch_related('tags').all()

# SQL g√©n√©r√© :
# 1. SELECT * FROM articles
# 2. SELECT * FROM article_tags WHERE article_id IN (...)
# 3. SELECT * FROM tags WHERE id IN (...)

for article in articles:
    print(f"{article.title}")
    for tag in article.tags.all():  # Pas de requ√™te
        print(f"  #{tag.name}")
```

### 7.4. Subquery pour Agr√©gations

**Probl√®me :** Afficher le nombre de commentaires par article.

**Solution 1 : Annotation (eager) :**
```python
from django.db.models import Count

articles = Article.objects.annotate(
    comment_count=Count('comments')
).all()

for article in articles:
    print(f"{article.title} - {article.comment_count} commentaires")
```

**Solution 2 : Lazy loading (si rarement utilis√©) :**
```python
articles = Article.objects.all()

for article in articles:
    if some_rare_condition:
        count = article.comments.count()  # Requ√™te seulement si n√©cessaire
```

---

## 8. Debugging et Monitoring

### 8.1. Django Debug Toolbar

**Installation :**
```bash
pip install django-debug-toolbar
```

**Fonctionnalit√©s :**
- Affiche toutes les requ√™tes SQL
- Temps d'ex√©cution par requ√™te
- D√©tection automatique des N+1
- Panneau d√©di√© aux duplications de requ√™tes

**Exemple de d√©tection :**
```
‚ö†Ô∏è Warning: 100 similar queries detected
SELECT * FROM authors WHERE id = ?
```

### 8.2. Compter les Requ√™tes en Test

```python
# Django
from django.test.utils import override_settings
from django.db import connection, reset_queries

@override_settings(DEBUG=True)
def test_no_n_plus_one():
    reset_queries()

    articles = Article.objects.select_related('author').all()

    for article in articles[:10]:
        _ = article.author.name

    # V√©rifier le nombre de requ√™tes
    assert len(connection.queries) == 1, \
        f"Expected 1 query, got {len(connection.queries)}"
```

### 8.3. Logging SQL en Production

**Configuration PostgreSQL :**
```sql
-- Activer pg_stat_statements
CREATE EXTENSION pg_stat_statements;

-- Identifier les requ√™tes r√©p√©titives
SELECT
    calls,
    mean_exec_time,
    query
FROM pg_stat_statements
WHERE query LIKE '%authors%'
ORDER BY calls DESC
LIMIT 20;
```

**R√©sultat typique d'un N+1 :**
```
calls  | mean_exec_time | query
-------|----------------|-------
10000  | 1.2 ms         | SELECT * FROM authors WHERE id = $1
1      | 15 ms          | SELECT * FROM articles
```

### 8.4. APM (Application Performance Monitoring)

**Outils recommand√©s :**
- **New Relic** : D√©tection automatique N+1
- **DataDog APM** : Traces de requ√™tes
- **Sentry Performance** : Alertes sur slow queries
- **Scout APM** : Sp√©cialis√© Rails/Django

**Exemple d'alerte New Relic :**
```
üö® N+1 Query Detected
Endpoint: /api/articles
Queries: 1 + 247
Impact: +850ms response time
```

---

## 9. Cas Pratiques par Framework

### 9.1. Django : Le Guide Complet

#### Lazy Loading (par d√©faut)
```python
article = Article.objects.get(id=1)
author = article.author  # Requ√™te lazy
```

#### Eager Loading N-1
```python
articles = Article.objects.select_related('author', 'category').all()
```

#### Eager Loading 1-N
```python
authors = Author.objects.prefetch_related('articles').all()
```

#### Combin√©
```python
articles = Article.objects \
    .select_related('author', 'category') \
    .prefetch_related('comments', 'tags') \
    .all()
```

#### Prefetch Avanc√©
```python
from django.db.models import Prefetch

articles = Article.objects.prefetch_related(
    Prefetch('comments', queryset=Comment.objects.filter(is_approved=True))
).all()
```

### 9.2. SQLAlchemy : Strat√©gies Multiples

#### Lazy Loading (par d√©faut)
```python
article = session.query(Article).get(1)
author = article.author  # Lazy
```

#### Eager Loading avec joinedload
```python
from sqlalchemy.orm import joinedload

articles = session.query(Article).options(
    joinedload(Article.author)
).all()
```

#### Eager Loading avec selectinload (1-N)
```python
from sqlalchemy.orm import selectinload

authors = session.query(Author).options(
    selectinload(Author.articles)
).all()
```

#### Subqueryload (alternative)
```python
from sqlalchemy.orm import subqueryload

authors = session.query(Author).options(
    subqueryload(Author.articles)
).all()
```

#### Configuration par D√©faut
```python
class Article(Base):
    __tablename__ = 'articles'

    author = relationship('Author', lazy='joined')  # Toujours eager
    comments = relationship('Comment', lazy='select')  # Lazy
    tags = relationship('Tag', lazy='selectin')  # Eager avec IN
```

### 9.3. Prisma : Include et Select

#### Lazy Loading
```javascript
// Par d√©faut, pas de relations charg√©es
const article = await prisma.article.findUnique({
  where: { id: 1 }
});
// article.author est undefined
```

#### Eager Loading
```javascript
const article = await prisma.article.findUnique({
  where: { id: 1 },
  include: {
    author: true,
    category: true,
  }
});
```

#### Include Imbriqu√©
```javascript
const articles = await prisma.article.findMany({
  include: {
    author: {
      include: {
        profile: true,
      }
    },
    comments: true,
  }
});
```

#### Select (charger seulement certains champs)
```javascript
const articles = await prisma.article.findMany({
  select: {
    id: true,
    title: true,
    author: {
      select: {
        name: true,
      }
    }
  }
});
```

### 9.4. Hibernate : Fetch Strategies

#### Lazy Loading (par d√©faut)
```java
@Entity
public class Article {
    @ManyToOne(fetch = FetchType.LAZY)  // Par d√©faut
    private Author author;
}
```

#### Eager Loading par Configuration
```java
@Entity
public class Article {
    @ManyToOne(fetch = FetchType.EAGER)
    private Author author;
}
```

#### Eager Loading par Requ√™te (recommand√©)
```java
// JPQL avec JOIN FETCH
String jpql = "SELECT a FROM Article a JOIN FETCH a.author";
List<Article> articles = entityManager.createQuery(jpql, Article.class)
    .getResultList();
```

#### EntityGraph (JPA 2.1+)
```java
@NamedEntityGraph(
    name = "Article.withAuthorAndComments",
    attributeNodes = {
        @NamedAttributeNode("author"),
        @NamedAttributeNode("comments")
    }
)
@Entity
public class Article { ... }

// Utilisation
EntityGraph<?> graph = entityManager.getEntityGraph("Article.withAuthorAndComments");
Map<String, Object> hints = new HashMap<>();
hints.put("javax.persistence.fetchgraph", graph);

Article article = entityManager.find(Article.class, 1, hints);
```

---

## 10. Checklist et Bonnes Pratiques

### 10.1. Checklist de D√©veloppement

Avant de merger du code qui interroge la base de donn√©es :

- [ ] Ai-je activ√© le logging SQL en d√©veloppement ?
- [ ] Ai-je compt√© le nombre de requ√™tes g√©n√©r√©es ?
- [ ] Y a-t-il des boucles qui acc√®dent √† des relations ?
- [ ] Si oui, ai-je ajout√© select_related/prefetch_related ?
- [ ] Ai-je test√© avec un dataset r√©aliste (> 100 lignes) ?
- [ ] Les tests automatis√©s v√©rifient-ils le nombre de requ√™tes ?

### 10.2. R√®gles d'Or √† Retenir

#### 1. Liste = Eager Loading
**Toujours** utiliser eager loading pour afficher des listes.

#### 2. Objet Unique = Flexible
Pour un seul objet, lazy loading est acceptable.

#### 3. Mesurer Avant d'Optimiser
Utilisez les outils de profiling pour identifier les vrais probl√®mes.

#### 4. N-1 = select_related
Pour les relations N-1 ou 1-1, utilisez `select_related` (JOIN).

#### 5. 1-N = prefetch_related
Pour les relations 1-N ou N-N, utilisez `prefetch_related` (2 requ√™tes).

#### 6. Ne Pas Sur-Optimiser
Ne chargez que ce qui est r√©ellement utilis√©.

### 10.3. Template de Code Review

```python
# ‚ùå Code Review : √Ä REJETER
def get_articles():
    articles = Article.objects.all()
    return [
        {
            'title': a.title,
            'author': a.author.name,  # ‚Üê N+1 !
        }
        for a in articles
    ]

# ‚úÖ Code Review : APPROUVER
def get_articles():
    articles = Article.objects.select_related('author').all()
    return [
        {
            'title': a.title,
            'author': a.author.name,  # ‚Üê Pas de requ√™te suppl√©mentaire
        }
        for a in articles
    ]
```

### 10.4. Tests Automatis√©s

```python
# Django : Test unitaire qui v√©rifie l'absence de N+1
from django.test import TestCase, override_settings
from django.db import connection, reset_queries

class ArticleViewTest(TestCase):
    @override_settings(DEBUG=True)
    def test_list_articles_no_n_plus_one(self):
        # Cr√©er 10 articles avec auteurs
        for i in range(10):
            author = Author.objects.create(name=f"Author {i}")
            Article.objects.create(title=f"Article {i}", author=author)

        reset_queries()

        # Appeler la vue qui liste les articles
        response = self.client.get('/articles/')

        # V√©rifier : maximum 2 requ√™tes (articles + prefetch authors)
        num_queries = len(connection.queries)
        self.assertLessEqual(
            num_queries,
            2,
            f"Expected <= 2 queries, got {num_queries}. Possible N+1!"
        )
```

---

## 11. R√©sum√© et Synth√®se

### 11.1. Lazy vs Eager : Le Verdict

**Il n'y a pas de "meilleur" choix absolu.**

- **Lazy loading** : Bon par d√©faut, flexible, √©conome... mais dangereusement facile de tomber dans le N+1
- **Eager loading** : Optimal pour les listes, pr√©visible... mais peut charger des donn√©es inutiles

**La vraie comp√©tence :** Savoir identifier quand utiliser quoi.

### 11.2. Matrice de D√©cision Finale

| Contexte | Strat√©gie | Raison |
|----------|-----------|--------|
| Liste avec relations | **Eager Loading** | √âviter N+1 |
| Objet unique avec relations | **Eager Loading** (recommand√©) | Pr√©visibilit√© |
| Liste sans utiliser relations | **Lazy Loading** | Pas de surcharge |
| Acc√®s conditionnel aux relations | **Lazy Loading** | Flexibilit√© |
| Relations N-1 ou 1-1 | **select_related** | JOIN optimal |
| Relations 1-N ou N-N | **prefetch_related** | √âviter explosion cart√©sienne |
| API haute fr√©quence | **Eager Loading** | Performance critique |
| Admin/Backoffice | **Lazy Loading** OK | Moins critique |

### 11.3. Points Cl√©s √† Retenir

1. **Le N+1 est le pi√®ge n¬∞1** caus√© par le lazy loading dans les boucles
2. **Toujours profiler** : activer le logging SQL en d√©veloppement
3. **select_related pour N-1**, prefetch_related pour 1-N
4. **Tester avec donn√©es r√©alistes** (> 100 lignes)
5. **Automatiser les tests** de nombre de requ√™tes
6. **Documenter les choix** d'optimisation dans le code

### 11.4. Le Workflow Optimal

```python
# 1. Commencer simple (lazy par d√©faut)
def get_articles():
    return Article.objects.all()

# 2. Profiler et identifier le N+1
# ‚Üí Logging SQL montre 1 + 100 requ√™tes

# 3. Ajouter eager loading cibl√©
def get_articles():
    return Article.objects.select_related('author').all()

# 4. V√©rifier l'am√©lioration
# ‚Üí 1 seule requ√™te maintenant

# 5. Ajouter un test pour √©viter la r√©gression
def test_get_articles_no_n_plus_one():
    assert_max_queries(2)
```

---

## 12. Pour Aller Plus Loin

### 12.1. Ressources Recommand√©es

**Documentation ORM :**
- Django : [Database access optimization](https://docs.djangoproject.com/en/stable/topics/db/optimization/)
- SQLAlchemy : [Loading Techniques](https://docs.sqlalchemy.org/en/14/orm/loading_relationships.html)
- Prisma : [Relation queries](https://www.prisma.io/docs/concepts/components/prisma-client/relation-queries)
- Hibernate : [Fetching strategies](https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#fetching)

**Articles :**
- "N+1 Queries and How to Avoid Them" - Bullet (Ruby)
- "Solving the N+1 Problem" - Use The Index, Luke

**Outils :**
- Django Debug Toolbar
- Bullet (Rails)
- Hibernate Statistics
- pg_stat_statements

### 12.2. Exercice Mental

**Situation :** Vous construisez un dashboard qui affiche :
- 50 projets
- Pour chaque projet : le nom du client
- Pour chaque projet : les 3 derni√®res t√¢ches
- Pour chaque t√¢che : le nom de l'assign√©

**Questions :**
1. Combien de requ√™tes avec lazy loading ?
2. Comment optimiser avec eager loading ?
3. Quelle strat√©gie pour les "3 derni√®res t√¢ches" ?

**R√©ponse sugg√©r√©e :**
```python
# Lazy : 1 + 50 + 50 + 150 = 251 requ√™tes

# Eager optimis√© :
projects = Project.objects \
    .select_related('client') \
    .prefetch_related(
        Prefetch(
            'tasks',
            queryset=Task.objects.select_related('assignee').order_by('-created_at')[:3],
            to_attr='recent_tasks'
        )
    ).all()

# Total : 3 requ√™tes
# 1. Projects + clients (JOIN)
# 2. Tasks filtr√©es
# 3. Assignees des tasks (ou inclus dans la requ√™te 2 avec JOIN)
```

### 12.3. Prochains Chapitres Recommand√©s

Maintenant que vous ma√Ætrisez lazy vs eager loading :
- **20.3.4. Batching et bulk operations** : Optimiser les INSERT/UPDATE en masse
- **13. Indexation et Optimisation** : Am√©liorer les performances des requ√™tes
- **14. Observabilit√© et Monitoring** : D√©tecter les probl√®mes en production

---

## Conclusion

Le choix entre **lazy loading** et **eager loading** n'est pas binaire : c'est une d√©cision contextuelle que vous devez prendre pour chaque requ√™te.

**La cl√© du succ√®s :**
1. **Conna√Ætre les deux strat√©gies** et leurs implications
2. **Profiler syst√©matiquement** en d√©veloppement
3. **Optimiser intelligemment** sans sur-optimiser
4. **Tester automatiquement** pour √©viter les r√©gressions

Le **lazy loading** est confortable mais dangereux (N+1). L'**eager loading** est performant mais peut sur-charger. **La vraie expertise : savoir jongler entre les deux.**

Avec cette connaissance, vous √™tes maintenant √©quip√© pour √©crire du code qui interagit efficacement avec PostgreSQL, que ce soit via un ORM ou en SQL brut.

---


‚è≠Ô∏è [Batching et bulk operations](/20-drivers-connexion-applicative/03.4-batching-bulk-operations.md)
