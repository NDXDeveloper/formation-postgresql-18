üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.1.2. Node.js : node-postgres (pg), Prisma

## Introduction

Node.js est une plateforme JavaScript c√¥t√© serveur extr√™mement populaire pour construire des APIs et applications web. Pour interagir avec PostgreSQL depuis Node.js, vous avez principalement deux approches :

1. **node-postgres (pg)** : Driver natif bas niveau, contr√¥le total sur SQL
2. **Prisma** : ORM moderne avec type-safety et g√©n√©ration de code

Ce tutoriel couvre les deux approches en profondeur pour vous permettre de choisir celle qui convient le mieux √† votre projet.

---

## Vue d'Ensemble : Driver vs ORM

### Qu'est-ce qu'un Driver ?

Un **driver** (ou adaptateur) est une biblioth√®que qui permet √† votre code Node.js de communiquer directement avec PostgreSQL. Vous √©crivez du SQL brut et r√©cup√©rez les r√©sultats.

**Analogie :** C'est comme parler directement au serveur PostgreSQL dans sa langue natale (SQL).

### Qu'est-ce qu'un ORM ?

Un **ORM** (Object-Relational Mapping) est une couche d'abstraction qui traduit votre code JavaScript/TypeScript en requ√™tes SQL. Vous manipulez des objets JavaScript au lieu d'√©crire du SQL.

**Analogie :** C'est comme avoir un traducteur automatique entre votre code et PostgreSQL.

### Comparaison Rapide

| Caract√©ristique | node-postgres (pg) | Prisma |
|-----------------|-------------------|---------|
| **Type** | Driver natif | ORM moderne |
| **Langage** | SQL brut | API JavaScript/TypeScript |
| **Courbe d'apprentissage** | Requiert connaissance SQL | Plus facile pour d√©butants |
| **Contr√¥le** | Total | Abstraction (moins de contr√¥le) |
| **Type-safety** | Non (sans effort) | Oui (TypeScript natif) |
| **Migrations** | Manuelles | Int√©gr√©es |
| **Performances** | Excellentes (direct SQL) | Tr√®s bonnes (optimis√©) |
| **Complexit√© SQL** | Toutes requ√™tes possibles | Limit√© aux capacit√©s de l'ORM |
| **Taille bundle** | L√©g√®re (~100 KB) | Plus lourde (~2 MB) |

**Recommandation :**
- **node-postgres** : Pour les projets n√©cessitant du SQL complexe, microservices l√©gers, ou √©quipes exp√©riment√©es en SQL
- **Prisma** : Pour les projets TypeScript, √©quipes pr√©f√©rant la productivit√©, ou applications CRUD standard

---

## Partie 1 : node-postgres (pg)

### Introduction √† node-postgres

**node-postgres** (npm package : `pg`) est le driver PostgreSQL le plus populaire pour Node.js. Il est :
- **L√©ger** : Peu de d√©pendances
- **Mature** : Utilis√© en production depuis plus de 10 ans
- **Flexible** : Support de toutes les fonctionnalit√©s PostgreSQL
- **Performant** : Acc√®s direct sans overhead

### Installation

```bash
npm install pg
```

Pour TypeScript (fortement recommand√©) :
```bash
npm install --save-dev @types/node @types/pg
```

### Connexion Basique

#### Connexion simple (client unique)

```javascript
const { Client } = require('pg');

// Configuration de connexion
const client = new Client({
  host: 'localhost',
  port: 5432,
  database: 'ma_database',
  user: 'mon_utilisateur',
  password: 'mon_password',
});

// Connexion asynchrone
async function connect() {
  try {
    await client.connect();
    console.log('‚úÖ Connect√© √† PostgreSQL');

    // Votre code ici

  } catch (error) {
    console.error('‚ùå Erreur de connexion:', error);
  } finally {
    await client.end(); // Toujours fermer la connexion
  }
}

connect();
```

**Important :** `Client` cr√©e une connexion unique. Pour les applications web, utilisez plut√¥t `Pool` (voir ci-dessous).

#### Configuration avec variables d'environnement (recommand√©)

Cr√©ez un fichier `.env` :
```env
DATABASE_URL=postgresql://user:password@localhost:5432/mydb
```

Puis utilisez `dotenv` :
```bash
npm install dotenv
```

```javascript
require('dotenv').config();
const { Client } = require('pg');

const client = new Client({
  connectionString: process.env.DATABASE_URL,
});
```

### Pool de Connexions (Production)

En production, **TOUJOURS** utiliser un pool de connexions pour de meilleures performances :

```javascript
const { Pool } = require('pg');

// Cr√©er un pool global
const pool = new Pool({
  host: 'localhost',
  port: 5432,
  database: 'ma_database',
  user: 'mon_utilisateur',
  password: 'mon_password',
  max: 20,                    // Maximum 20 connexions
  idleTimeoutMillis: 30000,   // Fermer apr√®s 30s d'inactivit√©
  connectionTimeoutMillis: 2000, // Timeout de connexion 2s
});

// Utilisation du pool
async function queryDatabase() {
  try {
    const result = await pool.query('SELECT NOW()');
    console.log(result.rows[0]);
  } catch (error) {
    console.error('Erreur:', error);
  }
}

// Fermer le pool √† la fin de l'application
process.on('SIGTERM', async () => {
  await pool.end();
});
```

**Avantages du Pool :**
- R√©utilisation des connexions (plus rapide)
- Gestion automatique des connexions
- Id√©al pour serveurs web (Express, Fastify, etc.)

### Ex√©cution de Requ√™tes

#### SELECT : R√©cup√©rer des donn√©es

```javascript
const { Pool } = require('pg');
const pool = new Pool(/* config */);

async function getUsers() {
  try {
    // Requ√™te simple
    const result = await pool.query('SELECT * FROM utilisateurs');

    console.log(`Nombre de lignes : ${result.rowCount}`);
    console.log('Colonnes :', result.fields.map(f => f.name));
    console.log('Donn√©es :', result.rows);

    // Parcourir les r√©sultats
    result.rows.forEach(user => {
      console.log(`ID: ${user.id}, Nom: ${user.nom}, Email: ${user.email}`);
    });

    return result.rows;
  } catch (error) {
    console.error('Erreur SELECT:', error);
    throw error;
  }
}

getUsers();
```

**Structure du r√©sultat :**
```javascript
{
  rows: [
    { id: 1, nom: 'Alice', email: 'alice@example.com' },
    { id: 2, nom: 'Bob', email: 'bob@example.com' }
  ],
  rowCount: 2,
  fields: [/* m√©tadonn√©es des colonnes */],
  command: 'SELECT'
}
```

#### Requ√™tes Param√©tr√©es (S√©curit√© Critique)

**‚ö†Ô∏è JAMAIS comme ceci (VULN√âRABLE) :**
```javascript
// ‚ùå DANGEREUX - Injection SQL possible !
const email = "alice@example.com' OR '1'='1";
const query = `SELECT * FROM users WHERE email = '${email}'`;
await pool.query(query);
```

**‚úÖ TOUJOURS utiliser des param√®tres :**
```javascript
// ‚úÖ S√âCURIS√â - Param√®tres √©chapp√©s automatiquement
const email = 'alice@example.com';
const query = 'SELECT * FROM users WHERE email = $1';
const result = await pool.query(query, [email]);
```

**Syntaxe des param√®tres :**
- `$1`, `$2`, `$3`, etc. : Positions des param√®tres
- Les valeurs sont pass√©es dans un tableau : `[param1, param2, ...]`

**Exemples avec plusieurs param√®tres :**
```javascript
// Param√®tres multiples
const query = 'SELECT * FROM produits WHERE categorie = $1 AND prix > $2';
const result = await pool.query(query, ['√âlectronique', 100]);

// INSERT avec param√®tres
const insertQuery = 'INSERT INTO users (nom, email, age) VALUES ($1, $2, $3) RETURNING id';
const values = ['Charlie', 'charlie@example.com', 35];
const result = await pool.query(insertQuery, values);
console.log('Nouvel ID:', result.rows[0].id);
```

### Op√©rations CRUD Compl√®tes

#### CREATE : Ins√©rer des donn√©es

```javascript
async function createUser(nom, email, age) {
  const query = `
    INSERT INTO utilisateurs (nom, email, age)
    VALUES ($1, $2, $3)
    RETURNING id, nom, email, created_at
  `;

  try {
    const result = await pool.query(query, [nom, email, age]);
    const newUser = result.rows[0];
    console.log('‚úÖ Utilisateur cr√©√©:', newUser);
    return newUser;
  } catch (error) {
    // Violation de contrainte UNIQUE (email d√©j√† existant)
    if (error.code === '23505') {
      throw new Error('Cet email existe d√©j√†');
    }
    throw error;
  }
}

// Utilisation
createUser('Alice', 'alice@example.com', 30);
```

**Insertion multiple (bulk insert) :**
```javascript
async function createMultipleUsers(users) {
  // users = [['Alice', 'alice@...', 30], ['Bob', 'bob@...', 25]]

  const query = `
    INSERT INTO utilisateurs (nom, email, age)
    VALUES ($1, $2, $3), ($4, $5, $6), ($7, $8, $9)
  `;

  // Aplatir le tableau
  const values = users.flat();

  const result = await pool.query(query, values);
  console.log(`${result.rowCount} utilisateurs cr√©√©s`);
}
```

**Meilleure approche pour bulk insert :**
```javascript
const format = require('pg-format'); // npm install pg-format

async function bulkInsertUsers(users) {
  // users = [['Alice', 'alice@...', 30], ['Bob', 'bob@...', 25]]

  const query = format(
    'INSERT INTO utilisateurs (nom, email, age) VALUES %L RETURNING id',
    users
  );

  const result = await pool.query(query);
  return result.rows.map(r => r.id);
}
```

#### READ : Lire des donn√©es

```javascript
// R√©cup√©rer un utilisateur par ID
async function getUserById(id) {
  const query = 'SELECT * FROM utilisateurs WHERE id = $1';
  const result = await pool.query(query, [id]);

  if (result.rowCount === 0) {
    return null; // Utilisateur non trouv√©
  }

  return result.rows[0];
}

// R√©cup√©rer avec filtres multiples
async function searchUsers(filters) {
  const { nom, ageMin, ageMax } = filters;

  const query = `
    SELECT * FROM utilisateurs
    WHERE nom ILIKE $1
      AND age BETWEEN $2 AND $3
    ORDER BY nom
  `;

  const result = await pool.query(query, [`%${nom}%`, ageMin, ageMax]);
  return result.rows;
}

// Utilisation
const users = await searchUsers({ nom: 'Ali', ageMin: 20, ageMax: 40 });
```

#### UPDATE : Modifier des donn√©es

```javascript
async function updateUser(id, updates) {
  const { nom, email, age } = updates;

  const query = `
    UPDATE utilisateurs
    SET nom = $1, email = $2, age = $3, updated_at = NOW()
    WHERE id = $4
    RETURNING *
  `;

  const result = await pool.query(query, [nom, email, age, id]);

  if (result.rowCount === 0) {
    throw new Error('Utilisateur non trouv√©');
  }

  return result.rows[0];
}

// Utilisation
const updated = await updateUser(1, {
  nom: 'Alice Smith',
  email: 'alice.smith@example.com',
  age: 31
});
```

**UPDATE partiel (uniquement les champs fournis) :**
```javascript
async function partialUpdateUser(id, updates) {
  const fields = [];
  const values = [];
  let paramCounter = 1;

  // Construire dynamiquement la requ√™te
  Object.keys(updates).forEach(key => {
    fields.push(`${key} = $${paramCounter}`);
    values.push(updates[key]);
    paramCounter++;
  });

  if (fields.length === 0) {
    throw new Error('Aucun champ √† mettre √† jour');
  }

  const query = `
    UPDATE utilisateurs
    SET ${fields.join(', ')}, updated_at = NOW()
    WHERE id = $${paramCounter}
    RETURNING *
  `;

  values.push(id);

  const result = await pool.query(query, values);
  return result.rows[0];
}

// Utilisation : met √† jour uniquement l'√¢ge
await partialUpdateUser(1, { age: 32 });
```

#### DELETE : Supprimer des donn√©es

```javascript
async function deleteUser(id) {
  const query = 'DELETE FROM utilisateurs WHERE id = $1 RETURNING *';

  const result = await pool.query(query, [id]);

  if (result.rowCount === 0) {
    throw new Error('Utilisateur non trouv√©');
  }

  return result.rows[0];
}

// Suppression multiple
async function deleteUsersByAge(ageMax) {
  const query = 'DELETE FROM utilisateurs WHERE age < $1';
  const result = await pool.query(query, [ageMax]);
  console.log(`${result.rowCount} utilisateurs supprim√©s`);
}
```

### Gestion des Transactions

#### Transaction basique

```javascript
async function transferMoney(fromAccountId, toAccountId, amount) {
  // R√©cup√©rer une connexion du pool
  const client = await pool.connect();

  try {
    // D√©marrer la transaction
    await client.query('BEGIN');

    // Op√©ration 1 : D√©biter le compte source
    await client.query(
      'UPDATE comptes SET solde = solde - $1 WHERE id = $2',
      [amount, fromAccountId]
    );

    // Op√©ration 2 : Cr√©diter le compte destination
    await client.query(
      'UPDATE comptes SET solde = solde + $1 WHERE id = $2',
      [amount, toAccountId]
    );

    // Valider la transaction
    await client.query('COMMIT');
    console.log('‚úÖ Transfert r√©ussi');

  } catch (error) {
    // Annuler la transaction en cas d'erreur
    await client.query('ROLLBACK');
    console.error('‚ùå Transfert annul√©:', error);
    throw error;
  } finally {
    // Toujours lib√©rer la connexion
    client.release();
  }
}
```

**Points cl√©s :**
- `await pool.connect()` : Obtenir une connexion d√©di√©e
- `BEGIN` : D√©marrer une transaction
- `COMMIT` : Valider les changements
- `ROLLBACK` : Annuler les changements
- `client.release()` : Rendre la connexion au pool

#### Transaction avec SAVEPOINT

```javascript
async function complexTransaction() {
  const client = await pool.connect();

  try {
    await client.query('BEGIN');

    // Op√©ration 1
    await client.query('INSERT INTO logs (message) VALUES ($1)', ['Op 1']);

    // Cr√©er un point de sauvegarde
    await client.query('SAVEPOINT mon_savepoint');

    try {
      // Op√©ration 2 (risqu√©e)
      await client.query('INSERT INTO risky_table (data) VALUES ($1)', ['data']);
    } catch (error) {
      // Revenir au savepoint (annule uniquement l'Op 2)
      await client.query('ROLLBACK TO SAVEPOINT mon_savepoint');
      console.log('Savepoint restaur√©, Op 1 toujours valide');
    }

    // Op√©ration 3
    await client.query('INSERT INTO logs (message) VALUES ($1)', ['Op 3']);

    await client.query('COMMIT');
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}
```

### Types de Donn√©es PostgreSQL

#### Types num√©riques

```javascript
// INTEGER, BIGINT
await pool.query('INSERT INTO produits (id, quantite) VALUES ($1, $2)', [1, 100]);

// NUMERIC/DECIMAL (utiliser des strings pour la pr√©cision)
await pool.query('INSERT INTO prix (montant) VALUES ($1)', ['19.99']);

// FLOAT/DOUBLE PRECISION
await pool.query('INSERT INTO mesures (valeur) VALUES ($1)', [3.14159]);
```

#### Types texte

```javascript
// VARCHAR, TEXT
await pool.query('INSERT INTO articles (titre, contenu) VALUES ($1, $2)',
  ['Mon Titre', 'Contenu tr√®s long...']
);

// CHAR (taille fixe)
await pool.query('INSERT INTO codes (code_postal) VALUES ($1)', ['75001']);
```

#### Types temporels

```javascript
// DATE
const date = new Date('2025-11-23');
await pool.query('INSERT INTO evenements (date) VALUES ($1)', [date]);

// TIMESTAMP / TIMESTAMPTZ
const now = new Date();
await pool.query('INSERT INTO logs (timestamp) VALUES ($1)', [now]);

// INTERVAL
await pool.query("SELECT NOW() + INTERVAL '7 days'");
```

**Lecture des dates :**
```javascript
const result = await pool.query('SELECT created_at FROM users WHERE id = $1', [1]);
const date = result.rows[0].created_at; // Objet Date JavaScript
console.log(date.toISOString()); // "2025-11-23T10:30:00.000Z"
```

#### JSON et JSONB

```javascript
// Insertion JSON
const profile = { nom: 'Alice', age: 30, tags: ['developer', 'postgresql'] };

await pool.query('INSERT INTO users (profile) VALUES ($1)', [JSON.stringify(profile)]);
// Ou directement (pg le s√©rialise automatiquement)
await pool.query('INSERT INTO users (profile) VALUES ($1)', [profile]);

// Lecture JSON
const result = await pool.query('SELECT profile FROM users WHERE id = $1', [1]);
const userProfile = result.rows[0].profile; // Objet JavaScript d√©j√† pars√©
console.log(userProfile.nom); // 'Alice'
```

**Requ√™tes JSONB avanc√©es :**
```javascript
// Recherche dans JSONB
const result = await pool.query(
  "SELECT * FROM users WHERE profile->>'nom' = $1",
  ['Alice']
);

// Extraction de chemin
const result = await pool.query(
  "SELECT profile->'tags'->0 as premier_tag FROM users"
);
```

#### Arrays (Tableaux PostgreSQL)

```javascript
// Insertion de tableau
const tags = ['javascript', 'postgresql', 'nodejs'];
await pool.query('INSERT INTO articles (tags) VALUES ($1)', [tags]);

// Lecture de tableau
const result = await pool.query('SELECT tags FROM articles WHERE id = $1', [1]);
const articleTags = result.rows[0].tags; // ['javascript', 'postgresql', 'nodejs']

// Recherche dans tableau
const result = await pool.query(
  "SELECT * FROM articles WHERE $1 = ANY(tags)",
  ['postgresql']
);
```

#### UUID

```javascript
const { v4: uuidv4 } = require('uuid'); // npm install uuid

// G√©n√©ration c√¥t√© application (UUID v4)
const id = uuidv4();
await pool.query('INSERT INTO sessions (id, token) VALUES ($1, $2)', [id, 'token123']);

// G√©n√©ration c√¥t√© PostgreSQL (UUID v7 dans PG 18)
await pool.query('INSERT INTO events (id, data) VALUES (gen_uuid_v7(), $1)', ['event data']);

// Lecture UUID
const result = await pool.query('SELECT id FROM sessions WHERE token = $1', ['token123']);
const sessionId = result.rows[0].id; // String UUID
```

### Prepared Statements (Optimisation)

Les **prepared statements** permettent de pr√©parer une requ√™te une fois et de l'ex√©cuter plusieurs fois avec diff√©rents param√®tres.

```javascript
async function usePreparedStatement() {
  const client = await pool.connect();

  try {
    // Pr√©parer la requ√™te
    await client.query({
      name: 'get-user-by-email',
      text: 'SELECT * FROM users WHERE email = $1'
    });

    // Ex√©cuter plusieurs fois (plus rapide)
    const result1 = await client.query('get-user-by-email', ['alice@example.com']);
    const result2 = await client.query('get-user-by-email', ['bob@example.com']);

    // PostgreSQL r√©utilise le plan d'ex√©cution

  } finally {
    client.release();
  }
}
```

**Gain de performance :** ~10-30% pour les requ√™tes r√©p√©t√©es.

### Gestion des Erreurs

#### Codes d'erreur PostgreSQL courants

```javascript
async function handleErrors() {
  try {
    await pool.query('INSERT INTO users (email) VALUES ($1)', ['duplicate@example.com']);
  } catch (error) {
    console.error('Code erreur:', error.code);
    console.error('Message:', error.message);
    console.error('D√©tail:', error.detail);

    // Codes SQLSTATE courants
    switch (error.code) {
      case '23505': // Unique violation
        console.error('Cette valeur existe d√©j√†');
        break;
      case '23503': // Foreign key violation
        console.error('R√©f√©rence introuvable');
        break;
      case '23502': // NOT NULL violation
        console.error('Champ obligatoire manquant');
        break;
      case '42P01': // Undefined table
        console.error('Table inexistante');
        break;
      case '42703': // Undefined column
        console.error('Colonne inexistante');
        break;
      default:
        console.error('Erreur PostgreSQL:', error.message);
    }
  }
}
```

#### Retry logic (reconnexion automatique)

```javascript
async function queryWithRetry(query, params, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await pool.query(query, params);
    } catch (error) {
      if (attempt === maxRetries) {
        throw error;
      }

      // R√©essayer uniquement pour les erreurs de connexion
      if (error.code === 'ECONNREFUSED' || error.code === 'ETIMEDOUT') {
        console.log(`Tentative ${attempt}/${maxRetries} √©chou√©e, retry...`);
        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
      } else {
        throw error;
      }
    }
  }
}
```

### Exemple Complet : API REST avec Express

```javascript
const express = require('express');
const { Pool } = require('pg');

const app = express();
app.use(express.json());

// Configuration du pool
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 20,
});

// Middleware de gestion d'erreurs
const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};

// GET /users - Liste des utilisateurs
app.get('/users', asyncHandler(async (req, res) => {
  const result = await pool.query('SELECT id, nom, email FROM utilisateurs ORDER BY nom');
  res.json(result.rows);
}));

// GET /users/:id - Un utilisateur
app.get('/users/:id', asyncHandler(async (req, res) => {
  const { id } = req.params;
  const result = await pool.query('SELECT * FROM utilisateurs WHERE id = $1', [id]);

  if (result.rowCount === 0) {
    return res.status(404).json({ error: 'Utilisateur non trouv√©' });
  }

  res.json(result.rows[0]);
}));

// POST /users - Cr√©er un utilisateur
app.post('/users', asyncHandler(async (req, res) => {
  const { nom, email, age } = req.body;

  const result = await pool.query(
    'INSERT INTO utilisateurs (nom, email, age) VALUES ($1, $2, $3) RETURNING *',
    [nom, email, age]
  );

  res.status(201).json(result.rows[0]);
}));

// PUT /users/:id - Modifier un utilisateur
app.put('/users/:id', asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { nom, email, age } = req.body;

  const result = await pool.query(
    'UPDATE utilisateurs SET nom = $1, email = $2, age = $3 WHERE id = $4 RETURNING *',
    [nom, email, age, id]
  );

  if (result.rowCount === 0) {
    return res.status(404).json({ error: 'Utilisateur non trouv√©' });
  }

  res.json(result.rows[0]);
}));

// DELETE /users/:id - Supprimer un utilisateur
app.delete('/users/:id', asyncHandler(async (req, res) => {
  const { id } = req.params;

  const result = await pool.query('DELETE FROM utilisateurs WHERE id = $1 RETURNING *', [id]);

  if (result.rowCount === 0) {
    return res.status(404).json({ error: 'Utilisateur non trouv√©' });
  }

  res.json({ message: 'Utilisateur supprim√©', user: result.rows[0] });
}));

// Middleware de gestion d'erreurs global
app.use((error, req, res, next) => {
  console.error('Erreur serveur:', error);

  if (error.code === '23505') {
    return res.status(409).json({ error: 'Cette valeur existe d√©j√†' });
  }

  res.status(500).json({ error: 'Erreur serveur interne' });
});

// D√©marrage du serveur
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`üöÄ Serveur d√©marr√© sur le port ${PORT}`);
});

// Fermeture propre
process.on('SIGTERM', async () => {
  await pool.end();
  process.exit(0);
});
```

---

## Partie 2 : Prisma (ORM Moderne)

### Introduction √† Prisma

**Prisma** est un ORM next-generation pour Node.js et TypeScript. Il offre :
- **Type-safety** : Types TypeScript g√©n√©r√©s automatiquement
- **Migrations** : Gestion int√©gr√©e du sch√©ma de base de donn√©es
- **Prisma Studio** : Interface graphique pour explorer vos donn√©es
- **Prisma Client** : API auto-g√©n√©r√©e pour vos requ√™tes

### Architecture Prisma

```
Votre Application (TypeScript/JavaScript)
           ‚Üì
    Prisma Client (g√©n√©r√©)
           ‚Üì
    Prisma Query Engine
           ‚Üì
    PostgreSQL Database
```

**Fichiers cl√©s :**
- `schema.prisma` : D√©finition du sch√©ma (single source of truth)
- `prisma/migrations/` : Historique des migrations
- `node_modules/.prisma/client/` : Client g√©n√©r√© automatiquement

### Installation et Configuration

#### Installation

```bash
npm install prisma --save-dev
npm install @prisma/client
```

#### Initialisation

```bash
npx prisma init
```

Cette commande cr√©e :
- `prisma/schema.prisma` : Fichier de configuration
- `.env` : Variables d'environnement

#### Configuration du schema.prisma

```prisma
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// D√©finition du mod√®le (table)
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  nom       String
  age       Int?     // ? = nullable
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relation
  posts     Post[]
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  Int

  // Relation many-to-one
  author    User     @relation(fields: [authorId], references: [id])
}
```

**Fichier .env :**
```env
DATABASE_URL="postgresql://user:password@localhost:5432/mydb?schema=public"
```

### Workflow Prisma

#### 1. D√©finir le sch√©ma (schema.prisma)

Vous d√©finissez vos mod√®les dans `schema.prisma`.

#### 2. Cr√©er une migration

```bash
npx prisma migrate dev --name init
```

Cette commande :
- G√©n√®re le SQL de migration
- Applique la migration √† la base de donn√©es
- R√©g√©n√®re le Prisma Client

#### 3. G√©n√©rer le Client

```bash
npx prisma generate
```

G√©n√®re/r√©g√©n√®re le Prisma Client avec vos types TypeScript.

#### 4. Utiliser le Client dans votre code

```javascript
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

// Votre code ici
```

### CRUD avec Prisma

#### CREATE : Cr√©er des enregistrements

```javascript
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

async function main() {
  // Cr√©er un utilisateur
  const user = await prisma.user.create({
    data: {
      email: 'alice@example.com',
      nom: 'Alice',
      age: 30,
    },
  });

  console.log('Utilisateur cr√©√©:', user);
}

main()
  .catch((e) => console.error(e))
  .finally(async () => {
    await prisma.$disconnect();
  });
```

**Cr√©ation avec relation :**
```javascript
// Cr√©er un utilisateur ET ses posts en une seule requ√™te
const userWithPosts = await prisma.user.create({
  data: {
    email: 'bob@example.com',
    nom: 'Bob',
    posts: {
      create: [
        { title: 'Mon premier post', content: 'Hello World!' },
        { title: 'Mon deuxi√®me post', content: 'Prisma est g√©nial' },
      ],
    },
  },
  include: {
    posts: true, // Inclure les posts dans le r√©sultat
  },
});
```

**Cr√©ation multiple (bulk insert) :**
```javascript
const users = await prisma.user.createMany({
  data: [
    { email: 'user1@example.com', nom: 'User 1', age: 25 },
    { email: 'user2@example.com', nom: 'User 2', age: 30 },
    { email: 'user3@example.com', nom: 'User 3', age: 35 },
  ],
  skipDuplicates: true, // Ignorer les doublons (email unique)
});

console.log(`${users.count} utilisateurs cr√©√©s`);
```

#### READ : Lire des donn√©es

```javascript
// R√©cup√©rer tous les utilisateurs
const allUsers = await prisma.user.findMany();

// R√©cup√©rer avec filtres
const filteredUsers = await prisma.user.findMany({
  where: {
    age: {
      gte: 18, // Greater Than or Equal (age >= 18)
      lte: 65, // Less Than or Equal (age <= 65)
    },
  },
  orderBy: {
    nom: 'asc', // Tri ascendant
  },
  take: 10, // LIMIT 10
  skip: 0,  // OFFSET 0 (pagination)
});

// R√©cup√©rer un seul utilisateur par ID
const user = await prisma.user.findUnique({
  where: {
    id: 1,
  },
});

// R√©cup√©rer avec relations
const userWithPosts = await prisma.user.findUnique({
  where: { id: 1 },
  include: {
    posts: true, // Charger les posts associ√©s
  },
});

console.log('Utilisateur:', userWithPosts.nom);
console.log('Nombre de posts:', userWithPosts.posts.length);
```

**Recherche avanc√©e :**
```javascript
// Op√©rateurs de filtrage
const users = await prisma.user.findMany({
  where: {
    OR: [
      { email: { contains: '@gmail.com' } },  // LIKE '%@gmail.com%'
      { nom: { startsWith: 'A' } },            // LIKE 'A%'
    ],
    AND: [
      { age: { not: null } },
      { createdAt: { gte: new Date('2025-01-01') } },
    ],
  },
});

// Recherche full-text (si configur√©)
const results = await prisma.user.findMany({
  where: {
    nom: {
      search: 'Alice Bob', // PostgreSQL full-text search
    },
  },
});
```

#### UPDATE : Modifier des donn√©es

```javascript
// Mettre √† jour un utilisateur
const updatedUser = await prisma.user.update({
  where: {
    id: 1,
  },
  data: {
    age: 31,
    email: 'newemail@example.com',
  },
});

// Mettre √† jour plusieurs enregistrements
const updateResult = await prisma.user.updateMany({
  where: {
    age: {
      lt: 18, // Moins de 18 ans
    },
  },
  data: {
    age: 18, // D√©finir √† 18
  },
});

console.log(`${updateResult.count} utilisateurs mis √† jour`);

// Incr√©menter une valeur
const incrementedUser = await prisma.user.update({
  where: { id: 1 },
  data: {
    age: {
      increment: 1, // age = age + 1
    },
  },
});
```

#### DELETE : Supprimer des donn√©es

```javascript
// Supprimer un utilisateur
const deletedUser = await prisma.user.delete({
  where: {
    id: 1,
  },
});

// Supprimer plusieurs utilisateurs
const deleteResult = await prisma.user.deleteMany({
  where: {
    age: {
      lt: 18,
    },
  },
});

console.log(`${deleteResult.count} utilisateurs supprim√©s`);

// Supprimer tous les enregistrements (attention !)
await prisma.user.deleteMany({});
```

### Relations dans Prisma

#### One-to-Many (Un √† Plusieurs)

```prisma
model User {
  id    Int    @id @default(autoincrement())
  nom   String
  posts Post[] // Un user a plusieurs posts
}

model Post {
  id       Int    @id @default(autoincrement())
  title    String
  authorId Int
  author   User   @relation(fields: [authorId], references: [id])
}
```

**Utilisation :**
```javascript
// Cr√©er un post pour un utilisateur existant
const post = await prisma.post.create({
  data: {
    title: 'Nouveau post',
    author: {
      connect: { id: 1 }, // Lier √† l'utilisateur ID 1
    },
  },
});

// R√©cup√©rer un utilisateur avec ses posts
const userWithPosts = await prisma.user.findUnique({
  where: { id: 1 },
  include: {
    posts: {
      where: { published: true }, // Filtrer les posts
      orderBy: { createdAt: 'desc' },
    },
  },
});
```

#### Many-to-Many (Plusieurs √† Plusieurs)

```prisma
model Post {
  id         Int        @id @default(autoincrement())
  title      String
  categories Category[] @relation("PostCategories")
}

model Category {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[] @relation("PostCategories")
}
```

Prisma cr√©e automatiquement la table de jonction `_PostCategories`.

**Utilisation :**
```javascript
// Cr√©er un post avec plusieurs cat√©gories
const post = await prisma.post.create({
  data: {
    title: 'Mon article',
    categories: {
      connect: [
        { id: 1 },
        { id: 2 },
      ],
    },
  },
});

// R√©cup√©rer avec relations
const postWithCategories = await prisma.post.findUnique({
  where: { id: 1 },
  include: {
    categories: true,
  },
});
```

### Transactions avec Prisma

#### Transaction basique

```javascript
// Transaction automatique avec $transaction
const [user, post] = await prisma.$transaction([
  prisma.user.create({
    data: { email: 'alice@example.com', nom: 'Alice' },
  }),
  prisma.post.create({
    data: { title: 'Premier post', authorId: 1 },
  }),
]);

// Si une op√©ration √©choue, tout est annul√© (rollback)
```

#### Transaction interactive

Pour des transactions complexes avec logique conditionnelle :

```javascript
const result = await prisma.$transaction(async (tx) => {
  // tx est un Prisma Client transactionnel

  // Op√©ration 1
  const user = await tx.user.create({
    data: { email: 'bob@example.com', nom: 'Bob' },
  });

  // Logique conditionnelle
  if (user.id % 2 === 0) {
    // Op√©ration 2
    await tx.post.create({
      data: { title: 'Post pair', authorId: user.id },
    });
  }

  return user;
});
```

### Requ√™tes Brutes (Raw SQL)

Parfois, vous avez besoin d'√©crire du SQL brut pour des requ√™tes complexes :

```javascript
// Requ√™te brute avec typage
const users = await prisma.$queryRaw`
  SELECT * FROM "User"
  WHERE age > ${18}
  ORDER BY nom
`;

console.log(users);

// Requ√™te brute sans typage
const result = await prisma.$queryRawUnsafe(
  'SELECT * FROM "User" WHERE email = $1',
  'alice@example.com'
);

// Ex√©cution SQL (INSERT, UPDATE, DELETE)
const affected = await prisma.$executeRaw`
  UPDATE "User" SET age = age + 1 WHERE age < ${50}
`;

console.log(`${affected} lignes affect√©es`);
```

**‚ö†Ô∏è Attention :** Utilisez toujours les template literals (backticks) pour √©viter les injections SQL.

### Migrations

#### Cr√©er une migration

```bash
npx prisma migrate dev --name add_user_profile
```

#### Appliquer les migrations en production

```bash
npx prisma migrate deploy
```

#### R√©initialiser la base de donn√©es (d√©veloppement)

```bash
npx prisma migrate reset
```

**Warning :** Supprime toutes les donn√©es !

#### Voir l'√©tat des migrations

```bash
npx prisma migrate status
```

### Prisma Studio (Interface Graphique)

Prisma Studio est une interface web pour explorer et modifier vos donn√©es :

```bash
npx prisma studio
```

Ouvre une interface sur `http://localhost:5555` o√π vous pouvez :
- Voir toutes vos tables
- Filtrer et rechercher
- Cr√©er, modifier, supprimer des enregistrements
- Visualiser les relations

### Exemple Complet : API REST avec Prisma

```javascript
const express = require('express');
const { PrismaClient } = require('@prisma/client');

const app = express();
app.use(express.json());

const prisma = new PrismaClient();

// GET /users - Liste des utilisateurs
app.get('/users', async (req, res) => {
  try {
    const users = await prisma.user.findMany({
      include: {
        posts: {
          where: { published: true },
        },
      },
    });
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: 'Erreur serveur' });
  }
});

// GET /users/:id - Un utilisateur
app.get('/users/:id', async (req, res) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id: parseInt(req.params.id) },
      include: { posts: true },
    });

    if (!user) {
      return res.status(404).json({ error: 'Utilisateur non trouv√©' });
    }

    res.json(user);
  } catch (error) {
    res.status(500).json({ error: 'Erreur serveur' });
  }
});

// POST /users - Cr√©er un utilisateur
app.post('/users', async (req, res) => {
  try {
    const { email, nom, age } = req.body;

    const user = await prisma.user.create({
      data: { email, nom, age },
    });

    res.status(201).json(user);
  } catch (error) {
    if (error.code === 'P2002') {
      return res.status(409).json({ error: 'Email d√©j√† utilis√©' });
    }
    res.status(500).json({ error: 'Erreur serveur' });
  }
});

// PUT /users/:id - Modifier un utilisateur
app.put('/users/:id', async (req, res) => {
  try {
    const { email, nom, age } = req.body;

    const user = await prisma.user.update({
      where: { id: parseInt(req.params.id) },
      data: { email, nom, age },
    });

    res.json(user);
  } catch (error) {
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Utilisateur non trouv√©' });
    }
    res.status(500).json({ error: 'Erreur serveur' });
  }
});

// DELETE /users/:id - Supprimer un utilisateur
app.delete('/users/:id', async (req, res) => {
  try {
    await prisma.user.delete({
      where: { id: parseInt(req.params.id) },
    });

    res.json({ message: 'Utilisateur supprim√©' });
  } catch (error) {
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Utilisateur non trouv√©' });
    }
    res.status(500).json({ error: 'Erreur serveur' });
  }
});

// D√©marrage
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`üöÄ Serveur d√©marr√© sur le port ${PORT}`);
});

// Fermeture propre
process.on('SIGTERM', async () => {
  await prisma.$disconnect();
  process.exit(0);
});
```

### Codes d'Erreur Prisma

| Code | Description | Action |
|------|-------------|--------|
| `P2002` | Contrainte unique viol√©e | Retourner 409 Conflict |
| `P2003` | Contrainte FK viol√©e | Retourner 400 Bad Request |
| `P2025` | Enregistrement non trouv√© | Retourner 404 Not Found |
| `P1001` | Impossible de se connecter | V√©rifier la connexion DB |
| `P1017` | Serveur ferm√© la connexion | Retry avec backoff |

---

## Comparaison : node-postgres vs Prisma

### Quand utiliser node-postgres (pg)

‚úÖ **Choisir pg si :**
- Vous avez besoin de **requ√™tes SQL complexes** (CTEs r√©cursifs, window functions avanc√©es)
- Vous optimisez pour des **performances maximales**
- Votre √©quipe est **experte en SQL**
- Vous avez des **contraintes de taille** (bundles l√©gers)
- Vous travaillez sur des **microservices** simples
- Vous voulez un **contr√¥le total** sur le SQL g√©n√©r√©

**Exemple de cas d'usage :**
- Syst√®me analytique avec requ√™tes complexes
- API haute performance avec latence critique
- Scripts de migration de donn√©es
- Applications legacy avec beaucoup de SQL existant

### Quand utiliser Prisma

‚úÖ **Choisir Prisma si :**
- Vous d√©veloppez en **TypeScript** et voulez du type-safety
- Vous voulez de la **productivit√©** et moins de boilerplate
- Votre √©quipe est **moins exp√©riment√©e en SQL**
- Vous avez besoin de **migrations automatiques**
- Vous voulez **Prisma Studio** pour explorer vos donn√©es
- Vous construisez une **application CRUD standard**

**Exemple de cas d'usage :**
- SaaS moderne avec API REST/GraphQL
- Applications full-stack TypeScript (Next.js, Nest.js)
- Prototypes et MVPs rapides
- √âquipes pr√©f√©rant l'abstraction

### Comparaison de Performance

**Benchmark indicatif (1000 requ√™tes SELECT simples) :**
- **node-postgres** : ~150ms
- **Prisma** : ~180ms

**Diff√©rence :** ~20% plus lent pour Prisma, mais n√©gligeable dans la plupart des applications.

### Approche Hybride

Vous pouvez **combiner** les deux :

```javascript
const { PrismaClient } = require('@prisma/client');
const { Pool } = require('pg');

const prisma = new PrismaClient();
const pool = new Pool(/* config */);

// Utiliser Prisma pour les op√©rations CRUD standard
const users = await prisma.user.findMany();

// Utiliser pg pour les requ√™tes complexes
const analytics = await pool.query(`
  WITH monthly_stats AS (
    SELECT
      DATE_TRUNC('month', created_at) as month,
      COUNT(*) as user_count
    FROM "User"
    GROUP BY month
  )
  SELECT * FROM monthly_stats
  ORDER BY month DESC
  LIMIT 12
`);
```

---

## Bonnes Pratiques

### 1. Gestion de la connexion

**node-postgres :**
```javascript
// ‚úÖ Bon : Pool global
const pool = new Pool({ /* config */ });

// Export pour r√©utilisation
module.exports = { pool };

// ‚ùå √âviter : Cr√©er un nouveau pool √† chaque requ√™te
```

**Prisma :**
```javascript
// ‚úÖ Bon : Instance globale unique
const { PrismaClient } = require('@prisma/client');

const prisma = global.prisma || new PrismaClient();

if (process.env.NODE_ENV !== 'production') {
  global.prisma = prisma;
}

module.exports = { prisma };
```

### 2. Variables d'environnement

```javascript
// .env
DATABASE_URL=postgresql://user:pass@localhost:5432/db
NODE_ENV=development
PORT=3000

// Utilisation
require('dotenv').config();

const config = {
  database: process.env.DATABASE_URL,
  port: process.env.PORT || 3000,
};
```

### 3. Logging et Debugging

**node-postgres :**
```javascript
const pool = new Pool({
  /* config */
  log: (msg) => console.log('PostgreSQL:', msg),
});
```

**Prisma :**
```javascript
const prisma = new PrismaClient({
  log: ['query', 'info', 'warn', 'error'],
});

// √âcouter les √©v√©nements de requ√™te
prisma.$on('query', (e) => {
  console.log('Query: ' + e.query);
  console.log('Duration: ' + e.duration + 'ms');
});
```

### 4. Gestion des erreurs centralis√©e

```javascript
// Express error handler
app.use((error, req, res, next) => {
  console.error('Error:', error);

  // Erreurs PostgreSQL (pg)
  if (error.code === '23505') {
    return res.status(409).json({ error: 'Duplicate entry' });
  }

  // Erreurs Prisma
  if (error.code === 'P2002') {
    return res.status(409).json({ error: 'Duplicate entry' });
  }

  res.status(500).json({ error: 'Internal server error' });
});
```

### 5. Tests

**Avec node-postgres :**
```javascript
const { Pool } = require('pg');

describe('User Repository', () => {
  let pool;

  beforeAll(async () => {
    pool = new Pool({
      connectionString: process.env.TEST_DATABASE_URL,
    });
  });

  afterAll(async () => {
    await pool.end();
  });

  it('should create a user', async () => {
    const result = await pool.query(
      'INSERT INTO users (email) VALUES ($1) RETURNING *',
      ['test@example.com']
    );
    expect(result.rows[0].email).toBe('test@example.com');
  });
});
```

**Avec Prisma :**
```javascript
const { PrismaClient } = require('@prisma/client');

describe('User Repository', () => {
  let prisma;

  beforeAll(async () => {
    prisma = new PrismaClient({
      datasources: {
        db: { url: process.env.TEST_DATABASE_URL },
      },
    });
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  it('should create a user', async () => {
    const user = await prisma.user.create({
      data: { email: 'test@example.com', nom: 'Test' },
    });
    expect(user.email).toBe('test@example.com');
  });
});
```

---

## Ressources et Documentation

### node-postgres (pg)
- **Documentation officielle** : https://node-postgres.com/
- **GitHub** : https://github.com/brianc/node-postgres
- **npm** : https://www.npmjs.com/package/pg

### Prisma
- **Documentation officielle** : https://www.prisma.io/docs
- **GitHub** : https://github.com/prisma/prisma
- **Prisma Studio** : Interface graphique int√©gr√©e
- **Community Discord** : https://pris.ly/discord

### Tutoriels et Guides
- **Prisma Getting Started** : https://www.prisma.io/docs/getting-started
- **node-postgres Tutorial** : https://node-postgres.com/guides/project-structure
- **PostgreSQL + Node.js Best Practices** : Nombreux articles sur Medium, Dev.to

---

## R√©sum√© des Points Cl√©s

### node-postgres (pg)

- ‚úÖ **Driver natif** l√©ger et performant
- ‚úÖ Utilisez **toujours** un `Pool` en production
- ‚úÖ **Param√®tres** (`$1`, `$2`) pour √©viter les injections SQL
- ‚úÖ Gestion manuelle des **transactions** avec `BEGIN/COMMIT/ROLLBACK`
- ‚úÖ Id√©al pour **SQL complexe** et **performances critiques**

### Prisma

- ‚úÖ **ORM moderne** avec type-safety TypeScript
- ‚úÖ **Sch√©ma unique** (`schema.prisma`) = source de v√©rit√©
- ‚úÖ **Migrations** automatiques et versionn√©es
- ‚úÖ **Prisma Studio** pour explorer vos donn√©es visuellement
- ‚úÖ API **intuitive** et **productive** pour CRUD
- ‚úÖ Id√©al pour **d√©veloppement rapide** et **maintenabilit√©**

### Choix Final

**Pas de mauvais choix !** Les deux approches sont excellentes. Choisissez en fonction de :
- Votre **expertise** (SQL vs ORM)
- Vos **besoins** (performance vs productivit√©)
- Votre **stack** (JavaScript vs TypeScript)
- La **complexit√©** de vos requ√™tes

**Conseil :** Pour un nouveau projet TypeScript, commencez avec **Prisma**. Si vous avez besoin de SQL complexe, utilisez `prisma.$queryRaw` ou combinez avec **node-postgres**.

---

**Prochaine √©tape :** Explorez les autres drivers (Java JDBC, Go pgx, .NET Npgsql) pour comparer les approches et ma√Ætriser PostgreSQL dans tous les √©cosyst√®mes.

‚è≠Ô∏è [Java : JDBC, HikariCP, R2DBC](/20-drivers-connexion-applicative/01.3-java-jdbc-hikari.md)
