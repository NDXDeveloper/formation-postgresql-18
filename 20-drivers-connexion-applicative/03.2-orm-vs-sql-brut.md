üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.3.2. ORM vs SQL brut : Quand utiliser quoi

## Introduction

Le d√©bat entre **ORM** (Object-Relational Mapping) et **SQL brut** est l'un des plus anciens et des plus passionn√©s dans le monde du d√©veloppement. Certains d√©veloppeurs jurent que par les ORM, d'autres les fuient comme la peste. La v√©rit√© ? **Les deux ont leur place**, et savoir quand utiliser l'un ou l'autre est une comp√©tence essentielle.

**Objectif de ce chapitre :** Comprendre ce qu'est un ORM, ses avantages et limites, et d√©velopper un sens critique pour choisir la bonne approche selon le contexte.

---

## 1. Qu'est-ce qu'un ORM ?

### 1.1. D√©finition Simple

Un **ORM** (Object-Relational Mapping) est une biblioth√®que qui fait le pont entre votre code orient√© objet et votre base de donn√©es relationnelle.

**Analogie :** C'est comme un traducteur automatique entre votre langage de programmation et SQL.

**Concr√®tement :**
- Vous manipulez des **objets** (classes, instances)
- L'ORM g√©n√®re et ex√©cute du **SQL** pour vous
- Vous n'√©crivez (presque) jamais de SQL directement

### 1.2. Exemple Visuel

**Sans ORM (SQL brut) :**
```python
# Python avec psycopg3
cursor.execute("SELECT * FROM users WHERE email = %s", (email,))
row = cursor.fetchone()
user = {
    'id': row[0],
    'name': row[1],
    'email': row[2]
}
```

**Avec ORM (exemple Django) :**
```python
# Python avec Django ORM
user = User.objects.get(email=email)
# user.id, user.name, user.email sont directement accessibles
```

**R√©sultat :** Le code avec ORM est plus court, plus lisible, plus "pythonique".

### 1.3. ORM Populaires par Langage

| Langage | ORM Principal | Alternatives |
|---------|---------------|--------------|
| **Python** | Django ORM, SQLAlchemy | Peewee, Tortoise ORM, Pony ORM |
| **Java** | Hibernate | JPA, MyBatis, jOOQ |
| **JavaScript/TypeScript** | Prisma, TypeORM | Sequelize, Knex.js, Drizzle |
| **PHP** | Eloquent (Laravel), Doctrine | Propel, RedBeanPHP |
| **Ruby** | Active Record (Rails) | Sequel, DataMapper |
| **C#** | Entity Framework | Dapper, NHibernate |
| **Go** | GORM | SQLBoiler, Ent |

### 1.4. Que Fait un ORM Concr√®tement ?

**Fonctionnalit√©s typiques :**

1. **Mapping Objet-Table**
   ```python
   class User:  # Classe Python
       id: int
       name: str
       email: str
   # ‚Üí Table 'users' en base de donn√©es
   ```

2. **G√©n√©ration de SQL**
   ```python
   User.objects.filter(age__gte=18)
   # ‚Üí SELECT * FROM users WHERE age >= 18
   ```

3. **Gestion des Relations**
   ```python
   user.articles.all()  # Articles de cet utilisateur
   # ‚Üí SELECT * FROM articles WHERE user_id = ?
   ```

4. **Migrations de Sch√©ma**
   ```bash
   python manage.py makemigrations
   # ‚Üí G√©n√®re un fichier de migration SQL
   ```

5. **Validation et Contraintes**
   ```python
   user = User(email="invalid")  # Validation automatique
   user.save()  # ‚Üí Erreur si email invalide
   ```

---

## 2. SQL Brut : La Fondation

### 2.1. Qu'est-ce que le SQL Brut ?

**SQL brut** (ou raw SQL) signifie √©crire directement vos requ√™tes SQL et les ex√©cuter via un driver de base de donn√©es.

**Exemple avec Python (psycopg3) :**
```python
import psycopg

# Connexion
conn = psycopg.connect("dbname=mydb user=postgres")
cursor = conn.cursor()

# Requ√™te SQL brute
cursor.execute("""
    SELECT u.name, COUNT(a.id) as article_count
    FROM users u
    LEFT JOIN articles a ON u.id = a.user_id
    GROUP BY u.id, u.name
    HAVING COUNT(a.id) > 5
    ORDER BY article_count DESC
""")

results = cursor.fetchall()
for row in results:
    print(f"{row[0]}: {row[1]} articles")

cursor.close()
conn.close()
```

### 2.2. Avantages du SQL Brut

#### ‚úÖ 1. Contr√¥le Total

Vous √©crivez **exactement** le SQL que vous voulez, sans surprise.

**Exemple :** Requ√™te optimis√©e avec window functions
```sql
SELECT
    user_id,
    name,
    article_title,
    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY published_at DESC) as rank
FROM users u
JOIN articles a ON u.id = a.user_id
WHERE rank <= 3;  -- Top 3 articles par utilisateur
```

Difficile (voire impossible) √† faire proprement avec certains ORM.

#### ‚úÖ 2. Performance Optimale

Vous pouvez utiliser **toutes les features** de PostgreSQL :
- CTE r√©cursives
- Window functions avanc√©es
- LATERAL joins
- Optimisations sp√©cifiques (EXPLAIN, hints)

#### ‚úÖ 3. Pas de "Magie Noire"

Ce qui s'ex√©cute = ce que vous avez √©crit. Pas de surprise sur :
- Le SQL g√©n√©r√©
- Le nombre de requ√™tes
- Les jointures effectu√©es

#### ‚úÖ 4. Courbe d'Apprentissage SQL

√âcrire du SQL brut **am√©liore votre ma√Ætrise de SQL**, une comp√©tence transf√©rable.

### 2.3. Inconv√©nients du SQL Brut

#### ‚ùå 1. Verbosit√©

Beaucoup de code "boilerplate" :
- Gestion des connexions
- Gestion des curseurs
- Mapping manuel des r√©sultats
- Gestion des erreurs

#### ‚ùå 2. Risque d'Injection SQL

Sans pr√©cautions, le code devient vuln√©rable :

```python
# ‚ö†Ô∏è DANGEREUX : Injection SQL possible
query = f"SELECT * FROM users WHERE email = '{email}'"
cursor.execute(query)

# ‚úÖ S√õR : Param√®tres li√©s
cursor.execute("SELECT * FROM users WHERE email = %s", (email,))
```

#### ‚ùå 3. D√©pendance √† la Base de Donn√©es

Votre SQL est souvent sp√©cifique √† PostgreSQL. Migrer vers MySQL = r√©√©criture.

#### ‚ùå 4. Pas de Migrations Automatiques

Vous devez g√©rer manuellement :
- Les fichiers de migration SQL
- Les versions du sch√©ma
- Le rollback en cas d'erreur

---

## 3. Les ORM : Productivit√© vs Contr√¥le

### 3.1. Avantages des ORM

#### ‚úÖ 1. Productivit√© Acc√©l√©r√©e

**Moins de code pour les op√©rations courantes :**

```python
# Cr√©er un utilisateur
user = User.objects.create(name="Alice", email="alice@example.com")

# R√©cup√©rer tous les utilisateurs actifs
active_users = User.objects.filter(is_active=True)

# Compter les articles
article_count = Article.objects.count()
```

**√âquivalent SQL brut :** 3√ó plus de lignes de code.

#### ‚úÖ 2. Abstraction de la Base de Donn√©es

Le m√™me code ORM fonctionne sur PostgreSQL, MySQL, SQLite... (avec quelques limites).

```python
# Ce code fonctionne sur plusieurs SGBD
users = User.objects.filter(created_at__gte=datetime(2024, 1, 1))
```

#### ‚úÖ 3. Gestion Automatique des Relations

```python
# Django ORM : R√©cup√©rer les articles d'un utilisateur
user = User.objects.get(id=1)
articles = user.articles.all()  # Relation 1-N automatique

# L'ORM g√©n√®re le JOIN pour vous
```

#### ‚úÖ 4. Migrations de Sch√©ma Automatis√©es

```python
# Modifier un mod√®le
class User(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField()
    bio = models.TextField()  # ‚Üê Nouveau champ

# G√©n√©rer et appliquer la migration
# python manage.py makemigrations
# python manage.py migrate
```

L'ORM g√©n√®re le SQL `ALTER TABLE` pour vous.

#### ‚úÖ 5. Validation et Contraintes

```python
class User(models.Model):
    email = models.EmailField(unique=True)  # Validation automatique
    age = models.IntegerField(validators=[MinValueValidator(0)])

# Si email invalide ou age < 0 ‚Üí Exception avant m√™me d'aller en base
```

#### ‚úÖ 6. Protection Contre les Injections SQL

Les ORM param√®trent automatiquement les requ√™tes :

```python
# Automatiquement s√©curis√©
User.objects.filter(email=user_input)
# L'ORM g√©n√®re : WHERE email = %s avec param√®tre li√©
```

### 3.2. Inconv√©nients des ORM

#### ‚ùå 1. Courbe d'Apprentissage Double

Vous devez apprendre :
1. **SQL** (pour comprendre ce qui se passe)
2. **L'API de l'ORM** (syntaxe sp√©cifique)

**Exemple :** Faire un `OUTER JOIN` en Django ORM vs SQL :

```python
# Django ORM (pas imm√©diatement √©vident)
User.objects.annotate(
    article_count=Count('articles')
).filter(article_count__gte=5)

# SQL (plus clair si on conna√Æt SQL)
SELECT u.*, COUNT(a.id) as article_count
FROM users u
LEFT JOIN articles a ON u.id = a.user_id
GROUP BY u.id
HAVING COUNT(a.id) >= 5
```

#### ‚ùå 2. Performance : Requ√™tes Suboptimales

Les ORM g√©n√®rent parfois du SQL inefficace.

**Exemple 1 : N+1 queries** (vu au chapitre pr√©c√©dent)

```python
# ‚ùå G√©n√®re N+1 requ√™tes
for article in Article.objects.all():
    print(article.author.name)

# ‚úÖ Solution : select_related
for article in Article.objects.select_related('author'):
    print(article.author.name)
```

**Exemple 2 : SELECT * inutile**

```python
# ORM g√©n√®re : SELECT * FROM users (tous les champs)
users = User.objects.all()

# Alors qu'on veut juste :
# SELECT name, email FROM users
users = User.objects.values('name', 'email')
```

#### ‚ùå 3. Limitations sur Requ√™tes Complexes

Certaines requ√™tes avanc√©es sont difficiles voire impossibles :
- CTE r√©cursives
- Window functions complexes
- LATERAL joins
- Optimisations PostgreSQL sp√©cifiques

**Solution :** Revenir au SQL brut pour ces cas.

#### ‚ùå 4. Abstraction qui Fuit (Leaky Abstraction)

L'ORM cache la complexit√©... jusqu'√† ce que √ßa ne marche plus.

**Sympt√¥me :** "√áa marchait avec 100 lignes, mais avec 100,000 c'est tr√®s lent !"

**Cause :** L'ORM g√©n√®re du SQL inefficace qu'il faut investiguer.

#### ‚ùå 5. D√©pendance √† l'ORM

Votre code devient d√©pendant de l'ORM choisi. Changer d'ORM = r√©√©criture majeure.

---

## 4. Arbre de D√©cision : ORM ou SQL Brut ?

### 4.1. Quand Utiliser un ORM ?

#### ‚úÖ Sc√©nario 1 : CRUD Basique (Create, Read, Update, Delete)

**Op√©rations simples sur une seule table ou relations 1-1 :**

```python
# Cr√©er
user = User.objects.create(name="Bob", email="bob@example.com")

# Lire
user = User.objects.get(id=1)

# Mettre √† jour
user.name = "Robert"
user.save()

# Supprimer
user.delete()
```

**Verdict :** ORM parfait. Rapide, lisible, s√©curis√©.

#### ‚úÖ Sc√©nario 2 : Application CRUD Standard

**Blog, CMS, backoffice, dashboard simples** o√π :
- Peu de jointures complexes
- Requ√™tes pr√©visibles
- Volume de donn√©es mod√©r√© (< 1M lignes par table)

**Verdict :** ORM recommand√©. Productivit√© maximale.

#### ‚úÖ Sc√©nario 3 : Prototypage Rapide

**MVP, POC, d√©mos** o√π la vitesse de d√©veloppement prime.

**Verdict :** ORM optimal. It√©rez vite, optimisez plus tard.

#### ‚úÖ Sc√©nario 4 : √âquipe Junior ou Mixte

**Si l'√©quipe conna√Æt peu SQL** ou pr√©f√®re le code orient√© objet.

**Verdict :** ORM avec formation sur les pi√®ges (N+1, etc.).

### 4.2. Quand Utiliser SQL Brut ?

#### ‚úÖ Sc√©nario 1 : Requ√™tes Analytiques Complexes

**Reporting, BI, dashboards** avec :
- Multiples jointures
- Agr√©gations complexes
- Window functions
- CTE r√©cursives

**Exemple :**
```sql
WITH monthly_stats AS (
    SELECT
        DATE_TRUNC('month', created_at) as month,
        user_id,
        COUNT(*) as article_count,
        AVG(view_count) as avg_views
    FROM articles
    GROUP BY 1, 2
),
ranked_users AS (
    SELECT
        month,
        user_id,
        article_count,
        RANK() OVER (PARTITION BY month ORDER BY article_count DESC) as rank
    FROM monthly_stats
)
SELECT * FROM ranked_users WHERE rank <= 10;
```

**Verdict :** SQL brut indispensable.

#### ‚úÖ Sc√©nario 2 : Performance Critique

**Endpoints √† haute fr√©quence** (> 1000 req/s) o√π chaque milliseconde compte.

**Exemple :** API de prix en temps r√©el, flux de trading, jeux en ligne.

**Verdict :** SQL brut, optimis√© au maximum avec EXPLAIN ANALYZE.

#### ‚úÖ Sc√©nario 3 : Bulk Operations

**Import/export massif** de donn√©es (millions de lignes).

**Exemple :**
```sql
COPY users(name, email, created_at)
FROM '/tmp/users.csv'
WITH (FORMAT csv, HEADER true);
```

**Verdict :** SQL brut + commandes PostgreSQL natives.

#### ‚úÖ Sc√©nario 4 : Migrations Complexes

**Transformations de sch√©ma** avec logique m√©tier embarqu√©e.

**Exemple :**
```sql
-- Migration : scinder le champ "full_name" en "first_name" et "last_name"
UPDATE users
SET
    first_name = SPLIT_PART(full_name, ' ', 1),
    last_name = SPLIT_PART(full_name, ' ', 2)
WHERE full_name IS NOT NULL;
```

**Verdict :** SQL brut pour contr√¥le total.

#### ‚úÖ Sc√©nario 5 : Features PostgreSQL Avanc√©es

**Si vous devez utiliser :**
- PostGIS (requ√™tes spatiales)
- Full-Text Search avanc√©
- JSONB avec op√©rateurs sp√©cifiques
- Extensions sp√©cifiques (pg_trgm, hstore)

**Verdict :** SQL brut ou mix ORM + SQL brut.

### 4.3. L'Approche Hybride (Recommand√©e)

**La vraie r√©ponse :** Utilisez **les deux** !

```python
# Python avec Django

# ‚úÖ ORM pour le CRUD simple
user = User.objects.get(email=email)
user.last_login = timezone.now()
user.save()

# ‚úÖ SQL brut pour les requ√™tes complexes
from django.db import connection

with connection.cursor() as cursor:
    cursor.execute("""
        SELECT
            u.name,
            COUNT(DISTINCT a.id) as article_count,
            AVG(a.view_count) as avg_views
        FROM users u
        LEFT JOIN articles a ON u.id = a.user_id
        WHERE u.created_at >= %s
        GROUP BY u.id, u.name
        HAVING COUNT(DISTINCT a.id) > 10
        ORDER BY avg_views DESC
        LIMIT 20
    """, [start_date])

    top_users = cursor.fetchall()
```

**Principe :** ORM par d√©faut, SQL brut quand n√©cessaire.

---

## 5. Comparaison D√©taill√©e par Crit√®re

### 5.1. Tableau R√©capitulatif

| Crit√®re | ORM | SQL Brut | Gagnant |
|---------|-----|----------|---------|
| **Productivit√©** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Tr√®s rapide | ‚≠ê‚≠ê‚≠ê Moyen | ORM |
| **Performance** | ‚≠ê‚≠ê‚≠ê Variable | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Optimale | SQL Brut |
| **Lisibilit√©** | ‚≠ê‚≠ê‚≠ê‚≠ê Bon (si on conna√Æt l'ORM) | ‚≠ê‚≠ê‚≠ê Moyen | ORM |
| **Maintenabilit√©** | ‚≠ê‚≠ê‚≠ê‚≠ê Bonne | ‚≠ê‚≠ê‚≠ê Moyenne | ORM |
| **S√©curit√©** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Automatique | ‚≠ê‚≠ê‚≠ê Manuel | ORM |
| **Portabilit√©** | ‚≠ê‚≠ê‚≠ê‚≠ê Multi-SGBD | ‚≠ê‚≠ê Sp√©cifique | ORM |
| **Courbe d'apprentissage** | ‚≠ê‚≠ê‚≠ê Moyenne | ‚≠ê‚≠ê‚≠ê‚≠ê SQL universel | SQL Brut |
| **Requ√™tes complexes** | ‚≠ê‚≠ê Limit√© | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Total | SQL Brut |
| **Migrations sch√©ma** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Automatis√©es | ‚≠ê‚≠ê‚≠ê Manuelles | ORM |

### 5.2. Performance : Benchmark R√©el

**Test :** R√©cup√©rer 10,000 utilisateurs avec leurs statistiques d'articles.

**ORM (Django) :**
```python
users = User.objects.annotate(
    article_count=Count('articles')
).select_related('profile')
# Temps : ~120ms
```

**SQL Brut Optimis√© :**
```python
cursor.execute("""
    SELECT u.*, COUNT(a.id) as article_count
    FROM users u
    LEFT JOIN articles a ON u.id = a.user_id
    GROUP BY u.id
    LIMIT 10000
""")
# Temps : ~80ms
```

**Diff√©rence :** 30-40% plus rapide avec SQL brut.

**Mais :** L'ORM √©vite 50 lignes de code boilerplate.

---

## 6. Cas Pratiques : ORM vs SQL Brut

### 6.1. Cas 1 : Afficher la Liste des Utilisateurs

**Besoin :** Afficher tous les utilisateurs actifs avec pagination.

**ORM (Django) :**
```python
from django.core.paginator import Paginator

users = User.objects.filter(is_active=True).order_by('-created_at')
paginator = Paginator(users, 25)  # 25 par page
page_obj = paginator.get_page(page_number)
```

**SQL Brut :**
```python
cursor.execute("""
    SELECT id, name, email, created_at
    FROM users
    WHERE is_active = true
    ORDER BY created_at DESC
    LIMIT %s OFFSET %s
""", [25, (page_number - 1) * 25])

users = cursor.fetchall()
# + Code pour compter le total et calculer les pages
```

**Verdict :** ORM gagne haut la main. Plus simple, plus lisible.

### 6.2. Cas 2 : Rapport Mensuel des Ventes

**Besoin :** CA mensuel par r√©gion avec comparaison ann√©e pr√©c√©dente.

**ORM (Django) :**
```python
# Possible mais complexe et peu lisible
from django.db.models import Sum, F
from django.db.models.functions import TruncMonth

sales = Sale.objects.annotate(
    month=TruncMonth('date')
).values('month', 'region').annotate(
    total=Sum('amount')
).order_by('month', 'region')

# Comparaison ann√©e pr√©c√©dente ? Tr√®s compliqu√© en ORM...
```

**SQL Brut :**
```sql
WITH current_year AS (
    SELECT
        DATE_TRUNC('month', date) as month,
        region,
        SUM(amount) as total
    FROM sales
    WHERE EXTRACT(YEAR FROM date) = 2025
    GROUP BY 1, 2
),
previous_year AS (
    SELECT
        DATE_TRUNC('month', date) + INTERVAL '1 year' as month,
        region,
        SUM(amount) as total
    FROM sales
    WHERE EXTRACT(YEAR FROM date) = 2024
    GROUP BY 1, 2
)
SELECT
    c.month,
    c.region,
    c.total as current_total,
    p.total as previous_total,
    ROUND(((c.total - p.total) / p.total * 100)::numeric, 2) as growth_pct
FROM current_year c
LEFT JOIN previous_year p ON c.month = p.month AND c.region = p.region
ORDER BY c.month, c.region;
```

**Verdict :** SQL brut indispensable. L'ORM ne peut pas g√©rer √ßa proprement.

### 6.3. Cas 3 : Top 10 Articles par Cat√©gorie

**Besoin :** Les 10 articles les plus vus dans chaque cat√©gorie.

**ORM (tr√®s difficile) :**
```python
# N√©cessite plusieurs requ√™tes ou du raw SQL
categories = Category.objects.all()
result = {}
for category in categories:
    top_articles = category.articles.order_by('-view_count')[:10]
    result[category] = list(top_articles)
# ‚Üí N+1 queries !
```

**SQL Brut (avec Window Function) :**
```sql
WITH ranked_articles AS (
    SELECT
        a.*,
        c.name as category_name,
        ROW_NUMBER() OVER (
            PARTITION BY a.category_id
            ORDER BY a.view_count DESC
        ) as rank
    FROM articles a
    JOIN categories c ON a.category_id = c.id
)
SELECT *
FROM ranked_articles
WHERE rank <= 10
ORDER BY category_name, rank;
```

**Verdict :** SQL brut. Les window functions sont hors de port√©e de la plupart des ORM.

### 6.4. Cas 4 : Import Massif de Donn√©es

**Besoin :** Importer 10 millions de lignes depuis un CSV.

**ORM :**
```python
# ‚ùå TR√àS LENT : 1 INSERT par ligne
with open('data.csv') as f:
    for line in f:
        User.objects.create(name=line['name'], email=line['email'])
# Temps : plusieurs heures !

# ‚ö†Ô∏è Mieux : bulk_create (mais limit√©)
users = []
with open('data.csv') as f:
    for line in f:
        users.append(User(name=line['name'], email=line['email']))
        if len(users) >= 1000:
            User.objects.bulk_create(users)
            users = []
# Temps : ~30 minutes
```

**SQL Brut (COPY) :**
```python
cursor.execute("""
    COPY users(name, email)
    FROM '/tmp/data.csv'
    WITH (FORMAT csv, HEADER true);
""")
# Temps : ~2 minutes !
```

**Verdict :** SQL brut avec COPY. 15√ó plus rapide.

---

## 7. Bonnes Pratiques et Recommandations

### 7.1. R√®gle des 80/20

**Principe :**
- **80% de votre code** : ORM (CRUD, relations simples)
- **20% critique** : SQL brut (performance, complexit√©)

### 7.2. Strat√©gie Recommand√©e

#### √âtape 1 : Commencer avec l'ORM

Utilisez l'ORM par d√©faut pour :
- D√©finir vos mod√®les
- CRUD basique
- Relations simples
- Migrations de sch√©ma

#### √âtape 2 : Identifier les Hotspots

Avec monitoring (pg_stat_statements, APM) :
- Requ√™tes lentes (> 100ms)
- Requ√™tes fr√©quentes (> 1000/min)
- N+1 queries

#### √âtape 3 : Optimiser S√©lectivement

Pour les hotspots identifi√©s :
1. Essayer d'optimiser avec l'ORM (`select_related`, `prefetch_related`, `only()`)
2. Si impossible ou insuffisant ‚Üí SQL brut
3. Mesurer l'am√©lioration avec EXPLAIN ANALYZE

#### √âtape 4 : Documenter les Exceptions

```python
# users/queries.py

def get_user_stats_report(start_date, end_date):
    """
    Requ√™te SQL brute pour performance.

    L'ORM g√©n√®re un plan suboptimal avec trop de subqueries.
    SQL brut : 80ms vs ORM : 450ms

    Derni√®re r√©vision : 2025-11-23
    """
    with connection.cursor() as cursor:
        cursor.execute(RAW_USER_STATS_QUERY, [start_date, end_date])
        return cursor.fetchall()
```

### 7.3. Checklist de D√©cision

Avant d'utiliser SQL brut, demandez-vous :

- [ ] L'ORM g√©n√®re-t-il vraiment du SQL inefficace ? (v√©rifier avec logging)
- [ ] Ai-je essay√© toutes les optimisations ORM ? (`select_related`, `annotate`, etc.)
- [ ] Le gain de performance justifie-t-il la perte de lisibilit√© ?
- [ ] Puis-je isoler ce SQL dans une fonction d√©di√©e et document√©e ?
- [ ] Ai-je test√© et mesur√© l'am√©lioration ?

### 7.4. Anti-Patterns √† √âviter

#### ‚ùå Anti-Pattern 1 : "ORM Partout"

```python
# ‚ùå Forcer l'ORM pour des requ√™tes complexes
result = User.objects.annotate(
    article_count=Count('articles')
).annotate(
    avg_views=Avg('articles__view_count')
).filter(
    article_count__gte=10
).annotate(
    rank=Window(
        expression=RowNumber(),
        order_by=F('avg_views').desc()
    )
)
# Code illisible et SQL g√©n√©r√© peut-√™tre inefficace
```

**‚úÖ Solution :** SQL brut pour cette requ√™te complexe.

#### ‚ùå Anti-Pattern 2 : "SQL Brut Partout"

```python
# ‚ùå Utiliser SQL brut pour du CRUD simple
cursor.execute("SELECT * FROM users WHERE id = %s", [user_id])
row = cursor.fetchone()
user = {
    'id': row[0],
    'name': row[1],
    'email': row[2]
}
```

**‚úÖ Solution :** ORM est parfait pour √ßa.
```python
user = User.objects.get(id=user_id)
```

#### ‚ùå Anti-Pattern 3 : "Mix Chaotique"

```python
# ‚ùå M√©langer ORM et SQL sans logique
def get_user_articles(user_id):
    cursor.execute("SELECT * FROM users WHERE id = %s", [user_id])
    user = cursor.fetchone()

    articles = Article.objects.filter(user_id=user_id)

    cursor.execute("SELECT COUNT(*) FROM comments WHERE user_id = %s", [user_id])
    comment_count = cursor.fetchone()[0]

    # Pourquoi ce m√©lange ?
```

**‚úÖ Solution :** Coh√©rence. Tout en ORM ou tout en SQL pour une fonction donn√©e.

### 7.5. Organisation du Code

**Structure recommand√©e :**

```
myapp/
‚îú‚îÄ‚îÄ models.py          # D√©finitions ORM
‚îú‚îÄ‚îÄ queries.py         # SQL brut complexe
‚îú‚îÄ‚îÄ views.py           # Logique m√©tier (utilise models et queries)
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ test_models.py
    ‚îî‚îÄ‚îÄ test_queries.py
```

**Exemple queries.py :**
```python
# myapp/queries.py

from django.db import connection

def get_monthly_sales_report(year):
    """
    Rapport mensuel des ventes avec comparaison ann√©e pr√©c√©dente.

    Utilise SQL brut car n√©cessite des CTE et window functions
    que Django ORM ne g√®re pas √©l√©gamment.
    """
    query = """
        WITH current_year AS (
            SELECT DATE_TRUNC('month', date) as month, ...
        )
        SELECT * FROM current_year ...
    """

    with connection.cursor() as cursor:
        cursor.execute(query, [year])
        return cursor.fetchall()
```

---

## 8. ORM Avanc√©s : Query Builders

### 8.1. Qu'est-ce qu'un Query Builder ?

**D√©finition :** Un compromis entre ORM et SQL brut.

**Caract√©ristiques :**
- API fluide pour construire des requ√™tes
- G√©n√®re du SQL mais avec contr√¥le fin
- Moins de "magie" qu'un ORM complet

**Exemples :**
- **Knex.js** (JavaScript)
- **jOOQ** (Java)
- **Ecto** (Elixir)

### 8.2. Exemple avec Knex.js

```javascript
// Query Builder (Knex.js)
const users = await knex('users')
  .select('users.name', 'users.email')
  .count('articles.id as article_count')
  .leftJoin('articles', 'users.id', 'articles.user_id')
  .where('users.is_active', true)
  .groupBy('users.id')
  .having('article_count', '>', 5)
  .orderBy('article_count', 'desc');

// √âquivalent SQL g√©n√©r√©
// SELECT users.name, users.email, COUNT(articles.id) as article_count
// FROM users
// LEFT JOIN articles ON users.id = articles.user_id
// WHERE users.is_active = true
// GROUP BY users.id
// HAVING COUNT(articles.id) > 5
// ORDER BY article_count DESC
```

**Avantages :**
- Plus flexible qu'un ORM classique
- Moins verbeux que du SQL brut
- Toujours type-safe (en TypeScript)

### 8.3. Quand Utiliser un Query Builder ?

**‚úÖ Bon choix si :**
- Vous voulez le contr√¥le du SQL brut
- Mais avec une API plus ergonomique
- Et des garanties de type (TypeScript, Scala)

**‚ùå Moins bon si :**
- Vous voulez la simplicit√© totale d'un ORM
- Ou le contr√¥le absolu du SQL brut

---

## 9. Outils et Techniques de Monitoring

### 9.1. Activer le Logging SQL en D√©veloppement

**Django :**
```python
# settings.py
LOGGING = {
    'version': 1,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'loggers': {
        'django.db.backends': {
            'handlers': ['console'],
            'level': 'DEBUG',
        },
    },
}
```

**SQLAlchemy :**
```python
import logging
logging.basicConfig()
logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)
```

### 9.2. Django Debug Toolbar

**Installation :**
```bash
pip install django-debug-toolbar
```

**Fonctionnalit√©s :**
- Affiche toutes les requ√™tes SQL
- Temps d'ex√©cution par requ√™te
- D√©tection des N+1
- Plan d'ex√©cution (EXPLAIN)

### 9.3. Mesurer l'Impact en Production

**Avec pg_stat_statements :**
```sql
-- Requ√™tes les plus co√ªteuses
SELECT
    calls,
    total_exec_time,
    mean_exec_time,
    query
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 20;
```

**M√©triques √† surveiller :**
- `total_exec_time` : Temps cumul√© (identifie les hotspots globaux)
- `mean_exec_time` : Temps moyen (identifie les requ√™tes lentes)
- `calls` : Fr√©quence (identifie les N+1)

---

## 10. Migration : ORM ‚Üí SQL Brut ou Inverse

### 10.1. Migrer d'ORM vers SQL Brut (Optimisation)

**√âtapes :**

1. **Identifier la requ√™te ORM lente**
   ```python
   # Requ√™te ORM actuelle
   users = User.objects.annotate(
       article_count=Count('articles')
   ).filter(article_count__gte=10)
   ```

2. **Activer le logging et r√©cup√©rer le SQL g√©n√©r√©**
   ```sql
   SELECT users.*, COUNT(articles.id) as article_count
   FROM users
   LEFT JOIN articles ON ...
   GROUP BY users.id
   HAVING COUNT(articles.id) >= 10
   ```

3. **Optimiser le SQL**
   ```sql
   -- Version optimis√©e avec index
   SELECT u.id, u.name, u.email, COUNT(a.id) as article_count
   FROM users u
   LEFT JOIN articles a ON u.id = a.user_id
   WHERE u.is_active = true
   GROUP BY u.id
   HAVING COUNT(a.id) >= 10
   ORDER BY article_count DESC;
   ```

4. **Remplacer par du SQL brut**
   ```python
   from django.db import connection

   def get_prolific_users(min_articles=10):
       with connection.cursor() as cursor:
           cursor.execute(OPTIMIZED_QUERY, [min_articles])
           return cursor.fetchall()
   ```

5. **Mesurer l'am√©lioration**
   - Avant : 450ms
   - Apr√®s : 80ms
   - Gain : 82%

### 10.2. Migrer de SQL Brut vers ORM (Simplification)

**Quand :** Si le SQL brut est devenu du boilerplate pour des requ√™tes simples.

**Avant (SQL brut) :**
```python
cursor.execute("SELECT * FROM users WHERE is_active = %s ORDER BY created_at DESC", [True])
users = cursor.fetchall()
# + Code de mapping vers des objets
```

**Apr√®s (ORM) :**
```python
users = User.objects.filter(is_active=True).order_by('-created_at')
```

**Gain :** Lisibilit√©, maintenabilit√©.

---

## 11. Cas Particuliers et Niches

### 11.1. Stored Procedures et Functions

**Sc√©nario :** Logique m√©tier complexe en base de donn√©es.

```sql
CREATE FUNCTION calculate_user_score(user_id INT)
RETURNS DECIMAL AS $$
DECLARE
    score DECIMAL;
BEGIN
    SELECT
        (article_count * 10) + (comment_count * 2) + (like_count * 0.5)
    INTO score
    FROM user_stats
    WHERE id = user_id;

    RETURN COALESCE(score, 0);
END;
$$ LANGUAGE plpgsql;
```

**Appel depuis ORM vs SQL Brut :**

```python
# SQL Brut (direct)
cursor.callproc('calculate_user_score', [user_id])
score = cursor.fetchone()[0]

# ORM (Django) : n√©cessite du raw SQL
from django.db import connection
score = connection.cursor().callproc('calculate_user_score', [user_id])
```

**Verdict :** Les stored procedures n√©cessitent souvent du SQL brut.

### 11.2. Transactions Complexes

**Sc√©nario :** Transaction avec logique conditionnelle et rollback partiel.

**Avec ORM (Django) :**
```python
from django.db import transaction

try:
    with transaction.atomic():
        user = User.objects.create(name="Alice")
        account = Account.objects.create(user=user, balance=100)

        if account.balance < 0:
            raise ValueError("Balance cannot be negative")

        # Si exception : rollback automatique
except ValueError:
    # Gestion d'erreur
    pass
```

**Avec SQL Brut :**
```python
try:
    cursor.execute("BEGIN;")
    cursor.execute("INSERT INTO users (name) VALUES (%s) RETURNING id", ["Alice"])
    user_id = cursor.fetchone()[0]

    cursor.execute("INSERT INTO accounts (user_id, balance) VALUES (%s, %s)", [user_id, 100])

    cursor.execute("SELECT balance FROM accounts WHERE user_id = %s", [user_id])
    balance = cursor.fetchone()[0]

    if balance < 0:
        cursor.execute("ROLLBACK;")
        raise ValueError("Balance cannot be negative")

    cursor.execute("COMMIT;")
except Exception as e:
    cursor.execute("ROLLBACK;")
    raise
```

**Verdict :** ORM plus simple pour les transactions standards.

### 11.3. Avec des Extensions PostgreSQL (PostGIS, pg_trgm)

**Exemple avec PostGIS (requ√™tes spatiales) :**

```sql
-- Trouver les restaurants dans un rayon de 5km
SELECT name, ST_Distance(location, ST_Point(-122.4194, 37.7749)) as distance
FROM restaurants
WHERE ST_DWithin(location, ST_Point(-122.4194, 37.7749), 5000)
ORDER BY distance;
```

**Avec ORM (Django + GeoDjango) :**
```python
from django.contrib.gis.geos import Point
from django.contrib.gis.measure import D

user_location = Point(-122.4194, 37.7749, srid=4326)
restaurants = Restaurant.objects.filter(
    location__distance_lte=(user_location, D(km=5))
).annotate(
    distance=Distance('location', user_location)
).order_by('distance')
```

**Verdict :** Les ORM sp√©cialis√©s (GeoDjango) g√®rent bien les extensions. Sinon, SQL brut.

---

## 12. R√©sum√© et Synth√®se

### 12.1. Les Grandes V√©rit√©s

1. **Il n'y a pas de "meilleur" choix absolu** : tout d√©pend du contexte
2. **Les ORM sont parfaits pour 80% des cas** : CRUD, relations simples
3. **Le SQL brut est indispensable pour 20% critique** : performance, complexit√©
4. **Conna√Ætre SQL est obligatoire** m√™me avec un ORM (pour d√©bugger, optimiser)
5. **La vraie comp√©tence : savoir quand utiliser quoi**

### 12.2. Principes de D√©cision

**Utilisez l'ORM par d√©faut, sauf si :**
- ‚ùå Requ√™te trop complexe (CTE, window functions)
- ‚ùå Performance critique identifi√©e
- ‚ùå Op√©rations en masse (bulk)
- ‚ùå Extensions PostgreSQL sp√©cifiques

**Revenez au SQL brut quand :**
- ‚úÖ EXPLAIN montre un plan inefficace
- ‚úÖ Temps de r√©ponse > 100ms sur hotspot
- ‚úÖ ORM g√©n√®re N+1 non corrigeable
- ‚úÖ Requ√™te analytique complexe

### 12.3. Matrice de D√©cision Finale

| Type de Requ√™te | Recommandation | Raison |
|-----------------|----------------|--------|
| CRUD simple (1 table) | **ORM** | Productivit√© maximale |
| Relations 1-1 ou N-1 | **ORM** | `select_related` suffit |
| Listes pagin√©es | **ORM** | Gestion native pagination |
| Recherche full-text simple | **ORM** | Bonne abstraction |
| Dashboard avec agr√©gations | **SQL Brut** | Requ√™tes analytiques |
| Top N par groupe | **SQL Brut** | Window functions |
| Import/export masse | **SQL Brut** | COPY natif |
| Migrations complexes | **SQL Brut** | Contr√¥le total n√©cessaire |
| API haute fr√©quence | **SQL Brut** | Performance critique |
| Prototypage rapide | **ORM** | It√©ration rapide |

### 12.4. Checklist Finale

Avant de choisir, r√©pondez √† ces questions :

**Questions ORM :**
- [ ] Mon √©quipe conna√Æt-elle bien cet ORM ?
- [ ] La requ√™te est-elle un CRUD simple ?
- [ ] Les performances actuelles sont-elles acceptables ?
- [ ] La lisibilit√© du code ORM est-elle bonne ?

**Questions SQL Brut :**
- [ ] Ai-je vraiment besoin de features PostgreSQL avanc√©es ?
- [ ] Les performances ORM sont-elles insuffisantes ?
- [ ] Puis-je documenter et maintenir ce SQL ?
- [ ] Le gain justifie-t-il la complexit√© ajout√©e ?

---

## 13. Pour Aller Plus Loin

### 13.1. Ressources Recommand√©es

**Livres :**
- "SQL Performance Explained" - Markus Winand
- "Two Scoops of Django" - Daniel & Audrey Feldroy (ORM Django)
- "High Performance MySQL" (principes valables pour PostgreSQL)

**Articles :**
- "ORM is an Anti-Pattern" - Jeff Atwood
- "In Defense of ORM" - Martin Fowler
- "The Vietnam of Computer Science" - Ted Neward (sur les ORM)

**Documentation :**
- Documentation officielle de votre ORM
- PostgreSQL Performance Tips

### 13.2. Exercice Mental

**Situation :** Vous devez construire un dashboard de BI en temps r√©el.

**Fonctionnalit√©s :**
- Graphiques de ventes (30 derniers jours)
- Top 10 produits par cat√©gorie
- Carte thermique des commandes par r√©gion
- Comparaison ann√©e N vs N-1

**R√©flexion :**
1. Utiliseriez-vous un ORM ou SQL brut ?
2. Pourquoi ?
3. Quels seraient les pi√®ges de l'autre approche ?

**R√©ponse sugg√©r√©e :**
- **SQL brut** : Requ√™tes analytiques complexes, window functions, CTE
- ORM serait trop limit√© et g√©n√©rerait du SQL inefficace
- Mais : mod√®les ORM peuvent d√©finir le sch√©ma et les migrations

### 13.3. Prochains Chapitres Recommand√©s

Maintenant que vous ma√Ætrisez ORM vs SQL brut :
- **20.3.3. Lazy loading vs Eager loading** : Strat√©gies de chargement
- **20.3.4. Batching et bulk operations** : Op√©rations en masse
- **13. Indexation et Optimisation** : Am√©liorer vos requ√™tes SQL

---

## Conclusion

Le d√©bat ORM vs SQL brut n'est pas binaire. Les meilleurs d√©veloppeurs ma√Ætrisent **les deux** et savent instinctivement lequel utiliser selon le contexte.

**R√®gle d'or :** Commencez avec l'ORM (productivit√©), surveillez les performances (monitoring), optimisez s√©lectivement avec SQL brut (hotspots critiques).

Votre objectif : √©crire du code **maintenable**, **performant** et **s√©curis√©**. Parfois c'est l'ORM, parfois c'est SQL brut, souvent c'est un mix des deux.

**La vraie expertise : savoir quand utiliser quoi.**

---

**Prochaine section recommand√©e :** 20.3.3. Lazy loading vs Eager loading


‚è≠Ô∏è [Lazy loading vs Eager loading](/20-drivers-connexion-applicative/03.3-lazy-vs-eager-loading.md)
