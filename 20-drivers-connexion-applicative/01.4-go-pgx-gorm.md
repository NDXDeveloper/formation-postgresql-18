üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.1.4. Go : pgx, GORM

## Introduction

Go (Golang) est un langage de programmation moderne cr√©√© par Google, particuli√®rement appr√©ci√© pour la construction de services backend performants et de microservices. Pour interagir avec PostgreSQL en Go, deux approches principales existent :

1. **pgx** : Driver natif PostgreSQL bas niveau, haute performance
2. **GORM** : ORM (Object-Relational Mapping) complet et feature-rich

Ce tutoriel couvre les deux approches en profondeur pour vous permettre de choisir celle qui convient le mieux √† votre projet.

---

## Vue d'Ensemble : Driver vs ORM

### Qu'est-ce qu'un Driver ?

Un **driver** (ou adaptateur) est une biblioth√®que qui permet √† votre code Go de communiquer directement avec PostgreSQL. Vous √©crivez du SQL brut et manipulez les r√©sultats.

**Analogie :** C'est comme parler directement √† PostgreSQL dans sa langue native (SQL).

### Qu'est-ce qu'un ORM ?

Un **ORM** (Object-Relational Mapping) est une couche d'abstraction qui traduit vos structures Go en requ√™tes SQL. Vous manipulez des objets Go au lieu d'√©crire du SQL.

**Analogie :** C'est comme avoir un traducteur automatique entre votre code Go et PostgreSQL.

### Comparaison Rapide

| Caract√©ristique | pgx | GORM |
|-----------------|-----|------|
| **Type** | Driver natif | ORM complet |
| **Langage** | SQL brut | API Go |
| **Performance** | Excellente (direct) | Tr√®s bonne (overhead minimal) |
| **Courbe d'apprentissage** | Moyenne (SQL requis) | Facile |
| **Contr√¥le** | Total | Abstraction |
| **Flexibilit√© SQL** | Toutes requ√™tes possibles | Limit√© aux capacit√©s ORM |
| **Type-safety** | Manuelle | Automatique (structs) |
| **Migrations** | Manuelles | Int√©gr√©es (AutoMigrate) |
| **Boilerplate** | Plus de code | Moins de code |
| **Popularit√©** | Tr√®s √©lev√©e | Tr√®s √©lev√©e |
| **Maintenance** | Active | Active |

**Recommandation :**
- **pgx** : Pour des performances maximales, SQL complexe, contr√¥le total, microservices l√©gers
- **GORM** : Pour la productivit√©, applications CRUD standard, prototypage rapide

---

## Partie 1 : pgx (Driver PostgreSQL Natif)

### Introduction √† pgx

**pgx** est le driver PostgreSQL le plus performant et le plus complet pour Go. Il est :
- **Rapide** : Optimis√© pour PostgreSQL sp√©cifiquement
- **Complet** : Support de toutes les fonctionnalit√©s PostgreSQL
- **Idiomatique** : Suit les conventions Go
- **Mature** : Utilis√© en production par de grandes entreprises

**pgx vs lib/pq (driver standard) :**
- pgx est **2-3√ó plus rapide** que lib/pq
- pgx supporte les types PostgreSQL avanc√©s (JSONB, Arrays, hstore)
- pgx offre un pool de connexions int√©gr√©
- lib/pq est maintenant en mode maintenance

### Installation

```bash
# pgx v5 (derni√®re version majeure)
go get github.com/jackc/pgx/v5
go get github.com/jackc/pgx/v5/pgxpool
```

### Structure d'un Projet Go avec pgx

```
myproject/
‚îú‚îÄ‚îÄ go.mod
‚îú‚îÄ‚îÄ go.sum
‚îú‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îî‚îÄ‚îÄ db.go          # Configuration connexion
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îî‚îÄ‚îÄ user.go        # Structures de donn√©es
‚îî‚îÄ‚îÄ repository/
    ‚îî‚îÄ‚îÄ user_repo.go   # Logique d'acc√®s aux donn√©es
```

### Connexion Simple

```go
package main

import (
    "context"
    "fmt"
    "log"

    "github.com/jackc/pgx/v5"
)

func main() {
    // URL de connexion PostgreSQL
    connString := "postgres://user:password@localhost:5432/mydb"

    // √âtablir la connexion
    conn, err := pgx.Connect(context.Background(), connString)
    if err != nil {
        log.Fatalf("Impossible de se connecter : %v\n", err)
    }
    defer conn.Close(context.Background())

    fmt.Println("‚úÖ Connexion √©tablie avec succ√®s")

    // Tester la connexion
    var version string
    err = conn.QueryRow(context.Background(), "SELECT version()").Scan(&version)
    if err != nil {
        log.Fatalf("Erreur de requ√™te : %v\n", err)
    }

    fmt.Printf("Version PostgreSQL : %s\n", version)
}
```

**Format de l'URL de connexion :**
```
postgres://[user]:[password]@[host]:[port]/[database]?[param√®tres]
```

**Exemples d'URLs :**
```go
// Local avec port par d√©faut
"postgres://user:password@localhost/mydb"

// Avec SSL
"postgres://user:password@localhost/mydb?sslmode=require"

// Avec timeout
"postgres://user:password@localhost/mydb?connect_timeout=10"

// Avec sch√©ma sp√©cifique
"postgres://user:password@localhost/mydb?search_path=public"
```

### Pool de Connexions (Production)

En production, **TOUJOURS** utiliser un pool de connexions :

```go
package database

import (
    "context"
    "fmt"
    "log"

    "github.com/jackc/pgx/v5/pgxpool"
)

var Pool *pgxpool.Pool

// InitDB initialise le pool de connexions
func InitDB() error {
    connString := "postgres://user:password@localhost:5432/mydb"

    // Configuration du pool
    config, err := pgxpool.ParseConfig(connString)
    if err != nil {
        return fmt.Errorf("impossible de parser la config : %w", err)
    }

    // Param√®tres du pool
    config.MaxConns = 25                      // Maximum 25 connexions
    config.MinConns = 5                       // Minimum 5 connexions actives
    config.MaxConnLifetime = 1 * time.Hour    // Dur√©e de vie max
    config.MaxConnIdleTime = 30 * time.Minute // Timeout inactivit√©

    // Cr√©er le pool
    Pool, err = pgxpool.NewWithConfig(context.Background(), config)
    if err != nil {
        return fmt.Errorf("impossible de cr√©er le pool : %w", err)
    }

    // V√©rifier la connexion
    err = Pool.Ping(context.Background())
    if err != nil {
        return fmt.Errorf("impossible de ping la DB : %w", err)
    }

    log.Println("‚úÖ Pool de connexions initialis√©")
    return nil
}

// Close ferme le pool
func Close() {
    if Pool != nil {
        Pool.Close()
    }
}
```

**Utilisation dans main.go :**

```go
package main

import (
    "log"
    "myproject/database"
)

func main() {
    // Initialiser le pool
    err := database.InitDB()
    if err != nil {
        log.Fatal(err)
    }
    defer database.Close()

    // Votre application ici
}
```

### Mod√®les de Donn√©es (Structs)

```go
package models

import (
    "time"
)

// User repr√©sente un utilisateur dans la base de donn√©es
type User struct {
    ID        int       `json:"id"`
    Nom       string    `json:"nom"`
    Email     string    `json:"email"`
    Age       int       `json:"age"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
}

// CreateUserInput pour l'insertion (sans ID)
type CreateUserInput struct {
    Nom   string `json:"nom"`
    Email string `json:"email"`
    Age   int    `json:"age"`
}

// UpdateUserInput pour la mise √† jour (champs optionnels)
type UpdateUserInput struct {
    Nom   *string `json:"nom,omitempty"`
    Email *string `json:"email,omitempty"`
    Age   *int    `json:"age,omitempty"`
}
```

### CRUD Op√©rations

#### CREATE : Ins√©rer des donn√©es

```go
package repository

import (
    "context"
    "fmt"

    "myproject/database"
    "myproject/models"
)

// CreateUser ins√®re un nouvel utilisateur
func CreateUser(ctx context.Context, input models.CreateUserInput) (*models.User, error) {
    query := `
        INSERT INTO utilisateurs (nom, email, age)
        VALUES ($1, $2, $3)
        RETURNING id, nom, email, age, created_at, updated_at
    `

    var user models.User

    err := database.Pool.QueryRow(ctx, query,
        input.Nom,
        input.Email,
        input.Age,
    ).Scan(
        &user.ID,
        &user.Nom,
        &user.Email,
        &user.Age,
        &user.CreatedAt,
        &user.UpdatedAt,
    )

    if err != nil {
        return nil, fmt.Errorf("erreur lors de la cr√©ation : %w", err)
    }

    return &user, nil
}

// Utilisation
func main() {
    ctx := context.Background()

    input := models.CreateUserInput{
        Nom:   "Alice",
        Email: "alice@example.com",
        Age:   30,
    }

    user, err := repository.CreateUser(ctx, input)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Utilisateur cr√©√© : ID=%d, Nom=%s\n", user.ID, user.Nom)
}
```

**Insertion multiple (batch) :**

```go
func CreateUsers(ctx context.Context, users []models.CreateUserInput) error {
    // Utiliser une transaction pour le batch
    tx, err := database.Pool.Begin(ctx)
    if err != nil {
        return err
    }
    defer tx.Rollback(ctx) // Rollback si commit non appel√©

    query := `
        INSERT INTO utilisateurs (nom, email, age)
        VALUES ($1, $2, $3)
    `

    // Pr√©parer le batch
    batch := &pgx.Batch{}
    for _, user := range users {
        batch.Queue(query, user.Nom, user.Email, user.Age)
    }

    // Ex√©cuter le batch
    results := tx.SendBatch(ctx, batch)
    defer results.Close()

    // Commit la transaction
    return tx.Commit(ctx)
}
```

#### READ : Lire des donn√©es

```go
// GetUserByID r√©cup√®re un utilisateur par ID
func GetUserByID(ctx context.Context, id int) (*models.User, error) {
    query := `
        SELECT id, nom, email, age, created_at, updated_at
        FROM utilisateurs
        WHERE id = $1
    `

    var user models.User

    err := database.Pool.QueryRow(ctx, query, id).Scan(
        &user.ID,
        &user.Nom,
        &user.Email,
        &user.Age,
        &user.CreatedAt,
        &user.UpdatedAt,
    )

    if err != nil {
        if err == pgx.ErrNoRows {
            return nil, fmt.Errorf("utilisateur non trouv√©")
        }
        return nil, fmt.Errorf("erreur de lecture : %w", err)
    }

    return &user, nil
}

// GetAllUsers r√©cup√®re tous les utilisateurs
func GetAllUsers(ctx context.Context) ([]models.User, error) {
    query := `
        SELECT id, nom, email, age, created_at, updated_at
        FROM utilisateurs
        ORDER BY nom
    `

    rows, err := database.Pool.Query(ctx, query)
    if err != nil {
        return nil, fmt.Errorf("erreur de requ√™te : %w", err)
    }
    defer rows.Close()

    var users []models.User

    for rows.Next() {
        var user models.User
        err := rows.Scan(
            &user.ID,
            &user.Nom,
            &user.Email,
            &user.Age,
            &user.CreatedAt,
            &user.UpdatedAt,
        )
        if err != nil {
            return nil, fmt.Errorf("erreur de scan : %w", err)
        }
        users = append(users, user)
    }

    // V√©rifier les erreurs de rows
    if err := rows.Err(); err != nil {
        return nil, fmt.Errorf("erreur de rows : %w", err)
    }

    return users, nil
}

// SearchUsers recherche avec filtres
func SearchUsers(ctx context.Context, namePattern string, minAge, maxAge int) ([]models.User, error) {
    query := `
        SELECT id, nom, email, age, created_at, updated_at
        FROM utilisateurs
        WHERE nom ILIKE $1 AND age BETWEEN $2 AND $3
        ORDER BY nom
    `

    rows, err := database.Pool.Query(ctx, query, "%"+namePattern+"%", minAge, maxAge)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var users []models.User
    for rows.Next() {
        var user models.User
        err := rows.Scan(&user.ID, &user.Nom, &user.Email, &user.Age, &user.CreatedAt, &user.UpdatedAt)
        if err != nil {
            return nil, err
        }
        users = append(users, user)
    }

    return users, rows.Err()
}
```

**Utilisation de pgx.CollectRows (pgx v5) :**

```go
// M√©thode moderne avec CollectRows (moins de boilerplate)
func GetAllUsersV2(ctx context.Context) ([]models.User, error) {
    query := `
        SELECT id, nom, email, age, created_at, updated_at
        FROM utilisateurs
        ORDER BY nom
    `

    rows, err := database.Pool.Query(ctx, query)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    // CollectRows fait le scan automatiquement
    return pgx.CollectRows(rows, pgx.RowToStructByName[models.User])
}
```

#### UPDATE : Modifier des donn√©es

```go
// UpdateUser met √† jour un utilisateur
func UpdateUser(ctx context.Context, id int, input models.UpdateUserInput) (*models.User, error) {
    query := `
        UPDATE utilisateurs
        SET nom = $1, email = $2, age = $3, updated_at = NOW()
        WHERE id = $4
        RETURNING id, nom, email, age, created_at, updated_at
    `

    var user models.User

    err := database.Pool.QueryRow(ctx, query,
        *input.Nom,
        *input.Email,
        *input.Age,
        id,
    ).Scan(
        &user.ID,
        &user.Nom,
        &user.Email,
        &user.Age,
        &user.CreatedAt,
        &user.UpdatedAt,
    )

    if err != nil {
        if err == pgx.ErrNoRows {
            return nil, fmt.Errorf("utilisateur non trouv√©")
        }
        return nil, fmt.Errorf("erreur de mise √† jour : %w", err)
    }

    return &user, nil
}

// UpdateUserPartial met √† jour uniquement les champs fournis
func UpdateUserPartial(ctx context.Context, id int, input models.UpdateUserInput) error {
    // Construction dynamique de la requ√™te
    query := "UPDATE utilisateurs SET "
    args := []interface{}{}
    argIndex := 1

    if input.Nom != nil {
        query += fmt.Sprintf("nom = $%d, ", argIndex)
        args = append(args, *input.Nom)
        argIndex++
    }

    if input.Email != nil {
        query += fmt.Sprintf("email = $%d, ", argIndex)
        args = append(args, *input.Email)
        argIndex++
    }

    if input.Age != nil {
        query += fmt.Sprintf("age = $%d, ", argIndex)
        args = append(args, *input.Age)
        argIndex++
    }

    // Ajouter updated_at
    query += fmt.Sprintf("updated_at = NOW() WHERE id = $%d", argIndex)
    args = append(args, id)

    commandTag, err := database.Pool.Exec(ctx, query, args...)
    if err != nil {
        return err
    }

    if commandTag.RowsAffected() == 0 {
        return fmt.Errorf("utilisateur non trouv√©")
    }

    return nil
}
```

#### DELETE : Supprimer des donn√©es

```go
// DeleteUser supprime un utilisateur
func DeleteUser(ctx context.Context, id int) error {
    query := `DELETE FROM utilisateurs WHERE id = $1`

    commandTag, err := database.Pool.Exec(ctx, query, id)
    if err != nil {
        return fmt.Errorf("erreur de suppression : %w", err)
    }

    if commandTag.RowsAffected() == 0 {
        return fmt.Errorf("utilisateur non trouv√©")
    }

    return nil
}

// DeleteUsersByAge supprime plusieurs utilisateurs
func DeleteUsersByAge(ctx context.Context, maxAge int) (int64, error) {
    query := `DELETE FROM utilisateurs WHERE age < $1`

    commandTag, err := database.Pool.Exec(ctx, query, maxAge)
    if err != nil {
        return 0, err
    }

    return commandTag.RowsAffected(), nil
}
```

### Gestion des Transactions

```go
// TransferMoney effectue un transfert avec transaction
func TransferMoney(ctx context.Context, fromAccountID, toAccountID int, amount float64) error {
    // Commencer une transaction
    tx, err := database.Pool.Begin(ctx)
    if err != nil {
        return err
    }

    // Defer rollback (ne fait rien si commit est appel√©)
    defer tx.Rollback(ctx)

    // Op√©ration 1 : D√©biter le compte source
    _, err = tx.Exec(ctx,
        "UPDATE comptes SET solde = solde - $1 WHERE id = $2",
        amount, fromAccountID)
    if err != nil {
        return fmt.Errorf("erreur de d√©bit : %w", err)
    }

    // Op√©ration 2 : Cr√©diter le compte destination
    _, err = tx.Exec(ctx,
        "UPDATE comptes SET solde = solde + $1 WHERE id = $2",
        amount, toAccountID)
    if err != nil {
        return fmt.Errorf("erreur de cr√©dit : %w", err)
    }

    // Valider la transaction
    err = tx.Commit(ctx)
    if err != nil {
        return fmt.Errorf("erreur de commit : %w", err)
    }

    return nil
}
```

**Transaction avec fonction callback :**

```go
// WithTransaction ex√©cute une fonction dans une transaction
func WithTransaction(ctx context.Context, fn func(pgx.Tx) error) error {
    tx, err := database.Pool.Begin(ctx)
    if err != nil {
        return err
    }
    defer tx.Rollback(ctx)

    if err := fn(tx); err != nil {
        return err
    }

    return tx.Commit(ctx)
}

// Utilisation
err := WithTransaction(ctx, func(tx pgx.Tx) error {
    // Op√©ration 1
    _, err := tx.Exec(ctx, "INSERT INTO logs (message) VALUES ($1)", "Log 1")
    if err != nil {
        return err
    }

    // Op√©ration 2
    _, err = tx.Exec(ctx, "INSERT INTO logs (message) VALUES ($1)", "Log 2")
    if err != nil {
        return err
    }

    return nil
})
```

### Types de Donn√©es PostgreSQL

#### Types num√©riques

```go
// INTEGER, BIGINT
var age int
var bigNumber int64

// NUMERIC/DECIMAL (utiliser pgtype.Numeric)
import "github.com/jackc/pgx/v5/pgtype"

var price pgtype.Numeric
err := price.Scan("19.99")

// FLOAT/DOUBLE PRECISION
var pi float64 = 3.14159
```

#### Types texte

```go
// VARCHAR, TEXT
var nom string
var description string
```

#### Types temporels

```go
import "time"

// DATE
var birthday time.Time

// TIMESTAMP, TIMESTAMPTZ
var createdAt time.Time

// Insertion
_, err := db.Exec(ctx,
    "INSERT INTO events (date, timestamp) VALUES ($1, $2)",
    time.Now(), time.Now())
```

#### JSON et JSONB

```go
import (
    "encoding/json"
)

// Structure Go pour JSON
type Profile struct {
    Nom  string   `json:"nom"`
    Age  int      `json:"age"`
    Tags []string `json:"tags"`
}

// Insertion JSONB
profile := Profile{
    Nom:  "Alice",
    Age:  30,
    Tags: []string{"developer", "postgresql"},
}

profileJSON, _ := json.Marshal(profile)

_, err := db.Exec(ctx,
    "INSERT INTO users (profile) VALUES ($1)",
    profileJSON)

// Lecture JSONB
var profileBytes []byte
err := db.QueryRow(ctx, "SELECT profile FROM users WHERE id = $1", 1).Scan(&profileBytes)

var readProfile Profile
json.Unmarshal(profileBytes, &readProfile)

// Requ√™tes JSONB
rows, err := db.Query(ctx,
    "SELECT * FROM users WHERE profile->>'nom' = $1",
    "Alice")
```

#### Arrays (Tableaux PostgreSQL)

```go
// Insertion d'array
tags := []string{"golang", "postgresql", "pgx"}

_, err := db.Exec(ctx,
    "INSERT INTO articles (tags) VALUES ($1)",
    tags)

// Lecture d'array
var readTags []string
err := db.QueryRow(ctx, "SELECT tags FROM articles WHERE id = $1", 1).Scan(&readTags)

fmt.Println(readTags) // [golang postgresql pgx]

// Recherche dans array
rows, err := db.Query(ctx,
    "SELECT * FROM articles WHERE $1 = ANY(tags)",
    "postgresql")
```

#### UUID

```go
import "github.com/google/uuid"

// G√©n√©ration UUID c√¥t√© Go
id := uuid.New()

_, err := db.Exec(ctx,
    "INSERT INTO sessions (id, token) VALUES ($1, $2)",
    id, "token123")

// G√©n√©ration UUID c√¥t√© PostgreSQL
var newID uuid.UUID
err := db.QueryRow(ctx,
    "INSERT INTO events (id, data) VALUES (gen_uuid_v7(), $1) RETURNING id",
    "event data").Scan(&newID)

// Lecture UUID
var sessionID uuid.UUID
err := db.QueryRow(ctx, "SELECT id FROM sessions WHERE token = $1", "token123").Scan(&sessionID)
```

### Prepared Statements

```go
// Pr√©parer une requ√™te (r√©utilisable)
func GetUserByEmailOptimized(ctx context.Context, email string) (*models.User, error) {
    // Pr√©parer la requ√™te
    stmt, err := database.Pool.Prepare(ctx, "get-user-by-email",
        "SELECT id, nom, email, age FROM utilisateurs WHERE email = $1")
    if err != nil {
        return nil, err
    }

    // Ex√©cuter avec le statement pr√©par√©
    var user models.User
    err = database.Pool.QueryRow(ctx, "get-user-by-email", email).Scan(
        &user.ID,
        &user.Nom,
        &user.Email,
        &user.Age,
    )

    if err != nil {
        return nil, err
    }

    return &user, nil
}
```

### Gestion des Erreurs

```go
import (
    "errors"
    "github.com/jackc/pgx/v5/pgconn"
)

func CreateUser(ctx context.Context, user models.CreateUserInput) error {
    _, err := database.Pool.Exec(ctx,
        "INSERT INTO utilisateurs (nom, email) VALUES ($1, $2)",
        user.Nom, user.Email)

    if err != nil {
        // Cast vers pgconn.PgError pour les d√©tails
        var pgErr *pgconn.PgError
        if errors.As(err, &pgErr) {
            switch pgErr.Code {
            case "23505": // Unique violation
                return fmt.Errorf("email d√©j√† utilis√©")
            case "23503": // Foreign key violation
                return fmt.Errorf("r√©f√©rence invalide")
            case "23502": // NOT NULL violation
                return fmt.Errorf("champ obligatoire manquant")
            default:
                return fmt.Errorf("erreur DB: %s", pgErr.Message)
            }
        }
        return err
    }

    return nil
}
```

### Exemple Complet : API HTTP avec pgx

```go
package main

import (
    "context"
    "encoding/json"
    "log"
    "net/http"
    "strconv"

    "github.com/gorilla/mux"
    "myproject/database"
    "myproject/models"
    "myproject/repository"
)

func main() {
    // Initialiser la base de donn√©es
    if err := database.InitDB(); err != nil {
        log.Fatal(err)
    }
    defer database.Close()

    // Router
    r := mux.NewRouter()

    // Routes
    r.HandleFunc("/users", GetUsersHandler).Methods("GET")
    r.HandleFunc("/users/{id}", GetUserHandler).Methods("GET")
    r.HandleFunc("/users", CreateUserHandler).Methods("POST")
    r.HandleFunc("/users/{id}", UpdateUserHandler).Methods("PUT")
    r.HandleFunc("/users/{id}", DeleteUserHandler).Methods("DELETE")

    // D√©marrer le serveur
    log.Println("üöÄ Serveur d√©marr√© sur :8080")
    log.Fatal(http.ListenAndServe(":8080", r))
}

// GetUsersHandler r√©cup√®re tous les utilisateurs
func GetUsersHandler(w http.ResponseWriter, r *http.Request) {
    users, err := repository.GetAllUsers(r.Context())
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(users)
}

// GetUserHandler r√©cup√®re un utilisateur par ID
func GetUserHandler(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id, err := strconv.Atoi(vars["id"])
    if err != nil {
        http.Error(w, "ID invalide", http.StatusBadRequest)
        return
    }

    user, err := repository.GetUserByID(r.Context(), id)
    if err != nil {
        http.Error(w, err.Error(), http.StatusNotFound)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

// CreateUserHandler cr√©e un utilisateur
func CreateUserHandler(w http.ResponseWriter, r *http.Request) {
    var input models.CreateUserInput
    if err := json.NewDecoder(r.Body).Decode(&input); err != nil {
        http.Error(w, "JSON invalide", http.StatusBadRequest)
        return
    }

    user, err := repository.CreateUser(r.Context(), input)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(user)
}

// UpdateUserHandler met √† jour un utilisateur
func UpdateUserHandler(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id, err := strconv.Atoi(vars["id"])
    if err != nil {
        http.Error(w, "ID invalide", http.StatusBadRequest)
        return
    }

    var input models.UpdateUserInput
    if err := json.NewDecoder(r.Body).Decode(&input); err != nil {
        http.Error(w, "JSON invalide", http.StatusBadRequest)
        return
    }

    user, err := repository.UpdateUser(r.Context(), id, input)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

// DeleteUserHandler supprime un utilisateur
func DeleteUserHandler(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id, err := strconv.Atoi(vars["id"])
    if err != nil {
        http.Error(w, "ID invalide", http.StatusBadRequest)
        return
    }

    if err := repository.DeleteUser(r.Context(), id); err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    w.WriteHeader(http.StatusNoContent)
}
```

---

## Partie 2 : GORM (ORM pour Go)

### Introduction √† GORM

**GORM** est l'ORM (Object-Relational Mapping) le plus populaire pour Go. Il offre :
- **Simplicit√©** : API intuitive et moins de boilerplate
- **Productivit√©** : Migrations automatiques, relations, hooks
- **Puissance** : Requ√™tes complexes, transactions, soft deletes
- **Extensibilit√©** : Plugins et callbacks personnalisables

### Installation

```bash
# GORM core
go get -u gorm.io/gorm

# Driver PostgreSQL pour GORM
go get -u gorm.io/driver/postgres
```

### Configuration et Connexion

```go
package database

import (
    "log"

    "gorm.io/driver/postgres"
    "gorm.io/gorm"
    "gorm.io/gorm/logger"
)

var DB *gorm.DB

// InitDB initialise la connexion GORM
func InitDB() error {
    // DSN (Data Source Name)
    dsn := "host=localhost user=user password=password dbname=mydb port=5432 sslmode=disable"

    // Configuration GORM
    config := &gorm.Config{
        Logger: logger.Default.LogMode(logger.Info), // Log des requ√™tes
    }

    // Connexion
    var err error
    DB, err = gorm.Open(postgres.Open(dsn), config)
    if err != nil {
        return err
    }

    // Configuration du pool de connexions
    sqlDB, err := DB.DB()
    if err != nil {
        return err
    }

    sqlDB.SetMaxOpenConns(25)                      // Max 25 connexions
    sqlDB.SetMaxIdleConns(5)                       // Max 5 connexions idle
    sqlDB.SetConnMaxLifetime(time.Hour)            // Dur√©e de vie max
    sqlDB.SetConnMaxIdleTime(30 * time.Minute)     // Timeout idle

    log.Println("‚úÖ GORM initialis√© avec succ√®s")
    return nil
}
```

### D√©finition des Mod√®les (Models)

```go
package models

import (
    "time"
    "gorm.io/gorm"
)

// User repr√©sente un utilisateur
type User struct {
    ID        uint           `gorm:"primaryKey" json:"id"`
    Nom       string         `gorm:"size:100;not null" json:"nom"`
    Email     string         `gorm:"uniqueIndex;not null" json:"email"`
    Age       int            `json:"age"`
    CreatedAt time.Time      `json:"created_at"`
    UpdatedAt time.Time      `json:"updated_at"`
    DeletedAt gorm.DeletedAt `gorm:"index" json:"-"` // Soft delete
}

// TableName sp√©cifie le nom de la table (optionnel)
func (User) TableName() string {
    return "utilisateurs"
}

// BeforeCreate hook avant cr√©ation
func (u *User) BeforeCreate(tx *gorm.DB) error {
    // Logique avant cr√©ation
    log.Printf("Cr√©ation de l'utilisateur : %s", u.Email)
    return nil
}

// AfterCreate hook apr√®s cr√©ation
func (u *User) AfterCreate(tx *gorm.DB) error {
    log.Printf("Utilisateur cr√©√© : ID=%d", u.ID)
    return nil
}
```

**Tags GORM courants :**

| Tag | Description | Exemple |
|-----|-------------|---------|
| `primaryKey` | Cl√© primaire | `gorm:"primaryKey"` |
| `autoIncrement` | Auto-incr√©ment | `gorm:"autoIncrement"` |
| `unique` | Contrainte UNIQUE | `gorm:"unique"` |
| `uniqueIndex` | Index unique | `gorm:"uniqueIndex"` |
| `not null` | NOT NULL | `gorm:"not null"` |
| `default` | Valeur par d√©faut | `gorm:"default:0"` |
| `size` | Taille VARCHAR | `gorm:"size:255"` |
| `index` | Index simple | `gorm:"index"` |
| `type` | Type SQL custom | `gorm:"type:varchar(100)"` |
| `-` | Ignorer le champ | `gorm:"-"` |

### Auto Migration

```go
// Cr√©er/Modifier automatiquement les tables
func AutoMigrate() error {
    return database.DB.AutoMigrate(
        &models.User{},
        &models.Post{},
        // Autres mod√®les...
    )
}

// Dans main.go
func main() {
    database.InitDB()

    // Ex√©cuter les migrations
    if err := database.AutoMigrate(); err != nil {
        log.Fatal(err)
    }
}
```

**‚ö†Ô∏è Attention :** AutoMigrate cr√©e/modifie les tables mais ne supprime jamais de colonnes.

### CRUD avec GORM

#### CREATE : Cr√©er des enregistrements

```go
// Cr√©er un utilisateur
func CreateUser(user *models.User) error {
    result := database.DB.Create(user)
    if result.Error != nil {
        return result.Error
    }

    log.Printf("Utilisateur cr√©√© : ID=%d\n", user.ID)
    return nil
}

// Utilisation
user := &models.User{
    Nom:   "Alice",
    Email: "alice@example.com",
    Age:   30,
}

err := CreateUser(user)
// user.ID est maintenant rempli automatiquement
```

**Cr√©ation multiple (batch) :**

```go
users := []models.User{
    {Nom: "Alice", Email: "alice@example.com", Age: 30},
    {Nom: "Bob", Email: "bob@example.com", Age: 25},
    {Nom: "Charlie", Email: "charlie@example.com", Age: 35},
}

result := database.DB.Create(&users)
if result.Error != nil {
    log.Fatal(result.Error)
}

fmt.Printf("%d utilisateurs cr√©√©s\n", result.RowsAffected)
```

**Cr√©ation avec champs s√©lectionn√©s :**

```go
// Cr√©er uniquement avec nom et email (ignore age)
user := models.User{Nom: "Alice", Email: "alice@example.com", Age: 30}

database.DB.Select("Nom", "Email").Create(&user)
// Age sera NULL ou valeur par d√©faut
```

#### READ : Lire des donn√©es

```go
// R√©cup√©rer un utilisateur par ID
func GetUserByID(id uint) (*models.User, error) {
    var user models.User

    result := database.DB.First(&user, id)
    if result.Error != nil {
        if errors.Is(result.Error, gorm.ErrRecordNotFound) {
            return nil, fmt.Errorf("utilisateur non trouv√©")
        }
        return nil, result.Error
    }

    return &user, nil
}

// R√©cup√©rer par condition
func GetUserByEmail(email string) (*models.User, error) {
    var user models.User

    result := database.DB.Where("email = ?", email).First(&user)
    if result.Error != nil {
        return nil, result.Error
    }

    return &user, nil
}

// R√©cup√©rer tous les utilisateurs
func GetAllUsers() ([]models.User, error) {
    var users []models.User

    result := database.DB.Order("nom").Find(&users)
    if result.Error != nil {
        return nil, result.Error
    }

    return users, nil
}

// R√©cup√©rer avec conditions multiples
func SearchUsers(namePattern string, minAge, maxAge int) ([]models.User, error) {
    var users []models.User

    result := database.DB.Where("nom ILIKE ? AND age BETWEEN ? AND ?",
        "%"+namePattern+"%", minAge, maxAge).
        Order("nom").
        Find(&users)

    if result.Error != nil {
        return nil, result.Error
    }

    return users, nil
}
```

**M√©thodes de recherche :**

```go
// First : Premier r√©sultat (ORDER BY primary key)
db.First(&user)

// Last : Dernier r√©sultat
db.Last(&user)

// Take : Un r√©sultat (sans ordre)
db.Take(&user)

// Find : Tous les r√©sultats
db.Find(&users)

// Avec conditions
db.Where("age > ?", 18).Find(&users)
db.Where(&User{Nom: "Alice"}).First(&user)
```

**Requ√™tes avanc√©es :**

```go
// OR conditions
db.Where("nom = ?", "Alice").Or("nom = ?", "Bob").Find(&users)

// NOT conditions
db.Not("age < ?", 18).Find(&users)

// IN clause
db.Where("id IN ?", []int{1, 2, 3}).Find(&users)

// LIKE
db.Where("email LIKE ?", "%@gmail.com").Find(&users)

// S√©lectionner des colonnes sp√©cifiques
db.Select("nom", "email").Find(&users)

// Pagination
db.Limit(10).Offset(20).Find(&users)

// Compter
var count int64
db.Model(&models.User{}).Where("age > ?", 18).Count(&count)
```

#### UPDATE : Modifier des donn√©es

```go
// Mettre √† jour un utilisateur (tous les champs)
func UpdateUser(user *models.User) error {
    result := database.DB.Save(user)
    return result.Error
}

// Mettre √† jour des champs sp√©cifiques
func UpdateUserFields(id uint, updates map[string]interface{}) error {
    result := database.DB.Model(&models.User{}).Where("id = ?", id).Updates(updates)

    if result.Error != nil {
        return result.Error
    }

    if result.RowsAffected == 0 {
        return fmt.Errorf("utilisateur non trouv√©")
    }

    return nil
}

// Utilisation
updates := map[string]interface{}{
    "nom":   "Alice Smith",
    "age":   31,
}
UpdateUserFields(1, updates)

// Mettre √† jour avec struct (uniquement champs non-zero)
user := models.User{Age: 32}
database.DB.Model(&models.User{}).Where("id = ?", 1).Updates(user)

// Mettre √† jour un seul champ
database.DB.Model(&models.User{}).Where("id = ?", 1).Update("age", 33)

// Incr√©menter
database.DB.Model(&models.User{}).Where("id = ?", 1).Update("age", gorm.Expr("age + ?", 1))
```

#### DELETE : Supprimer des donn√©es

```go
// Suppression logique (soft delete) - par d√©faut avec DeletedAt
func DeleteUser(id uint) error {
    result := database.DB.Delete(&models.User{}, id)

    if result.Error != nil {
        return result.Error
    }

    if result.RowsAffected == 0 {
        return fmt.Errorf("utilisateur non trouv√©")
    }

    return nil
}

// Suppression physique (d√©finitive)
func HardDeleteUser(id uint) error {
    result := database.DB.Unscoped().Delete(&models.User{}, id)
    return result.Error
}

// Supprimer avec condition
func DeleteUsersByAge(maxAge int) (int64, error) {
    result := database.DB.Where("age < ?", maxAge).Delete(&models.User{})
    return result.RowsAffected, result.Error
}

// Restaurer un enregistrement soft-deleted
func RestoreUser(id uint) error {
    return database.DB.Model(&models.User{}).Unscoped().
        Where("id = ?", id).
        Update("deleted_at", nil).Error
}
```

### Relations dans GORM

#### One-to-Many (Un √† Plusieurs)

```go
// User a plusieurs Posts
type User struct {
    ID    uint   `gorm:"primaryKey"`
    Nom   string
    Posts []Post // Relation
}

// Post appartient √† un User
type Post struct {
    ID      uint   `gorm:"primaryKey"`
    Title   string
    Content string
    UserID  uint   // Cl√© √©trang√®re
    User    User   `gorm:"constraint:OnUpdate:CASCADE,OnDelete:CASCADE;"`
}

// Cr√©er un utilisateur avec posts
user := models.User{
    Nom: "Alice",
    Posts: []models.Post{
        {Title: "Post 1", Content: "Contenu 1"},
        {Title: "Post 2", Content: "Contenu 2"},
    },
}
database.DB.Create(&user)

// Charger les relations (Preload)
var user models.User
database.DB.Preload("Posts").First(&user, 1)

fmt.Printf("User: %s\n", user.Nom)
for _, post := range user.Posts {
    fmt.Printf("  - %s\n", post.Title)
}

// Ajouter un post √† un utilisateur existant
post := models.Post{Title: "Nouveau post", Content: "Contenu", UserID: 1}
database.DB.Create(&post)

// Ou avec association
database.DB.Model(&user).Association("Posts").Append(&post)
```

#### Many-to-Many (Plusieurs √† Plusieurs)

```go
// Post a plusieurs Tags, Tag a plusieurs Posts
type Post struct {
    ID    uint   `gorm:"primaryKey"`
    Title string
    Tags  []Tag  `gorm:"many2many:post_tags;"` // Table de jointure
}

type Tag struct {
    ID    uint   `gorm:"primaryKey"`
    Name  string
    Posts []Post `gorm:"many2many:post_tags;"`
}

// Cr√©er avec relations
post := models.Post{
    Title: "Mon article",
    Tags: []models.Tag{
        {Name: "go"},
        {Name: "postgresql"},
    },
}
database.DB.Create(&post)

// Charger avec tags
var post models.Post
database.DB.Preload("Tags").First(&post, 1)

// Ajouter un tag √† un post
tag := models.Tag{Name: "gorm"}
database.DB.Model(&post).Association("Tags").Append(&tag)

// Supprimer une association (sans supprimer le tag)
database.DB.Model(&post).Association("Tags").Delete(&tag)
```

#### Belongs To (Appartient √Ä)

```go
type Profile struct {
    ID     uint
    Bio    string
    UserID uint
    User   User `gorm:"constraint:OnUpdate:CASCADE,OnDelete:CASCADE;"`
}

// Charger avec user
var profile models.Profile
database.DB.Preload("User").First(&profile, 1)
```

### Transactions avec GORM

```go
// Transaction basique
func TransferMoney(fromAccountID, toAccountID uint, amount float64) error {
    return database.DB.Transaction(func(tx *gorm.DB) error {
        // Op√©ration 1 : D√©biter
        if err := tx.Model(&Account{}).Where("id = ?", fromAccountID).
            Update("balance", gorm.Expr("balance - ?", amount)).Error; err != nil {
            return err
        }

        // Op√©ration 2 : Cr√©diter
        if err := tx.Model(&Account{}).Where("id = ?", toAccountID).
            Update("balance", gorm.Expr("balance + ?", amount)).Error; err != nil {
            return err
        }

        // Si aucune erreur, commit automatique
        return nil
    })
}
```

**Transaction manuelle :**

```go
// D√©marrer une transaction
tx := database.DB.Begin()

// Op√©rations
if err := tx.Create(&user1).Error; err != nil {
    tx.Rollback()
    return err
}

if err := tx.Create(&user2).Error; err != nil {
    tx.Rollback()
    return err
}

// Commit
tx.Commit()
```

### Requ√™tes Brutes (Raw SQL)

```go
// Requ√™te brute avec scan
var users []models.User
database.DB.Raw("SELECT * FROM utilisateurs WHERE age > ?", 18).Scan(&users)

// Exec SQL brut
database.DB.Exec("UPDATE utilisateurs SET age = age + 1 WHERE age < ?", 50)

// Avec r√©sultat
type Result struct {
    Nom   string
    Count int
}

var result Result
database.DB.Raw("SELECT nom, COUNT(*) as count FROM posts GROUP BY nom").Scan(&result)
```

### Scopes (Requ√™tes r√©utilisables)

```go
// D√©finir des scopes
func Adults(db *gorm.DB) *gorm.DB {
    return db.Where("age >= ?", 18)
}

func Active(db *gorm.DB) *gorm.DB {
    return db.Where("deleted_at IS NULL")
}

func OrderByName(db *gorm.DB) *gorm.DB {
    return db.Order("nom")
}

// Utiliser les scopes
var users []models.User
database.DB.Scopes(Adults, Active, OrderByName).Find(&users)

// Pagination scope
func Paginate(page, pageSize int) func(db *gorm.DB) *gorm.DB {
    return func(db *gorm.DB) *gorm.DB {
        offset := (page - 1) * pageSize
        return db.Offset(offset).Limit(pageSize)
    }
}

// Utilisation
database.DB.Scopes(Paginate(2, 10)).Find(&users)
```

### Exemple Complet : API HTTP avec GORM

```go
package main

import (
    "encoding/json"
    "log"
    "net/http"
    "strconv"

    "github.com/gorilla/mux"
    "myproject/database"
    "myproject/models"
)

func main() {
    // Initialiser GORM
    if err := database.InitDB(); err != nil {
        log.Fatal(err)
    }

    // Auto-migrer les tables
    database.DB.AutoMigrate(&models.User{})

    // Router
    r := mux.NewRouter()

    // Routes
    r.HandleFunc("/users", GetUsersHandler).Methods("GET")
    r.HandleFunc("/users/{id}", GetUserHandler).Methods("GET")
    r.HandleFunc("/users", CreateUserHandler).Methods("POST")
    r.HandleFunc("/users/{id}", UpdateUserHandler).Methods("PUT")
    r.HandleFunc("/users/{id}", DeleteUserHandler).Methods("DELETE")

    log.Println("üöÄ Serveur d√©marr√© sur :8080")
    log.Fatal(http.ListenAndServe(":8080", r))
}

func GetUsersHandler(w http.ResponseWriter, r *http.Request) {
    var users []models.User

    result := database.DB.Find(&users)
    if result.Error != nil {
        http.Error(w, result.Error.Error(), http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(users)
}

func GetUserHandler(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id, _ := strconv.Atoi(vars["id"])

    var user models.User
    result := database.DB.First(&user, id)

    if result.Error != nil {
        http.Error(w, "Utilisateur non trouv√©", http.StatusNotFound)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

func CreateUserHandler(w http.ResponseWriter, r *http.Request) {
    var user models.User

    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
        http.Error(w, "JSON invalide", http.StatusBadRequest)
        return
    }

    result := database.DB.Create(&user)
    if result.Error != nil {
        http.Error(w, result.Error.Error(), http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(user)
}

func UpdateUserHandler(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id, _ := strconv.Atoi(vars["id"])

    var user models.User
    if database.DB.First(&user, id).Error != nil {
        http.Error(w, "Utilisateur non trouv√©", http.StatusNotFound)
        return
    }

    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
        http.Error(w, "JSON invalide", http.StatusBadRequest)
        return
    }

    user.ID = uint(id)
    database.DB.Save(&user)

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

func DeleteUserHandler(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id, _ := strconv.Atoi(vars["id"])

    result := database.DB.Delete(&models.User{}, id)
    if result.Error != nil {
        http.Error(w, result.Error.Error(), http.StatusInternalServerError)
        return
    }

    if result.RowsAffected == 0 {
        http.Error(w, "Utilisateur non trouv√©", http.StatusNotFound)
        return
    }

    w.WriteHeader(http.StatusNoContent)
}
```

---

## Comparaison : pgx vs GORM

### Performance

**Benchmark indicatif (10000 requ√™tes SELECT) :**
- **pgx** : ~800ms
- **GORM** : ~1200ms

**Diff√©rence :** GORM est ~30-50% plus lent que pgx, mais reste tr√®s performant pour la plupart des applications.

### Complexit√© du Code

**pgx :**
```go
// Plus verbeux mais contr√¥le total
rows, err := db.Query(ctx, "SELECT id, nom, email FROM users WHERE age > $1", 18)
defer rows.Close()

var users []User
for rows.Next() {
    var u User
    rows.Scan(&u.ID, &u.Nom, &u.Email)
    users = append(users, u)
}
```

**GORM :**
```go
// Concis et expressif
var users []User
db.Where("age > ?", 18).Find(&users)
```

### Quand Utiliser Chaque Approche

#### pgx ‚úÖ

**Choisir pgx si :**
- Besoin de **performances maximales**
- Requ√™tes SQL **complexes** (CTEs, window functions, optimisations avanc√©es)
- **Microservices** l√©gers avec peu de d√©pendances
- Contr√¥le total sur le SQL g√©n√©r√©
- √âquipe **exp√©riment√©e en SQL**
- Benchmarking et optimisation critique

**Exemples de cas d'usage :**
- API haute performance (>10k req/s)
- Services de donn√©es analytiques
- Syst√®me de trading temps r√©el
- Batch processing massif

#### GORM ‚úÖ

**Choisir GORM si :**
- Productivit√© et **d√©veloppement rapide**
- Application **CRUD standard**
- √âquipe **moins exp√©riment√©e en SQL**
- Besoin de **migrations automatiques**
- Relations complexes entre tables
- Prototypage et MVP

**Exemples de cas d'usage :**
- API REST standard
- Application web e-commerce
- Syst√®me de gestion interne
- SaaS standard

### Approche Hybride

Vous pouvez **combiner** les deux :

```go
// Utiliser GORM pour le CRUD standard
var users []models.User
database.DB.Where("active = ?", true).Find(&users)

// Utiliser pgx pour les requ√™tes complexes
sqlDB, _ := database.DB.DB()
rows, _ := sqlDB.Query(`
    WITH monthly_stats AS (
        SELECT DATE_TRUNC('month', created_at) as month,
               COUNT(*) as user_count
        FROM users
        GROUP BY month
    )
    SELECT * FROM monthly_stats
    ORDER BY month DESC
    LIMIT 12
`)
```

---

## Bonnes Pratiques

### 1. Toujours Utiliser un Pool de Connexions

‚úÖ **Bon :**
```go
// Configuration du pool
config.MaxConns = 25
config.MinConns = 5
```

### 2. Utiliser le Context

```go
// ‚úÖ Passer le context pour timeout et cancellation
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

users, err := repository.GetAllUsers(ctx)
```

### 3. G√©rer les Erreurs Proprement

```go
// pgx
if err != nil {
    var pgErr *pgconn.PgError
    if errors.As(err, &pgErr) {
        switch pgErr.Code {
        case "23505":
            return ErrDuplicateKey
        }
    }
}

// GORM
if errors.Is(err, gorm.ErrRecordNotFound) {
    return ErrNotFound
}
```

### 4. Transactions pour Op√©rations Multiples

```go
// pgx
tx, _ := db.Begin(ctx)
defer tx.Rollback(ctx)
// ... op√©rations
tx.Commit(ctx)

// GORM
db.Transaction(func(tx *gorm.DB) error {
    // ... op√©rations
    return nil
})
```

### 5. Utiliser Prepared Statements (pgx)

```go
// Pr√©parer une requ√™te r√©utilisable
stmt, _ := db.Prepare(ctx, "get-user", "SELECT * FROM users WHERE id = $1")

// R√©utiliser plusieurs fois
db.QueryRow(ctx, "get-user", 1).Scan(&user)
db.QueryRow(ctx, "get-user", 2).Scan(&user)
```

### 6. Indexation et Optimisation GORM

```go
// Ajouter des index
type User struct {
    Email string `gorm:"uniqueIndex"`
    Age   int    `gorm:"index"`
}

// Charger uniquement les champs n√©cessaires
db.Select("id", "nom").Find(&users)

// Preload pour √©viter N+1
db.Preload("Posts").Find(&users)
```

### 7. Logging et Monitoring

```go
// pgx : Logger personnalis√©
import "github.com/jackc/pgx/v5/tracelog"

config.ConnConfig.Tracer = &tracelog.TraceLog{
    Logger:   logger,
    LogLevel: tracelog.LogLevelInfo,
}

// GORM : Configuration du logger
config := &gorm.Config{
    Logger: logger.Default.LogMode(logger.Info),
}
```

---

## Ressources et Documentation

### pgx
- **Documentation officielle** : https://pkg.go.dev/github.com/jackc/pgx/v5
- **GitHub** : https://github.com/jackc/pgx
- **Wiki** : https://github.com/jackc/pgx/wiki

### GORM
- **Documentation officielle** : https://gorm.io/docs/
- **GitHub** : https://github.com/go-gorm/gorm
- **Community** : https://github.com/go-gorm/gorm/discussions

### Go Database
- **database/sql** : https://pkg.go.dev/database/sql
- **Go Database Best Practices** : https://go.dev/doc/database/

---

## R√©sum√© des Points Cl√©s

### pgx

- ‚úÖ **Driver natif** PostgreSQL haute performance
- ‚úÖ **2-3√ó plus rapide** que les alternatives
- ‚úÖ Pool de connexions int√©gr√© (`pgxpool`)
- ‚úÖ Support complet des types PostgreSQL (JSONB, Arrays, UUID)
- ‚úÖ API **bas niveau** avec contr√¥le total
- ‚úÖ Id√©al pour **performances critiques** et SQL complexe

### GORM

- ‚úÖ **ORM complet** et feature-rich
- ‚úÖ **Productivit√©** √©lev√©e, moins de boilerplate
- ‚úÖ **Auto-migrations** et gestion de sch√©ma
- ‚úÖ Relations (One-to-Many, Many-to-Many)
- ‚úÖ **Hooks** et callbacks
- ‚úÖ **Soft deletes** int√©gr√©
- ‚úÖ Id√©al pour **d√©veloppement rapide** et CRUD standard

### Choix Final

**Pour 70% des projets Go :** GORM (productivit√©, maintenabilit√©)
**Pour performances critiques :** pgx (contr√¥le, vitesse)
**Approche hybride :** GORM pour CRUD + pgx pour requ√™tes complexes

---

**Prochaine √©tape :** Explorez les autres drivers (.NET Npgsql) pour comparer les approches et ma√Ætriser PostgreSQL dans tous les √©cosyst√®mes.

‚è≠Ô∏è [.NET : Npgsql, Entity Framework Core](/20-drivers-connexion-applicative/01.5-dotnet-npgsql.md)
