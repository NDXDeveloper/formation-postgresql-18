üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.2.4. Connection Leaks et Timeouts

## Introduction

Les **connection leaks** (fuites de connexions) et les **timeouts** (d√©lais d'attente) sont parmi les probl√®mes les plus courants et les plus frustrants lors du travail avec des bases de donn√©es. Dans cette section, nous allons comprendre :

- Ce qu'est un connection leak et comment il se produit
- Les diff√©rents types de timeouts
- Comment d√©tecter ces probl√®mes
- Comment les pr√©venir et les corriger

**Pourquoi c'est important ?** Un seul connection leak peut progressivement saturer votre pool de connexions et faire tomber toute votre application.

---

## Partie 1 : Les Connection Leaks

### Qu'est-ce qu'un connection leak ?

Un **connection leak** (fuite de connexion) se produit quand une connexion est emprunt√©e au pool mais **jamais rendue**.

**Analogie** : Imaginez une biblioth√®que :
- Vous empruntez un livre (connexion)
- Vous le lisez
- Vous **oubliez de le ramener** ‚Üê Connection leak !
- La biblioth√®que a un livre de moins disponible
- Apr√®s plusieurs oublis, plus de livres disponibles ‚Üí Catastrophe !

### Comment √ßa se produit ?

#### Sc√©nario 1 : Oubli de fermeture

**Code probl√©matique (Python)** :
```python
from psycopg_pool import ConnectionPool

pool = ConnectionPool("postgresql://user:pass@localhost/mydb")

def get_user(user_id):
    # Emprunter une connexion
    conn = pool.connection()

    # Utiliser la connexion
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))
    user = cursor.fetchone()

    # OUBLI : ne jamais rendre conn au pool
    return user
    # ‚Üê La connexion reste emprunt√©e pour toujours !

# Apr√®s 10 appels √† cette fonction :
# ‚Üí 10 connexions perdues
# Apr√®s 20 appels avec pool_size=20 :
# ‚Üí Pool compl√®tement vide ‚Üí Application bloqu√©e !
```

**Pourquoi c'est grave ?** :
```
Appel 1  ‚Üí 1 connexion perdue
Appel 2  ‚Üí 2 connexions perdues
Appel 3  ‚Üí 3 connexions perdues
...
Appel 20 ‚Üí 20 connexions perdues (pool vide)
Appel 21 ‚Üí ERREUR : Timeout waiting for connection !
```

#### Sc√©nario 2 : Exception non g√©r√©e

**Code probl√©matique (Node.js)** :
```javascript
const { Pool } = require('pg');
const pool = new Pool({ max: 10 });

async function updateUser(userId, name) {
    const client = await pool.connect();  // Emprunter

    // Si cette requ√™te √©choue ‚Üí Exception lev√©e
    await client.query('UPDATE users SET name = $1 WHERE id = $2',
                       [name, userId]);

    client.release();  // Cette ligne n'est JAMAIS ex√©cut√©e en cas d'erreur !
    // ‚Üê Connection leak !
}

// Utilisation
try {
    await updateUser(999, 'John');  // Si userId=999 n'existe pas ‚Üí erreur
} catch (error) {
    console.error(error);
    // La connexion n'a pas √©t√© rendue au pool !
}
```

#### Sc√©nario 3 : Return pr√©matur√©

**Code probl√©matique (Java)** :
```java
public User getUser(int userId) throws SQLException {
    Connection conn = dataSource.getConnection();  // Emprunter
    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery("SELECT * FROM users WHERE id = " + userId);

    if (rs.next()) {
        User user = new User(rs.getInt("id"), rs.getString("name"));
        return user;  // Return ici !
        // ‚Üê conn.close() jamais appel√© ‚Üí Connection leak !
    }

    conn.close();  // Cette ligne n'est jamais atteinte
    return null;
}
```

### Cons√©quences d'un connection leak

#### 1. Saturation progressive du pool

```
Temps    Connexions utilis√©es    Connexions disponibles    √âtat
----------------------------------------------------------------------
T+0      2                       18 (sur 20)               ‚úÖ OK
T+1min   5 (3 leaks)             15                        ‚úÖ OK
T+5min   12 (10 leaks)           8                         ‚ö†Ô∏è Attention
T+10min  18 (16 leaks)           2                         ‚ö†Ô∏è‚ö†Ô∏è Critique
T+15min  20 (20 leaks)           0                         üî¥ ERREUR
‚Üí Toutes nouvelles requ√™tes √©chouent avec timeout !
```

#### 2. Erreurs applicatives

**Messages d'erreur typiques** :

**Python (psycopg)** :
```
psycopg_pool.PoolTimeout: couldn't get a connection after 30.00 sec
```

**Node.js (pg)** :
```
TimeoutError: Timeout waiting for connection from pool
```

**Java (HikariCP)** :
```
SQLTransientConnectionException: Connection is not available, request timed out after 30000ms
```

**.NET (Npgsql)** :
```
TimeoutException: Timeout while getting a connection from pool
```

#### 3. Impact en production

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ S√©quence catastrophique                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1. Code avec leak d√©ploy√© en production         ‚îÇ
‚îÇ 2. Connexions s'accumulent progressivement      ‚îÇ
‚îÇ 3. Pool se vide                                 ‚îÇ
‚îÇ 4. Nouvelles requ√™tes √©chouent (timeouts)       ‚îÇ
‚îÇ 5. Utilisateurs voient des erreurs 500          ‚îÇ
‚îÇ 6. Application semble "gel√©e"                   ‚îÇ
‚îÇ 7. Red√©marrage n√©cessaire (solution temporaire) ‚îÇ
‚îÇ 8. Le probl√®me revient quelques minutes apr√®s   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Comment d√©tecter un connection leak ?

#### M√©thode 1 : Monitoring du pool

**Python (psycopg3)** :
```python
from psycopg_pool import ConnectionPool

pool = ConnectionPool("postgresql://...")

# Fonction de monitoring
def check_pool_health():
    stats = pool.get_stats()
    print(f"Pool total: {stats['pool_size']}")
    print(f"Disponibles: {stats['pool_available']}")
    print(f"Utilis√©es: {stats['pool_size'] - stats['pool_available']}")

    # Alerte si trop de connexions utilis√©es
    used_percent = (stats['pool_size'] - stats['pool_available']) / stats['pool_size']
    if used_percent > 0.8:
        print("‚ö†Ô∏è WARNING: Pool utilisation > 80%")

# Appeler r√©guli√®rement (toutes les 10 secondes)
import time
while True:
    check_pool_health()
    time.sleep(10)
```

**Node.js (pg)** :
```javascript
const pool = new Pool({ max: 20 });

// Monitoring du pool
setInterval(() => {
    console.log('Pool stats:');
    console.log('  Total:', pool.totalCount);
    console.log('  Idle:', pool.idleCount);
    console.log('  Waiting:', pool.waitingCount);

    const usedPercent = (pool.totalCount - pool.idleCount) / pool.totalCount;
    if (usedPercent > 0.8) {
        console.warn('‚ö†Ô∏è WARNING: Pool utilisation > 80%');
    }
}, 10000);
```

**Java (HikariCP)** :
```java
import com.zaxxer.hikari.HikariPoolMXBean;

// Obtenir les statistiques via JMX
HikariPoolMXBean poolMBean = hikariDataSource.getHikariPoolMXBean();

// Monitoring r√©gulier
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
scheduler.scheduleAtFixedRate(() -> {
    int total = poolMBean.getTotalConnections();
    int active = poolMBean.getActiveConnections();
    int idle = poolMBean.getIdleConnections();

    System.out.println("Pool stats:");
    System.out.println("  Total: " + total);
    System.out.println("  Active: " + active);
    System.out.println("  Idle: " + idle);

    double usedPercent = (double) active / total;
    if (usedPercent > 0.8) {
        System.err.println("‚ö†Ô∏è WARNING: Pool utilisation > 80%");
    }
}, 0, 10, TimeUnit.SECONDS);
```

#### M√©thode 2 : Logs PostgreSQL

**Activer les logs de connexion/d√©connexion** :

**postgresql.conf** :
```conf
log_connections = on
log_disconnections = on
log_line_prefix = '%t [%p] %u@%d '
```

**Analyser les logs** :
```bash
# Compter les connexions vs d√©connexions
grep "connection authorized" /var/log/postgresql/postgresql-*.log | wc -l
grep "disconnection" /var/log/postgresql/postgresql-*.log | wc -l

# Si connexions >> d√©connexions ‚Üí Leak probable
```

**Exemple de sortie** :
```
Connexions : 1523
D√©connexions : 1234
Diff√©rence : 289 connexions non ferm√©es ‚Üí LEAK !
```

#### M√©thode 3 : Requ√™te PostgreSQL

**Voir les connexions par √¢ge** :
```sql
SELECT
    pid,
    usename,
    application_name,
    client_addr,
    state,
    now() - backend_start as age,
    query
FROM pg_stat_activity
WHERE datname = current_database()
ORDER BY backend_start
LIMIT 20;
```

**Indicateurs de leak** :
```
 pid  | usename | app_name | state |    age     | query
------+---------+----------+-------+------------+-------
 1234 | myapp   | MyAPI    | idle  | 02:15:32   | SELECT ...
 1235 | myapp   | MyAPI    | idle  | 02:10:45   | UPDATE ...
 1236 | myapp   | MyAPI    | idle  | 02:05:12   | INSERT ...
```

Si vous voyez des connexions `idle` depuis **des heures** ‚Üí Leak probable !

### Comment corriger un connection leak ?

#### Solution 1 : Toujours utiliser try/finally

**Python - Version CORRECTE** :
```python
def get_user(user_id):
    conn = pool.connection()
    try:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))
        return cursor.fetchone()
    finally:
        conn.close()  # TOUJOURS ex√©cut√©, m√™me en cas d'erreur
```

**Encore mieux : Context manager (with)** :
```python
def get_user(user_id):
    with pool.connection() as conn:  # Fermeture automatique
        with conn.cursor() as cursor:
            cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))
            return cursor.fetchone()
    # Connexion automatiquement rendue au pool ici
```

#### Solution 2 : Try/catch/finally en Node.js

**Node.js - Version CORRECTE** :
```javascript
async function updateUser(userId, name) {
    const client = await pool.connect();

    try {
        await client.query(
            'UPDATE users SET name = $1 WHERE id = $2',
            [name, userId]
        );
    } catch (error) {
        console.error('Error updating user:', error);
        throw error;
    } finally {
        client.release();  // TOUJOURS ex√©cut√©
    }
}
```

**Encore mieux : Utiliser pool.query()** :
```javascript
// pool.query() g√®re automatiquement connect() et release()
async function updateUser(userId, name) {
    await pool.query(
        'UPDATE users SET name = $1 WHERE id = $2',
        [name, userId]
    );
    // Pas de leak possible !
}
```

#### Solution 3 : Try-with-resources en Java

**Java - Version CORRECTE** :
```java
public User getUser(int userId) throws SQLException {
    // try-with-resources : fermeture automatique
    try (Connection conn = dataSource.getConnection();
         Statement stmt = conn.createStatement();
         ResultSet rs = stmt.executeQuery("SELECT * FROM users WHERE id = " + userId)) {

        if (rs.next()) {
            return new User(rs.getInt("id"), rs.getString("name"));
        }
        return null;
    }
    // conn est automatiquement ferm√© ici, m√™me avec return ou exception
}
```

#### Solution 4 : Using statement en .NET

**.NET - Version CORRECTE** :
```csharp
public User GetUser(int userId)
{
    using (var conn = new NpgsqlConnection(connectionString))
    using (var cmd = new NpgsqlCommand("SELECT * FROM users WHERE id = @id", conn))
    {
        conn.Open();
        cmd.Parameters.AddWithValue("id", userId);

        using (var reader = cmd.ExecuteReader())
        {
            if (reader.Read())
            {
                return new User
                {
                    Id = reader.GetInt32(0),
                    Name = reader.GetString(1)
                };
            }
        }
    }
    // Connexion automatiquement ferm√©e
    return null;
}
```

#### Solution 5 : defer en Go

**Go - Version CORRECTE** :
```go
func getUser(ctx context.Context, userId int) (*User, error) {
    conn, err := pool.Acquire(ctx)
    if err != nil {
        return nil, err
    }
    defer conn.Release()  // Ex√©cut√© √† la fin de la fonction

    var user User
    err = conn.QueryRow(ctx,
        "SELECT id, name FROM users WHERE id = $1",
        userId,
    ).Scan(&user.ID, &user.Name)

    if err != nil {
        return nil, err
    }
    return &user, nil
}
```

### Pr√©vention des connection leaks

#### Pattern 1 : Repository Pattern

**Principe** : Centraliser l'acc√®s aux donn√©es dans une couche d√©di√©e.

**Python - Exemple** :
```python
class UserRepository:
    def __init__(self, pool):
        self.pool = pool

    def get_user(self, user_id):
        """M√©thode qui g√®re automatiquement les connexions"""
        with self.pool.connection() as conn:
            with conn.cursor() as cursor:
                cursor.execute(
                    "SELECT id, name, email FROM users WHERE id = %s",
                    (user_id,)
                )
                return cursor.fetchone()

    def update_user(self, user_id, name, email):
        with self.pool.connection() as conn:
            with conn.cursor() as cursor:
                cursor.execute(
                    "UPDATE users SET name = %s, email = %s WHERE id = %s",
                    (name, email, user_id)
                )
                conn.commit()

# Utilisation (pas de gestion de connexion manuelle)
repo = UserRepository(pool)
user = repo.get_user(42)
repo.update_user(42, "Alice", "alice@example.com")
```

#### Pattern 2 : Decorators/Wrappers

**Python - D√©corateur** :
```python
from functools import wraps

def with_connection(func):
    """D√©corateur qui g√®re automatiquement les connexions"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        with pool.connection() as conn:
            return func(conn, *args, **kwargs)
    return wrapper

# Utilisation
@with_connection
def get_user(conn, user_id):
    with conn.cursor() as cursor:
        cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))
        return cursor.fetchone()

# Pas besoin de g√©rer la connexion manuellement
user = get_user(42)
```

#### Pattern 3 : ORM (Object-Relational Mapping)

Les ORMs g√®rent automatiquement les connexions :

**Python - SQLAlchemy** :
```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session

engine = create_engine("postgresql://user:pass@localhost/mydb")
SessionLocal = sessionmaker(bind=engine)

def get_user(user_id: int):
    session = SessionLocal()
    try:
        user = session.query(User).filter(User.id == user_id).first()
        return user
    finally:
        session.close()  # G√®re la connexion

# Ou avec context manager
def get_user(user_id: int):
    with SessionLocal() as session:
        return session.query(User).filter(User.id == user_id).first()
```

**Node.js - Sequelize** :
```javascript
const { Sequelize, Model, DataTypes } = require('sequelize');

const sequelize = new Sequelize('postgresql://user:pass@localhost/mydb');

class User extends Model {}
User.init({
    name: DataTypes.STRING,
    email: DataTypes.STRING
}, { sequelize });

// Sequelize g√®re les connexions automatiquement
async function getUser(userId) {
    return await User.findByPk(userId);
    // Pas de gestion de connexion manuelle !
}
```

---

## Partie 2 : Les Timeouts

### Qu'est-ce qu'un timeout ?

Un **timeout** est un d√©lai maximal d'attente apr√®s lequel une op√©ration √©choue.

**Analogie** : Vous attendez le bus. Apr√®s 30 minutes (timeout), vous d√©cidez que le bus ne viendra pas et vous prenez un taxi.

### Types de timeouts

#### 1. Connection Timeout

**D√©finition** : Temps maximum pour **√©tablir** une connexion au serveur PostgreSQL.

**Configuration** :

**Python (psycopg3)** :
```python
import psycopg

# Timeout de 5 secondes pour se connecter
conn = psycopg.connect(
    "postgresql://user:pass@localhost/mydb",
    connect_timeout=5
)
```

**Node.js (pg)** :
```javascript
const pool = new Pool({
    connectionTimeoutMillis: 5000  // 5 secondes
});
```

**Java (HikariCP)** :
```java
config.setConnectionTimeout(5000);  // 5 secondes
```

**Quand il se d√©clenche** :
- Serveur PostgreSQL injoignable
- Probl√®mes r√©seau
- Pare-feu bloquant

**Erreur typique** :
```
psycopg.OperationalError: connection to server at "localhost" (::1), port 5432 failed:
timeout expired
```

#### 2. Pool Timeout (Pool Exhaustion)

**D√©finition** : Temps maximum d'attente pour **obtenir une connexion du pool**.

**Configuration** :

**Python (psycopg3)** :
```python
from psycopg_pool import ConnectionPool

pool = ConnectionPool(
    conninfo="postgresql://...",
    timeout=30  # Attendre max 30 secondes
)
```

**Node.js (pg)** :
```javascript
const pool = new Pool({
    connectionTimeoutMillis: 30000  // 30 secondes
});
```

**Java (HikariCP)** :
```java
config.setConnectionTimeout(30000);  // 30 secondes
```

**Quand il se d√©clenche** :
- Pool satur√© (toutes les connexions utilis√©es)
- Connection leaks en cours
- Requ√™tes lentes monopolisant les connexions

**Erreur typique** :
```
PoolTimeout: couldn't get a connection after 30.00 sec
```

**Diagramme** :
```
Pool (10 connexions)
‚îú‚îÄ Connexion 1 : UTILIS√âE (requ√™te en cours)
‚îú‚îÄ Connexion 2 : UTILIS√âE
‚îú‚îÄ Connexion 3 : UTILIS√âE
‚îú‚îÄ ...
‚îú‚îÄ Connexion 10 : UTILIS√âE
‚îî‚îÄ [AUCUNE DISPONIBLE]

Nouvelle requ√™te arrive ‚Üí Attend une connexion libre
‚è±Ô∏è 30 secondes passent ‚Üí Toujours rien
‚Üí PoolTimeout !
```

#### 3. Statement Timeout

**D√©finition** : Temps maximum d'**ex√©cution** d'une requ√™te SQL.

**Configuration** :

**PostgreSQL (postgresql.conf)** :
```conf
statement_timeout = 30000  # 30 secondes (en millisecondes)
```

**Ou par session** :
```sql
SET statement_timeout = 30000;  -- 30 secondes

-- Ou pour une base sp√©cifique
ALTER DATABASE mydb SET statement_timeout = 30000;
```

**Python (psycopg3)** :
```python
with pool.connection() as conn:
    conn.execute("SET statement_timeout = 30000")
    # Toutes les requ√™tes de cette connexion auront ce timeout
    conn.execute("SELECT * FROM big_table")
```

**Quand il se d√©clenche** :
- Requ√™te trop lente (full table scan)
- Jointures complexes sur grandes tables
- Deadlocks
- Requ√™tes mal optimis√©es

**Erreur typique** :
```sql
ERROR: canceling statement due to statement timeout
```

#### 4. Idle In Transaction Timeout

**D√©finition** : Temps maximum qu'une transaction peut rester **ouverte sans activit√©**.

**Configuration** :

**PostgreSQL (postgresql.conf)** :
```conf
idle_in_transaction_session_timeout = 300000  # 5 minutes
```

**Exemple de probl√®me** :
```python
# Code PROBL√âMATIQUE
conn = pool.connection()
conn.execute("BEGIN")
conn.execute("UPDATE users SET name = 'Alice' WHERE id = 1")

# Oubli de COMMIT ou ROLLBACK
# La transaction reste ouverte...
time.sleep(600)  # 10 minutes !

# ‚Üí idle_in_transaction_session_timeout se d√©clenche
# ‚Üí Transaction annul√©e automatiquement
```

**Pourquoi c'est important** :
- Emp√™che les transactions zombies
- Lib√®re les verrous (locks)
- √âvite le blocage d'autres transactions

#### 5. Lock Timeout

**D√©finition** : Temps maximum d'attente pour acqu√©rir un **verrou** (lock).

**Configuration** :
```sql
SET lock_timeout = 5000;  -- 5 secondes
```

**Exemple** :
```sql
-- Transaction 1
BEGIN;
UPDATE users SET name = 'Bob' WHERE id = 1;
-- Ne COMMIT pas ‚Üí Garde le verrou

-- Transaction 2 (connexion diff√©rente)
BEGIN;
SET lock_timeout = 5000;
UPDATE users SET name = 'Alice' WHERE id = 1;  -- Attend le verrou
-- Apr√®s 5 secondes ‚Üí lock_timeout !
ERROR: canceling statement due to lock timeout
```

### Configuration recommand√©e des timeouts

#### Configuration PostgreSQL globale

**postgresql.conf** :
```conf
# Connexion
tcp_keepalives_idle = 60              # Ping toutes les 60s
tcp_keepalives_interval = 10          # Retry toutes les 10s
tcp_keepalives_count = 6              # 6 retries avant abandon

# Requ√™tes
statement_timeout = 60000             # 60 secondes max par requ√™te
idle_in_transaction_session_timeout = 300000  # 5 minutes

# Verrous
lock_timeout = 10000                  # 10 secondes
deadlock_timeout = 1000               # 1 seconde
```

#### Configuration par application

**API REST (temps de r√©ponse rapide attendu)** :
```python
pool = ConnectionPool(
    conninfo="postgresql://...",
    timeout=5,           # 5s pour obtenir connexion
    max_size=20
)

# Dans chaque connexion
with pool.connection() as conn:
    conn.execute("SET statement_timeout = 10000")  # 10s max par requ√™te
    conn.execute("SET lock_timeout = 2000")        # 2s max pour lock
```

**Application batch (requ√™tes longues autoris√©es)** :
```python
pool = ConnectionPool(
    conninfo="postgresql://...",
    timeout=30,          # 30s pour obtenir connexion
    max_size=5
)

with pool.connection() as conn:
    conn.execute("SET statement_timeout = 600000")  # 10 min max
    conn.execute("SET lock_timeout = 30000")        # 30s max pour lock
```

### Gestion des timeouts dans le code

#### Pattern 1 : Retry avec backoff

**Python - Retry simple** :
```python
import time
from psycopg_pool import PoolTimeout

def execute_with_retry(func, max_retries=3):
    """R√©essaie en cas de timeout"""
    for attempt in range(max_retries):
        try:
            return func()
        except PoolTimeout:
            if attempt < max_retries - 1:
                wait_time = 2 ** attempt  # Backoff exponentiel: 1s, 2s, 4s
                print(f"Timeout, retry in {wait_time}s...")
                time.sleep(wait_time)
            else:
                raise  # Dernier essai rat√©, propagation de l'erreur

# Utilisation
def get_user():
    with pool.connection() as conn:
        with conn.cursor() as cursor:
            cursor.execute("SELECT * FROM users WHERE id = 1")
            return cursor.fetchone()

user = execute_with_retry(get_user)
```

**Node.js - Retry avec biblioth√®que** :
```javascript
const retry = require('async-retry');

async function getUserWithRetry(userId) {
    return await retry(
        async (bail) => {
            try {
                const result = await pool.query(
                    'SELECT * FROM users WHERE id = $1',
                    [userId]
                );
                return result.rows[0];
            } catch (error) {
                if (error.message.includes('timeout')) {
                    throw error;  // Retry
                } else {
                    bail(error);  // Erreur non-recoverable, arr√™t
                }
            }
        },
        {
            retries: 3,
            factor: 2,      // Backoff exponentiel
            minTimeout: 1000
        }
    );
}
```

#### Pattern 2 : Circuit Breaker

**Principe** : Arr√™ter d'essayer si trop d'√©checs cons√©cutifs.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ √âtats du Circuit Breaker                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                 ‚îÇ
‚îÇ  [CLOSED] ‚îÄ‚îÄ(5 √©checs)‚îÄ‚îÄ‚ñ∫ [OPEN]                ‚îÇ
‚îÇ     ‚Üë                         ‚îÇ                 ‚îÇ
‚îÇ     ‚îÇ                         ‚îÇ (1 minute)      ‚îÇ
‚îÇ     ‚îÇ                         ‚ñº                 ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ(succ√®s)‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ [HALF-OPEN]              ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  CLOSED    : Trafic normal                      ‚îÇ
‚îÇ  OPEN      : Rejette imm√©diatement              ‚îÇ
‚îÇ  HALF-OPEN : Teste avec 1 requ√™te               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Python - Impl√©mentation simple** :
```python
import time
from enum import Enum

class CircuitState(Enum):
    CLOSED = "closed"
    OPEN = "open"
    HALF_OPEN = "half_open"

class CircuitBreaker:
    def __init__(self, failure_threshold=5, timeout=60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failures = 0
        self.last_failure_time = None
        self.state = CircuitState.CLOSED

    def call(self, func):
        if self.state == CircuitState.OPEN:
            # V√©rifier si timeout expir√©
            if time.time() - self.last_failure_time >= self.timeout:
                self.state = CircuitState.HALF_OPEN
            else:
                raise Exception("Circuit breaker is OPEN")

        try:
            result = func()
            # Succ√®s
            self.failures = 0
            self.state = CircuitState.CLOSED
            return result
        except Exception as e:
            # √âchec
            self.failures += 1
            self.last_failure_time = time.time()

            if self.failures >= self.failure_threshold:
                self.state = CircuitState.OPEN

            raise e

# Utilisation
breaker = CircuitBreaker(failure_threshold=5, timeout=60)

def query_database():
    with pool.connection() as conn:
        # Requ√™te...
        pass

try:
    result = breaker.call(query_database)
except Exception as e:
    print(f"Circuit breaker prevented call or call failed: {e}")
```

#### Pattern 3 : Timeout granulaire

**Node.js - Timeout sur une requ√™te sp√©cifique** :
```javascript
async function queryWithTimeout(query, params, timeoutMs = 5000) {
    return Promise.race([
        pool.query(query, params),
        new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Query timeout')), timeoutMs)
        )
    ]);
}

// Utilisation
try {
    const result = await queryWithTimeout(
        'SELECT * FROM large_table',
        [],
        10000  // 10 secondes max
    );
} catch (error) {
    if (error.message === 'Query timeout') {
        console.error('Requ√™te trop lente !');
    }
}
```

---

## Diagnostic et troubleshooting

### D√©tecter un connection leak en production

#### Checklist de diagnostic

**1. V√©rifier l'utilisation du pool** :
```python
# Python
stats = pool.get_stats()
print(f"Disponibles: {stats['pool_available']}")
print(f"Utilis√©es: {stats['pool_size'] - stats['pool_available']}")
```

**2. V√©rifier les connexions PostgreSQL** :
```sql
-- Connexions par √©tat
SELECT state, count(*)
FROM pg_stat_activity
WHERE datname = current_database()
GROUP BY state;

-- R√©sultat suspect :
--  state  | count
-- --------+-------
--  idle   | 87     ‚Üê BEAUCOUP trop !
--  active | 3
```

**3. V√©rifier les connexions anciennes** :
```sql
-- Connexions ouvertes depuis longtemps
SELECT
    pid,
    usename,
    application_name,
    state,
    now() - backend_start as duration
FROM pg_stat_activity
WHERE state = 'idle'
  AND now() - backend_start > interval '10 minutes'
ORDER BY duration DESC;
```

**4. Logs applicatifs** :
```bash
# Chercher les timeouts
grep -i "timeout" /var/log/myapp/app.log

# Chercher les erreurs de pool
grep -i "pool" /var/log/myapp/app.log
```

### Solutions d'urgence en production

#### Solution 1 : Red√©marrage applicatif

**Le plus rapide (mais temporaire)** :
```bash
# Red√©marrer l'application
systemctl restart myapp

# Ou en Kubernetes
kubectl rollout restart deployment/myapp
```

**Effet** : Nettoie les connexions leaked, mais le probl√®me reviendra.

#### Solution 2 : Tuer les connexions idle

**C√¥t√© PostgreSQL** :
```sql
-- Tuer toutes les connexions idle depuis plus de 1 heure
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE datname = current_database()
  AND state = 'idle'
  AND now() - state_change > interval '1 hour';
```

**‚ö†Ô∏è Attention** : Ceci peut casser des applications qui attendent ces connexions.

#### Solution 3 : Augmenter temporairement le pool

**PgBouncer** :
```sql
-- Se connecter √† la console admin
psql -h localhost -p 6432 -U admin pgbouncer

-- Augmenter temporairement le pool
SET default_pool_size = 50;  -- Au lieu de 20

-- Recharger
RELOAD;
```

**Application** :
```python
# Modifier temporairement et red√©ployer
pool = ConnectionPool(
    conninfo="...",
    max_size=40  # Au lieu de 20
)
```

### Outils de debugging

#### 1. py-spy (Python)

```bash
# Installer
pip install py-spy

# Profiler l'application en cours
sudo py-spy top --pid 12345

# Voir o√π le code est bloqu√©
sudo py-spy dump --pid 12345
```

#### 2. Node.js - clinic.js

```bash
# Installer
npm install -g clinic

# Profiler
clinic doctor -- node app.js

# Analyser
clinic doctor --analyze
```

#### 3. Java - JConsole / VisualVM

```bash
# Lancer JConsole
jconsole

# Se connecter au processus Java
# Aller dans MBeans ‚Üí HikariPool
# Voir : ActiveConnections, IdleConnections, ThreadsAwaitingConnection
```

#### 4. Logs structur√©s

**Python - Loguru** :
```python
from loguru import logger

# Configuration
logger.add(
    "app.log",
    format="{time} {level} {message}",
    rotation="100 MB"
)

# Utilisation
def get_user(user_id):
    logger.info(f"Acquiring connection for user {user_id}")

    with pool.connection() as conn:
        logger.info(f"Connection acquired")
        # Requ√™te...
        logger.info(f"Connection released")
```

Analyser ensuite :
```bash
# V√©rifier que chaque "acquired" a un "released"
grep "Acquiring connection" app.log | wc -l
grep "Connection released" app.log | wc -l

# Si diff√©rence ‚Üí Leak !
```

---

## Bonnes pratiques - Checklist compl√®te

### ‚úÖ Pr√©vention des connection leaks

```
‚òê Toujours utiliser les gestionnaires de contexte
   Python: with statement
   Java: try-with-resources
   .NET: using statement
   Go: defer
   Node.js: try/finally

‚òê Pr√©f√©rer les m√©thodes de haut niveau
   pool.query() au lieu de connect() + release()

‚òê Impl√©menter le Repository Pattern
   Centraliser l'acc√®s aux donn√©es

‚òê Utiliser un ORM si appropri√©
   SQLAlchemy, Sequelize, Hibernate, Entity Framework

‚òê Ajouter des tests automatis√©s
   V√©rifier qu'il n'y a pas de leak apr√®s chaque test
```

### ‚úÖ Configuration des timeouts

```
‚òê Connection timeout : 5-10 secondes
   √âchec rapide si serveur injoignable

‚òê Pool timeout : 10-30 secondes
   Assez long pour pics de charge

‚òê Statement timeout : 30-60 secondes (API)
   Emp√™che les requ√™tes infinies

‚òê Statement timeout : 5-10 minutes (batch)
   Pour traitement de masse

‚òê idle_in_transaction_timeout : 5 minutes
   Nettoie les transactions zombies

‚òê lock_timeout : 5-10 secondes
   √âvite les blocages prolong√©s
```

### ‚úÖ Monitoring

```
‚òê Surveiller l'utilisation du pool
   Alerte si > 80%

‚òê Tracer les connexions PostgreSQL
   Idle, active, idle in transaction

‚òê Logger les timeouts applicatifs
   Identifier les patterns

‚òê Dashboard temps r√©el
   Grafana + Prometheus

‚òê Alerting proactif
   Avant saturation compl√®te
```

### ‚úÖ Testing

```
‚òê Tests de charge
   Simuler charge r√©aliste

‚òê Tests de saturation
   Que se passe-t-il si pool vide ?

‚òê Tests de leak
   V√©rifier lib√©ration apr√®s tests

‚òê Tests de timeout
   Comportement en cas de lenteur

‚òê Tests de r√©silience
   Circuit breaker, retry, fallback
```

---

## Sc√©narios r√©els et solutions

### Sc√©nario 1 : API qui se "g√®le" apr√®s quelques heures

**Sympt√¥mes** :
- Application d√©marre bien
- Apr√®s 2-3 heures : timeouts, erreurs 500
- Red√©marrage ‚Üí √ßa repart pendant 2-3 heures

**Diagnostic** :
```sql
-- Beaucoup de connexions idle
SELECT count(*) FROM pg_stat_activity WHERE state = 'idle';
-- R√©sultat : 95 (sur pool_size=20 ‚Üí Multiplication anormale !)
```

**Cause** : Connection leak dans le code

**Solution** :
```python
# AVANT (incorrect)
def process_data():
    conn = pool.connection()
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM data")
    return cursor.fetchall()
    # Oubli de fermeture !

# APR√àS (correct)
def process_data():
    with pool.connection() as conn:
        with conn.cursor() as cursor:
            cursor.execute("SELECT * FROM data")
            return cursor.fetchall()
```

### Sc√©nario 2 : Timeouts al√©atoires sous charge

**Sympt√¥mes** :
- Application normale en charge faible
- Sous charge : timeouts sporadiques
- pool_size = 10, max_connections = 100

**Diagnostic** :
```javascript
// Node.js monitoring
console.log(pool.waitingCount);  // 45 requ√™tes en attente !
```

**Cause** : Pool trop petit

**Solution** :
```javascript
// Augmenter le pool
const pool = new Pool({
    max: 20,  // Au lieu de 10
    min: 5
});

// Ou introduire PgBouncer
```

### Sc√©nario 3 : Deadlocks fr√©quents

**Sympt√¥mes** :
```
ERROR: deadlock detected
DETAIL: Process 1234 waits for ShareLock on transaction 5678;
        blocked by process 5678.
```

**Diagnostic** :
```sql
-- Voir les verrous
SELECT * FROM pg_locks WHERE NOT granted;
```

**Solution** :
```sql
-- Configurer lock_timeout
SET lock_timeout = 5000;  -- 5 secondes

-- Dans l'application, ordonner les acc√®s
-- TOUJOURS dans le m√™me ordre : users puis orders
-- Jamais : orders puis users dans une transaction
--          et users puis orders dans une autre
```

### Sc√©nario 4 : Transactions zombies

**Sympt√¥mes** :
```sql
SELECT count(*) FROM pg_stat_activity
WHERE state = 'idle in transaction';
-- R√©sultat : 23 !
```

**Cause** : Transactions ouvertes jamais commit√©es

**Solution** :
```sql
-- Configuration PostgreSQL
idle_in_transaction_session_timeout = 300000  -- 5 minutes

-- Dans le code : Toujours commit/rollback
with pool.connection() as conn:
    try:
        conn.execute("BEGIN")
        # Op√©rations...
        conn.execute("COMMIT")
    except:
        conn.execute("ROLLBACK")
        raise
```

---

## R√©sum√© : Points cl√©s √† retenir

### üîë Connection Leaks

**Causes principales** :
1. Oubli de fermeture (conn.close())
2. Exception non g√©r√©e
3. Return pr√©matur√©

**Solutions** :
1. ‚úÖ Toujours utiliser with/try-with-resources/using/defer
2. ‚úÖ Pr√©f√©rer les m√©thodes de haut niveau (pool.query())
3. ‚úÖ Impl√©menter Repository Pattern
4. ‚úÖ Monitorer continuellement le pool

### ‚è±Ô∏è Timeouts

**Types principaux** :
1. **Connection timeout** : √âtablir connexion (5-10s)
2. **Pool timeout** : Obtenir connexion du pool (10-30s)
3. **Statement timeout** : Ex√©cuter requ√™te (30s-10min)
4. **Idle in transaction** : Transaction inactive (5min)
5. **Lock timeout** : Acqu√©rir verrou (5-10s)

**Configuration recommand√©e** :
```sql
-- PostgreSQL
statement_timeout = 60000  -- 1 minute
idle_in_transaction_session_timeout = 300000  -- 5 minutes
lock_timeout = 10000  -- 10 secondes
```

### üéØ Patterns essentiels

1. **Always Close** : Toujours fermer les connexions
2. **Retry with Backoff** : R√©essayer intelligemment
3. **Circuit Breaker** : Arr√™ter si trop d'√©checs
4. **Monitoring** : Surveiller en continu
5. **Graceful Degradation** : D√©grader plut√¥t que crasher

---

## Pour aller plus loin

### Documentation

- [PostgreSQL Timeouts](https://www.postgresql.org/docs/current/runtime-config-client.html)
- [HikariCP Connection Leak Detection](https://github.com/brettwooldridge/HikariCP/wiki/Leak-Detection)
- [psycopg3 Connection Pool](https://www.psycopg.org/psycopg3/docs/advanced/pool.html)

### Outils recommand√©s

- **Sentry** : Tracking d'erreurs et timeouts
- **DataDog / New Relic** : APM et monitoring
- **Grafana** : Dashboards de monitoring
- **PgHero** : Health dashboard PostgreSQL

---


‚è≠Ô∏è [Patterns anti-corruption](/20-drivers-connexion-applicative/03-patterns-anti-corruption.md)
