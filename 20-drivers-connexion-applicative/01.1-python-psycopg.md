üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.1.1. Python : psycopg3 (psycopg2 legacy)

## Introduction

Python est l'un des langages les plus populaires pour interagir avec PostgreSQL, notamment gr√¢ce √† la biblioth√®que **psycopg**, qui est le driver PostgreSQL le plus utilis√© dans l'√©cosyst√®me Python. Cette section vous guide √† travers l'utilisation de **psycopg3**, la version moderne et recommand√©e, tout en mentionnant **psycopg2** pour contexte historique.

---

## Qu'est-ce que psycopg ?

**psycopg** est un adaptateur PostgreSQL pour Python qui permet √† vos applications Python de communiquer avec une base de donn√©es PostgreSQL. Il impl√©mente la sp√©cification **DB-API 2.0** (PEP 249), qui est le standard Python pour les interfaces de bases de donn√©es.

### Historique : psycopg2 vs psycopg3

| Caract√©ristique | psycopg2 (Legacy) | psycopg3 (Moderne) |
|----------------|-------------------|-------------------|
| **Premi√®re version** | 2006 | 2021 |
| **Support Python** | Python 2.7 - 3.11+ | Python 3.7+ uniquement |
| **Architecture** | Synchrone uniquement | Synchrone **et** asynchrone |
| **Performance** | Bonne | Excellente (optimisations modernes) |
| **Syntaxe** | Ancienne API | API modernis√©e et plus pythonique |
| **Support PostgreSQL** | Jusqu'√† PostgreSQL 15 | Support complet PostgreSQL 18 |
| **Maintenance** | Maintenance limit√©e | D√©veloppement actif |
| **Recommandation** | Migration conseill√©e | **Choix par d√©faut** pour nouveaux projets |

> **üí° Important pour d√©butants :** Si vous d√©marrez un nouveau projet aujourd'hui, utilisez **psycopg3**. Psycopg2 n'est plus recommand√© sauf pour maintenir des projets existants.

---

## Installation de psycopg3

### Installation standard (synchrone)

Pour installer psycopg3 avec pip :

```bash
pip install psycopg
```

Cette commande installe la version pure Python de psycopg3, qui fonctionne imm√©diatement sans d√©pendances syst√®me suppl√©mentaires.

### Installation avec binaires C (performance optimale)

Pour de meilleures performances en production, installez la version avec les extensions C compil√©es :

```bash
pip install "psycopg[binary]"
```

**Diff√©rence :** La version binaire utilise du code C optimis√© pour les op√©rations critiques, offrant jusqu'√† 20-30% de performance suppl√©mentaire.

### Installation pour le support asynchrone

Si vous d√©veloppez des applications asynchrones (avec `asyncio`) :

```bash
pip install "psycopg[binary,pool]"
```

L'option `pool` ajoute le support du connection pooling, essentiel pour les applications performantes.

### V√©rification de l'installation

```python
import psycopg

print(f"Version de psycopg : {psycopg.__version__}")
```

---

## Concepts Fondamentaux

### 1. Le mod√®le de connexion

Avant d'ex√©cuter des requ√™tes SQL, vous devez √©tablir une **connexion** avec PostgreSQL. Cette connexion repr√©sente une session entre votre application Python et le serveur de base de donn√©es.

**Sch√©ma conceptuel :**
```
Application Python
      ‚Üì
[psycopg3 Driver]
      ‚Üì
[Connexion r√©seau]
      ‚Üì
Serveur PostgreSQL
```

### 2. Les curseurs (Cursors)

Un **curseur** est un objet qui permet d'ex√©cuter des requ√™tes SQL et de r√©cup√©rer les r√©sultats. Pensez au curseur comme un "pointeur" qui parcourt les r√©sultats d'une requ√™te.

**Analogie :** Si la connexion est comme une "ligne t√©l√©phonique" avec la base de donn√©es, le curseur est comme le "microphone" que vous utilisez pour parler et √©couter.

### 3. Les transactions

Par d√©faut, PostgreSQL fonctionne en mode transactionnel. Chaque op√©ration (INSERT, UPDATE, DELETE) fait partie d'une transaction qui doit √™tre **valid√©e** (COMMIT) ou **annul√©e** (ROLLBACK).

---

## Connexion √† PostgreSQL

### Syntaxe de base

```python
import psycopg

# Cha√Æne de connexion (Connection String)
conn = psycopg.connect(
    host="localhost",        # Adresse du serveur PostgreSQL
    port=5432,              # Port (5432 par d√©faut)
    dbname="ma_database",   # Nom de la base de donn√©es
    user="mon_utilisateur", # Nom d'utilisateur
    password="mon_password" # Mot de passe
)

print("Connexion √©tablie avec succ√®s !")

# Important : toujours fermer la connexion
conn.close()
```

### Utilisation du context manager (recommand√©)

Le **context manager** (mot-cl√© `with`) garantit que la connexion sera automatiquement ferm√©e, m√™me en cas d'erreur :

```python
import psycopg

with psycopg.connect(
    host="localhost",
    dbname="ma_database",
    user="mon_utilisateur",
    password="mon_password"
) as conn:
    print("Connexion active")
    # Votre code ici
# La connexion est automatiquement ferm√©e ici
```

**Avantage :** Vous n'avez plus besoin d'appeler `conn.close()` manuellement.

### Cha√Æne de connexion (Connection String)

Vous pouvez √©galement utiliser une **cha√Æne de connexion** unique, appel√©e DSN (Data Source Name) ou connstring :

```python
import psycopg

# Format libpq (PostgreSQL standard)
connstring = "postgresql://mon_utilisateur:mon_password@localhost:5432/ma_database"

with psycopg.connect(connstring) as conn:
    print("Connect√© via connstring")
```

**Format de la connstring :**
```
postgresql://[user]:[password]@[host]:[port]/[database]?[options]
```

**Exemple avec SSL :**
```python
connstring = "postgresql://user:pass@localhost/db?sslmode=require"
```

---

## Ex√©cution de Requ√™tes SQL

### 1. Requ√™tes simples (SELECT)

```python
import psycopg

with psycopg.connect("postgresql://user:pass@localhost/db") as conn:
    with conn.cursor() as cur:
        # Ex√©cuter une requ√™te SELECT
        cur.execute("SELECT version()")

        # R√©cup√©rer le r√©sultat (une seule ligne)
        result = cur.fetchone()
        print(f"Version PostgreSQL : {result[0]}")
```

**Explication :**
- `conn.cursor()` : Cr√©e un curseur pour ex√©cuter des requ√™tes
- `cur.execute()` : Ex√©cute la requ√™te SQL
- `cur.fetchone()` : R√©cup√®re une seule ligne de r√©sultat (renvoie un tuple)

### 2. R√©cup√©ration de plusieurs lignes

```python
with psycopg.connect(connstring) as conn:
    with conn.cursor() as cur:
        cur.execute("SELECT id, nom, email FROM utilisateurs")

        # R√©cup√©rer toutes les lignes
        rows = cur.fetchall()

        for row in rows:
            print(f"ID: {row[0]}, Nom: {row[1]}, Email: {row[2]}")
```

**M√©thodes de r√©cup√©ration :**
- `fetchone()` : R√©cup√®re une seule ligne (ou `None` si plus de r√©sultats)
- `fetchall()` : R√©cup√®re toutes les lignes restantes (retourne une liste)
- `fetchmany(size)` : R√©cup√®re `size` lignes (utile pour traiter par batch)

### 3. It√©ration sur les r√©sultats

Pour √©conomiser la m√©moire avec de grandes tables, vous pouvez it√©rer directement sur le curseur :

```python
with psycopg.connect(connstring) as conn:
    with conn.cursor() as cur:
        cur.execute("SELECT * FROM grande_table")

        # It√©ration ligne par ligne (√©conome en m√©moire)
        for row in cur:
            print(row)
```

**Avantage :** Les lignes sont charg√©es progressivement, √©vitant de saturer la m√©moire.

### 4. Utilisation de dictionnaires (Row Factories)

Par d√©faut, les r√©sultats sont des tuples. Pour avoir des dictionnaires (plus lisibles), utilisez un **row factory** :

```python
from psycopg.rows import dict_row

with psycopg.connect(connstring) as conn:
    with conn.cursor(row_factory=dict_row) as cur:
        cur.execute("SELECT id, nom, email FROM utilisateurs")

        for row in cur:
            print(f"ID: {row['id']}, Nom: {row['nom']}, Email: {row['email']}")
```

**Autres row factories disponibles :**
- `tuple_row` : Comportement par d√©faut (tuple)
- `dict_row` : Dictionnaire (cl√© = nom de colonne)
- `namedtuple_row` : Named tuple (acc√®s par attribut : `row.nom`)
- `class_row(MyClass)` : Mapper vers une classe personnalis√©e

---

## Param√©trage des Requ√™tes (S√©curit√© Critique)

### ‚ö†Ô∏è Le danger de l'injection SQL

**JAMAIS comme ceci (DANGEREUX) :**
```python
# ‚ùå CODE VULN√âRABLE - NE JAMAIS FAIRE √áA !
nom_utilisateur = "Alice' OR '1'='1"  # Injection SQL malveillante
cur.execute(f"SELECT * FROM users WHERE nom = '{nom_utilisateur}'")
```

Cette approche permet des **injections SQL**, l'une des vuln√©rabilit√©s les plus graves en s√©curit√© informatique.

### ‚úÖ La bonne m√©thode : Requ√™tes param√©tr√©es

psycopg3 utilise le symbole `%s` comme **placeholder** pour les param√®tres :

```python
with psycopg.connect(connstring) as conn:
    with conn.cursor() as cur:
        # ‚úÖ M√©thode s√©curis√©e
        nom = "Alice"
        cur.execute(
            "SELECT * FROM utilisateurs WHERE nom = %s",
            (nom,)  # Tuple de param√®tres
        )
        result = cur.fetchone()
```

**Important :**
- Utilisez toujours `%s` (m√™me pour les nombres)
- Les param√®tres sont pass√©s dans un **tuple** ou une **liste**
- psycopg3 √©chappe automatiquement les valeurs dangereuses

### Param√®tres multiples

```python
with conn.cursor() as cur:
    cur.execute(
        "SELECT * FROM produits WHERE categorie = %s AND prix > %s",
        ("√âlectronique", 100.0)
    )
```

### Param√®tres nomm√©s (recommand√© pour la lisibilit√©)

```python
with conn.cursor() as cur:
    cur.execute(
        "SELECT * FROM produits WHERE categorie = %(cat)s AND prix > %(prix)s",
        {"cat": "√âlectronique", "prix": 100.0}
    )
```

**Avantage :** Le code est plus lisible et maintenable.

---

## Op√©rations d'√âcriture (INSERT, UPDATE, DELETE)

### 1. INSERT : Ins√©rer des donn√©es

```python
with psycopg.connect(connstring) as conn:
    with conn.cursor() as cur:
        cur.execute(
            "INSERT INTO utilisateurs (nom, email, age) VALUES (%s, %s, %s)",
            ("Bob", "bob@example.com", 30)
        )
        # Commit automatique gr√¢ce au context manager
```

### 2. INSERT avec RETURNING (sp√©cificit√© PostgreSQL)

PostgreSQL permet de r√©cup√©rer des valeurs apr√®s insertion (par exemple, l'ID auto-g√©n√©r√©) :

```python
with psycopg.connect(connstring) as conn:
    with conn.cursor() as cur:
        cur.execute(
            "INSERT INTO utilisateurs (nom, email) VALUES (%s, %s) RETURNING id",
            ("Charlie", "charlie@example.com")
        )
        nouveau_id = cur.fetchone()[0]
        print(f"Nouvel utilisateur cr√©√© avec ID : {nouveau_id}")
```

### 3. Insertions multiples (bulk insert)

Pour ins√©rer plusieurs lignes efficacement, utilisez `executemany()` :

```python
data = [
    ("Alice", "alice@example.com", 25),
    ("Bob", "bob@example.com", 30),
    ("Charlie", "charlie@example.com", 35)
]

with psycopg.connect(connstring) as conn:
    with conn.cursor() as cur:
        cur.executemany(
            "INSERT INTO utilisateurs (nom, email, age) VALUES (%s, %s, %s)",
            data
        )
        print(f"{cur.rowcount} lignes ins√©r√©es")
```

**Performance :** `executemany()` est beaucoup plus rapide que des `execute()` multiples.

### 4. UPDATE : Modifier des donn√©es

```python
with psycopg.connect(connstring) as conn:
    with conn.cursor() as cur:
        cur.execute(
            "UPDATE utilisateurs SET email = %s WHERE nom = %s",
            ("nouvel_email@example.com", "Alice")
        )
        print(f"{cur.rowcount} ligne(s) modifi√©e(s)")
```

### 5. DELETE : Supprimer des donn√©es

```python
with psycopg.connect(connstring) as conn:
    with conn.cursor() as cur:
        cur.execute(
            "DELETE FROM utilisateurs WHERE age < %s",
            (18,)
        )
        print(f"{cur.rowcount} ligne(s) supprim√©e(s)")
```

---

## Gestion des Transactions

### Comportement par d√©faut

Par d√©faut, psycopg3 d√©marre une transaction automatiquement. Quand vous utilisez le context manager `with conn`, la transaction est :
- **Valid√©e (COMMIT)** si tout se passe bien
- **Annul√©e (ROLLBACK)** en cas d'erreur

### Gestion manuelle des transactions

```python
import psycopg

conn = psycopg.connect(connstring)

try:
    with conn.cursor() as cur:
        # Op√©ration 1
        cur.execute("INSERT INTO comptes (nom, solde) VALUES (%s, %s)", ("Alice", 1000))

        # Op√©ration 2
        cur.execute("INSERT INTO comptes (nom, solde) VALUES (%s, %s)", ("Bob", 500))

    # Validation explicite
    conn.commit()
    print("Transaction valid√©e")

except Exception as e:
    # Annulation en cas d'erreur
    conn.rollback()
    print(f"Transaction annul√©e : {e}")

finally:
    conn.close()
```

### Transactions avec SAVEPOINT

Les **savepoints** permettent d'annuler partiellement une transaction :

```python
with psycopg.connect(connstring) as conn:
    with conn.cursor() as cur:
        cur.execute("INSERT INTO logs (message) VALUES (%s)", ("Op√©ration 1",))

        # Cr√©er un point de sauvegarde
        conn.execute("SAVEPOINT mon_savepoint")

        try:
            cur.execute("INSERT INTO logs (message) VALUES (%s)", ("Op√©ration 2",))
            # Op√©ration risqu√©e qui peut √©chouer
            cur.execute("INSERT INTO logs (bad_column) VALUES (%s)", ("Erreur",))
        except Exception:
            # Revenir au savepoint (annule seulement apr√®s le savepoint)
            conn.execute("ROLLBACK TO SAVEPOINT mon_savepoint")
            print("Savepoint restaur√©")

        # Op√©ration 1 est toujours valide
```

### Autocommit (mode non-transactionnel)

Pour d√©sactiver les transactions automatiques :

```python
conn = psycopg.connect(connstring, autocommit=True)

with conn.cursor() as cur:
    cur.execute("INSERT INTO logs (message) VALUES (%s)", ("Log direct",))
    # Pas besoin de commit, chaque requ√™te est imm√©diatement valid√©e
```

**Usage :** Rare, utilis√© pour des op√©rations comme `VACUUM` ou `CREATE DATABASE` qui ne peuvent pas √™tre dans une transaction.

---

## Gestion des Types de Donn√©es PostgreSQL

### Types num√©riques

```python
with conn.cursor() as cur:
    # INTEGER
    cur.execute("INSERT INTO produits (id, prix) VALUES (%s, %s)", (1, 99))

    # NUMERIC/DECIMAL (utilise Python Decimal pour la pr√©cision)
    from decimal import Decimal
    cur.execute("INSERT INTO prix (montant) VALUES (%s)", (Decimal("19.99"),))
```

### Types texte

```python
with conn.cursor() as cur:
    # VARCHAR, TEXT
    cur.execute("INSERT INTO articles (titre, contenu) VALUES (%s, %s)",
                ("Mon titre", "Contenu long..."))
```

### Types temporels

```python
from datetime import date, datetime, timedelta

with conn.cursor() as cur:
    # DATE
    cur.execute("INSERT INTO evenements (date) VALUES (%s)", (date(2025, 11, 23),))

    # TIMESTAMP
    cur.execute("INSERT INTO logs (timestamp) VALUES (%s)", (datetime.now(),))

    # INTERVAL
    cur.execute("SELECT NOW() + %s", (timedelta(days=7),))
```

### JSON et JSONB

```python
import json

data = {"nom": "Alice", "age": 30, "tags": ["Python", "PostgreSQL"]}

with conn.cursor() as cur:
    # JSONB (format binaire, recommand√©)
    cur.execute("INSERT INTO users (profile) VALUES (%s)", (json.dumps(data),))

    # Lecture
    cur.execute("SELECT profile FROM users WHERE id = %s", (1,))
    profile_json = cur.fetchone()[0]
    profile = json.loads(profile_json)
```

**Note :** psycopg3 s√©rialise automatiquement les dictionnaires Python en JSON si la colonne est de type JSON/JSONB.

### Arrays (Tableaux PostgreSQL)

```python
with conn.cursor() as cur:
    # Insertion d'un tableau
    tags = ["python", "postgresql", "sql"]
    cur.execute("INSERT INTO articles (tags) VALUES (%s)", (tags,))

    # Lecture d'un tableau
    cur.execute("SELECT tags FROM articles WHERE id = %s", (1,))
    tags_result = cur.fetchone()[0]  # Liste Python
    print(tags_result)  # ['python', 'postgresql', 'sql']
```

### UUID

```python
import uuid

with conn.cursor() as cur:
    # UUID v4 (al√©atoire)
    new_uuid = uuid.uuid4()
    cur.execute("INSERT INTO sessions (id, token) VALUES (%s, %s)",
                (new_uuid, "token123"))

    # UUID v7 (nouveau dans PostgreSQL 18, bas√© sur le temps)
    cur.execute("INSERT INTO events (id) VALUES (gen_uuid_v7())")
```

---

## Connection Pooling (Gestion des Connexions)

### Pourquoi le pooling est important

Cr√©er une nouvelle connexion √† PostgreSQL est **co√ªteux** :
- √âtablissement de la connexion TCP
- Authentification
- Allocation de ressources c√¥t√© serveur

Un **pool de connexions** r√©utilise des connexions existantes au lieu d'en cr√©er de nouvelles √† chaque requ√™te.

### Utilisation de ConnectionPool

```python
from psycopg_pool import ConnectionPool

# Cr√©er un pool de connexions
pool = ConnectionPool(
    conninfo="postgresql://user:pass@localhost/db",
    min_size=2,      # Minimum 2 connexions actives
    max_size=10,     # Maximum 10 connexions
    timeout=5.0      # Timeout en secondes
)

# Utiliser une connexion du pool
with pool.connection() as conn:
    with conn.cursor() as cur:
        cur.execute("SELECT * FROM utilisateurs")
        results = cur.fetchall()

# La connexion retourne automatiquement dans le pool

# Fermer le pool √† la fin de l'application
pool.close()
```

### Param√®tres de configuration du pool

| Param√®tre | Description | Valeur recommand√©e |
|-----------|-------------|-------------------|
| `min_size` | Connexions toujours actives | 2-5 |
| `max_size` | Connexions maximum autoris√©es | 10-20 (OLTP), 5-10 (OLAP) |
| `timeout` | Temps d'attente pour obtenir une connexion | 5-30 secondes |
| `max_idle` | Dur√©e de vie d'une connexion inactive | 300-600 secondes |
| `max_lifetime` | Dur√©e de vie totale d'une connexion | 3600 secondes |

### Pool asynchrone (pour asyncio)

```python
from psycopg_pool import AsyncConnectionPool

# Pool pour applications asynchrones
pool = AsyncConnectionPool(
    conninfo="postgresql://user:pass@localhost/db",
    min_size=2,
    max_size=10
)

# Utilisation avec async/await
async def query_data():
    async with pool.connection() as conn:
        async with conn.cursor() as cur:
            await cur.execute("SELECT * FROM utilisateurs")
            results = await cur.fetchall()
            return results
```

---

## Gestion des Erreurs

### Hi√©rarchie des exceptions psycopg3

```
Exception (Python standard)
    ‚îî‚îÄ‚îÄ psycopg.Error
            ‚îú‚îÄ‚îÄ psycopg.DatabaseError
            ‚îÇ       ‚îú‚îÄ‚îÄ psycopg.IntegrityError (violation de contrainte)
            ‚îÇ       ‚îú‚îÄ‚îÄ psycopg.OperationalError (probl√®me de connexion)
            ‚îÇ       ‚îú‚îÄ‚îÄ psycopg.ProgrammingError (erreur SQL)
            ‚îÇ       ‚îî‚îÄ‚îÄ psycopg.DataError (probl√®me de type de donn√©es)
            ‚îî‚îÄ‚îÄ psycopg.InterfaceError (probl√®me avec psycopg lui-m√™me)
```

### Gestion basique des erreurs

```python
import psycopg

try:
    with psycopg.connect(connstring) as conn:
        with conn.cursor() as cur:
            cur.execute("INSERT INTO utilisateurs (email) VALUES (%s)",
                       ("duplicate@example.com",))

except psycopg.IntegrityError as e:
    print(f"Erreur d'int√©grit√© (contrainte viol√©e) : {e}")

except psycopg.OperationalError as e:
    print(f"Erreur de connexion : {e}")

except psycopg.Error as e:
    print(f"Erreur PostgreSQL g√©n√©rique : {e}")
```

### Acc√©der aux d√©tails de l'erreur

PostgreSQL fournit des informations d√©taill√©es sur les erreurs :

```python
try:
    with conn.cursor() as cur:
        cur.execute("INSERT INTO users (id, email) VALUES (%s, %s)", (1, "test@example.com"))

except psycopg.IntegrityError as e:
    print(f"Message : {e}")
    print(f"Code SQLSTATE : {e.sqlstate}")  # Ex: '23505' pour unique violation
    print(f"D√©tail : {e.diag.message_detail}")
    print(f"Table : {e.diag.table_name}")
    print(f"Colonne : {e.diag.column_name}")
```

**Codes SQLSTATE courants :**
- `23505` : Violation de contrainte UNIQUE
- `23503` : Violation de contrainte FOREIGN KEY
- `23502` : Violation de contrainte NOT NULL
- `42P01` : Table inexistante
- `42703` : Colonne inexistante

---

## Bonnes Pratiques

### 1. Toujours utiliser des context managers

‚úÖ **Bon :**
```python
with psycopg.connect(connstring) as conn:
    with conn.cursor() as cur:
        cur.execute("SELECT * FROM users")
```

‚ùå **√âviter :**
```python
conn = psycopg.connect(connstring)
cur = conn.cursor()
cur.execute("SELECT * FROM users")
cur.close()
conn.close()
```

### 2. Toujours utiliser des requ√™tes param√©tr√©es

‚úÖ **Bon :**
```python
cur.execute("SELECT * FROM users WHERE email = %s", (email,))
```

‚ùå **Dangereux :**
```python
cur.execute(f"SELECT * FROM users WHERE email = '{email}'")
```

### 3. Utiliser un pool de connexions en production

Pour une application web ou API :
```python
# Au d√©marrage de l'application
from psycopg_pool import ConnectionPool

app_pool = ConnectionPool(connstring, min_size=5, max_size=20)

# Dans vos handlers/routes
def get_user(user_id):
    with app_pool.connection() as conn:
        with conn.cursor(row_factory=dict_row) as cur:
            cur.execute("SELECT * FROM users WHERE id = %s", (user_id,))
            return cur.fetchone()
```

### 4. G√©rer les erreurs de mani√®re appropri√©e

```python
try:
    with conn.cursor() as cur:
        cur.execute("INSERT INTO logs (message) VALUES (%s)", (msg,))
except psycopg.OperationalError:
    # R√©essayer ou logger
    logger.error("Connexion perdue, tentative de reconnexion...")
except psycopg.IntegrityError:
    # Contrainte viol√©e, informer l'utilisateur
    return {"error": "Cette valeur existe d√©j√†"}
```

### 5. Utiliser des transactions explicites pour les op√©rations critiques

```python
with conn:  # Transaction automatique
    with conn.cursor() as cur:
        cur.execute("UPDATE comptes SET solde = solde - %s WHERE id = %s", (100, 1))
        cur.execute("UPDATE comptes SET solde = solde + %s WHERE id = %s", (100, 2))
    # Commit automatique si aucune exception
```

### 6. Fermer le pool √† la fin de l'application

```python
import atexit

pool = ConnectionPool(connstring)

# Enregistrer la fermeture automatique
atexit.register(pool.close)
```

### 7. Utiliser des row factories pour plus de lisibilit√©

```python
from psycopg.rows import dict_row, namedtuple_row

# Dictionnaire (acc√®s par cl√©)
with conn.cursor(row_factory=dict_row) as cur:
    cur.execute("SELECT id, nom FROM users")
    user = cur.fetchone()
    print(user['nom'])  # Plus lisible que user[1]

# Named tuple (acc√®s par attribut)
with conn.cursor(row_factory=namedtuple_row) as cur:
    cur.execute("SELECT id, nom FROM users")
    user = cur.fetchone()
    print(user.nom)  # Encore plus pythonique
```

---

## Comparaison avec psycopg2 (Migration)

Si vous avez du code existant en psycopg2, voici les principales diff√©rences :

### Import

```python
# psycopg2
import psycopg2

# psycopg3
import psycopg
```

### Context managers

```python
# psycopg2 : connexion ne supporte pas 'with' pour autocommit
conn = psycopg2.connect(...)
try:
    cur = conn.cursor()
    cur.execute("...")
    conn.commit()
finally:
    conn.close()

# psycopg3 : 'with' g√®re automatiquement commit/rollback
with psycopg.connect(...) as conn:
    with conn.cursor() as cur:
        cur.execute("...")
```

### Placeholders

```python
# psycopg2 : %s ou %(name)s
cur.execute("SELECT * FROM users WHERE id = %s", (1,))

# psycopg3 : identique, %s ou %(name)s
cur.execute("SELECT * FROM users WHERE id = %s", (1,))
```

**Bonne nouvelle :** La syntaxe des requ√™tes est identique ! La migration est donc assez simple.

### Row factories

```python
# psycopg2
import psycopg2.extras
cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)

# psycopg3
from psycopg.rows import dict_row
cur = conn.cursor(row_factory=dict_row)
```

---

## Exemple Complet : Application CRUD Simple

Voici un exemple complet d'application Python avec psycopg3 :

```python
import psycopg
from psycopg.rows import dict_row
from psycopg_pool import ConnectionPool

# Configuration
DATABASE_URL = "postgresql://user:password@localhost:5432/myapp"

# Pool de connexions global
pool = ConnectionPool(DATABASE_URL, min_size=2, max_size=10)

class UserRepository:
    """Gestion des utilisateurs dans la base de donn√©es"""

    def create_user(self, nom, email, age):
        """Cr√©er un nouvel utilisateur"""
        with pool.connection() as conn:
            with conn.cursor() as cur:
                try:
                    cur.execute(
                        "INSERT INTO utilisateurs (nom, email, age) VALUES (%s, %s, %s) RETURNING id",
                        (nom, email, age)
                    )
                    user_id = cur.fetchone()[0]
                    return {"success": True, "id": user_id}
                except psycopg.IntegrityError:
                    return {"success": False, "error": "Email d√©j√† utilis√©"}

    def get_user(self, user_id):
        """R√©cup√©rer un utilisateur par ID"""
        with pool.connection() as conn:
            with conn.cursor(row_factory=dict_row) as cur:
                cur.execute("SELECT * FROM utilisateurs WHERE id = %s", (user_id,))
                user = cur.fetchone()
                return user if user else None

    def get_all_users(self):
        """R√©cup√©rer tous les utilisateurs"""
        with pool.connection() as conn:
            with conn.cursor(row_factory=dict_row) as cur:
                cur.execute("SELECT * FROM utilisateurs ORDER BY nom")
                return cur.fetchall()

    def update_user(self, user_id, nom=None, email=None, age=None):
        """Mettre √† jour un utilisateur"""
        with pool.connection() as conn:
            with conn.cursor() as cur:
                updates = []
                params = []

                if nom:
                    updates.append("nom = %s")
                    params.append(nom)
                if email:
                    updates.append("email = %s")
                    params.append(email)
                if age:
                    updates.append("age = %s")
                    params.append(age)

                if not updates:
                    return False

                params.append(user_id)
                query = f"UPDATE utilisateurs SET {', '.join(updates)} WHERE id = %s"

                cur.execute(query, params)
                return cur.rowcount > 0

    def delete_user(self, user_id):
        """Supprimer un utilisateur"""
        with pool.connection() as conn:
            with conn.cursor() as cur:
                cur.execute("DELETE FROM utilisateurs WHERE id = %s", (user_id,))
                return cur.rowcount > 0

# Utilisation
if __name__ == "__main__":
    repo = UserRepository()

    # Cr√©er
    result = repo.create_user("Alice", "alice@example.com", 30)
    print(f"Utilisateur cr√©√© : {result}")

    # Lire
    user = repo.get_user(1)
    print(f"Utilisateur : {user}")

    # Lister
    tous = repo.get_all_users()
    print(f"Tous les utilisateurs : {tous}")

    # Modifier
    repo.update_user(1, age=31)

    # Supprimer
    repo.delete_user(1)

    # Fermer le pool √† la fin
    pool.close()
```

---

## Support Asynchrone (asyncio)

psycopg3 offre un support natif pour la programmation asynchrone avec `asyncio` :

```python
import asyncio
import psycopg

async def fetch_users():
    """Exemple de requ√™te asynchrone"""
    async with await psycopg.AsyncConnection.connect(
        "postgresql://user:pass@localhost/db"
    ) as conn:
        async with conn.cursor() as cur:
            await cur.execute("SELECT * FROM utilisateurs")
            users = await cur.fetchall()
            return users

# Ex√©cution
async def main():
    users = await fetch_users()
    print(users)

asyncio.run(main())
```

**Avantages :**
- Id√©al pour les applications web asynchrones (FastAPI, aiohttp)
- Permet de g√©rer des milliers de connexions simultan√©es
- Meilleures performances pour les I/O-bound workloads

---

## Ressources et Documentation

### Documentation officielle
- **psycopg3 Documentation** : https://www.psycopg.org/psycopg3/docs/
- **PostgreSQL Python Tutorial** : https://wiki.postgresql.org/wiki/Psycopg

### Migration depuis psycopg2
- **Guide de migration** : https://www.psycopg.org/psycopg3/docs/basic/from_pg2.html

### Communaut√©
- **GitHub** : https://github.com/psycopg/psycopg
- **Mailing list** : https://lists.postgresql.org/

---

## R√©sum√© des Points Cl√©s

- ‚úÖ **psycopg3** est le driver moderne recommand√© pour Python + PostgreSQL
- ‚úÖ Utilisez toujours des **context managers** (`with`) pour g√©rer connexions et curseurs
- ‚úÖ **S√©curit√©** : Toujours utiliser des requ√™tes param√©tr√©es (jamais de f-strings)
- ‚úÖ **Performance** : Utiliser un **ConnectionPool** en production
- ‚úÖ **Lisibilit√©** : Pr√©f√©rer `dict_row` ou `namedtuple_row` pour les r√©sultats
- ‚úÖ **Transactions** : Laisser le context manager g√©rer commit/rollback automatiquement
- ‚úÖ **Erreurs** : Capturer les exceptions psycopg sp√©cifiques (IntegrityError, OperationalError)
- ‚úÖ **Asynchrone** : psycopg3 supporte nativement asyncio pour les applications modernes

---

**Prochaine √©tape :** Explorez maintenant les autres drivers (Node.js, Java, Go) dans les sections suivantes pour comparer les approches et choisir le meilleur outil pour votre stack technique.

‚è≠Ô∏è [Node.js : node-postgres (pg), Prisma](/20-drivers-connexion-applicative/01.2-nodejs-node-postgres.md)
