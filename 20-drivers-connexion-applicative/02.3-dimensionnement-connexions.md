ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 20.2.3. Dimensionnement (max_connections vs pool_size)

## Introduction

Le dimensionnement correct des connexions est **crucial** pour la performance et la stabilitÃ© de vos applications PostgreSQL. Trop peu de connexions et votre application sera lente, trop et PostgreSQL sera surchargÃ©.

Dans cette section, nous allons comprendre :
- Qu'est-ce que `max_connections` (cÃ´tÃ© PostgreSQL)
- Qu'est-ce que `pool_size` (cÃ´tÃ© application/PgBouncer)
- Comment les dimensionner correctement
- Les formules et calculs pratiques

---

## Les deux types de connexions

### Vue d'ensemble

Il existe **deux niveaux** de connexions Ã  considÃ©rer :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Application   â”‚          â”‚   PgBouncer     â”‚          â”‚   PostgreSQL    â”‚
â”‚                 â”‚          â”‚                 â”‚          â”‚                 â”‚
â”‚  Connexions     â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  Pool           â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  max_connectionsâ”‚
â”‚  clientes       â”‚          â”‚  (pool_size)    â”‚          â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    100-10000                      10-100                       50-200
```

**Analogie** : Imaginez un restaurant :
- **Clients** = Connexions de l'application (peuvent Ãªtre des milliers)
- **Serveurs** = Pool PgBouncer (une dizaine)
- **Cuisiniers** = Connexions PostgreSQL (limitÃ© par la cuisine)

---

## max_connections : La limite de PostgreSQL

### Qu'est-ce que max_connections ?

`max_connections` est un paramÃ¨tre de **configuration PostgreSQL** qui dÃ©finit le **nombre maximum de connexions simultanÃ©es** que le serveur acceptera.

**Emplacement** : Fichier `postgresql.conf`
```conf
max_connections = 100    # Valeur par dÃ©faut
```

### Comment Ã§a fonctionne ?

Quand PostgreSQL dÃ©marre :
1. Il alloue les ressources pour `max_connections` connexions
2. Chaque connexion consomme de la mÃ©moire (mÃªme si inutilisÃ©e)
3. Si une nouvelle connexion arrive et dÃ©passe la limite â†’ **Rejet**

**Erreur typique** :
```
FATAL: sorry, too many clients already
```

### Le coÃ»t d'une connexion PostgreSQL

Chaque connexion PostgreSQL consomme des ressources :

#### MÃ©moire par connexion

```
MÃ©moire par connexion = work_mem + (shared_buffers / max_connections) + overhead

Exemple typique :
- work_mem = 4 MB
- shared_buffers = 2 GB = 2048 MB
- max_connections = 100
- overhead â‰ˆ 2 MB

MÃ©moire â‰ˆ 4 + (2048 / 100) + 2 = 26 MB par connexion
```

**Calcul total** :
```
max_connections = 100
â†’ MÃ©moire totale â‰ˆ 100 Ã— 26 MB = 2.6 GB rien que pour les connexions !
```

#### Processus systÃ¨me

Chaque connexion PostgreSQL = **1 processus systÃ¨me Unix/Linux**

```bash
# Voir les processus PostgreSQL
ps aux | grep postgres

# Exemple de sortie avec 50 connexions actives :
postgres  1234  ... postgres: postgres mydb 192.168.1.10(45678) idle
postgres  1235  ... postgres: postgres mydb 192.168.1.10(45679) idle
postgres  1236  ... postgres: postgres mydb 192.168.1.10(45680) SELECT
...
# 50 lignes au total
```

**CoÃ»t** :
- CrÃ©ation/destruction de processus = coÃ»t CPU
- Context switching entre processus = overhead

### Valeurs par dÃ©faut selon les installations

| Installation | max_connections par dÃ©faut |
|-------------|----------------------------|
| PostgreSQL compilation standard | 100 |
| Debian/Ubuntu (apt) | 100 |
| Red Hat/CentOS (yum) | 100 |
| AWS RDS (db.t3.micro) | 87 |
| AWS RDS (db.t3.medium) | 112 |
| AWS RDS (db.m5.large) | 145 |
| Azure Database | Variable selon vCores |
| Docker image officiel | 100 |

### Modifier max_connections

#### MÃ©thode 1 : Ã‰diter postgresql.conf

```bash
# Trouver le fichier de configuration
sudo -u postgres psql -c "SHOW config_file;"

# Ã‰diter le fichier
sudo nano /etc/postgresql/18/main/postgresql.conf

# Chercher et modifier la ligne
max_connections = 200    # Au lieu de 100

# RedÃ©marrer PostgreSQL (OBLIGATOIRE)
sudo systemctl restart postgresql
```

âš ï¸ **Important** : Modifier `max_connections` nÃ©cessite un **redÃ©marrage** de PostgreSQL.

#### MÃ©thode 2 : Avec ALTER SYSTEM (PostgreSQL 9.4+)

```sql
-- Modifier via SQL
ALTER SYSTEM SET max_connections = 200;

-- Recharger la configuration (pas suffisant, redÃ©marrage nÃ©cessaire)
SELECT pg_reload_conf();

-- RedÃ©marrage obligatoire
-- sudo systemctl restart postgresql
```

### Limites pratiques de max_connections

#### Limite thÃ©orique

PostgreSQL peut techniquement supporter **jusqu'Ã  8388607 connexions**, mais c'est **totalement irrÃ©aliste**.

#### Limites pratiques

**Serveurs typiques** :

| Taille serveur | RAM | CPU | max_connections recommandÃ© |
|----------------|-----|-----|---------------------------|
| Petit (dev/test) | 4 GB | 2 cores | 50-100 |
| Moyen | 16 GB | 4 cores | 100-200 |
| Grand | 64 GB | 8 cores | 200-300 |
| TrÃ¨s grand | 128+ GB | 16+ cores | 300-500 |

âš ï¸ **Au-delÃ  de 500 connexions**, vous avez probablement un problÃ¨me d'architecture.

#### Pourquoi pas 1000+ connexions ?

**ProblÃ¨mes avec beaucoup de connexions** :

1. **MÃ©moire excessive**
   ```
   max_connections = 1000
   26 MB par connexion
   â†’ 26 GB rien que pour les connexions !
   ```

2. **CPU surchargÃ©**
   - 1000 processus Ã  gÃ©rer
   - Context switching excessif
   - Performance qui s'effondre

3. **Latence accrue**
   - Le scheduler du systÃ¨me peine
   - Chaque requÃªte attend plus longtemps

**RÃ©sultat** : Les performances se **dÃ©gradent** quand on augmente trop `max_connections`.

---

## pool_size : La taille des pools

### Qu'est-ce que pool_size ?

`pool_size` est le nombre de connexions **maintenues dans un pool** par :
- Votre application (connection pooling applicatif)
- PgBouncer (connection pooler externe)

### DiffÃ©rents pool_size selon le contexte

#### 1. Pool_size applicatif (par instance)

**Python (psycopg3)** :
```python
pool = ConnectionPool(
    conninfo="postgresql://...",
    min_size=5,      # Minimum 5 connexions maintenues
    max_size=20      # Maximum 20 connexions
)
```

**Node.js (pg)** :
```javascript
const pool = new Pool({
  max: 20,  // pool_size = 20
  min: 5
});
```

**Java (HikariCP)** :
```java
config.setMaximumPoolSize(20);  // pool_size = 20
config.setMinimumIdle(5);
```

#### 2. Pool_size PgBouncer (global)

**pgbouncer.ini** :
```ini
[pgbouncer]
default_pool_size = 10      # Pool de 10 connexions PostgreSQL
reserve_pool_size = 5       # 5 connexions de rÃ©serve
```

### Calcul du nombre total de connexions

#### ScÃ©nario 1 : Application directe (sans PgBouncer)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Application (3 instances)                   â”‚
â”‚                                             â”‚
â”‚  Instance 1: pool_size=10 â”€â”€â”               â”‚
â”‚  Instance 2: pool_size=10 â”€â”€â”¼â”€â”€â–º            â”‚
â”‚  Instance 3: pool_size=10 â”€â”€â”˜               â”‚
â”‚                                             â”‚
â”‚  Total connexions PostgreSQL = 3 Ã— 10 = 30  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ PostgreSQL            â”‚
        â”‚ max_connections = 50  â”‚
        â”‚ (OK, 30 < 50)         â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Formule** :
```
Connexions totales = nombre_instances Ã— pool_size_par_instance
```

#### ScÃ©nario 2 : Avec PgBouncer

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Applications (plusieurs instances)          â”‚
â”‚                                             â”‚
â”‚  App1 (3 inst): 3Ã—10 = 30 connexions  â”€â”€â”   â”‚
â”‚  App2 (2 inst): 2Ã—10 = 20 connexions  â”€â”€â”¼â”€â”€â–ºâ”‚
â”‚  App3 (5 inst): 5Ã—10 = 50 connexions  â”€â”€â”˜   â”‚
â”‚                                             â”‚
â”‚  Total : 100 connexions vers PgBouncer      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ PgBouncer             â”‚
        â”‚ pool_size = 20        â”‚
        â”‚                       â”‚
        â”‚ 100 clients â†’ 20 cnx  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ PostgreSQL            â”‚
        â”‚ max_connections = 50  â”‚
        â”‚ (OK, 20 < 50)         â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Avantage** : Mutualisation massive des connexions !

---

## La relation max_connections vs pool_size

### RÃ¨gle d'or

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Somme de tous les pool_size < max_connections         â”‚
â”‚                                                        â”‚
â”‚  Avec marge de sÃ©curitÃ© :                              â”‚
â”‚  Somme des pools â‰¤ (max_connections Ã— 0.8)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Pourquoi 80% ?**
- RÃ©server des connexions pour les admins
- Marge pour les pics temporaires
- Connexions systÃ¨me (autovacuum, background workers)

### Exemples de calcul

#### Exemple 1 : Application simple

**Configuration** :
- 1 application web
- 3 instances (load balancing)
- Pool par instance = 10 connexions

**Calcul** :
```
Total connexions = 3 Ã— 10 = 30

max_connections nÃ©cessaire = 30 / 0.8 = 37.5
â†’ max_connections = 50 (arrondi supÃ©rieur)
```

#### Exemple 2 : Plusieurs applications

**Configuration** :
- Application Web : 5 instances Ã— 10 = 50 connexions
- Worker background : 2 instances Ã— 5 = 10 connexions
- Reporting : 1 instance Ã— 5 = 5 connexions

**Calcul** :
```
Total connexions = 50 + 10 + 5 = 65

max_connections nÃ©cessaire = 65 / 0.8 = 81.25
â†’ max_connections = 100
```

#### Exemple 3 : Avec PgBouncer

**Configuration** :
- 10 microservices
- Chaque service : 3 instances Ã— 10 = 30 connexions
- Total vers PgBouncer : 10 Ã— 30 = 300 connexions
- PgBouncer pool_size = 20

**Calcul** :
```
Connexions vers PostgreSQL = 20 (pool PgBouncer)

max_connections nÃ©cessaire = 20 / 0.8 = 25
â†’ max_connections = 50 (avec beaucoup de marge)
```

**Ã‰conomie massive** : 300 â†’ 20 connexions !

---

## Formules de dimensionnement

### Formule gÃ©nÃ©rale pour pool_size (sans PgBouncer)

```
pool_size = (nombre_de_CPU_cores Ã— 2) + nombre_de_disques
```

**Explication** : Cette formule vient des contraintes hardware :
- **CPU** : Nombre de tÃ¢ches parallÃ¨les possibles
- **Disques** : I/O en attente pendant les lectures/Ã©critures

**Exemples** :

| Serveur | CPU Cores | Disques | pool_size recommandÃ© |
|---------|-----------|---------|---------------------|
| Petit | 2 | 1 | (2Ã—2) + 1 = 5 |
| Moyen | 4 | 1 | (4Ã—2) + 1 = 9 â‰ˆ **10** |
| Grand | 8 | 2 | (8Ã—2) + 2 = 18 â‰ˆ **20** |
| TrÃ¨s grand | 16 | 4 | (16Ã—2) + 4 = 36 â‰ˆ **40** |

### Formule pour max_connections

```
max_connections = (total_de_tous_les_pools / 0.8) + connexions_rÃ©servÃ©es

oÃ¹ :
- total_de_tous_les_pools = somme de tous les pool_size
- 0.8 = coefficient de sÃ©curitÃ© (80%)
- connexions_rÃ©servÃ©es = ~10 pour admin/monitoring/maintenance
```

**Exemple dÃ©taillÃ©** :
```
Applications :
- API REST : 5 instances Ã— 10 = 50
- Worker : 2 instances Ã— 5 = 10
- Total pools : 60

max_connections = (60 / 0.8) + 10
                = 75 + 10
                = 85
â†’ Configurer max_connections = 100
```

### Formule avec PgBouncer

```
pool_size_app = 5 Ã  10 par instance
pool_size_pgbouncer = (nb_instances_totales Ã— 2) / 10

max_connections = (pool_size_pgbouncer / 0.8) + 10
```

**Exemple** :
```
Applications :
- 20 instances au total
- pool_size_app = 5 par instance

pool_size_pgbouncer = (20 Ã— 2) / 10 = 4
â†’ Utiliser pool_size = 10 (minimum recommandÃ©)

max_connections = (10 / 0.8) + 10 = 22.5
â†’ Configurer max_connections = 50 (avec marge)
```

---

## Cas d'usage rÃ©els

### Cas 1 : Startup - Application web simple

**Contexte** :
- 1 serveur web (Node.js/Express)
- 1 serveur PostgreSQL (4 cores, 16 GB RAM)
- Trafic : 100 requÃªtes/seconde
- Utilisateurs : ~1000

**Dimensionnement** :

```
Serveur web :
- 1 instance Node.js
- pool_size = 10

PostgreSQL :
- 4 cores â†’ pool optimal = (4Ã—2) + 1 = 9 â‰ˆ 10
- max_connections = (10 / 0.8) + 10 = 22.5

Configuration :
- Pool app : 10
- max_connections : 50 (avec marge pour croissance)
```

**Fichiers de configuration** :

**Node.js** :
```javascript
const pool = new Pool({
  max: 10,
  min: 2
});
```

**postgresql.conf** :
```conf
max_connections = 50
shared_buffers = 4GB      # 25% de la RAM
work_mem = 32MB
```

### Cas 2 : Scale-up - Application en croissance

**Contexte** :
- 3 serveurs web (load balanced)
- 1 serveur PostgreSQL (8 cores, 32 GB RAM)
- Trafic : 500 requÃªtes/seconde
- Utilisateurs : ~10000

**Dimensionnement** :

```
Serveurs web :
- 3 instances Ã— pool_size 10 = 30 connexions

PostgreSQL :
- 8 cores â†’ pool optimal = (8Ã—2) + 1 = 17 â‰ˆ 20
- max_connections = (30 / 0.8) + 10 = 47.5

Configuration :
- Pool par instance : 10
- max_connections : 100 (anticipe la croissance)
```

**ProblÃ¨me potentiel** : Si on passe Ã  5 instances â†’ 50 connexions
- Solution 1 : Augmenter max_connections Ã  100
- Solution 2 : Introduire PgBouncer

### Cas 3 : Entreprise - Microservices

**Contexte** :
- 15 microservices (Node.js, Python, Java)
- Chaque service : 3-5 instances
- Total : ~60 instances d'application
- 1 serveur PostgreSQL (16 cores, 64 GB RAM)

**Sans PgBouncer (mauvaise approche)** :
```
60 instances Ã— 10 connexions = 600 connexions
â†’ IMPOSSIBLE ! PostgreSQL ne peut pas gÃ©rer 600 connexions efficacement
```

**Avec PgBouncer (bonne approche)** :
```
Applications :
- 60 instances Ã— 5 connexions = 300 connexions vers PgBouncer

PgBouncer :
- pool_mode = transaction
- pool_size = 20

PostgreSQL :
- max_connections = (20 / 0.8) + 10 = 35

Configuration :
- Pool par app : 5
- PgBouncer pool : 20
- max_connections : 50
```

**Architecture** :
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 60 instances app (300 connexions)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  PgBouncer   â”‚
        â”‚  pool = 20   â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ PostgreSQL   â”‚
        â”‚ max_conn=50  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Cas 4 : Serverless (AWS Lambda, Cloud Functions)

**Contexte** :
- Fonctions Lambda dÃ©ployÃ©es
- Chaque invocation = nouvelle connexion potentielle
- Trafic variable (0 Ã  1000 req/sec)

**ProblÃ¨me** :
```
Pic de 1000 requÃªtes simultanÃ©es
â†’ 1000 connexions PostgreSQL demandÃ©es
â†’ CRASH !
```

**Solution** :
```
Lambda â†’ RDS Proxy (ou PgBouncer sur EC2/ECS) â†’ RDS PostgreSQL

Configuration :
- RDS Proxy pool : 20-30 connexions
- max_connections : 50
```

**Exemple AWS RDS Proxy** :
```json
{
  "MaxConnectionsPercent": 50,
  "MaxIdleConnectionsPercent": 20,
  "ConnectionBorrowTimeout": 120
}
```

### Cas 5 : Application legacy + nouvelles applications

**Contexte** :
- Application legacy (Java) : 5 instances Ã— 20 = 100 connexions
- Nouvelles APIs (Node.js) : 10 instances Ã— 10 = 100 connexions
- Total : 200 connexions

**ProblÃ¨me** :
```
200 connexions directes = PostgreSQL surchargÃ©
```

**Solution progressive** :

**Phase 1 : PgBouncer pour nouvelles apps seulement**
```
Legacy (Java) : 100 connexions directes
Nouvelles APIs â†’ PgBouncer (pool=20) â†’ PostgreSQL

Total vers PostgreSQL : 100 + 20 = 120
max_connections = 150
```

**Phase 2 : Migration complÃ¨te vers PgBouncer**
```
Legacy â†’ PgBouncer #1 (session mode, pool=30)
APIs â†’ PgBouncer #2 (transaction mode, pool=20)

Total vers PostgreSQL : 30 + 20 = 50
max_connections = 100
```

---

## ProblÃ¨mes courants et solutions

### ProblÃ¨me 1 : Pool trop petit

**SymptÃ´mes** :
```
- Erreurs "timeout waiting for connection"
- Latence Ã©levÃ©e et variable
- Logs montrant beaucoup de connexions en attente
```

**Diagnostic** :
```sql
-- PgBouncer : Voir les clients en attente
SHOW POOLS;

-- Application : Logs
"PoolTimeout: Timed out waiting for connection from pool"
```

**Solution** :
```
Augmenter progressivement le pool_size :
- Ã‰tait 10 â†’ Essayer 15
- Monitorer
- Puis 20 si nÃ©cessaire
```

### ProblÃ¨me 2 : Pool trop grand

**SymptÃ´mes** :
```
- CPU Ã©levÃ© sur PostgreSQL sans charge apparente
- Beaucoup de connexions "idle"
- Performance qui se dÃ©grade avec plus de connexions
```

**Diagnostic** :
```sql
-- Voir les connexions idle
SELECT
    count(*) as idle_count
FROM pg_stat_activity
WHERE state = 'idle';

-- Si idle_count > pool_size Ã— 0.5 : pool trop grand
```

**Solution** :
```
RÃ©duire le pool_size :
- Ã‰tait 50 â†’ Essayer 30
- Ã‰tait 30 â†’ Essayer 20
```

### ProblÃ¨me 3 : max_connections atteint

**SymptÃ´me** :
```
FATAL: sorry, too many clients already
FATAL: remaining connection slots are reserved for non-replication superuser connections
```

**Diagnostic** :
```sql
-- Voir le nombre de connexions actuelles
SELECT
    count(*) as current,
    current_setting('max_connections')::int as max,
    (count(*)::float / current_setting('max_connections')::int * 100)::numeric(5,2) as percent
FROM pg_stat_activity;

-- Si percent > 90% : problÃ¨me imminent
```

**Solutions** :

**Solution immÃ©diate** :
```sql
-- Tuer les connexions idle depuis longtemps
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE state = 'idle'
  AND state_change < now() - interval '1 hour';
```

**Solution Ã  long terme** :
```
Option 1 : Augmenter max_connections
- Ã‰diter postgresql.conf
- RedÃ©marrer PostgreSQL

Option 2 : Introduire PgBouncer (recommandÃ©)
- RÃ©duire les connexions directes
- Mutualiser via PgBouncer
```

### ProblÃ¨me 4 : Croissance non contrÃ´lÃ©e

**ScÃ©nario** :
```
DÃ©ploiement d'une nouvelle version de l'app
â†’ Doublement des instances (scaling horizontal)
â†’ Doublement des connexions
â†’ Saturation de PostgreSQL
```

**PrÃ©vention** :

**Sans PgBouncer** :
```
Avant dÃ©ploiement, calculer :
nouvelles_connexions = nouvelle_instance_count Ã— pool_size

Si nouvelles_connexions > (max_connections Ã— 0.8) :
â†’ Augmenter max_connections AVANT le dÃ©ploiement
```

**Avec PgBouncer** :
```
PgBouncer absorbe la croissance automatiquement :
- 10 instances â†’ 50 instances
- PgBouncer maintient toujours le mÃªme pool_size
â†’ Pas d'impact sur PostgreSQL
```

### ProblÃ¨me 5 : Connexions bloquÃ©es (idle in transaction)

**SymptÃ´me** :
```sql
SELECT count(*)
FROM pg_stat_activity
WHERE state = 'idle in transaction';

-- Si count > 10 : problÃ¨me
```

**Cause** :
- Application qui ouvre une transaction mais ne la ferme pas
- Connection leak dans le code

**Solution** :
```sql
-- Configurer un timeout automatique
ALTER DATABASE mydb SET idle_in_transaction_session_timeout = '5min';

-- Ou dans postgresql.conf
idle_in_transaction_session_timeout = 300000  # 5 minutes en ms
```

---

## Monitoring et mÃ©triques

### MÃ©triques essentielles Ã  surveiller

#### 1. Utilisation de max_connections

**RequÃªte** :
```sql
SELECT
    count(*) AS used,
    current_setting('max_connections')::int AS max,
    ROUND(
        count(*)::numeric / current_setting('max_connections')::int * 100,
        2
    ) AS percent_used
FROM pg_stat_activity;
```

**Seuils d'alerte** :
- < 50% : âœ… OK
- 50-70% : âš ï¸ Surveiller
- 70-85% : âš ï¸âš ï¸ Attention
- > 85% : ğŸ”´ Critique - Agir immÃ©diatement

#### 2. Connexions par Ã©tat

**RequÃªte** :
```sql
SELECT
    state,
    count(*) as count
FROM pg_stat_activity
WHERE datname = 'mydb'
GROUP BY state
ORDER BY count DESC;
```

**RÃ©sultat sain** :
```
     state     | count
---------------+-------
 active        |    12
 idle          |    45
 idle in trans |     2
```

**ProblÃ¨mes** :
- `idle in transaction` > 10 : Connexions qui ne finissent pas leurs transactions
- `idle` > pool_size Ã— 1.5 : Pool trop grand

#### 3. DurÃ©e des connexions

**RequÃªte** :
```sql
SELECT
    pid,
    usename,
    application_name,
    state,
    now() - backend_start as connection_age,
    now() - state_change as time_in_state
FROM pg_stat_activity
WHERE datname = 'mydb'
ORDER BY backend_start
LIMIT 10;
```

**Attention si** :
- `connection_age` > 1 heure pour connexions idle (connection leak ?)
- `time_in_state` > 5 min pour "idle in transaction"

### Dashboard de monitoring

**RequÃªte complÃ¨te pour tableau de bord** :
```sql
WITH connection_stats AS (
    SELECT
        count(*) FILTER (WHERE state = 'active') AS active,
        count(*) FILTER (WHERE state = 'idle') AS idle,
        count(*) FILTER (WHERE state = 'idle in transaction') AS idle_in_trans,
        count(*) AS total
    FROM pg_stat_activity
    WHERE datname = current_database()
)
SELECT
    cs.*,
    current_setting('max_connections')::int AS max_connections,
    ROUND((cs.total::numeric / current_setting('max_connections')::int * 100), 2) AS percent_used,
    current_setting('max_connections')::int - cs.total AS remaining
FROM connection_stats cs;
```

**RÃ©sultat** :
```
 active | idle | idle_in_trans | total | max_connections | percent_used | remaining
--------+------+---------------+-------+-----------------+--------------+-----------
     15 |   32 |             2 |    49 |             100 |        49.00 |        51
```

### Alerting avec Prometheus

**MÃ©triques Ã  exporter** (via postgres_exporter) :

```yaml
# Taux d'utilisation max_connections
- alert: PostgreSQLConnectionsNearLimit
  expr: |
    (pg_stat_database_numbackends / pg_settings_max_connections) > 0.85
  for: 5m
  labels:
    severity: warning
  annotations:
    summary: "PostgreSQL connections near limit"

# Connexions idle in transaction
- alert: PostgreSQLIdleInTransaction
  expr: |
    pg_stat_activity_idle_in_transaction_count > 10
  for: 5m
  labels:
    severity: warning
```

---

## StratÃ©gies d'optimisation

### StratÃ©gie 1 : Start Small, Scale Smart

**Principe** : Commencer avec des valeurs conservatrices, puis ajuster.

**Phase 1 : DÃ©veloppement**
```
pool_size = 5
max_connections = 20
```

**Phase 2 : Staging/Test**
```
pool_size = 10
max_connections = 50
â†’ Tester en charge, monitorer
```

**Phase 3 : Production**
```
Selon rÃ©sultats tests :
pool_size = 10-20
max_connections = 100

Avec PgBouncer si nÃ©cessaire
```

### StratÃ©gie 2 : RÃ¨gle du 80/20

**Principe** : 80% du trafic nÃ©cessite 20% des ressources

**Application** :
```
max_connections = 100

RÃ©servation :
- 80 connexions pour applications (80%)
- 10 connexions pour admin/monitoring (10%)
- 10 connexions de marge (10%)
```

### StratÃ©gie 3 : Pool par type de workload

**Principe** : DiffÃ©rents pools pour diffÃ©rents usages

**Exemple** :
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PgBouncer - Port 6432                   â”‚
â”‚ Mode: transaction                       â”‚
â”‚ pool_size: 20                           â”‚
â”‚ Usage: API REST (lectures/Ã©critures)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PgBouncer - Port 6433                   â”‚
â”‚ Mode: session                           â”‚
â”‚ pool_size: 5                            â”‚
â”‚ Usage: Jobs batch (longues transactions)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Connexion directe                       â”‚
â”‚ Usage: Admin, monitoring                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### StratÃ©gie 4 : Auto-scaling avec limites

**Principe** : Permettre la croissance tout en protÃ©geant PostgreSQL

**Configuration HikariCP (Java)** :
```java
// Pool qui grandit avec la charge
config.setMinimumIdle(5);           // Toujours 5 connexions
config.setMaximumPoolSize(20);      // Jamais plus de 20
config.setConnectionTimeout(3000);   // Timeout rapide si saturÃ©
```

**Configuration avec PgBouncer** :
```ini
default_pool_size = 10
reserve_pool_size = 5        # 5 connexions de rÃ©serve
reserve_pool_timeout = 3     # Utiliser aprÃ¨s 3 secondes d'attente
```

---

## Checklist de configuration

### Pour l'application

```
â˜ DÃ©finir pool_size par instance
   - Formule : (CPU_cores Ã— 2) + disques
   - Valeur typique : 10-20

â˜ Configurer les timeouts
   - Connection timeout : 5-10 secondes
   - Statement timeout : 30-60 secondes

â˜ ImplÃ©menter la libÃ©ration des connexions
   - Utiliser try/finally ou with statements
   - Jamais de connection leaks

â˜ Monitorer le pool applicatif
   - Connexions actives
   - Connexions en attente
   - Temps d'attente moyen
```

### Pour PgBouncer (si utilisÃ©)

```
â˜ Choisir le mode appropriÃ©
   - Transaction : API REST, microservices
   - Session : Legacy, prepared statements

â˜ Dimensionner le pool PgBouncer
   - Formule : (nb_instances Ã— 2) / 10
   - Minimum : 10

â˜ Configurer server_reset_query
   - Transaction mode : DISCARD ALL
   - Performance : RESET ALL

â˜ DÃ©finir les timeouts
   - server_idle_timeout : 600s (10 min)
   - server_lifetime : 3600s (1h)
```

### Pour PostgreSQL

```
â˜ Calculer max_connections nÃ©cessaire
   - Formule : (total_pools / 0.8) + 10
   - Minimum : 50
   - Maximum pratique : 300-500

â˜ Ajuster shared_buffers
   - Formule : 25% de la RAM
   - Exemple : 16 GB RAM â†’ 4 GB shared_buffers

â˜ Configurer work_mem
   - Formule : (RAM - shared_buffers) / (max_connections Ã— 2)
   - Exemple : (16GB - 4GB) / (100 Ã— 2) = 60 MB

â˜ Activer connection timeout
   idle_in_transaction_session_timeout = 5min

â˜ Configurer les logs
   log_connections = on
   log_disconnections = on
```

### Monitoring

```
â˜ Surveiller l'utilisation de max_connections
   - Alerte si > 85%

â˜ Tracer les connexions idle in transaction
   - Alerte si > 10

â˜ Monitorer les timeouts d'application
   - Tracer les erreurs de pool exhaustÃ©

â˜ Dashboard avec mÃ©triques essentielles
   - Connexions actives/idle
   - Taux d'utilisation
   - Temps d'attente
```

---

## Tableau rÃ©capitulatif

### Valeurs recommandÃ©es selon la taille

| Taille | RAM | CPU | Instances app | pool_size/inst | PgBouncer pool | max_connections |
|--------|-----|-----|---------------|----------------|----------------|-----------------|
| Micro | 2 GB | 1 | 1 | 5 | N/A | 20 |
| Petit | 8 GB | 2 | 2-3 | 10 | 10 | 50 |
| Moyen | 16 GB | 4 | 5-10 | 10 | 20 | 100 |
| Grand | 32 GB | 8 | 10-20 | 10 | 30 | 200 |
| TrÃ¨s grand | 64+ GB | 16+ | 20+ | 5-10 | 50 | 300 |

### Formules de rÃ©fÃ©rence rapide

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FORMULES ESSENTIELLES                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚ pool_size = (CPU_cores Ã— 2) + disques                   â”‚
â”‚                                                         â”‚
â”‚ max_connections = (total_pools / 0.8) + 10              â”‚
â”‚                                                         â”‚
â”‚ work_mem = (RAM - shared_buffers) / (max_conn Ã— 2)      â”‚
â”‚                                                         â”‚
â”‚ shared_buffers = RAM Ã— 0.25                             â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## RÃ©sumÃ© : Points clÃ©s Ã  retenir

### âœ¨ Les 3 nombres magiques

1. **pool_size** (application) : 5-20 par instance
2. **pool_size** (PgBouncer) : 10-50 selon charge
3. **max_connections** (PostgreSQL) : 50-300 max

### ğŸ¯ RÃ¨gles d'or

1. **Plus n'est pas mieux** : Trop de connexions = performance dÃ©gradÃ©e
2. **Utiliser PgBouncer** : Au-delÃ  de 3-5 instances d'application
3. **Garder de la marge** : Rester sous 80% de max_connections
4. **Monitorer activement** : Surveiller les mÃ©triques en continu

### âš–ï¸ Trade-offs

| Approche | Avantages | InconvÃ©nients |
|----------|-----------|---------------|
| **Pool petit** | Ã‰conomie ressources | Risque de timeouts |
| **Pool grand** | Pas de timeouts | Surcharge PostgreSQL |
| **Sans PgBouncer** | Architecture simple | ScalabilitÃ© limitÃ©e |
| **Avec PgBouncer** | ScalabilitÃ© maximale | ComplexitÃ© ajoutÃ©e |

### ğŸ’¡ Quand introduire PgBouncer ?

âœ… **Oui, utiliser PgBouncer si** :
- Plus de 5 instances d'application
- Microservices (plusieurs applications)
- Serverless (Lambda, Cloud Functions)
- Besoin de scaler rapidement

âŒ **Non, pas nÃ©cessaire si** :
- 1-2 instances d'application
- Trafic stable et prÃ©visible
- < 50 connexions totales

---

## Pour aller plus loin

### Documentation officielle

- [PostgreSQL Connection Configuration](https://www.postgresql.org/docs/current/runtime-config-connection.html)
- [PgBouncer Configuration](https://www.pgbouncer.org/config.html)

### Articles recommandÃ©s

- [HikariCP Pool Sizing](https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing) - Excellent article sur le dimensionnement (applicable Ã  tous les langages)
- [PostgreSQL Connection Pooling: Part 2](https://scalegrid.io/blog/postgresql-connection-pooling-part-2-pgbouncer/) - Dimensionnement avec PgBouncer
- [How to size PostgreSQL max_connections](https://www.cybertec-postgresql.com/en/tuning-max_connections-in-postgresql/) - Guide Cybertec

### Outils

- **pg_stat_activity** : Monitoring natif PostgreSQL
- **pgBouncer SHOW commands** : Statistiques PgBouncer
- **Prometheus + Grafana** : Dashboards de monitoring
- **pgBadger** : Analyse des logs de connexion

---


â­ï¸ [Connection leaks et timeouts](/20-drivers-connexion-applicative/02.4-connection-leaks-timeouts.md)
