üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.1.5. .NET : Npgsql, Entity Framework Core

## Introduction

.NET (anciennement .NET Core) est une plateforme de d√©veloppement moderne cr√©√©e par Microsoft, id√©ale pour construire des applications web, APIs, microservices et applications desktop. Pour interagir avec PostgreSQL en .NET, deux approches principales existent :

1. **Npgsql** : Provider ADO.NET natif pour PostgreSQL, acc√®s bas niveau
2. **Entity Framework Core (EF Core)** : ORM moderne et puissant de Microsoft

Ce tutoriel couvre les deux approches en profondeur pour vous permettre de choisir celle qui convient le mieux √† votre projet.

---

## Vue d'Ensemble : Provider vs ORM

### Qu'est-ce qu'un Provider ADO.NET ?

**ADO.NET** est l'API standard .NET pour l'acc√®s aux bases de donn√©es. **Npgsql** est le provider ADO.NET pour PostgreSQL qui vous permet d'√©crire du SQL brut et de manipuler les r√©sultats directement.

**Analogie :** C'est comme parler directement √† PostgreSQL dans sa langue native (SQL).

### Qu'est-ce qu'un ORM ?

Un **ORM** (Object-Relational Mapping) est une couche d'abstraction qui traduit vos classes C# en requ√™tes SQL. **Entity Framework Core** est l'ORM phare de Microsoft, moderne et performant.

**Analogie :** C'est comme avoir un traducteur automatique entre votre code C# et PostgreSQL.

### Comparaison Rapide

| Caract√©ristique | Npgsql (ADO.NET) | EF Core |
|-----------------|------------------|---------|
| **Type** | Provider natif | ORM complet |
| **Langage** | SQL brut | LINQ (C# queries) |
| **Performance** | Excellente (direct) | Tr√®s bonne (overhead minimal) |
| **Courbe d'apprentissage** | Moyenne (SQL requis) | Facile (C# natif) |
| **Contr√¥le** | Total | Abstraction |
| **Type-safety** | Manuelle | Automatique (forte) |
| **Migrations** | Manuelles | Int√©gr√©es (Code-First) |
| **Boilerplate** | Plus de code | Moins de code |
| **IntelliSense** | Limit√© (strings SQL) | Complet (LINQ) |
| **Tracking** | Manuel | Automatique (ChangeTracking) |
| **Relations** | Manuelles | Automatiques (Navigation properties) |

**Recommandation :**
- **Npgsql** : Pour des performances maximales, SQL complexe, contr√¥le total, microservices l√©gers
- **EF Core** : Pour la productivit√©, applications CRUD standard, prototypage rapide, √©quipes C# exp√©riment√©es

---

## Partie 1 : Npgsql (Provider ADO.NET)

### Introduction √† Npgsql

**Npgsql** est le provider ADO.NET open-source pour PostgreSQL. Il est :
- **Performant** : Optimis√© sp√©cifiquement pour PostgreSQL
- **Complet** : Support de toutes les fonctionnalit√©s PostgreSQL
- **Mature** : Plus de 15 ans de d√©veloppement actif
- **Standard** : Impl√©mente l'API ADO.NET standard de .NET

### Installation

#### Via NuGet Package Manager Console

```powershell
Install-Package Npgsql
```

#### Via .NET CLI

```bash
dotnet add package Npgsql
```

#### Fichier .csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Npgsql" Version="8.0.1" />
  </ItemGroup>
</Project>
```

### Connexion Simple

```csharp
using Npgsql;
using System;

class Program
{
    static void Main()
    {
        // Cha√Æne de connexion
        string connectionString = "Host=localhost;Port=5432;Database=mydb;Username=user;Password=password";

        // √âtablir la connexion
        using var conn = new NpgsqlConnection(connectionString);
        conn.Open();

        Console.WriteLine("‚úÖ Connexion √©tablie avec succ√®s");

        // Tester la connexion
        using var cmd = new NpgsqlCommand("SELECT version()", conn);
        string version = (string)cmd.ExecuteScalar();

        Console.WriteLine($"Version PostgreSQL : {version}");
    }
}
```

**Format de la cha√Æne de connexion :**
```
Host=[host];Port=[port];Database=[database];Username=[user];Password=[password]
```

**Exemples de cha√Ænes de connexion :**

```csharp
// Local avec port par d√©faut
"Host=localhost;Database=mydb;Username=user;Password=password"

// Avec SSL
"Host=localhost;Database=mydb;Username=user;Password=password;SSL Mode=Require"

// Avec timeout
"Host=localhost;Database=mydb;Username=user;Password=password;Timeout=30;Command Timeout=30"

// Avec pooling (activ√© par d√©faut)
"Host=localhost;Database=mydb;Username=user;Password=password;Pooling=true;Maximum Pool Size=100"
```

### Pool de Connexions

Le pooling est **activ√© par d√©faut** dans Npgsql, mais vous pouvez le configurer :

```csharp
var connectionString = "Host=localhost;Database=mydb;Username=user;Password=password;" +
                      "Pooling=true;" +                     // Activ√© par d√©faut
                      "Minimum Pool Size=5;" +              // Min 5 connexions
                      "Maximum Pool Size=100;" +            // Max 100 connexions
                      "Connection Idle Lifetime=300;" +     // 5 min avant fermeture
                      "Connection Pruning Interval=10";     // Nettoyage toutes les 10s

using var conn = new NpgsqlConnection(connectionString);
```

### Mod√®les de Donn√©es (Classes)

```csharp
using System;

namespace MyApp.Models
{
    public class User
    {
        public int Id { get; set; }
        public string Nom { get; set; }
        public string Email { get; set; }
        public int Age { get; set; }
        public DateTime CreatedAt { get; set; }
        public DateTime UpdatedAt { get; set; }
    }

    public class CreateUserDto
    {
        public string Nom { get; set; }
        public string Email { get; set; }
        public int Age { get; set; }
    }

    public class UpdateUserDto
    {
        public string Nom { get; set; }
        public string Email { get; set; }
        public int? Age { get; set; }
    }
}
```

### CRUD Op√©rations

#### CREATE : Ins√©rer des donn√©es

```csharp
using Npgsql;
using MyApp.Models;

public class UserRepository
{
    private readonly string _connectionString;

    public UserRepository(string connectionString)
    {
        _connectionString = connectionString;
    }

    public User CreateUser(CreateUserDto dto)
    {
        using var conn = new NpgsqlConnection(_connectionString);
        conn.Open();

        string sql = @"
            INSERT INTO utilisateurs (nom, email, age)
            VALUES (@nom, @email, @age)
            RETURNING id, nom, email, age, created_at, updated_at";

        using var cmd = new NpgsqlCommand(sql, conn);

        // Param√®tres (protection contre injection SQL)
        cmd.Parameters.AddWithValue("nom", dto.Nom);
        cmd.Parameters.AddWithValue("email", dto.Email);
        cmd.Parameters.AddWithValue("age", dto.Age);

        using var reader = cmd.ExecuteReader();

        if (reader.Read())
        {
            return new User
            {
                Id = reader.GetInt32(0),
                Nom = reader.GetString(1),
                Email = reader.GetString(2),
                Age = reader.GetInt32(3),
                CreatedAt = reader.GetDateTime(4),
                UpdatedAt = reader.GetDateTime(5)
            };
        }

        throw new Exception("√âchec de la cr√©ation");
    }
}

// Utilisation
var repo = new UserRepository(connectionString);
var newUser = new CreateUserDto
{
    Nom = "Alice",
    Email = "alice@example.com",
    Age = 30
};

User user = repo.CreateUser(newUser);
Console.WriteLine($"Utilisateur cr√©√© : ID={user.Id}");
```

**Insertion multiple (batch) :**

```csharp
public void CreateUsers(List<CreateUserDto> users)
{
    using var conn = new NpgsqlConnection(_connectionString);
    conn.Open();

    using var transaction = conn.BeginTransaction();

    try
    {
        string sql = "INSERT INTO utilisateurs (nom, email, age) VALUES (@nom, @email, @age)";

        foreach (var user in users)
        {
            using var cmd = new NpgsqlCommand(sql, conn, transaction);
            cmd.Parameters.AddWithValue("nom", user.Nom);
            cmd.Parameters.AddWithValue("email", user.Email);
            cmd.Parameters.AddWithValue("age", user.Age);
            cmd.ExecuteNonQuery();
        }

        transaction.Commit();
        Console.WriteLine($"{users.Count} utilisateurs cr√©√©s");
    }
    catch
    {
        transaction.Rollback();
        throw;
    }
}
```

**M√©thode alternative avec Prepared Statement :**

```csharp
public void CreateUsersPrepared(List<CreateUserDto> users)
{
    using var conn = new NpgsqlConnection(_connectionString);
    conn.Open();

    string sql = "INSERT INTO utilisateurs (nom, email, age) VALUES ($1, $2, $3)";

    using var cmd = new NpgsqlCommand(sql, conn);
    cmd.Parameters.Add(new NpgsqlParameter { ParameterName = "p1" });
    cmd.Parameters.Add(new NpgsqlParameter { ParameterName = "p2" });
    cmd.Parameters.Add(new NpgsqlParameter { ParameterName = "p3" });
    cmd.Prepare();

    foreach (var user in users)
    {
        cmd.Parameters[0].Value = user.Nom;
        cmd.Parameters[1].Value = user.Email;
        cmd.Parameters[2].Value = user.Age;
        cmd.ExecuteNonQuery();
    }
}
```

#### READ : Lire des donn√©es

```csharp
// R√©cup√©rer un utilisateur par ID
public User GetUserById(int id)
{
    using var conn = new NpgsqlConnection(_connectionString);
    conn.Open();

    string sql = @"
        SELECT id, nom, email, age, created_at, updated_at
        FROM utilisateurs
        WHERE id = @id";

    using var cmd = new NpgsqlCommand(sql, conn);
    cmd.Parameters.AddWithValue("id", id);

    using var reader = cmd.ExecuteReader();

    if (reader.Read())
    {
        return new User
        {
            Id = reader.GetInt32(0),
            Nom = reader.GetString(1),
            Email = reader.GetString(2),
            Age = reader.GetInt32(3),
            CreatedAt = reader.GetDateTime(4),
            UpdatedAt = reader.GetDateTime(5)
        };
    }

    return null; // Utilisateur non trouv√©
}

// R√©cup√©rer tous les utilisateurs
public List<User> GetAllUsers()
{
    var users = new List<User>();

    using var conn = new NpgsqlConnection(_connectionString);
    conn.Open();

    string sql = "SELECT id, nom, email, age, created_at, updated_at FROM utilisateurs ORDER BY nom";

    using var cmd = new NpgsqlCommand(sql, conn);
    using var reader = cmd.ExecuteReader();

    while (reader.Read())
    {
        users.Add(new User
        {
            Id = reader.GetInt32(0),
            Nom = reader.GetString(1),
            Email = reader.GetString(2),
            Age = reader.GetInt32(3),
            CreatedAt = reader.GetDateTime(4),
            UpdatedAt = reader.GetDateTime(5)
        });
    }

    return users;
}

// Recherche avec filtres
public List<User> SearchUsers(string namePattern, int minAge, int maxAge)
{
    var users = new List<User>();

    using var conn = new NpgsqlConnection(_connectionString);
    conn.Open();

    string sql = @"
        SELECT id, nom, email, age, created_at, updated_at
        FROM utilisateurs
        WHERE nom ILIKE @pattern AND age BETWEEN @minAge AND @maxAge
        ORDER BY nom";

    using var cmd = new NpgsqlCommand(sql, conn);
    cmd.Parameters.AddWithValue("pattern", $"%{namePattern}%");
    cmd.Parameters.AddWithValue("minAge", minAge);
    cmd.Parameters.AddWithValue("maxAge", maxAge);

    using var reader = cmd.ExecuteReader();

    while (reader.Read())
    {
        users.Add(new User
        {
            Id = reader.GetInt32(0),
            Nom = reader.GetString(1),
            Email = reader.GetString(2),
            Age = reader.GetInt32(3),
            CreatedAt = reader.GetDateTime(4),
            UpdatedAt = reader.GetDateTime(5)
        });
    }

    return users;
}
```

**M√©thode helper pour mapper les r√©sultats :**

```csharp
private User MapReaderToUser(NpgsqlDataReader reader)
{
    return new User
    {
        Id = reader.GetInt32(reader.GetOrdinal("id")),
        Nom = reader.GetString(reader.GetOrdinal("nom")),
        Email = reader.GetString(reader.GetOrdinal("email")),
        Age = reader.GetInt32(reader.GetOrdinal("age")),
        CreatedAt = reader.GetDateTime(reader.GetOrdinal("created_at")),
        UpdatedAt = reader.GetDateTime(reader.GetOrdinal("updated_at"))
    };
}

public List<User> GetAllUsersV2()
{
    var users = new List<User>();

    using var conn = new NpgsqlConnection(_connectionString);
    conn.Open();

    string sql = "SELECT * FROM utilisateurs ORDER BY nom";
    using var cmd = new NpgsqlCommand(sql, conn);
    using var reader = cmd.ExecuteReader();

    while (reader.Read())
    {
        users.Add(MapReaderToUser(reader));
    }

    return users;
}
```

#### UPDATE : Modifier des donn√©es

```csharp
// Mettre √† jour un utilisateur
public User UpdateUser(int id, UpdateUserDto dto)
{
    using var conn = new NpgsqlConnection(_connectionString);
    conn.Open();

    string sql = @"
        UPDATE utilisateurs
        SET nom = @nom, email = @email, age = @age, updated_at = NOW()
        WHERE id = @id
        RETURNING id, nom, email, age, created_at, updated_at";

    using var cmd = new NpgsqlCommand(sql, conn);
    cmd.Parameters.AddWithValue("nom", dto.Nom);
    cmd.Parameters.AddWithValue("email", dto.Email);
    cmd.Parameters.AddWithValue("age", dto.Age ?? 0);
    cmd.Parameters.AddWithValue("id", id);

    using var reader = cmd.ExecuteReader();

    if (reader.Read())
    {
        return MapReaderToUser(reader);
    }

    throw new Exception("Utilisateur non trouv√©");
}

// Mise √† jour partielle (uniquement les champs fournis)
public void UpdateUserPartial(int id, UpdateUserDto dto)
{
    using var conn = new NpgsqlConnection(_connectionString);
    conn.Open();

    var updates = new List<string>();
    var cmd = new NpgsqlCommand { Connection = conn };

    if (!string.IsNullOrEmpty(dto.Nom))
    {
        updates.Add("nom = @nom");
        cmd.Parameters.AddWithValue("nom", dto.Nom);
    }

    if (!string.IsNullOrEmpty(dto.Email))
    {
        updates.Add("email = @email");
        cmd.Parameters.AddWithValue("email", dto.Email);
    }

    if (dto.Age.HasValue)
    {
        updates.Add("age = @age");
        cmd.Parameters.AddWithValue("age", dto.Age.Value);
    }

    if (updates.Count == 0)
    {
        throw new Exception("Aucun champ √† mettre √† jour");
    }

    updates.Add("updated_at = NOW()");

    cmd.CommandText = $"UPDATE utilisateurs SET {string.Join(", ", updates)} WHERE id = @id";
    cmd.Parameters.AddWithValue("id", id);

    int rowsAffected = cmd.ExecuteNonQuery();

    if (rowsAffected == 0)
    {
        throw new Exception("Utilisateur non trouv√©");
    }
}
```

#### DELETE : Supprimer des donn√©es

```csharp
// Supprimer un utilisateur
public void DeleteUser(int id)
{
    using var conn = new NpgsqlConnection(_connectionString);
    conn.Open();

    string sql = "DELETE FROM utilisateurs WHERE id = @id";

    using var cmd = new NpgsqlCommand(sql, conn);
    cmd.Parameters.AddWithValue("id", id);

    int rowsAffected = cmd.ExecuteNonQuery();

    if (rowsAffected == 0)
    {
        throw new Exception("Utilisateur non trouv√©");
    }
}

// Supprimer plusieurs utilisateurs
public int DeleteUsersByAge(int maxAge)
{
    using var conn = new NpgsqlConnection(_connectionString);
    conn.Open();

    string sql = "DELETE FROM utilisateurs WHERE age < @maxAge";

    using var cmd = new NpgsqlCommand(sql, conn);
    cmd.Parameters.AddWithValue("maxAge", maxAge);

    return cmd.ExecuteNonQuery();
}
```

### Gestion des Transactions

```csharp
public void TransferMoney(int fromAccountId, int toAccountId, decimal amount)
{
    using var conn = new NpgsqlConnection(_connectionString);
    conn.Open();

    using var transaction = conn.BeginTransaction();

    try
    {
        // Op√©ration 1 : D√©biter
        using (var cmd = new NpgsqlCommand(
            "UPDATE comptes SET solde = solde - @amount WHERE id = @id",
            conn, transaction))
        {
            cmd.Parameters.AddWithValue("amount", amount);
            cmd.Parameters.AddWithValue("id", fromAccountId);
            cmd.ExecuteNonQuery();
        }

        // Op√©ration 2 : Cr√©diter
        using (var cmd = new NpgsqlCommand(
            "UPDATE comptes SET solde = solde + @amount WHERE id = @id",
            conn, transaction))
        {
            cmd.Parameters.AddWithValue("amount", amount);
            cmd.Parameters.AddWithValue("id", toAccountId);
            cmd.ExecuteNonQuery();
        }

        // Valider
        transaction.Commit();
        Console.WriteLine("‚úÖ Transfert r√©ussi");
    }
    catch (Exception ex)
    {
        // Annuler
        transaction.Rollback();
        Console.WriteLine($"‚ùå Transfert annul√© : {ex.Message}");
        throw;
    }
}
```

**Transaction avec Savepoint :**

```csharp
public void ComplexTransaction()
{
    using var conn = new NpgsqlConnection(_connectionString);
    conn.Open();

    using var transaction = conn.BeginTransaction();

    try
    {
        // Op√©ration 1
        using (var cmd = new NpgsqlCommand("INSERT INTO logs (message) VALUES ('Op 1')", conn, transaction))
        {
            cmd.ExecuteNonQuery();
        }

        // Cr√©er un savepoint
        transaction.Save("savepoint1");

        try
        {
            // Op√©ration 2 (risqu√©e)
            using var cmd = new NpgsqlCommand("INSERT INTO risky_table (data) VALUES ('data')", conn, transaction);
            cmd.ExecuteNonQuery();
        }
        catch
        {
            // Revenir au savepoint
            transaction.Rollback("savepoint1");
            Console.WriteLine("Savepoint restaur√©");
        }

        // Op√©ration 3
        using (var cmd = new NpgsqlCommand("INSERT INTO logs (message) VALUES ('Op 3')", conn, transaction))
        {
            cmd.ExecuteNonQuery();
        }

        transaction.Commit();
    }
    catch
    {
        transaction.Rollback();
        throw;
    }
}
```

### Types de Donn√©es PostgreSQL

#### Types num√©riques

```csharp
// INTEGER, BIGINT
cmd.Parameters.AddWithValue("age", 30);
cmd.Parameters.AddWithValue("bigNumber", 1000000000L);

// NUMERIC/DECIMAL (utiliser decimal)
cmd.Parameters.AddWithValue("price", 19.99m);

// FLOAT/DOUBLE PRECISION
cmd.Parameters.AddWithValue("pi", 3.14159);
```

#### Types texte

```csharp
// VARCHAR, TEXT
cmd.Parameters.AddWithValue("nom", "Alice");
cmd.Parameters.AddWithValue("description", "Longue description...");
```

#### Types temporels

```csharp
using NpgsqlTypes;

// DATE
cmd.Parameters.Add("birthday", NpgsqlDbType.Date).Value = new DateTime(1995, 5, 15);

// TIMESTAMP
cmd.Parameters.Add("created_at", NpgsqlDbType.Timestamp).Value = DateTime.Now;

// TIMESTAMPTZ (avec timezone)
cmd.Parameters.Add("created_at_tz", NpgsqlDbType.TimestampTz).Value = DateTime.UtcNow;

// INTERVAL
cmd.Parameters.Add("duration", NpgsqlDbType.Interval).Value = TimeSpan.FromHours(2);
```

#### JSON et JSONB

```csharp
using System.Text.Json;
using NpgsqlTypes;

// Classe pour JSON
public class Profile
{
    public string Nom { get; set; }
    public int Age { get; set; }
    public List<string> Tags { get; set; }
}

// Insertion JSONB
var profile = new Profile
{
    Nom = "Alice",
    Age = 30,
    Tags = new List<string> { "developer", "postgresql" }
};

string profileJson = JsonSerializer.Serialize(profile);

cmd.Parameters.Add("profile", NpgsqlDbType.Jsonb).Value = profileJson;

// Lecture JSONB
string json = reader.GetString(reader.GetOrdinal("profile"));
Profile readProfile = JsonSerializer.Deserialize<Profile>(json);

// Requ√™te JSONB
string sql = "SELECT * FROM users WHERE profile->>'nom' = @nom";
cmd.Parameters.AddWithValue("nom", "Alice");
```

#### Arrays (Tableaux PostgreSQL)

```csharp
// Insertion d'array
string[] tags = { "csharp", "postgresql", "npgsql" };
cmd.Parameters.Add("tags", NpgsqlDbType.Array | NpgsqlDbType.Text).Value = tags;

// Lecture d'array
string[] readTags = (string[])reader["tags"];

foreach (string tag in readTags)
{
    Console.WriteLine(tag);
}

// Recherche dans array
string sql = "SELECT * FROM articles WHERE @tag = ANY(tags)";
cmd.Parameters.AddWithValue("tag", "postgresql");
```

#### UUID

```csharp
using System;

// G√©n√©ration UUID c√¥t√© C#
Guid id = Guid.NewGuid();
cmd.Parameters.Add("id", NpgsqlDbType.Uuid).Value = id;

// G√©n√©ration UUID c√¥t√© PostgreSQL
string sql = "INSERT INTO events (id, data) VALUES (gen_uuid_v7(), @data) RETURNING id";
cmd.Parameters.AddWithValue("data", "event data");

Guid newId = (Guid)cmd.ExecuteScalar();

// Lecture UUID
Guid sessionId = reader.GetGuid(reader.GetOrdinal("id"));
```

### Gestion des Erreurs

```csharp
using Npgsql;

try
{
    // Op√©ration de base de donn√©es
    CreateUser(newUser);
}
catch (PostgresException ex)
{
    // Erreurs PostgreSQL sp√©cifiques
    switch (ex.SqlState)
    {
        case "23505": // Unique violation
            Console.WriteLine("Erreur : Cette valeur existe d√©j√†");
            break;
        case "23503": // Foreign key violation
            Console.WriteLine("Erreur : R√©f√©rence introuvable");
            break;
        case "23502": // NOT NULL violation
            Console.WriteLine("Erreur : Champ obligatoire manquant");
            break;
        case "42P01": // Undefined table
            Console.WriteLine("Erreur : Table inexistante");
            break;
        default:
            Console.WriteLine($"Erreur PostgreSQL : {ex.Message}");
            break;
    }
}
catch (NpgsqlException ex)
{
    // Erreurs de connexion Npgsql
    Console.WriteLine($"Erreur de connexion : {ex.Message}");
}
catch (Exception ex)
{
    // Autres erreurs
    Console.WriteLine($"Erreur : {ex.Message}");
}
```

### Exemple Complet : API ASP.NET Core avec Npgsql

```csharp
using Microsoft.AspNetCore.Mvc;
using Npgsql;
using MyApp.Models;

// Program.cs (ASP.NET Core 6+)
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();
builder.Services.AddSingleton<UserRepository>(sp =>
    new UserRepository(builder.Configuration.GetConnectionString("PostgreSQL")));

var app = builder.Build();

app.MapControllers();
app.Run();

// appsettings.json
{
  "ConnectionStrings": {
    "PostgreSQL": "Host=localhost;Database=mydb;Username=user;Password=password"
  }
}

// Controllers/UsersController.cs
[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    private readonly UserRepository _repository;

    public UsersController(UserRepository repository)
    {
        _repository = repository;
    }

    // GET api/users
    [HttpGet]
    public ActionResult<List<User>> GetUsers()
    {
        try
        {
            var users = _repository.GetAllUsers();
            return Ok(users);
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { error = ex.Message });
        }
    }

    // GET api/users/5
    [HttpGet("{id}")]
    public ActionResult<User> GetUser(int id)
    {
        try
        {
            var user = _repository.GetUserById(id);

            if (user == null)
                return NotFound(new { error = "Utilisateur non trouv√©" });

            return Ok(user);
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { error = ex.Message });
        }
    }

    // POST api/users
    [HttpPost]
    public ActionResult<User> CreateUser([FromBody] CreateUserDto dto)
    {
        try
        {
            var user = _repository.CreateUser(dto);
            return CreatedAtAction(nameof(GetUser), new { id = user.Id }, user);
        }
        catch (PostgresException ex) when (ex.SqlState == "23505")
        {
            return Conflict(new { error = "Email d√©j√† utilis√©" });
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { error = ex.Message });
        }
    }

    // PUT api/users/5
    [HttpPut("{id}")]
    public ActionResult<User> UpdateUser(int id, [FromBody] UpdateUserDto dto)
    {
        try
        {
            var user = _repository.UpdateUser(id, dto);
            return Ok(user);
        }
        catch (Exception ex) when (ex.Message.Contains("non trouv√©"))
        {
            return NotFound(new { error = "Utilisateur non trouv√©" });
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { error = ex.Message });
        }
    }

    // DELETE api/users/5
    [HttpDelete("{id}")]
    public IActionResult DeleteUser(int id)
    {
        try
        {
            _repository.DeleteUser(id);
            return NoContent();
        }
        catch (Exception ex) when (ex.Message.Contains("non trouv√©"))
        {
            return NotFound(new { error = "Utilisateur non trouv√©" });
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { error = ex.Message });
        }
    }
}
```

---

## Partie 2 : Entity Framework Core (ORM)

### Introduction √† Entity Framework Core

**Entity Framework Core (EF Core)** est l'ORM moderne et cross-platform de Microsoft. Il offre :
- **Code-First** : D√©finissez vos mod√®les en C#, les tables sont g√©n√©r√©es automatiquement
- **LINQ** : Requ√™tes fortement typ√©es en C# au lieu de SQL
- **Change Tracking** : Suivi automatique des modifications
- **Migrations** : Gestion du sch√©ma de base de donn√©es
- **Relations** : Navigation properties automatiques

### Installation

```bash
# EF Core avec provider PostgreSQL
dotnet add package Microsoft.EntityFrameworkCore
dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL

# Outils pour les migrations
dotnet add package Microsoft.EntityFrameworkCore.Design

# CLI tools (global)
dotnet tool install --global dotnet-ef
```

### Configuration et DbContext

Le **DbContext** est le point central d'EF Core qui repr√©sente votre session avec la base de donn√©es.

```csharp
using Microsoft.EntityFrameworkCore;
using MyApp.Models;

namespace MyApp.Data
{
    public class AppDbContext : DbContext
    {
        public AppDbContext(DbContextOptions<AppDbContext> options) : base(options)
        {
        }

        // DbSets repr√©sentent les tables
        public DbSet<User> Users { get; set; }
        public DbSet<Post> Posts { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            // Configuration des entit√©s
            modelBuilder.Entity<User>(entity =>
            {
                entity.ToTable("utilisateurs");
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Nom).IsRequired().HasMaxLength(100);
                entity.Property(e => e.Email).IsRequired().HasMaxLength(255);
                entity.HasIndex(e => e.Email).IsUnique();
            });

            modelBuilder.Entity<Post>(entity =>
            {
                entity.ToTable("posts");
                entity.HasKey(e => e.Id);

                // Relation One-to-Many
                entity.HasOne(e => e.User)
                      .WithMany(e => e.Posts)
                      .HasForeignKey(e => e.UserId)
                      .OnDelete(DeleteBehavior.Cascade);
            });
        }
    }
}
```

**Configuration dans Program.cs (ASP.NET Core 6+) :**

```csharp
using Microsoft.EntityFrameworkCore;
using MyApp.Data;

var builder = WebApplication.CreateBuilder(args);

// Enregistrer le DbContext
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("PostgreSQL")));

var app = builder.Build();
app.Run();
```

### D√©finition des Mod√®les (Entities)

```csharp
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace MyApp.Models
{
    [Table("utilisateurs")]
    public class User
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int Id { get; set; }

        [Required]
        [MaxLength(100)]
        public string Nom { get; set; }

        [Required]
        [MaxLength(255)]
        [EmailAddress]
        public string Email { get; set; }

        public int Age { get; set; }

        [Column("created_at")]
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

        [Column("updated_at")]
        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

        // Navigation property (relation)
        public ICollection<Post> Posts { get; set; }
    }

    [Table("posts")]
    public class Post
    {
        public int Id { get; set; }

        [Required]
        [MaxLength(200)]
        public string Title { get; set; }

        public string Content { get; set; }

        public bool Published { get; set; } = false;

        // Foreign Key
        public int UserId { get; set; }

        // Navigation property
        public User User { get; set; }
    }
}
```

**Data Annotations courantes :**

| Annotation | Description | Exemple |
|------------|-------------|---------|
| `[Key]` | Cl√© primaire | `[Key] public int Id { get; set; }` |
| `[Required]` | NOT NULL | `[Required] public string Nom { get; set; }` |
| `[MaxLength]` | Taille max | `[MaxLength(100)] public string Nom { get; set; }` |
| `[Column]` | Nom de colonne | `[Column("created_at")] public DateTime CreatedAt { get; set; }` |
| `[Table]` | Nom de table | `[Table("utilisateurs")] public class User` |
| `[DatabaseGenerated]` | Auto-g√©n√©r√© | `[DatabaseGenerated(DatabaseGeneratedOption.Identity)]` |
| `[ForeignKey]` | Cl√© √©trang√®re | `[ForeignKey("UserId")] public User User { get; set; }` |
| `[Index]` | Index | `[Index(nameof(Email), IsUnique = true)]` |

### Migrations

Les **migrations** permettent de cr√©er et modifier le sch√©ma de base de donn√©es de mani√®re versionn√©e.

```bash
# Cr√©er une migration initiale
dotnet ef migrations add InitialCreate

# Appliquer les migrations √† la base de donn√©es
dotnet ef database update

# Cr√©er une nouvelle migration (apr√®s modification du mod√®le)
dotnet ef migrations add AddPostsTable

# Annuler la derni√®re migration
dotnet ef migrations remove

# Voir les migrations appliqu√©es
dotnet ef migrations list

# G√©n√©rer un script SQL
dotnet ef migrations script
```

**Migration programmatique (au d√©marrage) :**

```csharp
// Program.cs
var app = builder.Build();

// Appliquer les migrations au d√©marrage
using (var scope = app.Services.CreateScope())
{
    var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
    dbContext.Database.Migrate();
}

app.Run();
```

### CRUD avec Entity Framework Core

#### CREATE : Cr√©er des enregistrements

```csharp
public class UserService
{
    private readonly AppDbContext _context;

    public UserService(AppDbContext context)
    {
        _context = context;
    }

    // Cr√©er un utilisateur
    public async Task<User> CreateUserAsync(CreateUserDto dto)
    {
        var user = new User
        {
            Nom = dto.Nom,
            Email = dto.Email,
            Age = dto.Age
        };

        _context.Users.Add(user);
        await _context.SaveChangesAsync();

        return user; // Id est automatiquement rempli
    }

    // Cr√©er plusieurs utilisateurs (batch)
    public async Task CreateUsersAsync(List<CreateUserDto> dtos)
    {
        var users = dtos.Select(dto => new User
        {
            Nom = dto.Nom,
            Email = dto.Email,
            Age = dto.Age
        }).ToList();

        _context.Users.AddRange(users);
        await _context.SaveChangesAsync();
    }
}

// Utilisation
var service = new UserService(dbContext);
var newUser = await service.CreateUserAsync(new CreateUserDto
{
    Nom = "Alice",
    Email = "alice@example.com",
    Age = 30
});

Console.WriteLine($"Utilisateur cr√©√© : ID={newUser.Id}");
```

#### READ : Lire des donn√©es

```csharp
using Microsoft.EntityFrameworkCore;

// R√©cup√©rer un utilisateur par ID
public async Task<User> GetUserByIdAsync(int id)
{
    return await _context.Users.FindAsync(id);
}

// R√©cup√©rer par condition
public async Task<User> GetUserByEmailAsync(string email)
{
    return await _context.Users
        .FirstOrDefaultAsync(u => u.Email == email);
}

// R√©cup√©rer tous les utilisateurs
public async Task<List<User>> GetAllUsersAsync()
{
    return await _context.Users
        .OrderBy(u => u.Nom)
        .ToListAsync();
}

// Recherche avec filtres
public async Task<List<User>> SearchUsersAsync(string namePattern, int minAge, int maxAge)
{
    return await _context.Users
        .Where(u => u.Nom.Contains(namePattern) && u.Age >= minAge && u.Age <= maxAge)
        .OrderBy(u => u.Nom)
        .ToListAsync();
}

// Requ√™tes LINQ avanc√©es
public async Task<List<User>> GetAdultUsersAsync()
{
    return await _context.Users
        .Where(u => u.Age >= 18)
        .OrderByDescending(u => u.CreatedAt)
        .Take(10)
        .ToListAsync();
}

// Projection (s√©lectionner uniquement certains champs)
public async Task<List<object>> GetUserNamesAsync()
{
    return await _context.Users
        .Select(u => new { u.Id, u.Nom, u.Email })
        .ToListAsync<object>();
}

// Compter
public async Task<int> CountUsersAsync()
{
    return await _context.Users.CountAsync();
}

public async Task<int> CountAdultsAsync()
{
    return await _context.Users.CountAsync(u => u.Age >= 18);
}

// Pagination
public async Task<List<User>> GetUsersPaginatedAsync(int page, int pageSize)
{
    return await _context.Users
        .OrderBy(u => u.Id)
        .Skip((page - 1) * pageSize)
        .Take(pageSize)
        .ToListAsync();
}
```

#### UPDATE : Modifier des donn√©es

```csharp
// Mettre √† jour un utilisateur
public async Task<User> UpdateUserAsync(int id, UpdateUserDto dto)
{
    var user = await _context.Users.FindAsync(id);

    if (user == null)
        throw new Exception("Utilisateur non trouv√©");

    // Modifier les propri√©t√©s
    user.Nom = dto.Nom ?? user.Nom;
    user.Email = dto.Email ?? user.Email;
    user.Age = dto.Age ?? user.Age;
    user.UpdatedAt = DateTime.UtcNow;

    // EF Core track automatiquement les changements
    await _context.SaveChangesAsync();

    return user;
}

// Mise √† jour sans tracking (plus performant)
public async Task UpdateUserNoTrackingAsync(int id, UpdateUserDto dto)
{
    var user = new User
    {
        Id = id,
        Nom = dto.Nom,
        Email = dto.Email,
        Age = dto.Age ?? 0,
        UpdatedAt = DateTime.UtcNow
    };

    _context.Users.Attach(user);
    _context.Entry(user).State = EntityState.Modified;

    await _context.SaveChangesAsync();
}

// Mise √† jour partielle (ExecuteUpdate - EF Core 7+)
public async Task UpdateUserAgeAsync(int id, int newAge)
{
    await _context.Users
        .Where(u => u.Id == id)
        .ExecuteUpdateAsync(setters => setters
            .SetProperty(u => u.Age, newAge)
            .SetProperty(u => u.UpdatedAt, DateTime.UtcNow));
}

// Mise √† jour multiple
public async Task IncrementAllAgesAsync()
{
    await _context.Users
        .ExecuteUpdateAsync(setters => setters
            .SetProperty(u => u.Age, u => u.Age + 1));
}
```

#### DELETE : Supprimer des donn√©es

```csharp
// Supprimer un utilisateur
public async Task DeleteUserAsync(int id)
{
    var user = await _context.Users.FindAsync(id);

    if (user == null)
        throw new Exception("Utilisateur non trouv√©");

    _context.Users.Remove(user);
    await _context.SaveChangesAsync();
}

// Supprimer sans charger l'entit√© (plus performant)
public async Task DeleteUserNoTrackingAsync(int id)
{
    var user = new User { Id = id };
    _context.Users.Attach(user);
    _context.Users.Remove(user);
    await _context.SaveChangesAsync();
}

// Suppression multiple (ExecuteDelete - EF Core 7+)
public async Task DeleteUsersByAgeAsync(int maxAge)
{
    await _context.Users
        .Where(u => u.Age < maxAge)
        .ExecuteDeleteAsync();
}

// Soft Delete (suppression logique)
public async Task SoftDeleteUserAsync(int id)
{
    var user = await _context.Users.FindAsync(id);

    if (user == null)
        throw new Exception("Utilisateur non trouv√©");

    user.DeletedAt = DateTime.UtcNow; // Ajouter cette propri√©t√© au mod√®le
    await _context.SaveChangesAsync();
}
```

### Relations dans EF Core

#### One-to-Many (Un √† Plusieurs)

```csharp
// User a plusieurs Posts
public class User
{
    public int Id { get; set; }
    public string Nom { get; set; }

    // Navigation property
    public ICollection<Post> Posts { get; set; }
}

// Post appartient √† un User
public class Post
{
    public int Id { get; set; }
    public string Title { get; set; }

    public int UserId { get; set; }
    public User User { get; set; }
}

// Utilisation
// Cr√©er un utilisateur avec posts
var user = new User
{
    Nom = "Alice",
    Posts = new List<Post>
    {
        new Post { Title = "Post 1", Content = "Contenu 1" },
        new Post { Title = "Post 2", Content = "Contenu 2" }
    }
};

_context.Users.Add(user);
await _context.SaveChangesAsync();

// Charger avec Include (Eager Loading)
var userWithPosts = await _context.Users
    .Include(u => u.Posts)
    .FirstOrDefaultAsync(u => u.Id == 1);

// Lazy Loading (n√©cessite proxies)
// Install-Package Microsoft.EntityFrameworkCore.Proxies
var user = await _context.Users.FindAsync(1);
var posts = user.Posts; // Charg√© automatiquement

// Explicit Loading
var user = await _context.Users.FindAsync(1);
await _context.Entry(user).Collection(u => u.Posts).LoadAsync();
```

#### Many-to-Many (Plusieurs √† Plusieurs)

```csharp
// EF Core 5+ : Configuration automatique
public class Post
{
    public int Id { get; set; }
    public string Title { get; set; }

    public ICollection<Tag> Tags { get; set; }
}

public class Tag
{
    public int Id { get; set; }
    public string Name { get; set; }

    public ICollection<Post> Posts { get; set; }
}

// Utilisation
var post = new Post
{
    Title = "Mon article",
    Tags = new List<Tag>
    {
        new Tag { Name = "csharp" },
        new Tag { Name = "postgresql" }
    }
};

_context.Posts.Add(post);
await _context.SaveChangesAsync();

// Charger avec tags
var postWithTags = await _context.Posts
    .Include(p => p.Tags)
    .FirstOrDefaultAsync(p => p.Id == 1);

// Ajouter un tag √† un post existant
var post = await _context.Posts.FindAsync(1);
var tag = await _context.Tags.FindAsync(3);

post.Tags.Add(tag);
await _context.SaveChangesAsync();
```

#### One-to-One (Un √† Un)

```csharp
public class User
{
    public int Id { get; set; }
    public string Nom { get; set; }

    public Profile Profile { get; set; }
}

public class Profile
{
    public int Id { get; set; }
    public string Bio { get; set; }

    public int UserId { get; set; }
    public User User { get; set; }
}

// Configuration dans OnModelCreating
modelBuilder.Entity<User>()
    .HasOne(u => u.Profile)
    .WithOne(p => p.User)
    .HasForeignKey<Profile>(p => p.UserId);
```

### Transactions avec EF Core

```csharp
// Transaction automatique (SaveChanges)
// Toutes les modifications dans SaveChanges sont atomiques
await _context.Users.AddAsync(user1);
await _context.Users.AddAsync(user2);
await _context.SaveChangesAsync(); // Transaction automatique

// Transaction explicite
public async Task TransferMoneyAsync(int fromAccountId, int toAccountId, decimal amount)
{
    using var transaction = await _context.Database.BeginTransactionAsync();

    try
    {
        // Op√©ration 1
        var fromAccount = await _context.Accounts.FindAsync(fromAccountId);
        fromAccount.Balance -= amount;

        // Op√©ration 2
        var toAccount = await _context.Accounts.FindAsync(toAccountId);
        toAccount.Balance += amount;

        await _context.SaveChangesAsync();
        await transaction.CommitAsync();
    }
    catch
    {
        await transaction.RollbackAsync();
        throw;
    }
}

// Transaction avec scope
public async Task ComplexOperationAsync()
{
    using var transaction = await _context.Database.BeginTransactionAsync();

    try
    {
        await _context.Users.AddAsync(new User { Nom = "Alice" });
        await _context.SaveChangesAsync();

        await _context.Posts.AddAsync(new Post { Title = "Post 1", UserId = 1 });
        await _context.SaveChangesAsync();

        await transaction.CommitAsync();
    }
    catch
    {
        await transaction.RollbackAsync();
        throw;
    }
}
```

### Requ√™tes Brutes (Raw SQL)

```csharp
// Requ√™te SQL brute avec FromSqlRaw
var users = await _context.Users
    .FromSqlRaw("SELECT * FROM utilisateurs WHERE age > {0}", 18)
    .ToListAsync();

// Requ√™te SQL interpol√©e (recommand√©)
int minAge = 18;
var users = await _context.Users
    .FromSqlInterpolated($"SELECT * FROM utilisateurs WHERE age > {minAge}")
    .ToListAsync();

// Ex√©cuter SQL sans r√©sultat
await _context.Database.ExecuteSqlRawAsync(
    "UPDATE utilisateurs SET age = age + 1 WHERE age < {0}", 50);

// Proc√©dures stock√©es
var users = await _context.Users
    .FromSqlRaw("CALL get_users_by_age(@p0)", 18)
    .ToListAsync();
```

### Exemple Complet : API ASP.NET Core avec EF Core

```csharp
// Program.cs
using Microsoft.EntityFrameworkCore;
using MyApp.Data;
using MyApp.Services;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("PostgreSQL")));

builder.Services.AddScoped<UserService>();

var app = builder.Build();

// Appliquer les migrations
using (var scope = app.Services.CreateScope())
{
    var context = scope.ServiceProvider.GetRequiredService<AppDbContext>();
    context.Database.Migrate();
}

app.MapControllers();
app.Run();

// Services/UserService.cs
public class UserService
{
    private readonly AppDbContext _context;

    public UserService(AppDbContext context)
    {
        _context = context;
    }

    public async Task<List<User>> GetAllUsersAsync()
    {
        return await _context.Users.OrderBy(u => u.Nom).ToListAsync();
    }

    public async Task<User> GetUserByIdAsync(int id)
    {
        return await _context.Users.FindAsync(id);
    }

    public async Task<User> CreateUserAsync(CreateUserDto dto)
    {
        var user = new User
        {
            Nom = dto.Nom,
            Email = dto.Email,
            Age = dto.Age
        };

        _context.Users.Add(user);
        await _context.SaveChangesAsync();

        return user;
    }

    public async Task<User> UpdateUserAsync(int id, UpdateUserDto dto)
    {
        var user = await _context.Users.FindAsync(id);

        if (user == null)
            return null;

        user.Nom = dto.Nom ?? user.Nom;
        user.Email = dto.Email ?? user.Email;
        user.Age = dto.Age ?? user.Age;
        user.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();

        return user;
    }

    public async Task<bool> DeleteUserAsync(int id)
    {
        var user = await _context.Users.FindAsync(id);

        if (user == null)
            return false;

        _context.Users.Remove(user);
        await _context.SaveChangesAsync();

        return true;
    }
}

// Controllers/UsersController.cs
[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    private readonly UserService _service;

    public UsersController(UserService service)
    {
        _service = service;
    }

    [HttpGet]
    public async Task<ActionResult<List<User>>> GetUsers()
    {
        var users = await _service.GetAllUsersAsync();
        return Ok(users);
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<User>> GetUser(int id)
    {
        var user = await _service.GetUserByIdAsync(id);

        if (user == null)
            return NotFound(new { error = "Utilisateur non trouv√©" });

        return Ok(user);
    }

    [HttpPost]
    public async Task<ActionResult<User>> CreateUser([FromBody] CreateUserDto dto)
    {
        try
        {
            var user = await _service.CreateUserAsync(dto);
            return CreatedAtAction(nameof(GetUser), new { id = user.Id }, user);
        }
        catch (DbUpdateException ex) when (ex.InnerException is PostgresException pgEx && pgEx.SqlState == "23505")
        {
            return Conflict(new { error = "Email d√©j√† utilis√©" });
        }
    }

    [HttpPut("{id}")]
    public async Task<ActionResult<User>> UpdateUser(int id, [FromBody] UpdateUserDto dto)
    {
        var user = await _service.UpdateUserAsync(id, dto);

        if (user == null)
            return NotFound(new { error = "Utilisateur non trouv√©" });

        return Ok(user);
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteUser(int id)
    {
        var deleted = await _service.DeleteUserAsync(id);

        if (!deleted)
            return NotFound(new { error = "Utilisateur non trouv√©" });

        return NoContent();
    }
}
```

---

## Comparaison : Npgsql vs Entity Framework Core

### Performance

**Benchmark indicatif (10000 requ√™tes SELECT) :**
- **Npgsql** : ~900ms
- **EF Core** : ~1300ms

**Diff√©rence :** EF Core est ~30-45% plus lent que Npgsql brut, mais reste tr√®s performant pour la plupart des applications.

### Complexit√© du Code

**Npgsql :**
```csharp
// Plus verbeux mais contr√¥le total
using var conn = new NpgsqlConnection(connectionString);
conn.Open();

string sql = "SELECT * FROM users WHERE age > @age";
using var cmd = new NpgsqlCommand(sql, conn);
cmd.Parameters.AddWithValue("age", 18);

using var reader = cmd.ExecuteReader();
var users = new List<User>();

while (reader.Read())
{
    users.Add(new User
    {
        Id = reader.GetInt32(0),
        Nom = reader.GetString(1)
    });
}
```

**EF Core :**
```csharp
// Concis et fortement typ√©
var users = await _context.Users
    .Where(u => u.Age > 18)
    .ToListAsync();
```

### Quand Utiliser Chaque Approche

#### Npgsql (ADO.NET) ‚úÖ

**Choisir Npgsql si :**
- Besoin de **performances maximales**
- Requ√™tes SQL **tr√®s complexes** (CTEs avanc√©s, optimisations sp√©cifiques)
- **Microservices** ultra-l√©gers
- Contr√¥le total sur le SQL g√©n√©r√©
- Batch processing massif
- Pas besoin de Change Tracking

**Exemples de cas d'usage :**
- API haute performance (>20k req/s)
- ETL et data pipelines
- Syst√®mes analytiques temps r√©el
- Migration de donn√©es massives

#### Entity Framework Core ‚úÖ

**Choisir EF Core si :**
- Productivit√© et **d√©veloppement rapide**
- Application **CRUD standard**
- Besoin de **migrations automatiques**
- Relations complexes entre entit√©s
- **Change Tracking** utile
- √âquipe .NET standard
- Prototypage et MVP

**Exemples de cas d'usage :**
- API REST ASP.NET Core
- Applications web e-commerce
- Syst√®mes de gestion interne
- SaaS standard

### Approche Hybride

Vous pouvez **combiner** les deux dans la m√™me application :

```csharp
// Configuration
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseNpgsql(connectionString));

builder.Services.AddSingleton<NpgsqlConnection>(sp =>
    new NpgsqlConnection(connectionString));

// Dans un service
public class ReportService
{
    private readonly AppDbContext _context;
    private readonly NpgsqlConnection _npgsqlConn;

    public ReportService(AppDbContext context, NpgsqlConnection npgsqlConn)
    {
        _context = context;
        _npgsqlConn = npgsqlConn;
    }

    // Utiliser EF Core pour CRUD simple
    public async Task<User> GetUserAsync(int id)
    {
        return await _context.Users.FindAsync(id);
    }

    // Utiliser Npgsql pour requ√™tes complexes
    public async Task<List<MonthlyStats>> GetMonthlyStatsAsync()
    {
        await _npgsqlConn.OpenAsync();

        string sql = @"
            WITH monthly_stats AS (
                SELECT DATE_TRUNC('month', created_at) as month,
                       COUNT(*) as user_count,
                       AVG(age) as avg_age
                FROM users
                GROUP BY month
            )
            SELECT * FROM monthly_stats
            ORDER BY month DESC
            LIMIT 12";

        using var cmd = new NpgsqlCommand(sql, _npgsqlConn);
        using var reader = await cmd.ExecuteReaderAsync();

        var stats = new List<MonthlyStats>();
        while (await reader.ReadAsync())
        {
            stats.Add(new MonthlyStats
            {
                Month = reader.GetDateTime(0),
                UserCount = reader.GetInt32(1),
                AvgAge = reader.GetDouble(2)
            });
        }

        return stats;
    }
}
```

---

## Bonnes Pratiques

### 1. Toujours Utiliser le Pooling de Connexions

‚úÖ **Bon :** Le pooling est activ√© par d√©faut dans Npgsql
```csharp
// Configuration recommand√©e
"Pooling=true;Maximum Pool Size=100;Minimum Pool Size=10"
```

### 2. Utiliser Async/Await

```csharp
// ‚úÖ Bon : Async pour √©viter de bloquer les threads
var users = await _context.Users.ToListAsync();

// ‚ùå √âviter : Synchrone bloquant
var users = _context.Users.ToList();
```

### 3. Disposer Correctement les Ressources

```csharp
// ‚úÖ Bon : using statement
using var conn = new NpgsqlConnection(connectionString);

// ‚úÖ Bon : using declaration (C# 8+)
using var context = new AppDbContext(options);

// ‚ùå √âviter : Oublier de disposer
var conn = new NpgsqlConnection(connectionString);
// ... oubli de conn.Dispose()
```

### 4. Utiliser AsNoTracking pour les Lectures Seules

```csharp
// ‚úÖ Bon : Meilleure performance pour lecture seule
var users = await _context.Users
    .AsNoTracking()
    .ToListAsync();

// ‚ùå √âviter : Tracking inutile pour lecture
var users = await _context.Users.ToListAsync();
```

### 5. Projections pour S√©lectionner Uniquement les Donn√©es N√©cessaires

```csharp
// ‚úÖ Bon : Projection
var userNames = await _context.Users
    .Select(u => new { u.Id, u.Nom })
    .ToListAsync();

// ‚ùå √âviter : Charger toutes les colonnes
var users = await _context.Users.ToListAsync();
var names = users.Select(u => u.Nom);
```

### 6. Gestion des Erreurs PostgreSQL

```csharp
// ‚úÖ Bon : Gestion sp√©cifique
try
{
    await _context.SaveChangesAsync();
}
catch (DbUpdateException ex) when (ex.InnerException is PostgresException pgEx)
{
    switch (pgEx.SqlState)
    {
        case "23505":
            throw new DuplicateKeyException("Valeur d√©j√† existante");
        case "23503":
            throw new ForeignKeyException("R√©f√©rence invalide");
        default:
            throw;
    }
}
```

### 7. Utiliser des Indexes

```csharp
// Configuration des index dans OnModelCreating
modelBuilder.Entity<User>(entity =>
{
    entity.HasIndex(u => u.Email).IsUnique();
    entity.HasIndex(u => u.Age);
    entity.HasIndex(u => new { u.Nom, u.Age }); // Index composite
});
```

### 8. Pagination Efficace

```csharp
// ‚úÖ Bon : Pagination avec Skip/Take
var users = await _context.Users
    .OrderBy(u => u.Id)
    .Skip((page - 1) * pageSize)
    .Take(pageSize)
    .ToListAsync();
```

---

## Ressources et Documentation

### Npgsql
- **Documentation officielle** : https://www.npgsql.org/doc/
- **GitHub** : https://github.com/npgsql/npgsql
- **NuGet** : https://www.nuget.org/packages/Npgsql

### Entity Framework Core
- **Documentation officielle** : https://docs.microsoft.com/en-us/ef/core/
- **EF Core avec PostgreSQL** : https://www.npgsql.org/efcore/
- **GitHub** : https://github.com/dotnet/efcore

### ASP.NET Core
- **Documentation** : https://docs.microsoft.com/en-us/aspnet/core/
- **Tutorials** : https://docs.microsoft.com/en-us/aspnet/core/tutorials/

---

## R√©sum√© des Points Cl√©s

### Npgsql (ADO.NET)

- ‚úÖ **Provider natif** PostgreSQL haute performance
- ‚úÖ Pooling de connexions activ√© par d√©faut
- ‚úÖ Support complet des types PostgreSQL
- ‚úÖ API **ADO.NET** standard .NET
- ‚úÖ **Contr√¥le total** sur le SQL
- ‚úÖ Id√©al pour **performances critiques**

### Entity Framework Core

- ‚úÖ **ORM moderne** de Microsoft
- ‚úÖ **LINQ** : requ√™tes fortement typ√©es en C#
- ‚úÖ **Migrations** automatiques (Code-First)
- ‚úÖ **Change Tracking** automatique
- ‚úÖ Relations et **Navigation Properties**
- ‚úÖ **Productivit√©** √©lev√©e
- ‚úÖ Id√©al pour **d√©veloppement rapide** et maintenabilit√©

### Choix Final

**Pour 80% des projets .NET :** Entity Framework Core (productivit√©, maintenabilit√©)
**Pour performances critiques :** Npgsql (contr√¥le, vitesse)
**Approche hybride :** EF Core pour CRUD + Npgsql pour requ√™tes complexes

---

**Prochaine √©tape :** Explorez les patterns de conception (Repository, Unit of Work) et les architectures modernes (Clean Architecture, CQRS) pour structurer efficacement vos applications .NET avec PostgreSQL.

‚è≠Ô∏è [Gestion des connexions dans les applications](/20-drivers-connexion-applicative/02-gestion-des-connexions.md)
