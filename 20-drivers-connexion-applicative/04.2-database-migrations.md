üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.4.2. Database Migrations (Flyway, Liquibase, Alembic)

## Introduction

Les **migrations de base de donn√©es** (database migrations) sont un syst√®me de gestion des modifications du sch√©ma de votre base de donn√©es PostgreSQL au fil du temps. Pensez-y comme un **syst√®me de contr√¥le de version (Git) pour votre base de donn√©es**.

### M√©taphore : Le carnet de suivi

Imaginez que votre base de donn√©es PostgreSQL soit un immeuble en construction :
- **Sans migrations** : Vous modifiez l'immeuble au hasard, personne ne sait ce qui a √©t√© fait, quand, ni par qui
- **Avec migrations** : Chaque modification est document√©e dans un carnet (migration file), num√©rot√©e, dat√©e, et peut √™tre rejou√©e ou annul√©e

Les migrations permettent de **tracer l'√©volution** de votre sch√©ma de base de donn√©es, de la synchroniser entre plusieurs environnements (d√©veloppement, test, production), et de collaborer en √©quipe sans chaos.

## Le probl√®me sans migrations

### Sc√©nario typique sans syst√®me de migration

Vous d√©veloppez une application avec PostgreSQL :

**Jour 1 - D√©veloppeur A :**
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100)
);
```

**Jour 5 - D√©veloppeur B :**
```sql
-- Ajoute une colonne email
ALTER TABLE users ADD COLUMN email VARCHAR(255);
```

**Jour 10 - D√©veloppeur C :**
```sql
-- Renomme la colonne name en full_name
ALTER TABLE users RENAME COLUMN name TO full_name;
```

### Les probl√®mes qui surviennent :

#### 1. D√©synchronisation des environnements
```plaintext
Base de donn√©es locale du D√©veloppeur A :
  users(id, name, email)

Base de donn√©es locale du D√©veloppeur B :
  users(id, full_name, email)

Base de donn√©es de production :
  users(id, name)  ‚Üê Pas √† jour !

‚Üí Le code de l'application ne fonctionne pas partout
```

#### 2. Impossible de recr√©er la base

Si vous perdez votre base de donn√©es de production, comment la recr√©er dans le bon √©tat ? Vous avez lanc√© des dizaines de requ√™tes SQL au fil des mois, impossible de se souvenir de toutes.

#### 3. Collaboration difficile

Quand plusieurs d√©veloppeurs modifient le sch√©ma en parall√®le, les conflits sont in√©vitables et difficiles √† r√©soudre.

#### 4. D√©ploiements risqu√©s

Lors du d√©ploiement d'une nouvelle version de l'application, vous devez vous souvenir manuellement des modifications SQL √† appliquer sur la production. Oubliez une modification et l'application plante.

#### 5. Rollback impossible

Si une mise √† jour de production √©choue, comment revenir en arri√®re ? Sans historique structur√©, c'est tr√®s risqu√©.

## La solution : Les migrations de base de donn√©es

### Principe fondamental

Les migrations transforment les modifications de sch√©ma en **fichiers de migration versionn√©s** :

```plaintext
Historique des migrations :
‚îú‚îÄ‚îÄ 001_create_users_table.sql
‚îú‚îÄ‚îÄ 002_add_email_to_users.sql
‚îú‚îÄ‚îÄ 003_rename_name_to_full_name.sql
‚îú‚îÄ‚îÄ 004_create_orders_table.sql
‚îî‚îÄ‚îÄ 005_add_index_on_email.sql

Chaque fichier :
  ‚úÖ Est num√©rot√© (ordre d'ex√©cution)
  ‚úÖ D√©crit une modification atomique
  ‚úÖ Est versionn√© dans Git
  ‚úÖ Peut √™tre rejou√© sur n'importe quelle base
```

### Le workflow avec migrations

```plaintext
1. D√©veloppement local :
   D√©veloppeur cr√©e ‚Üí 006_add_phone_to_users.sql
   Ex√©cute la migration localement
   Commit le fichier dans Git

2. Autres d√©veloppeurs :
   Pull le code depuis Git
   Ex√©cutent automatiquement la nouvelle migration
   Leurs bases locales sont synchronis√©es

3. Tests / Staging :
   D√©ploiement automatique
   Les migrations s'appliquent automatiquement
   Base de test identique au d√©veloppement

4. Production :
   D√©ploiement
   Les migrations s'appliquent automatiquement
   Tra√ßabilit√© compl√®te de ce qui a √©t√© appliqu√©
```

### M√©tadonn√©es de migration

Les outils de migration cr√©ent une **table de suivi** dans PostgreSQL :

```sql
-- Table cr√©√©e automatiquement par l'outil de migration
CREATE TABLE schema_migrations (
    version VARCHAR(255) PRIMARY KEY,
    description TEXT,
    applied_at TIMESTAMP DEFAULT NOW(),
    execution_time_ms INTEGER,
    success BOOLEAN
);
```

Exemple de contenu :

```plaintext
version | description              | applied_at          | success
--------|--------------------------|---------------------|--------
001     | create_users_table       | 2025-01-15 10:00:00 | true
002     | add_email_to_users       | 2025-01-20 14:30:00 | true
003     | rename_name_to_full_name | 2025-01-25 09:15:00 | true
004     | create_orders_table      | 2025-02-01 11:45:00 | true
```

Gr√¢ce √† cette table, l'outil sait :
- Quelles migrations ont √©t√© appliqu√©es
- Quelles migrations restent √† appliquer
- Dans quel ordre les appliquer

## Les trois outils principaux

Il existe de nombreux outils de migration, mais trois sont particuli√®rement populaires dans l'√©cosyst√®me PostgreSQL :

### Tableau comparatif rapide

| Crit√®re              | Flyway                | Liquibase            | Alembic              |
|----------------------|-----------------------|----------------------|----------------------|
| **Langage principal** | Java                  | Java                 | Python               |
| **Format migrations** | SQL (+ Java)          | SQL, XML, JSON, YAML | Python (+ SQL)       |
| **Courbe apprentissage** | Facile             | Moyenne              | Moyenne              |
| **√âcosyst√®me**       | JVM (Java, Kotlin)    | JVM + autres         | Python (Django, Flask) |
| **Open Source**      | ‚úÖ Oui (+ version Pro) | ‚úÖ Oui (+ version Pro) | ‚úÖ Oui               |
| **Type de migrations** | Versionn√©es, Repeatable | Versionn√©es, ChangeSet | Versionn√©es (Alembic) |
| **Rollback**         | üî∂ Limit√© (version gratuite) | ‚úÖ Complet        | ‚úÖ Complet           |
| **CI/CD**            | ‚úÖ Excellent          | ‚úÖ Excellent         | ‚úÖ Excellent         |
| **PostgreSQL**       | ‚úÖ Support complet    | ‚úÖ Support complet   | ‚úÖ Support complet   |

---

## 1. Flyway : Simplicit√© et efficacit√©

### Philosophie

Flyway est con√ßu pour √™tre **simple et direct** : vous √©crivez du SQL pur, vous num√©rotez vos fichiers, Flyway les ex√©cute dans l'ordre. Pas de format propri√©taire, pas de complexit√© inutile.

**Slogan officieux :** *"Migrations made easy"*

### Origine

D√©velopp√© en Java, Flyway est particuli√®rement populaire dans l'√©cosyst√®me Java/Spring Boot, mais fonctionne avec n'importe quelle stack via sa CLI (Command Line Interface).

### Fonctionnement

#### Structure des fichiers de migration

Flyway utilise une **convention de nommage stricte** :

```plaintext
Format : V{version}__{description}.sql

Exemples :
  V1__create_users_table.sql
  V2__add_email_to_users.sql
  V3__create_orders_table.sql
  V4__add_index_on_email.sql
  V2.1__add_phone_to_users.sql  (version interm√©diaire)
```

**R√®gles :**
- Commence par `V` (Versioned migration)
- Suivi d'un num√©ro de version (1, 2, 3, ou 1.1, 1.2, etc.)
- Deux underscores `__`
- Description lisible (snake_case)
- Extension `.sql`

#### Exemple de migration Flyway

**Fichier : V1__create_users_table.sql**
```sql
-- Flyway migration: Create users table
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    full_name VARCHAR(255) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Cr√©er un index pour optimiser les recherches
CREATE INDEX idx_users_email ON users(email);
```

**Fichier : V2__add_phone_to_users.sql**
```sql
-- Flyway migration: Add phone number to users
ALTER TABLE users
ADD COLUMN phone VARCHAR(20);

-- Commentaire pour documentation
COMMENT ON COLUMN users.phone IS 'User phone number (optional)';
```

#### Commandes Flyway principales

```plaintext
flyway migrate
  ‚Üí Applique toutes les migrations en attente
  ‚Üí Ex√©cute les fichiers V1, V2, V3... dans l'ordre
  ‚Üí Met √† jour la table flyway_schema_history

flyway info
  ‚Üí Affiche l'√©tat de toutes les migrations
  ‚Üí Lesquelles sont appliqu√©es, lesquelles sont en attente

flyway validate
  ‚Üí V√©rifie que les migrations appliqu√©es n'ont pas √©t√© modifi√©es
  ‚Üí D√©tecte les incoh√©rences

flyway clean
  ‚Üí ‚ö†Ô∏è Supprime TOUTES les tables (base vide)
  ‚Üí Uniquement pour d√©veloppement !

flyway repair
  ‚Üí Corrige la table flyway_schema_history
  ‚Üí Utile en cas de migration √©chou√©e
```

#### Table de m√©tadonn√©es

Flyway cr√©e automatiquement la table `flyway_schema_history` :

```sql
CREATE TABLE flyway_schema_history (
    installed_rank INT NOT NULL,
    version VARCHAR(50),
    description VARCHAR(200) NOT NULL,
    type VARCHAR(20) NOT NULL,
    script VARCHAR(1000) NOT NULL,
    checksum INT,
    installed_by VARCHAR(100) NOT NULL,
    installed_on TIMESTAMP NOT NULL DEFAULT NOW(),
    execution_time INT NOT NULL,
    success BOOLEAN NOT NULL
);
```

Cette table enregistre **chaque migration ex√©cut√©e** avec son checksum (empreinte) pour d√©tecter toute modification ult√©rieure.

#### Migrations r√©p√©tables (Repeatable Migrations)

Flyway propose aussi des migrations **r√©p√©tables** qui s'ex√©cutent √† chaque fois qu'elles changent :

```plaintext
Format : R__{description}.sql

Exemples :
  R__create_view_active_users.sql
  R__create_function_calculate_total.sql

Cas d'usage :
  - Vues (VIEW)
  - Fonctions (FUNCTION)
  - Proc√©dures stock√©es
  - Triggers

‚Üí R√©-ex√©cut√©es automatiquement si le fichier change
```

**Exemple : R__create_view_active_users.sql**
```sql
-- Repeatable migration: Vue des utilisateurs actifs
CREATE OR REPLACE VIEW active_users AS
SELECT id, email, full_name
FROM users
WHERE deleted_at IS NULL
ORDER BY created_at DESC;
```

### Avantages de Flyway

- ‚úÖ **Simplicit√©** : SQL pur, pas de syntaxe propri√©taire √† apprendre
- ‚úÖ **Convention de nommage claire** : On comprend imm√©diatement l'ordre et le contenu
- ‚úÖ **Rapide √† mettre en place** : Configuration minimale
- ‚úÖ **CLI puissante** : Utilisable dans n'importe quel projet (Java, Node, Python, Go...)
- ‚úÖ **Int√©gration CI/CD** : Facile √† int√©grer dans les pipelines
- ‚úÖ **Validation automatique** : D√©tecte les modifications de migrations appliqu√©es

### Inconv√©nients de Flyway

- ‚ùå **Rollback limit√©** : Version gratuite ne supporte pas les rollbacks automatiques (version Pro payante requise)
- ‚ùå **Pas de g√©n√©ration automatique** : Vous devez √©crire le SQL manuellement
- ‚ùå **Migrations bidirectionnelles difficiles** : Pas de concept "UP/DOWN" natif
- ‚ùå **Version Pro payante** : Fonctionnalit√©s avanc√©es (rollback, undo, dry-run) n√©cessitent une licence

### Cas d'usage id√©aux

- Applications Java/Spring Boot (int√©gration native)
- Projets pr√©f√©rant SQL pur sans abstraction
- √âquipes voulant un outil simple et direct
- CI/CD automatis√©s n√©cessitant peu de configuration

---

## 2. Liquibase : Flexibilit√© et puissance

### Philosophie

Liquibase se veut **flexible et agnostique** : vous pouvez √©crire vos migrations en SQL, XML, JSON ou YAML. Il offre aussi des capacit√©s de rollback avanc√©es et de g√©n√©ration automatique de migrations.

**Slogan officieux :** *"Source control for your database"*

### Origine

D√©velopp√© en Java comme Flyway, mais avec une approche plus abstraite et orient√©e m√©tadonn√©es.

### Fonctionnement

#### Structure des fichiers de migration

Liquibase utilise des **ChangeSets** (ensembles de modifications) organis√©s dans un fichier principal :

```plaintext
Structure typique :
‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îú‚îÄ‚îÄ changelog/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ db.changelog-master.xml (ou .yaml/.json)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ changes/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 001-create-users-table.sql
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 002-add-email-to-users.sql
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ 003-create-orders-table.sql
```

#### Formats support√©s

##### 1. XML (Format historique)

**Fichier : db.changelog-master.xml**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
    xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
    http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">

    <changeSet id="1" author="john">
        <createTable tableName="users">
            <column name="id" type="SERIAL">
                <constraints primaryKey="true"/>
            </column>
            <column name="email" type="VARCHAR(255)">
                <constraints nullable="false" unique="true"/>
            </column>
            <column name="full_name" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
        </createTable>
    </changeSet>

    <changeSet id="2" author="jane">
        <addColumn tableName="users">
            <column name="phone" type="VARCHAR(20)"/>
        </addColumn>
    </changeSet>

</databaseChangeLog>
```

##### 2. YAML (Format moderne et lisible)

**Fichier : db.changelog-master.yaml**
```yaml
databaseChangeLog:
  - changeSet:
      id: 1
      author: john
      changes:
        - createTable:
            tableName: users
            columns:
              - column:
                  name: id
                  type: SERIAL
                  constraints:
                    primaryKey: true
              - column:
                  name: email
                  type: VARCHAR(255)
                  constraints:
                    nullable: false
                    unique: true
              - column:
                  name: full_name
                  type: VARCHAR(255)
                  constraints:
                    nullable: false

  - changeSet:
      id: 2
      author: jane
      changes:
        - addColumn:
            tableName: users
            columns:
              - column:
                  name: phone
                  type: VARCHAR(20)
```

##### 3. JSON

**Fichier : db.changelog-master.json**
```json
{
  "databaseChangeLog": [
    {
      "changeSet": {
        "id": "1",
        "author": "john",
        "changes": [
          {
            "createTable": {
              "tableName": "users",
              "columns": [
                {
                  "column": {
                    "name": "id",
                    "type": "SERIAL",
                    "constraints": {
                      "primaryKey": true
                    }
                  }
                }
              ]
            }
          }
        ]
      }
    }
  ]
}
```

##### 4. SQL (comme Flyway)

Liquibase peut aussi utiliser du SQL pur avec des annotations sp√©ciales :

**Fichier : 001-create-users-table.sql**
```sql
--liquibase formatted sql

--changeset john:1
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    full_name VARCHAR(255) NOT NULL
);
--rollback DROP TABLE users;

--changeset jane:2
ALTER TABLE users ADD COLUMN phone VARCHAR(20);
--rollback ALTER TABLE users DROP COLUMN phone;
```

**Note importante :** La directive `--rollback` permet de d√©finir comment annuler la migration !

#### Concept de ChangeSet

Un **ChangeSet** est une unit√© atomique de modification :

```plaintext
ChangeSet :
  - id: Identifiant unique (ex: "1", "create-users", "2024-01-15-001")
  - author: Qui a cr√©√© ce changement
  - changes: Liste des modifications SQL/DDL
  - rollback: (optionnel) Comment annuler ce changement
  - preconditions: (optionnel) Conditions pour ex√©cuter
  - context: (optionnel) Environnements cibles (dev, prod, etc.)
```

#### Commandes Liquibase principales

```plaintext
liquibase update
  ‚Üí Applique tous les changeSets en attente
  ‚Üí √âquivalent de flyway migrate

liquibase rollback <tag>
  ‚Üí Annule les changeSets jusqu'√† un tag donn√©
  ‚Üí ‚≠ê Fonctionnalit√© cl√© de Liquibase

liquibase rollbackCount <number>
  ‚Üí Annule les N derniers changeSets

liquibase status
  ‚Üí Affiche les changeSets en attente
  ‚Üí √âquivalent de flyway info

liquibase validate
  ‚Üí V√©rifie la coh√©rence des changeSets

liquibase generateChangeLog
  ‚Üí üöÄ G√©n√®re automatiquement un changelog depuis une base existante
  ‚Üí Tr√®s utile pour adopter Liquibase sur un projet existant

liquibase diff
  ‚Üí Compare deux bases et g√©n√®re les diff√©rences
  ‚Üí Utile pour synchroniser dev ‚Üî prod

liquibase tag <tagName>
  ‚Üí Cr√©e un point de restauration nomm√©
```

#### Table de m√©tadonn√©es

Liquibase cr√©e deux tables :

**1. databasechangelog** (historique des changeSets appliqu√©s)
```sql
CREATE TABLE databasechangelog (
    id VARCHAR(255) NOT NULL,
    author VARCHAR(255) NOT NULL,
    filename VARCHAR(255) NOT NULL,
    dateexecuted TIMESTAMP NOT NULL,
    orderexecuted INT NOT NULL,
    exectype VARCHAR(10) NOT NULL,
    md5sum VARCHAR(35),
    description VARCHAR(255),
    comments VARCHAR(255),
    tag VARCHAR(255),
    liquibase VARCHAR(20),
    contexts VARCHAR(255),
    labels VARCHAR(255),
    deployment_id VARCHAR(10)
);
```

**2. databasechangeloglock** (verrou pour √©viter les ex√©cutions concurrentes)
```sql
CREATE TABLE databasechangeloglock (
    id INT NOT NULL PRIMARY KEY,
    locked BOOLEAN NOT NULL,
    lockgranted TIMESTAMP,
    lockedby VARCHAR(255)
);
```

### Avantages de Liquibase

- ‚úÖ **Rollback int√©gr√©** : Annuler des migrations facilement (m√™me en version gratuite)
- ‚úÖ **Multi-format** : SQL, XML, YAML, JSON au choix
- ‚úÖ **G√©n√©ration automatique** : `generateChangeLog` pour bases existantes
- ‚úÖ **Diff entre bases** : D√©tecter automatiquement les diff√©rences
- ‚úÖ **Pr√©conditions** : Ex√©cuter un changeSet seulement si une condition est remplie
- ‚úÖ **Contextes** : Appliquer certains changeSets seulement en dev, prod, etc.
- ‚úÖ **Agnostique** : Support √©tendu de nombreuses bases de donn√©es

### Inconv√©nients de Liquibase

- ‚ùå **Courbe d'apprentissage** : Plus complexe que Flyway (syntaxe XML/YAML √† apprendre)
- ‚ùå **Verbosit√©** : Les fichiers XML/YAML peuvent √™tre longs
- ‚ùå **Configuration** : Plus de param√®tres √† configurer
- ‚ùå **Abstraction** : L'abstraction XML/YAML peut √©loigner du SQL r√©el
- ‚ùå **Debugging** : Erreurs parfois difficiles √† comprendre (surtout en XML)

### Cas d'usage id√©aux

- Projets n√©cessitant des rollbacks fr√©quents
- Migrations de bases de donn√©es existantes (generateChangeLog)
- D√©ploiements multi-environnements complexes (dev, test, staging, prod)
- √âquipes pr√©f√©rant une abstraction au-dessus du SQL
- Besoins de synchronisation entre bases (diff)

---

## 3. Alembic : Le choix Python

### Philosophie

Alembic est l'outil de migration **standard de l'√©cosyst√®me Python**, particuli√®rement utilis√© avec SQLAlchemy (l'ORM Python le plus populaire). Il combine flexibilit√© du Python avec SQL pur.

**Slogan officieux :** *"A database migration tool for SQLAlchemy"*

### Origine

D√©velopp√© par le cr√©ateur de SQLAlchemy (Mike Bayer), Alembic est le choix naturel pour les applications Python (Django, Flask, FastAPI).

**Note :** Django a son propre syst√®me de migrations int√©gr√©, mais Alembic peut √™tre utilis√© pour des besoins avanc√©s.

### Fonctionnement

#### Structure des fichiers de migration

```plaintext
Structure typique :
project/
‚îú‚îÄ‚îÄ alembic/
‚îÇ   ‚îú‚îÄ‚îÄ versions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 001_create_users_table.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 002_add_email_to_users.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ 003_create_orders_table.py
‚îÇ   ‚îú‚îÄ‚îÄ env.py (configuration Alembic)
‚îÇ   ‚îî‚îÄ‚îÄ script.py.mako (template de migration)
‚îú‚îÄ‚îÄ alembic.ini (configuration principale)
‚îî‚îÄ‚îÄ models.py (vos mod√®les SQLAlchemy)
```

#### Format des migrations

Alembic utilise des fichiers **Python** avec deux fonctions : `upgrade()` et `downgrade()`.

**Fichier : 001_create_users_table.py**
```python
"""Create users table

Revision ID: 001
Revises:
Create Date: 2025-01-15 10:00:00
"""
from alembic import op
import sqlalchemy as sa

# Identifiants de r√©vision
revision = '001'
down_revision = None
branch_labels = None
depends_on = None

def upgrade():
    """Applique la migration (UP)"""
    op.create_table(
        'users',
        sa.Column('id', sa.Integer(), primary_key=True),
        sa.Column('email', sa.String(255), unique=True, nullable=False),
        sa.Column('full_name', sa.String(255), nullable=False),
        sa.Column('created_at', sa.TIMESTAMP(timezone=True),
                  server_default=sa.text('NOW()'))
    )

    # Cr√©er un index
    op.create_index('idx_users_email', 'users', ['email'])

def downgrade():
    """Annule la migration (DOWN)"""
    op.drop_index('idx_users_email', 'users')
    op.drop_table('users')
```

**Fichier : 002_add_phone_to_users.py**
```python
"""Add phone to users

Revision ID: 002
Revises: 001
Create Date: 2025-01-20 14:30:00
"""
from alembic import op
import sqlalchemy as sa

revision = '002'
down_revision = '001'  # D√©pend de la migration 001

def upgrade():
    """Ajoute la colonne phone"""
    op.add_column('users',
                  sa.Column('phone', sa.String(20), nullable=True))

def downgrade():
    """Supprime la colonne phone"""
    op.drop_column('users', 'phone')
```

#### SQL brut dans Alembic

Vous pouvez aussi √©crire du SQL pur avec `op.execute()` :

```python
def upgrade():
    """Migration avec SQL brut"""
    op.execute("""
        CREATE TABLE orders (
            id SERIAL PRIMARY KEY,
            user_id INTEGER REFERENCES users(id),
            total NUMERIC(10, 2) NOT NULL,
            created_at TIMESTAMPTZ DEFAULT NOW()
        )
    """)

    # Index avec SQL pur
    op.execute("""
        CREATE INDEX idx_orders_user_id ON orders(user_id)
    """)

def downgrade():
    """Rollback avec SQL brut"""
    op.execute("DROP TABLE orders")
```

#### Commandes Alembic principales

```plaintext
alembic init alembic
  ‚Üí Initialise Alembic dans le projet
  ‚Üí Cr√©e la structure de dossiers

alembic revision -m "Create users table"
  ‚Üí Cr√©e un nouveau fichier de migration vide
  ‚Üí Vous devez √©crire upgrade() et downgrade()

alembic revision --autogenerate -m "Add phone column"
  ‚Üí üöÄ G√©n√®re automatiquement la migration en comparant les mod√®les SQLAlchemy
  ‚Üí Tr√®s puissant pour √©viter d'√©crire le SQL manuellement

alembic upgrade head
  ‚Üí Applique toutes les migrations en attente
  ‚Üí √âquivalent de flyway migrate / liquibase update

alembic downgrade -1
  ‚Üí Annule la derni√®re migration
  ‚Üí Ex√©cute la fonction downgrade()

alembic downgrade <revision>
  ‚Üí Annule jusqu'√† une r√©vision donn√©e

alembic current
  ‚Üí Affiche la r√©vision actuelle de la base

alembic history
  ‚Üí Affiche l'historique de toutes les migrations

alembic show <revision>
  ‚Üí Affiche les d√©tails d'une migration sp√©cifique

alembic stamp head
  ‚Üí Marque la base comme √©tant √† jour sans ex√©cuter les migrations
  ‚Üí Utile lors de l'adoption d'Alembic sur une base existante
```

#### G√©n√©ration automatique (Autogenerate)

La **killer feature** d'Alembic : comparer vos mod√®les SQLAlchemy avec la base actuelle et g√©n√©rer automatiquement les migrations.

**Exemple de workflow :**

**1. Vous modifiez votre mod√®le SQLAlchemy :**
```python
# models.py
class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    email = Column(String(255), unique=True, nullable=False)
    full_name = Column(String(255), nullable=False)
    phone = Column(String(20))  # ‚Üê Nouvelle colonne ajout√©e
    created_at = Column(TIMESTAMP(timezone=True), server_default=func.now())
```

**2. Vous lancez la g√©n√©ration automatique :**
```bash
alembic revision --autogenerate -m "Add phone to users"
```

**3. Alembic g√©n√®re automatiquement :**
```python
def upgrade():
    op.add_column('users', sa.Column('phone', sa.String(20), nullable=True))

def downgrade():
    op.drop_column('users', 'phone')
```

**4. Vous v√©rifiez et appliquez :**
```bash
alembic upgrade head
```

‚ö†Ô∏è **Important :** L'autogenerate n'est pas parfait. Vous devez toujours **v√©rifier** la migration g√©n√©r√©e. Il ne d√©tecte pas tout (changements de donn√©es, renommages complexes, etc.).

#### Table de m√©tadonn√©es

Alembic cr√©e la table `alembic_version` :

```sql
CREATE TABLE alembic_version (
    version_num VARCHAR(32) NOT NULL PRIMARY KEY
);
```

Contrairement √† Flyway/Liquibase, cette table ne stocke que la **version actuelle**, pas l'historique complet. L'historique est dans les fichiers de migration.

### Avantages d'Alembic

- ‚úÖ **Int√©gration SQLAlchemy** : G√©n√©ration automatique depuis les mod√®les ORM
- ‚úÖ **Rollback natif** : Fonctions upgrade()/downgrade() obligatoires
- ‚úÖ **Flexibilit√© Python** : Logique complexe possible dans les migrations (loops, conditions, etc.)
- ‚úÖ **SQL brut support√©** : Pas oblig√© d'utiliser l'abstraction si vous pr√©f√©rez SQL pur
- ‚úÖ **Branching** : Support de branches de migrations parall√®les (avanc√©)
- ‚úÖ **√âcosyst√®me Python** : Int√©gration naturelle avec Flask, FastAPI, Django (via extension)

### Inconv√©nients d'Alembic

- ‚ùå **Python uniquement** : Pas utilisable dans des projets non-Python
- ‚ùå **Courbe d'apprentissage** : API Alembic + SQLAlchemy √† apprendre
- ‚ùå **Autogenerate imparfait** : Ne d√©tecte pas tout, n√©cessite v√©rification manuelle
- ‚ùå **Moins populaire hors Python** : Flyway et Liquibase ont des communaut√©s plus larges
- ‚ùå **Configuration initiale** : Plus complexe que Flyway

### Cas d'usage id√©aux

- Applications Python (Flask, FastAPI, Django)
- Projets utilisant SQLAlchemy comme ORM
- Besoin de g√©n√©ration automatique de migrations
- Migrations n√©cessitant de la logique Python complexe
- √âquipes Python confortables avec l'√©cosyst√®me

---

## Concepts communs aux trois outils

### 1. Migration versionn√©e (Up)

Toutes les migrations ont une direction "vers l'avant" (upgrade, migrate, up) qui applique les modifications.

```plaintext
√âtat initial :
  Table users (id, name)

Migration 001 (UP) :
  ALTER TABLE users ADD COLUMN email VARCHAR(255)

√âtat final :
  Table users (id, name, email)
```

### 2. Rollback (Down)

La capacit√© d'annuler une migration pour revenir √† l'√©tat pr√©c√©dent.

```plaintext
√âtat actuel :
  Table users (id, name, email)

Migration 001 (DOWN) :
  ALTER TABLE users DROP COLUMN email

√âtat final :
  Table users (id, name)
```

**Comparaison :**
- **Flyway (gratuit)** : ‚ùå Pas de rollback automatique (version Pro payante)
- **Liquibase** : ‚úÖ Rollback complet (m√™me version gratuite)
- **Alembic** : ‚úÖ Rollback via downgrade()

### 3. Idempotence

Une migration doit √™tre **idempotente** : si elle est ex√©cut√©e plusieurs fois, elle ne doit pas causer d'erreur.

**Exemple non-idempotent :**
```sql
-- ‚ùå Erreur si la table existe d√©j√†
CREATE TABLE users (id SERIAL PRIMARY KEY);
```

**Exemple idempotent :**
```sql
-- ‚úÖ Ne fait rien si la table existe
CREATE TABLE IF NOT EXISTS users (id SERIAL PRIMARY KEY);
```

### 4. Transactions

Les migrations doivent s'ex√©cuter dans une **transaction PostgreSQL** pour garantir l'atomicit√©.

```plaintext
BEGIN;
  -- Migration 001
  CREATE TABLE users (...);
  CREATE INDEX idx_users_email ON users(email);
  -- Si une erreur survient ici, tout est annul√©
COMMIT;
```

Si une partie de la migration √©choue, PostgreSQL annule tout (ROLLBACK automatique).

### 5. Checksum / Hash

Les outils calculent une empreinte (hash) de chaque migration pour d√©tecter toute modification apr√®s application.

```plaintext
Migration 001_create_users.sql appliqu√©e :
  Checksum: a3f5b2c...

Quelqu'un modifie 001_create_users.sql :
  Nouveau checksum: e7d9a1f...

Outil d√©tecte : ‚ö†Ô∏è ERREUR - Migration modifi√©e apr√®s application !
```

**R√®gle d'or :** Ne JAMAIS modifier une migration d√©j√† appliqu√©e en production. Cr√©ez une nouvelle migration.

### 6. Baseline / Init

Pour adopter un outil de migration sur une base existante, il faut d√©finir un **point de d√©part (baseline)**.

```plaintext
Base de donn√©es existante avec 20 tables :

Option 1 - Baseline :
  alembic stamp head
  ‚Üí Marque la base comme √©tant √† la version actuelle
  ‚Üí Les futures migrations s'appliquent √† partir de l√†

Option 2 - G√©n√©rer le changelog initial :
  liquibase generateChangeLog
  ‚Üí Cr√©e une migration repr√©sentant l'√©tat actuel
  ‚Üí Cette migration devient la v1
```

---

## Strat√©gies et bonnes pratiques

### 1. Convention de nommage

Utilisez des noms de migration **descriptifs et dat√©s** :

```plaintext
‚úÖ Bon :
  V001__create_users_table.sql
  V002__add_email_index_to_users.sql
  2025_01_15_001_create_users_table.py

‚ùå Mauvais :
  migration1.sql
  fix.sql
  update.sql
```

### 2. Une migration = une modification atomique

Chaque migration doit faire **une seule chose logique** :

```plaintext
‚úÖ Bon :
  001_create_users_table.sql
  002_create_orders_table.sql
  003_add_foreign_key_orders_to_users.sql

‚ùå Mauvais :
  001_create_all_tables_and_indexes_and_data.sql
  ‚Üí Difficile √† d√©boguer si √ßa √©choue
```

### 3. Toujours tester les rollbacks

Si vous impl√©mentez un rollback (Liquibase, Alembic), testez-le **avant** de d√©ployer :

```bash
# Appliquer la migration
alembic upgrade +1

# Tester le rollback
alembic downgrade -1

# R√©-appliquer
alembic upgrade +1
```

### 4. Migrations de donn√©es vs migrations de sch√©ma

S√©parez les migrations qui modifient le sch√©ma de celles qui modifient les donn√©es :

**Migration de sch√©ma :**
```sql
-- 010_add_status_to_orders.sql
ALTER TABLE orders ADD COLUMN status VARCHAR(20) DEFAULT 'pending';
```

**Migration de donn√©es :**
```sql
-- 011_populate_order_status.sql
UPDATE orders SET status = 'completed' WHERE completed_at IS NOT NULL;
UPDATE orders SET status = 'cancelled' WHERE cancelled_at IS NOT NULL;
```

Pourquoi s√©parer ? Les migrations de donn√©es peuvent √™tre lentes sur de grandes tables et n√©cessitent une strat√©gie diff√©rente (batch processing, zero-downtime, etc.).

### 5. Migrations r√©versibles avec pr√©caution

Certaines migrations sont **destructives** et ne peuvent pas √™tre annul√©es sans perte de donn√©es :

```sql
-- ‚ö†Ô∏è Migration destructive
ALTER TABLE users DROP COLUMN phone;
-- Rollback : Impossible de r√©cup√©rer les donn√©es supprim√©es !
```

**Strat√©gie safe :**
```plaintext
Migration 1 : Ajouter nouvelle colonne phone_number
Migration 2 : Copier les donn√©es de phone vers phone_number
Migration 3 : D√©ployer le code utilisant phone_number
Migration 4 : (Plus tard) Supprimer l'ancienne colonne phone
```

### 6. Versionner les migrations dans Git

Les fichiers de migration **doivent √™tre versionn√©s** dans votre d√©p√¥t Git :

```plaintext
Git repository :
‚îú‚îÄ‚îÄ src/
‚îú‚îÄ‚îÄ tests/
‚îú‚îÄ‚îÄ migrations/  ‚Üê Versionn√© dans Git
‚îÇ   ‚îú‚îÄ‚îÄ V001__create_users.sql
‚îÇ   ‚îú‚îÄ‚îÄ V002__add_email_index.sql
‚îî‚îÄ‚îÄ README.md

‚Üí Toute l'√©quipe partage les m√™mes migrations
‚Üí Historique complet dans Git
```

### 7. Ne jamais modifier une migration appliqu√©e

**R√®gle absolue :** Une fois qu'une migration est appliqu√©e en production, elle est **immuable**.

```plaintext
‚ùå Jamais √ßa :
  Modifier V001__create_users.sql apr√®s l'avoir d√©ploy√©e

‚úÖ Faire √ßa :
  Cr√©er V005__fix_users_table.sql pour corriger
```

### 8. Environnements multiples

Votre strat√©gie de migration doit fonctionner sur tous les environnements :

```plaintext
D√©veloppement local :
  ‚Üí Migrations appliqu√©es au fur et √† mesure
  ‚Üí Base peut √™tre d√©truite/recr√©√©e facilement

Staging / Test :
  ‚Üí Copie de production (anonymis√©e)
  ‚Üí Migrations test√©es avant production

Production :
  ‚Üí Migrations appliqu√©es avec prudence
  ‚Üí Backup avant migration
  ‚Üí Plan de rollback pr√™t
```

### 9. Automatisation CI/CD

Int√©grez les migrations dans votre pipeline de d√©ploiement :

```plaintext
Pipeline CI/CD :
1. Tests unitaires
2. Build de l'application
3. ‚úÖ V√©rifier les migrations (validate)
4. D√©ployer l'application
5. ‚úÖ Appliquer les migrations (migrate)
6. Tests d'int√©gration
7. D√©ploiement en production
```

### 10. Documentation des migrations

Ajoutez des commentaires dans vos migrations pour expliquer **pourquoi** :

```sql
-- Migration: Add customer_tier column for loyalty program
-- Context: Marketing team requested tiering system for customers
-- Ticket: JIRA-1234
-- Author: John Doe
-- Date: 2025-01-15

ALTER TABLE customers
ADD COLUMN customer_tier VARCHAR(20) DEFAULT 'bronze'
CHECK (customer_tier IN ('bronze', 'silver', 'gold', 'platinum'));

COMMENT ON COLUMN customers.customer_tier IS
'Customer loyalty tier: bronze (default), silver, gold, platinum.
Based on total purchase amount in last 12 months.';
```

---

## Sc√©narios d'utilisation avanc√©s

### Sc√©nario 1 : Migration avec Zero-Downtime

**Probl√®me :** Vous devez renommer une colonne sans arr√™ter l'application.

**Strat√©gie en plusieurs √©tapes :**

```plaintext
√âtape 1 (Migration 010) : Ajouter nouvelle colonne
  ALTER TABLE users ADD COLUMN full_name VARCHAR(255);

√âtape 2 (Migration 011) : Copier les donn√©es
  UPDATE users SET full_name = name WHERE full_name IS NULL;

√âtape 3 (D√©ploiement code v2) :
  Application lit/√©crit dans les deux colonnes (name et full_name)

√âtape 4 (Migration 012) : Rendre full_name NOT NULL
  ALTER TABLE users ALTER COLUMN full_name SET NOT NULL;

√âtape 5 (D√©ploiement code v3) :
  Application utilise uniquement full_name

√âtape 6 (Migration 013 - Plus tard) : Supprimer ancienne colonne
  ALTER TABLE users DROP COLUMN name;
```

**Avantage :** Aucune interruption de service.

### Sc√©nario 2 : Migration sur table volumineuse

**Probl√®me :** Vous devez ajouter une colonne NOT NULL √† une table de 100 millions de lignes.

**Mauvaise approche :**
```sql
-- ‚ùå Bloque la table pendant des heures
ALTER TABLE orders ADD COLUMN processed BOOLEAN NOT NULL DEFAULT false;
```

**Bonne approche :**
```sql
-- Migration 020: Ajouter colonne nullable
ALTER TABLE orders ADD COLUMN processed BOOLEAN;

-- Migration 021: Remplir par batch (en plusieurs petits UPDATE)
-- Peut √™tre fait via un script Python/Job s√©par√©
UPDATE orders SET processed = false
WHERE id BETWEEN 1 AND 1000000 AND processed IS NULL;

-- R√©p√©ter pour tous les ranges...

-- Migration 022: Rendre NOT NULL une fois rempli
ALTER TABLE orders ALTER COLUMN processed SET DEFAULT false;
ALTER TABLE orders ALTER COLUMN processed SET NOT NULL;
```

### Sc√©nario 3 : Branches parall√®les de d√©veloppement

**Probl√®me :** Deux d√©veloppeurs cr√©ent des migrations en parall√®le.

**D√©veloppeur A cr√©e :**
```plaintext
V010__add_phone_to_users.sql
```

**D√©veloppeur B cr√©e (en m√™me temps) :**
```plaintext
V010__add_address_to_users.sql  ‚Üê Conflit !
```

**Solution avec Liquibase :**
```yaml
# Utiliser des IDs uniques (timestamp + description)
changeSet:
  id: 2025-01-15-10h30-add-phone
  author: dev-a

changeSet:
  id: 2025-01-15-11h00-add-address
  author: dev-b
```

**Solution avec Alembic :**
```bash
# Alembic g√©n√®re des IDs uniques automatiquement
alembic revision -m "Add phone"
# ‚Üí G√©n√®re : 0a3f2b1c_add_phone.py

alembic revision -m "Add address"
# ‚Üí G√©n√®re : 7d9e4f5a_add_address.py

# Fusion des branches :
alembic merge heads -m "Merge phone and address"
```

### Sc√©nario 4 : Rollback partiel

**Probl√®me :** Vous voulez annuler seulement certaines migrations, pas toutes.

**Avec Liquibase (tags) :**
```bash
# Cr√©er un tag avant d√©ploiement risqu√©
liquibase tag "before-major-refactor"

# D√©ployer plusieurs migrations
liquibase update

# Si probl√®me, revenir au tag
liquibase rollback "before-major-refactor"
```

**Avec Alembic :**
```bash
# Descendre √† une r√©vision sp√©cifique
alembic downgrade a3f2b1c

# Ou annuler les 3 derni√®res migrations
alembic downgrade -3
```

---

## Comparaison finale et choix

### Quand choisir Flyway ?

- ‚úÖ Vous voulez la **simplicit√©** avant tout
- ‚úÖ Vous √©crivez du **SQL pur** et ne voulez pas d'abstraction
- ‚úÖ Vous √™tes dans l'√©cosyst√®me **Java/Spring Boot**
- ‚úÖ Vous n'avez pas besoin de rollbacks fr√©quents
- ‚úÖ Vous voulez une int√©gration **CI/CD facile**
- ‚úÖ Vous avez un **budget limit√©** (version gratuite suffit)

### Quand choisir Liquibase ?

- ‚úÖ Vous avez besoin de **rollbacks** r√©guliers
- ‚úÖ Vous voulez **g√©n√©rer automatiquement** des migrations depuis une base existante
- ‚úÖ Vous g√©rez des **environnements multiples** complexes (dev/test/staging/prod)
- ‚úÖ Vous voulez **comparer et synchroniser** plusieurs bases (diff)
- ‚úÖ Vous pr√©f√©rez **XML/YAML** au SQL pur
- ‚úÖ Vous avez besoin de **pr√©conditions** et **contextes** avanc√©s

### Quand choisir Alembic ?

- ‚úÖ Vous d√©veloppez en **Python** (Flask, FastAPI, SQLAlchemy)
- ‚úÖ Vous utilisez un **ORM** et voulez g√©n√©rer les migrations automatiquement
- ‚úÖ Vous voulez √©crire de la **logique Python** dans les migrations
- ‚úÖ Vous avez besoin de **rollbacks** avec une approche up/down claire
- ‚úÖ Votre √©quipe est **confortable avec Python**
- ‚úÖ Vous voulez du **SQL brut** avec la flexibilit√© Python

### Tableau d√©cisionnel

| Crit√®re                     | Flyway | Liquibase | Alembic |
|-----------------------------|--------|-----------|---------|
| Simplicit√©                  | ‚≠ê‚≠ê‚≠ê   | ‚≠ê‚≠ê       | ‚≠ê‚≠ê     |
| Rollback automatique        | ‚ùå (Pro) | ‚úÖ       | ‚úÖ      |
| G√©n√©ration automatique      | ‚ùå     | ‚úÖ        | ‚úÖ      |
| SQL pur                     | ‚úÖ     | ‚úÖ        | ‚úÖ      |
| Multi-langage               | ‚úÖ     | ‚úÖ        | ‚ùå (Python) |
| Courbe d'apprentissage      | Facile | Moyenne   | Moyenne |
| Communaut√©                  | Large  | Large     | Python  |
| Open Source gratuit complet | üî∂     | ‚úÖ        | ‚úÖ      |

---

## Conclusion

Les **migrations de base de donn√©es** sont essentielles pour maintenir une base PostgreSQL √©volutive, tra√ßable et synchronis√©e entre environnements. Les trois outils pr√©sent√©s (Flyway, Liquibase, Alembic) offrent des approches diff√©rentes mais convergent vers le m√™me objectif : g√©rer le sch√©ma comme du code.

### Points cl√©s √† retenir :

1. **Les migrations versionnent votre sch√©ma** comme Git versionne votre code
2. **Chaque outil a ses forces** : simplicit√© (Flyway), flexibilit√© (Liquibase), int√©gration Python (Alembic)
3. **Les bonnes pratiques sont universelles** : atomicit√©, idempotence, tests, documentation
4. **Ne jamais modifier une migration appliqu√©e** : cr√©ez une nouvelle migration
5. **Automatisez dans votre CI/CD** pour √©viter les erreurs humaines
6. **Testez les rollbacks** m√™me si vous ne les utilisez jamais en production

### Prochaines √©tapes

Apr√®s avoir ma√Ætris√© les migrations, explorez :
- **20.4.3. Schema versioning** : Strat√©gies de versionnement avanc√©es
- **20.4.4. Zero-downtime deployments** : D√©ployer sans interruption
- **19.3. Migrations majeures** : Migrer de PostgreSQL 17 vers 18

Les migrations sont la **fondation d'un projet PostgreSQL professionnel**. Investir du temps dans leur mise en place vous √©pargnera d'innombrables heures de debugging et de conflits en production.

---

**Ressources compl√©mentaires :**
- Documentation Flyway : https://flywaydb.org/documentation/
- Documentation Liquibase : https://docs.liquibase.com/
- Documentation Alembic : https://alembic.sqlalchemy.org/
- Article Martin Fowler : "Evolutionary Database Design"

‚è≠Ô∏è [Schema versioning](/20-drivers-connexion-applicative/04.3-schema-versioning.md)
