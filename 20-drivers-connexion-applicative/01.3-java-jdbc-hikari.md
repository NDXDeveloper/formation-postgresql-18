üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.1.3. Java : JDBC, HikariCP, R2DBC

## Introduction

Java dispose de plusieurs approches pour interagir avec PostgreSQL, chacune adapt√©e √† diff√©rents besoins et architectures :

1. **JDBC** : API standard Java pour l'acc√®s aux bases de donn√©es (synchrone/bloquant)
2. **HikariCP** : Pool de connexions haute performance pour JDBC
3. **R2DBC** : API r√©active non-bloquante pour des applications asynchrones modernes

Ce tutoriel couvre les trois approches en profondeur pour vous permettre de choisir celle qui convient le mieux √† votre projet.

---

## Vue d'Ensemble : Les Trois Approches

### JDBC (Java Database Connectivity)

**JDBC** est l'API standard Java pour l'acc√®s aux bases de donn√©es depuis 1997. C'est la fondation sur laquelle reposent la plupart des frameworks Java.

**Caract√©ristiques :**
- API synchrone et bloquante
- Standard Java (java.sql.*)
- Compatible avec tous les SGBD via des drivers sp√©cifiques
- Mature et stable

**Analogie :** JDBC est comme le langage universel que tous les syst√®mes de bases de donn√©es comprennent en Java.

### HikariCP (Connection Pool)

**HikariCP** est un pool de connexions ultra-performant qui optimise l'utilisation de JDBC en r√©utilisant les connexions au lieu d'en cr√©er de nouvelles √† chaque requ√™te.

**Caract√©ristiques :**
- Pool de connexions le plus rapide du march√© Java
- Utilis√© par d√©faut dans Spring Boot
- Configuration simple et intuitive
- Monitoring int√©gr√©

**Analogie :** Si JDBC est comme appeler un taxi √† chaque fois, HikariCP est comme avoir une flotte de taxis toujours disponibles.

### R2DBC (Reactive Relational Database Connectivity)

**R2DBC** est une API moderne r√©active pour les bases de donn√©es relationnelles, bas√©e sur le mod√®le Reactive Streams.

**Caract√©ristiques :**
- API asynchrone et non-bloquante
- Id√©al pour les architectures r√©actives (WebFlux, Reactor)
- Meilleure utilisation des ressources (scalabilit√©)
- Standard r√©cent (2018+)

**Analogie :** R2DBC est comme passer des commandes asynchrones qui vous notifient quand elles sont pr√™tes, au lieu d'attendre √† chaque fois.

### Comparaison Rapide

| Caract√©ristique | JDBC | JDBC + HikariCP | R2DBC |
|-----------------|------|-----------------|--------|
| **Mod√®le** | Synchrone bloquant | Synchrone bloquant | Asynchrone non-bloquant |
| **Maturit√©** | Tr√®s mature (1997) | Tr√®s mature | R√©cent (2018+) |
| **Performance** | Moyenne | Excellente | Excellente |
| **Complexit√©** | Simple | Simple | Moyenne (r√©actif) |
| **Pool connexions** | Manuel | Int√©gr√© | Int√©gr√© |
| **Scalabilit√©** | Limit√©e (threads) | Bonne | Excellente |
| **Cas d'usage** | Applications legacy | Applications standard | Applications r√©actives |
| **Spring Boot** | Compatible | Par d√©faut | WebFlux |

**Recommandation :**
- **JDBC simple** : Prototypes, scripts, apprentissage
- **JDBC + HikariCP** : Applications standard Spring Boot, APIs REST
- **R2DBC** : Applications r√©actives haute scalabilit√© (Spring WebFlux, Reactor)

---

## Partie 1 : JDBC (Java Database Connectivity)

### Introduction √† JDBC

JDBC est l'API standard Java pour interagir avec les bases de donn√©es relationnelles. Elle d√©finit des interfaces que chaque SGBD impl√©mente via un **driver**.

**Architecture JDBC :**
```
Application Java
      ‚Üì
   JDBC API (java.sql.*)
      ‚Üì
PostgreSQL JDBC Driver (org.postgresql)
      ‚Üì
PostgreSQL Database
```

### Installation et D√©pendances

#### Maven (pom.xml)

```xml
<dependencies>
    <!-- PostgreSQL JDBC Driver -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.7.1</version>
    </dependency>
</dependencies>
```

#### Gradle (build.gradle)

```groovy
dependencies {
    implementation 'org.postgresql:postgresql:42.7.1'
}
```

### Connexion Basique √† PostgreSQL

#### Connexion simple

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class PostgreSQLConnection {
    public static void main(String[] args) {
        // URL de connexion JDBC
        String url = "jdbc:postgresql://localhost:5432/ma_database";
        String user = "mon_utilisateur";
        String password = "mon_password";

        Connection conn = null;

        try {
            // √âtablir la connexion
            conn = DriverManager.getConnection(url, user, password);
            System.out.println("‚úÖ Connexion √©tablie avec succ√®s");

            // Votre code ici

        } catch (SQLException e) {
            System.err.println("‚ùå Erreur de connexion : " + e.getMessage());
            e.printStackTrace();
        } finally {
            // Toujours fermer la connexion
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

**Format de l'URL JDBC PostgreSQL :**
```
jdbc:postgresql://[host]:[port]/[database]?[param√®tres]
```

**Exemples d'URLs :**
```java
// Local avec port par d√©faut
"jdbc:postgresql://localhost/mydb"

// Avec port sp√©cifique
"jdbc:postgresql://localhost:5432/mydb"

// Avec SSL
"jdbc:postgresql://localhost/mydb?ssl=true&sslmode=require"

// Avec sch√©ma sp√©cifique
"jdbc:postgresql://localhost/mydb?currentSchema=public"

// Avec timeout
"jdbc:postgresql://localhost/mydb?loginTimeout=10&connectTimeout=10"
```

#### Try-with-resources (Java 7+, recommand√©)

Le **try-with-resources** ferme automatiquement les ressources (Connection, Statement, ResultSet) :

```java
public class JDBCExample {
    private static final String URL = "jdbc:postgresql://localhost:5432/mydb";
    private static final String USER = "user";
    private static final String PASSWORD = "password";

    public static void main(String[] args) {
        try (Connection conn = DriverManager.getConnection(URL, USER, PASSWORD)) {
            System.out.println("Connexion √©tablie");
            // La connexion sera ferm√©e automatiquement
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

**Avantage :** Plus concis et plus s√ªr (pas d'oubli de fermeture).

### Ex√©cution de Requ√™tes

#### SELECT : R√©cup√©rer des donn√©es

```java
import java.sql.*;

public class SelectExample {
    public static void main(String[] args) {
        String url = "jdbc:postgresql://localhost:5432/mydb";
        String user = "user";
        String password = "password";

        try (Connection conn = DriverManager.getConnection(url, user, password)) {
            // Cr√©er un Statement
            Statement stmt = conn.createStatement();

            // Ex√©cuter une requ√™te SELECT
            String query = "SELECT id, nom, email, age FROM utilisateurs";
            ResultSet rs = stmt.executeQuery(query);

            // Parcourir les r√©sultats
            while (rs.next()) {
                int id = rs.getInt("id");
                String nom = rs.getString("nom");
                String email = rs.getString("email");
                int age = rs.getInt("age");

                System.out.printf("ID: %d, Nom: %s, Email: %s, Age: %d%n",
                                  id, nom, email, age);
            }

            // Fermer les ressources
            rs.close();
            stmt.close();

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

**Avec try-with-resources (recommand√©) :**

```java
try (Connection conn = DriverManager.getConnection(url, user, password);
     Statement stmt = conn.createStatement();
     ResultSet rs = stmt.executeQuery("SELECT * FROM utilisateurs")) {

    while (rs.next()) {
        System.out.println("Nom: " + rs.getString("nom"));
    }

} catch (SQLException e) {
    e.printStackTrace();
}
```

#### Prepared Statements (S√©curit√© Critique)

**‚ö†Ô∏è JAMAIS comme ceci (VULN√âRABLE) :**

```java
// ‚ùå DANGEREUX - Injection SQL possible !
String email = "alice@example.com' OR '1'='1";
Statement stmt = conn.createStatement();
String query = "SELECT * FROM users WHERE email = '" + email + "'";
ResultSet rs = stmt.executeQuery(query);
```

**‚úÖ TOUJOURS utiliser PreparedStatement :**

```java
// ‚úÖ S√âCURIS√â - Param√®tres √©chapp√©s automatiquement
String email = "alice@example.com";

try (Connection conn = DriverManager.getConnection(url, user, password);
     PreparedStatement pstmt = conn.prepareStatement(
         "SELECT * FROM users WHERE email = ?")) {

    // D√©finir les param√®tres (index commence √† 1)
    pstmt.setString(1, email);

    ResultSet rs = pstmt.executeQuery();

    while (rs.next()) {
        System.out.println("User: " + rs.getString("nom"));
    }

} catch (SQLException e) {
    e.printStackTrace();
}
```

**Param√®tres multiples :**

```java
String query = "SELECT * FROM produits WHERE categorie = ? AND prix > ?";

try (PreparedStatement pstmt = conn.prepareStatement(query)) {
    pstmt.setString(1, "√âlectronique");
    pstmt.setDouble(2, 100.0);

    ResultSet rs = pstmt.executeQuery();

    while (rs.next()) {
        System.out.println("Produit: " + rs.getString("nom"));
    }
}
```

### Op√©rations CRUD Compl√®tes

#### CREATE : Ins√©rer des donn√©es

```java
public class InsertExample {
    public static void insertUser(Connection conn, String nom, String email, int age)
            throws SQLException {

        String sql = "INSERT INTO utilisateurs (nom, email, age) VALUES (?, ?, ?)";

        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, nom);
            pstmt.setString(2, email);
            pstmt.setInt(3, age);

            int rowsAffected = pstmt.executeUpdate();
            System.out.println(rowsAffected + " ligne(s) ins√©r√©e(s)");
        }
    }
}
```

**INSERT avec RETURNING (r√©cup√©rer l'ID g√©n√©r√©) :**

```java
public static int insertUserWithId(Connection conn, String nom, String email, int age)
        throws SQLException {

    String sql = "INSERT INTO utilisateurs (nom, email, age) VALUES (?, ?, ?) RETURNING id";

    try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
        pstmt.setString(1, nom);
        pstmt.setString(2, email);
        pstmt.setInt(3, age);

        ResultSet rs = pstmt.executeQuery();

        if (rs.next()) {
            int newId = rs.getInt("id");
            System.out.println("‚úÖ Utilisateur cr√©√© avec ID : " + newId);
            return newId;
        }
    }

    return -1;
}
```

**M√©thode standard Java (getGeneratedKeys) :**

```java
String sql = "INSERT INTO utilisateurs (nom, email, age) VALUES (?, ?, ?)";

try (PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
    pstmt.setString(1, "Alice");
    pstmt.setString(2, "alice@example.com");
    pstmt.setInt(3, 30);

    pstmt.executeUpdate();

    // R√©cup√©rer les cl√©s g√©n√©r√©es
    ResultSet rs = pstmt.getGeneratedKeys();
    if (rs.next()) {
        int id = rs.getInt(1);
        System.out.println("ID g√©n√©r√© : " + id);
    }
}
```

**Insertion multiple (batch) :**

```java
public static void insertMultipleUsers(Connection conn, List<User> users)
        throws SQLException {

    String sql = "INSERT INTO utilisateurs (nom, email, age) VALUES (?, ?, ?)";

    try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
        // D√©sactiver l'autocommit pour le batch
        conn.setAutoCommit(false);

        for (User user : users) {
            pstmt.setString(1, user.getNom());
            pstmt.setString(2, user.getEmail());
            pstmt.setInt(3, user.getAge());
            pstmt.addBatch(); // Ajouter au batch
        }

        // Ex√©cuter toutes les insertions
        int[] results = pstmt.executeBatch();
        conn.commit(); // Valider la transaction

        System.out.println(results.length + " utilisateurs ins√©r√©s");

        // R√©tablir l'autocommit
        conn.setAutoCommit(true);
    } catch (SQLException e) {
        conn.rollback(); // Annuler en cas d'erreur
        throw e;
    }
}
```

#### READ : Lire des donn√©es

```java
public class User {
    private int id;
    private String nom;
    private String email;
    private int age;

    // Constructeurs, getters, setters...
}

public class UserRepository {
    // R√©cup√©rer un utilisateur par ID
    public static User getUserById(Connection conn, int id) throws SQLException {
        String sql = "SELECT * FROM utilisateurs WHERE id = ?";

        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setInt(1, id);

            ResultSet rs = pstmt.executeQuery();

            if (rs.next()) {
                User user = new User();
                user.setId(rs.getInt("id"));
                user.setNom(rs.getString("nom"));
                user.setEmail(rs.getString("email"));
                user.setAge(rs.getInt("age"));
                return user;
            }
        }

        return null; // Utilisateur non trouv√©
    }

    // R√©cup√©rer tous les utilisateurs
    public static List<User> getAllUsers(Connection conn) throws SQLException {
        List<User> users = new ArrayList<>();
        String sql = "SELECT * FROM utilisateurs ORDER BY nom";

        try (Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {

            while (rs.next()) {
                User user = new User();
                user.setId(rs.getInt("id"));
                user.setNom(rs.getString("nom"));
                user.setEmail(rs.getString("email"));
                user.setAge(rs.getInt("age"));
                users.add(user);
            }
        }

        return users;
    }

    // Recherche avec filtres
    public static List<User> searchUsers(Connection conn, String nomPattern,
                                         int ageMin, int ageMax) throws SQLException {
        List<User> users = new ArrayList<>();
        String sql = "SELECT * FROM utilisateurs WHERE nom LIKE ? AND age BETWEEN ? AND ?";

        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, "%" + nomPattern + "%");
            pstmt.setInt(2, ageMin);
            pstmt.setInt(3, ageMax);

            ResultSet rs = pstmt.executeQuery();

            while (rs.next()) {
                User user = new User();
                user.setId(rs.getInt("id"));
                user.setNom(rs.getString("nom"));
                user.setEmail(rs.getString("email"));
                user.setAge(rs.getInt("age"));
                users.add(user);
            }
        }

        return users;
    }
}
```

#### UPDATE : Modifier des donn√©es

```java
public static int updateUser(Connection conn, int id, String nom,
                             String email, int age) throws SQLException {

    String sql = "UPDATE utilisateurs SET nom = ?, email = ?, age = ? WHERE id = ?";

    try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
        pstmt.setString(1, nom);
        pstmt.setString(2, email);
        pstmt.setInt(3, age);
        pstmt.setInt(4, id);

        int rowsAffected = pstmt.executeUpdate();

        if (rowsAffected == 0) {
            System.out.println("‚ö†Ô∏è Utilisateur non trouv√©");
        } else {
            System.out.println("‚úÖ Utilisateur mis √† jour");
        }

        return rowsAffected;
    }
}

// UPDATE partiel (uniquement les champs non-null)
public static int partialUpdateUser(Connection conn, int id, User updates)
        throws SQLException {

    StringBuilder sql = new StringBuilder("UPDATE utilisateurs SET ");
    List<Object> params = new ArrayList<>();

    // Construire dynamiquement la requ√™te
    if (updates.getNom() != null) {
        sql.append("nom = ?, ");
        params.add(updates.getNom());
    }
    if (updates.getEmail() != null) {
        sql.append("email = ?, ");
        params.add(updates.getEmail());
    }
    if (updates.getAge() != 0) {
        sql.append("age = ?, ");
        params.add(updates.getAge());
    }

    // Retirer la derni√®re virgule
    sql.setLength(sql.length() - 2);
    sql.append(" WHERE id = ?");
    params.add(id);

    try (PreparedStatement pstmt = conn.prepareStatement(sql.toString())) {
        for (int i = 0; i < params.size(); i++) {
            pstmt.setObject(i + 1, params.get(i));
        }

        return pstmt.executeUpdate();
    }
}
```

#### DELETE : Supprimer des donn√©es

```java
public static int deleteUser(Connection conn, int id) throws SQLException {
    String sql = "DELETE FROM utilisateurs WHERE id = ?";

    try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
        pstmt.setInt(1, id);

        int rowsAffected = pstmt.executeUpdate();

        if (rowsAffected == 0) {
            System.out.println("‚ö†Ô∏è Utilisateur non trouv√©");
        } else {
            System.out.println("‚úÖ Utilisateur supprim√©");
        }

        return rowsAffected;
    }
}

// Suppression multiple
public static int deleteUsersByAge(Connection conn, int maxAge) throws SQLException {
    String sql = "DELETE FROM utilisateurs WHERE age < ?";

    try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
        pstmt.setInt(1, maxAge);
        int rowsAffected = pstmt.executeUpdate();
        System.out.println(rowsAffected + " utilisateurs supprim√©s");
        return rowsAffected;
    }
}
```

### Gestion des Transactions

#### Transaction basique

```java
public static void transferMoney(Connection conn, int fromAccountId,
                                 int toAccountId, double amount)
        throws SQLException {

    try {
        // D√©sactiver l'autocommit
        conn.setAutoCommit(false);

        // Op√©ration 1 : D√©biter le compte source
        String debitSql = "UPDATE comptes SET solde = solde - ? WHERE id = ?";
        try (PreparedStatement pstmt = conn.prepareStatement(debitSql)) {
            pstmt.setDouble(1, amount);
            pstmt.setInt(2, fromAccountId);
            pstmt.executeUpdate();
        }

        // Op√©ration 2 : Cr√©diter le compte destination
        String creditSql = "UPDATE comptes SET solde = solde + ? WHERE id = ?";
        try (PreparedStatement pstmt = conn.prepareStatement(creditSql)) {
            pstmt.setDouble(1, amount);
            pstmt.setInt(2, toAccountId);
            pstmt.executeUpdate();
        }

        // Valider la transaction
        conn.commit();
        System.out.println("‚úÖ Transfert r√©ussi");

    } catch (SQLException e) {
        // Annuler la transaction en cas d'erreur
        conn.rollback();
        System.err.println("‚ùå Transfert annul√© : " + e.getMessage());
        throw e;
    } finally {
        // R√©tablir l'autocommit
        conn.setAutoCommit(true);
    }
}
```

#### Transaction avec SAVEPOINT

```java
public static void complexTransaction(Connection conn) throws SQLException {
    Savepoint savepoint1 = null;

    try {
        conn.setAutoCommit(false);

        // Op√©ration 1
        String sql1 = "INSERT INTO logs (message) VALUES (?)";
        try (PreparedStatement pstmt = conn.prepareStatement(sql1)) {
            pstmt.setString(1, "Op√©ration 1");
            pstmt.executeUpdate();
        }

        // Cr√©er un savepoint
        savepoint1 = conn.setSavepoint("savepoint1");

        try {
            // Op√©ration 2 (risqu√©e)
            String sql2 = "INSERT INTO risky_table (data) VALUES (?)";
            try (PreparedStatement pstmt = conn.prepareStatement(sql2)) {
                pstmt.setString(1, "data");
                pstmt.executeUpdate();
            }
        } catch (SQLException e) {
            // Revenir au savepoint (annule seulement l'Op 2)
            if (savepoint1 != null) {
                conn.rollback(savepoint1);
                System.out.println("Savepoint restaur√©, Op 1 toujours valide");
            }
        }

        // Op√©ration 3
        String sql3 = "INSERT INTO logs (message) VALUES (?)";
        try (PreparedStatement pstmt = conn.prepareStatement(sql3)) {
            pstmt.setString(1, "Op√©ration 3");
            pstmt.executeUpdate();
        }

        conn.commit();
        System.out.println("‚úÖ Transaction valid√©e");

    } catch (SQLException e) {
        conn.rollback();
        throw e;
    } finally {
        conn.setAutoCommit(true);
    }
}
```

### Types de Donn√©es PostgreSQL

#### Types num√©riques

```java
// INTEGER, BIGINT
pstmt.setInt(1, 100);
pstmt.setLong(1, 1000000000L);

// NUMERIC/DECIMAL (utiliser BigDecimal pour la pr√©cision)
import java.math.BigDecimal;
pstmt.setBigDecimal(1, new BigDecimal("19.99"));

// FLOAT/DOUBLE PRECISION
pstmt.setFloat(1, 3.14f);
pstmt.setDouble(1, 3.14159);

// SERIAL (auto-increment) - g√©r√© automatiquement par PostgreSQL
```

#### Types texte

```java
// VARCHAR, TEXT
pstmt.setString(1, "Mon texte");

// CHAR (taille fixe)
pstmt.setString(1, "75001");
```

#### Types temporels

```java
import java.sql.Date;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;

// DATE
pstmt.setDate(1, Date.valueOf("2025-11-23"));
// Ou avec java.time (Java 8+)
pstmt.setObject(1, LocalDate.of(2025, 11, 23));

// TIMESTAMP
pstmt.setTimestamp(1, Timestamp.valueOf("2025-11-23 10:30:00"));
// Ou avec java.time
pstmt.setObject(1, LocalDateTime.now());

// TIMESTAMPTZ (avec timezone)
import java.time.ZonedDateTime;
pstmt.setObject(1, ZonedDateTime.now());

// Lecture
ResultSet rs = pstmt.executeQuery();
if (rs.next()) {
    LocalDate date = rs.getObject("date_column", LocalDate.class);
    LocalDateTime timestamp = rs.getObject("timestamp_column", LocalDateTime.class);
}
```

#### JSON et JSONB

```java
import org.postgresql.util.PGobject;

// Insertion JSON
PGobject jsonObject = new PGobject();
jsonObject.setType("jsonb");
jsonObject.setValue("{\"nom\": \"Alice\", \"age\": 30, \"tags\": [\"dev\", \"sql\"]}");

pstmt.setObject(1, jsonObject);

// Lecture JSON
ResultSet rs = pstmt.executeQuery();
if (rs.next()) {
    String json = rs.getString("profile");
    // Parser avec Jackson, Gson, etc.
    ObjectMapper mapper = new ObjectMapper();
    JsonNode node = mapper.readTree(json);
    String nom = node.get("nom").asText();
}
```

**Avec Jackson (biblioth√®que JSON populaire) :**

```java
import com.fasterxml.jackson.databind.ObjectMapper;

// S√©rialisation
ObjectMapper mapper = new ObjectMapper();
User user = new User("Alice", 30);
String json = mapper.writeValueAsString(user);

PGobject jsonb = new PGobject();
jsonb.setType("jsonb");
jsonb.setValue(json);
pstmt.setObject(1, jsonb);

// D√©s√©rialisation
ResultSet rs = pstmt.executeQuery();
if (rs.next()) {
    String jsonData = rs.getString("profile");
    User user = mapper.readValue(jsonData, User.class);
}
```

#### Arrays (Tableaux PostgreSQL)

```java
import java.sql.Array;

// Insertion d'array
String[] tags = {"java", "postgresql", "jdbc"};
Array sqlArray = conn.createArrayOf("text", tags);
pstmt.setArray(1, sqlArray);

// Lecture d'array
ResultSet rs = pstmt.executeQuery();
if (rs.next()) {
    Array array = rs.getArray("tags");
    String[] tags = (String[]) array.getArray();
    for (String tag : tags) {
        System.out.println(tag);
    }
}
```

#### UUID

```java
import java.util.UUID;

// G√©n√©ration UUID v4 c√¥t√© Java
UUID uuid = UUID.randomUUID();
pstmt.setObject(1, uuid);

// G√©n√©ration UUID v7 c√¥t√© PostgreSQL (PG 18)
pstmt.executeUpdate("INSERT INTO events (id, data) VALUES (gen_uuid_v7(), ?)");

// Lecture UUID
ResultSet rs = pstmt.executeQuery();
if (rs.next()) {
    UUID id = (UUID) rs.getObject("id");
    // Ou
    String uuidString = rs.getString("id");
    UUID id2 = UUID.fromString(uuidString);
}
```

### Gestion des Erreurs

#### Codes d'erreur PostgreSQL

```java
try {
    // Ex√©cution de requ√™te
    pstmt.executeUpdate();

} catch (SQLException e) {
    System.err.println("Code erreur : " + e.getErrorCode());
    System.err.println("SQLSTATE : " + e.getSQLState());
    System.err.println("Message : " + e.getMessage());

    // Codes SQLSTATE courants
    switch (e.getSQLState()) {
        case "23505": // Unique violation
            System.err.println("Cette valeur existe d√©j√†");
            break;
        case "23503": // Foreign key violation
            System.err.println("R√©f√©rence introuvable");
            break;
        case "23502": // NOT NULL violation
            System.err.println("Champ obligatoire manquant");
            break;
        case "42P01": // Undefined table
            System.err.println("Table inexistante");
            break;
        case "42703": // Undefined column
            System.err.println("Colonne inexistante");
            break;
        default:
            System.err.println("Erreur PostgreSQL : " + e.getMessage());
    }
}
```

#### Gestion avanc√©e avec exceptions personnalis√©es

```java
public class DatabaseException extends Exception {
    private final String sqlState;

    public DatabaseException(String message, String sqlState) {
        super(message);
        this.sqlState = sqlState;
    }

    public String getSqlState() {
        return sqlState;
    }
}

public class UserRepository {
    public void createUser(Connection conn, User user) throws DatabaseException {
        try {
            String sql = "INSERT INTO utilisateurs (nom, email) VALUES (?, ?)";
            try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
                pstmt.setString(1, user.getNom());
                pstmt.setString(2, user.getEmail());
                pstmt.executeUpdate();
            }
        } catch (SQLException e) {
            if ("23505".equals(e.getSQLState())) {
                throw new DatabaseException("Email d√©j√† utilis√©", e.getSQLState());
            }
            throw new DatabaseException("Erreur lors de la cr√©ation", e.getSQLState());
        }
    }
}
```

---

## Partie 2 : HikariCP (Connection Pool)

### Pourquoi un Pool de Connexions ?

Cr√©er une nouvelle connexion PostgreSQL est **co√ªteux** :
- √âtablissement de connexion TCP/IP
- Authentification SSL
- Allocation de ressources serveur
- Temps : ~50-200ms par connexion

Un **pool de connexions** maintient un ensemble de connexions r√©utilisables, r√©duisant drastiquement ce co√ªt.

**B√©n√©fices :**
- ‚ö° **Performance** : R√©duction de 80-95% du temps de connexion
- üéØ **Contr√¥le** : Limite le nombre de connexions actives
- üìä **Monitoring** : M√©triques et statistiques int√©gr√©es
- üîí **S√©curit√©** : Gestion automatique des connexions zombies

### Installation HikariCP

#### Maven

```xml
<dependency>
    <groupId>com.zaxxer</groupId>
    <artifactId>HikariCP</artifactId>
    <version>5.1.0</version>
</dependency>

<!-- PostgreSQL Driver -->
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>42.7.1</version>
</dependency>
```

#### Gradle

```groovy
implementation 'com.zaxxer:HikariCP:5.1.0'
implementation 'org.postgresql:postgresql:42.7.1'
```

### Configuration Basique

```java
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

public class DatabaseConfig {
    private static HikariDataSource dataSource;

    public static HikariDataSource getDataSource() {
        if (dataSource == null) {
            HikariConfig config = new HikariConfig();

            // Configuration de connexion
            config.setJdbcUrl("jdbc:postgresql://localhost:5432/mydb");
            config.setUsername("user");
            config.setPassword("password");

            // Configuration du pool
            config.setMaximumPoolSize(10);       // Maximum 10 connexions
            config.setMinimumIdle(2);            // Minimum 2 connexions actives
            config.setConnectionTimeout(30000);   // Timeout 30s
            config.setIdleTimeout(600000);        // Fermer apr√®s 10min d'inactivit√©
            config.setMaxLifetime(1800000);       // Dur√©e de vie max 30min

            // Optimisations
            config.setPoolName("PostgreSQLPool");
            config.addDataSourceProperty("cachePrepStmts", "true");
            config.addDataSourceProperty("prepStmtCacheSize", "250");
            config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");

            dataSource = new HikariDataSource(config);
        }
        return dataSource;
    }

    public static void close() {
        if (dataSource != null && !dataSource.isClosed()) {
            dataSource.close();
        }
    }
}
```

### Configuration Avanc√©e

```java
HikariConfig config = new HikariConfig();

// Connexion PostgreSQL
config.setJdbcUrl("jdbc:postgresql://localhost:5432/mydb");
config.setUsername("user");
config.setPassword("password");
config.setDriverClassName("org.postgresql.Driver");

// Taille du pool
config.setMaximumPoolSize(20);              // Max connexions (d√©faut: 10)
config.setMinimumIdle(5);                   // Min connexions idle (d√©faut: maxPoolSize)

// Timeouts
config.setConnectionTimeout(30000);         // 30s pour obtenir une connexion
config.setIdleTimeout(600000);              // 10min avant fermeture connexion idle
config.setMaxLifetime(1800000);             // 30min dur√©e de vie max d'une connexion
config.setKeepaliveTime(300000);            // 5min keepalive

// Validation
config.setConnectionTestQuery("SELECT 1");  // Query de validation (optionnel)
config.setValidationTimeout(5000);          // 5s pour valider une connexion

// Monitoring et logs
config.setPoolName("PostgreSQL-Pool");
config.setRegisterMbeans(true);             // JMX monitoring
config.setLeakDetectionThreshold(60000);    // D√©tecter connexions non ferm√©es (60s)

// Propri√©t√©s PostgreSQL sp√©cifiques
config.addDataSourceProperty("cachePrepStmts", "true");
config.addDataSourceProperty("prepStmtCacheSize", "250");
config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
config.addDataSourceProperty("useServerPrepStmts", "true");

HikariDataSource dataSource = new HikariDataSource(config);
```

### Param√®tres Recommand√©s par Cas d'Usage

#### Application Web Standard (OLTP)

```java
config.setMaximumPoolSize(20);      // CPU cores * 2 + disk spindles
config.setMinimumIdle(5);
config.setConnectionTimeout(30000);
config.setIdleTimeout(600000);
config.setMaxLifetime(1800000);
```

#### Microservice L√©ger

```java
config.setMaximumPoolSize(5);
config.setMinimumIdle(2);
config.setConnectionTimeout(10000);
config.setIdleTimeout(300000);
config.setMaxLifetime(900000);
```

#### Application Haute Charge

```java
config.setMaximumPoolSize(50);
config.setMinimumIdle(10);
config.setConnectionTimeout(5000);
config.setIdleTimeout(300000);
config.setMaxLifetime(1200000);
```

### Utilisation avec JDBC

```java
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

public class UserService {
    private final HikariDataSource dataSource;

    public UserService() {
        this.dataSource = DatabaseConfig.getDataSource();
    }

    public User findUserById(int id) throws SQLException {
        // Obtenir une connexion du pool
        try (Connection conn = dataSource.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(
                 "SELECT * FROM utilisateurs WHERE id = ?")) {

            pstmt.setInt(1, id);
            ResultSet rs = pstmt.executeQuery();

            if (rs.next()) {
                User user = new User();
                user.setId(rs.getInt("id"));
                user.setNom(rs.getString("nom"));
                user.setEmail(rs.getString("email"));
                return user;
            }

            return null;

        } // La connexion retourne automatiquement au pool
    }

    public void createUser(User user) throws SQLException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(
                 "INSERT INTO utilisateurs (nom, email, age) VALUES (?, ?, ?)",
                 Statement.RETURN_GENERATED_KEYS)) {

            pstmt.setString(1, user.getNom());
            pstmt.setString(2, user.getEmail());
            pstmt.setInt(3, user.getAge());

            pstmt.executeUpdate();

            ResultSet rs = pstmt.getGeneratedKeys();
            if (rs.next()) {
                user.setId(rs.getInt(1));
            }
        }
    }
}
```

### Monitoring et M√©triques

```java
import com.zaxxer.hikari.HikariPoolMXBean;

public class PoolMonitor {
    public static void printPoolStats(HikariDataSource dataSource) {
        HikariPoolMXBean poolBean = dataSource.getHikariPoolMXBean();

        System.out.println("=== Pool Statistics ===");
        System.out.println("Active Connections: " + poolBean.getActiveConnections());
        System.out.println("Idle Connections: " + poolBean.getIdleConnections());
        System.out.println("Total Connections: " + poolBean.getTotalConnections());
        System.out.println("Threads Awaiting: " + poolBean.getThreadsAwaitingConnection());
    }

    // Monitoring p√©riodique
    public static void startMonitoring(HikariDataSource dataSource) {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

        scheduler.scheduleAtFixedRate(() -> {
            printPoolStats(dataSource);
        }, 0, 30, TimeUnit.SECONDS);
    }
}
```

### Exemple Complet avec HikariCP

```java
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class UserRepository {
    private final HikariDataSource dataSource;

    public UserRepository(String jdbcUrl, String username, String password) {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(jdbcUrl);
        config.setUsername(username);
        config.setPassword(password);
        config.setMaximumPoolSize(10);
        config.setMinimumIdle(2);

        this.dataSource = new HikariDataSource(config);
    }

    public User create(User user) throws SQLException {
        String sql = "INSERT INTO utilisateurs (nom, email, age) VALUES (?, ?, ?) RETURNING *";

        try (Connection conn = dataSource.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setString(1, user.getNom());
            pstmt.setString(2, user.getEmail());
            pstmt.setInt(3, user.getAge());

            ResultSet rs = pstmt.executeQuery();

            if (rs.next()) {
                return mapResultSetToUser(rs);
            }

            throw new SQLException("√âchec de la cr√©ation");
        }
    }

    public User findById(int id) throws SQLException {
        String sql = "SELECT * FROM utilisateurs WHERE id = ?";

        try (Connection conn = dataSource.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, id);
            ResultSet rs = pstmt.executeQuery();

            if (rs.next()) {
                return mapResultSetToUser(rs);
            }

            return null;
        }
    }

    public List<User> findAll() throws SQLException {
        List<User> users = new ArrayList<>();
        String sql = "SELECT * FROM utilisateurs ORDER BY nom";

        try (Connection conn = dataSource.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {

            while (rs.next()) {
                users.add(mapResultSetToUser(rs));
            }
        }

        return users;
    }

    public void update(int id, User user) throws SQLException {
        String sql = "UPDATE utilisateurs SET nom = ?, email = ?, age = ? WHERE id = ?";

        try (Connection conn = dataSource.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setString(1, user.getNom());
            pstmt.setString(2, user.getEmail());
            pstmt.setInt(3, user.getAge());
            pstmt.setInt(4, id);

            int affected = pstmt.executeUpdate();

            if (affected == 0) {
                throw new SQLException("Utilisateur non trouv√©");
            }
        }
    }

    public void delete(int id) throws SQLException {
        String sql = "DELETE FROM utilisateurs WHERE id = ?";

        try (Connection conn = dataSource.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, id);

            int affected = pstmt.executeUpdate();

            if (affected == 0) {
                throw new SQLException("Utilisateur non trouv√©");
            }
        }
    }

    private User mapResultSetToUser(ResultSet rs) throws SQLException {
        User user = new User();
        user.setId(rs.getInt("id"));
        user.setNom(rs.getString("nom"));
        user.setEmail(rs.getString("email"));
        user.setAge(rs.getInt("age"));
        return user;
    }

    public void close() {
        if (dataSource != null && !dataSource.isClosed()) {
            dataSource.close();
        }
    }
}

// Utilisation
public class Main {
    public static void main(String[] args) {
        UserRepository repo = new UserRepository(
            "jdbc:postgresql://localhost:5432/mydb",
            "user",
            "password"
        );

        try {
            // Cr√©er
            User newUser = new User("Alice", "alice@example.com", 30);
            User created = repo.create(newUser);
            System.out.println("Cr√©√© : " + created.getId());

            // Lire
            User found = repo.findById(created.getId());
            System.out.println("Trouv√© : " + found.getNom());

            // Modifier
            found.setAge(31);
            repo.update(found.getId(), found);

            // Lister
            List<User> all = repo.findAll();
            System.out.println("Total : " + all.size());

            // Supprimer
            repo.delete(created.getId());

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            repo.close();
        }
    }
}
```

---

## Partie 3 : R2DBC (Reactive Relational Database Connectivity)

### Introduction √† R2DBC

**R2DBC** est une API r√©active pour les bases de donn√©es relationnelles, bas√©e sur le standard Reactive Streams. Contrairement √† JDBC (bloquant), R2DBC est :

- **Non-bloquant** : Les threads ne sont pas bloqu√©s en attendant les r√©ponses
- **R√©actif** : Bas√© sur les paradigmes Publisher/Subscriber (Reactor, RxJava)
- **Scalable** : Meilleure utilisation des ressources pour les charges √©lev√©es

**Quand utiliser R2DBC :**
- Applications Spring WebFlux (r√©actives)
- Microservices haute scalabilit√©
- Syst√®mes n√©cessitant des milliers de connexions concurrentes
- Architecture event-driven

**Quand NE PAS utiliser R2DBC :**
- Applications Spring MVC classiques
- √âquipes sans exp√©rience de la programmation r√©active
- Applications CRUD simples (overhead inutile)

### Installation R2DBC

#### Maven

```xml
<dependencies>
    <!-- R2DBC PostgreSQL Driver -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>r2dbc-postgresql</artifactId>
        <version>1.0.4.RELEASE</version>
    </dependency>

    <!-- R2DBC Pool -->
    <dependency>
        <groupId>io.r2dbc</groupId>
        <artifactId>r2dbc-pool</artifactId>
        <version>1.0.1.RELEASE</version>
    </dependency>

    <!-- Reactor Core (si pas d√©j√† inclus) -->
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-core</artifactId>
        <version>3.6.0</version>
    </dependency>
</dependencies>
```

### Concepts R√©actifs Essentiels

Avant d'utiliser R2DBC, il faut comprendre les concepts de base de la programmation r√©active :

#### Mono<T> : 0 ou 1 √©l√©ment

```java
// Mono = Publisher qui √©met 0 ou 1 √©l√©ment
Mono<User> userMono = userRepository.findById(1);

// Souscription (c'est l√† que l'op√©ration s'ex√©cute)
userMono.subscribe(
    user -> System.out.println("Trouv√© : " + user.getNom()),  // onNext
    error -> System.err.println("Erreur : " + error),          // onError
    () -> System.out.println("Termin√©")                        // onComplete
);
```

#### Flux<T> : 0 √† N √©l√©ments

```java
// Flux = Publisher qui √©met 0 √† N √©l√©ments
Flux<User> usersFlux = userRepository.findAll();

// Souscription
usersFlux.subscribe(
    user -> System.out.println("User : " + user.getNom()),
    error -> System.err.println("Erreur : " + error),
    () -> System.out.println("Tous les utilisateurs re√ßus")
);
```

**Analogie :**
- **Mono** = Promesse JavaScript (r√©sultat unique futur)
- **Flux** = Observable RxJS (stream de r√©sultats)

### Configuration de Base

```java
import io.r2dbc.postgresql.PostgresqlConnectionConfiguration;
import io.r2dbc.postgresql.PostgresqlConnectionFactory;
import io.r2dbc.spi.ConnectionFactory;

public class R2DBCConfig {
    public static ConnectionFactory createConnectionFactory() {
        PostgresqlConnectionConfiguration config = PostgresqlConnectionConfiguration.builder()
            .host("localhost")
            .port(5432)
            .database("mydb")
            .username("user")
            .password("password")
            .build();

        return new PostgresqlConnectionFactory(config);
    }
}
```

### Configuration avec Pool

```java
import io.r2dbc.pool.ConnectionPool;
import io.r2dbc.pool.ConnectionPoolConfiguration;
import io.r2dbc.postgresql.PostgresqlConnectionConfiguration;
import io.r2dbc.postgresql.PostgresqlConnectionFactory;

public class R2DBCPoolConfig {
    public static ConnectionPool createConnectionPool() {
        // Configuration PostgreSQL
        PostgresqlConnectionConfiguration pgConfig = PostgresqlConnectionConfiguration.builder()
            .host("localhost")
            .port(5432)
            .database("mydb")
            .username("user")
            .password("password")
            .build();

        ConnectionFactory connectionFactory = new PostgresqlConnectionFactory(pgConfig);

        // Configuration du pool
        ConnectionPoolConfiguration poolConfig = ConnectionPoolConfiguration.builder(connectionFactory)
            .maxSize(20)                        // Max 20 connexions
            .initialSize(5)                     // 5 connexions au d√©marrage
            .maxIdleTime(Duration.ofMinutes(30))
            .maxAcquireTime(Duration.ofSeconds(30))
            .maxCreateConnectionTime(Duration.ofSeconds(30))
            .build();

        return new ConnectionPool(poolConfig);
    }
}
```

### CRUD avec R2DBC

#### CREATE : Ins√©rer des donn√©es

```java
import io.r2dbc.spi.Connection;
import io.r2dbc.spi.ConnectionFactory;
import reactor.core.publisher.Mono;

public class UserRepository {
    private final ConnectionFactory connectionFactory;

    public UserRepository(ConnectionFactory connectionFactory) {
        this.connectionFactory = connectionFactory;
    }

    public Mono<User> create(User user) {
        String sql = "INSERT INTO utilisateurs (nom, email, age) VALUES ($1, $2, $3) RETURNING *";

        return Mono.from(connectionFactory.create())
            .flatMap(connection ->
                Mono.from(connection.createStatement(sql)
                    .bind("$1", user.getNom())
                    .bind("$2", user.getEmail())
                    .bind("$3", user.getAge())
                    .execute())
                .flatMap(result -> Mono.from(result.map((row, metadata) -> {
                    User newUser = new User();
                    newUser.setId(row.get("id", Integer.class));
                    newUser.setNom(row.get("nom", String.class));
                    newUser.setEmail(row.get("email", String.class));
                    newUser.setAge(row.get("age", Integer.class));
                    return newUser;
                })))
                .doFinally(signalType -> connection.close())
            );
    }
}

// Utilisation
Mono<User> userMono = userRepository.create(new User("Alice", "alice@example.com", 30));

userMono.subscribe(
    user -> System.out.println("Cr√©√© : " + user.getId()),
    error -> System.err.println("Erreur : " + error)
);
```

#### READ : Lire des donn√©es

```java
public Mono<User> findById(int id) {
    String sql = "SELECT * FROM utilisateurs WHERE id = $1";

    return Mono.from(connectionFactory.create())
        .flatMap(connection ->
            Mono.from(connection.createStatement(sql)
                .bind("$1", id)
                .execute())
            .flatMap(result -> Mono.from(result.map((row, metadata) -> {
                User user = new User();
                user.setId(row.get("id", Integer.class));
                user.setNom(row.get("nom", String.class));
                user.setEmail(row.get("email", String.class));
                user.setAge(row.get("age", Integer.class));
                return user;
            })))
            .doFinally(signalType -> connection.close())
        );
}

public Flux<User> findAll() {
    String sql = "SELECT * FROM utilisateurs ORDER BY nom";

    return Mono.from(connectionFactory.create())
        .flatMapMany(connection ->
            Flux.from(connection.createStatement(sql).execute())
                .flatMap(result -> result.map((row, metadata) -> {
                    User user = new User();
                    user.setId(row.get("id", Integer.class));
                    user.setNom(row.get("nom", String.class));
                    user.setEmail(row.get("email", String.class));
                    user.setAge(row.get("age", Integer.class));
                    return user;
                }))
                .doFinally(signalType -> connection.close())
        );
}
```

#### UPDATE : Modifier des donn√©es

```java
public Mono<Integer> update(int id, User user) {
    String sql = "UPDATE utilisateurs SET nom = $1, email = $2, age = $3 WHERE id = $4";

    return Mono.from(connectionFactory.create())
        .flatMap(connection ->
            Mono.from(connection.createStatement(sql)
                .bind("$1", user.getNom())
                .bind("$2", user.getEmail())
                .bind("$3", user.getAge())
                .bind("$4", id)
                .execute())
            .flatMap(result -> Mono.from(result.getRowsUpdated()))
            .doFinally(signalType -> connection.close())
        );
}
```

#### DELETE : Supprimer des donn√©es

```java
public Mono<Integer> delete(int id) {
    String sql = "DELETE FROM utilisateurs WHERE id = $1";

    return Mono.from(connectionFactory.create())
        .flatMap(connection ->
            Mono.from(connection.createStatement(sql)
                .bind("$1", id)
                .execute())
            .flatMap(result -> Mono.from(result.getRowsUpdated()))
            .doFinally(signalType -> connection.close())
        );
}
```

### Transactions R√©actives

```java
public Mono<Void> transferMoney(int fromAccountId, int toAccountId, double amount) {
    return Mono.from(connectionFactory.create())
        .flatMap(connection ->
            // D√©marrer la transaction
            Mono.from(connection.beginTransaction())
                .then(
                    // Op√©ration 1 : D√©biter
                    Mono.from(connection.createStatement(
                        "UPDATE comptes SET solde = solde - $1 WHERE id = $2")
                        .bind("$1", amount)
                        .bind("$2", fromAccountId)
                        .execute())
                    .flatMap(result -> Mono.from(result.getRowsUpdated()))
                )
                .then(
                    // Op√©ration 2 : Cr√©diter
                    Mono.from(connection.createStatement(
                        "UPDATE comptes SET solde = solde + $1 WHERE id = $2")
                        .bind("$1", amount)
                        .bind("$2", toAccountId)
                        .execute())
                    .flatMap(result -> Mono.from(result.getRowsUpdated()))
                )
                .then(Mono.from(connection.commitTransaction()))  // Commit
                .onErrorResume(error ->
                    Mono.from(connection.rollbackTransaction())   // Rollback
                        .then(Mono.error(error))
                )
                .doFinally(signalType -> connection.close())
        );
}
```

### Exemple Complet avec R2DBC

```java
import io.r2dbc.pool.ConnectionPool;
import io.r2dbc.spi.Connection;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

public class ReactiveUserRepository {
    private final ConnectionPool connectionPool;

    public ReactiveUserRepository(ConnectionPool connectionPool) {
        this.connectionPool = connectionPool;
    }

    public Mono<User> create(User user) {
        String sql = "INSERT INTO utilisateurs (nom, email, age) VALUES ($1, $2, $3) RETURNING *";

        return Mono.from(connectionPool.create())
            .flatMap(connection ->
                executeAndMapSingle(connection, sql, user)
                    .doFinally(sig -> connection.close())
            );
    }

    public Mono<User> findById(int id) {
        String sql = "SELECT * FROM utilisateurs WHERE id = $1";

        return Mono.from(connectionPool.create())
            .flatMap(connection ->
                Mono.from(connection.createStatement(sql)
                    .bind("$1", id)
                    .execute())
                .flatMap(result -> Mono.from(result.map(this::mapRowToUser)))
                .doFinally(sig -> connection.close())
            );
    }

    public Flux<User> findAll() {
        String sql = "SELECT * FROM utilisateurs ORDER BY nom";

        return Mono.from(connectionPool.create())
            .flatMapMany(connection ->
                Flux.from(connection.createStatement(sql).execute())
                    .flatMap(result -> result.map(this::mapRowToUser))
                    .doFinally(sig -> connection.close())
            );
    }

    public Mono<Integer> update(int id, User user) {
        String sql = "UPDATE utilisateurs SET nom = $1, email = $2, age = $3 WHERE id = $4";

        return Mono.from(connectionPool.create())
            .flatMap(connection ->
                Mono.from(connection.createStatement(sql)
                    .bind("$1", user.getNom())
                    .bind("$2", user.getEmail())
                    .bind("$3", user.getAge())
                    .bind("$4", id)
                    .execute())
                .flatMap(result -> Mono.from(result.getRowsUpdated()))
                .doFinally(sig -> connection.close())
            );
    }

    public Mono<Integer> delete(int id) {
        String sql = "DELETE FROM utilisateurs WHERE id = $1";

        return Mono.from(connectionPool.create())
            .flatMap(connection ->
                Mono.from(connection.createStatement(sql)
                    .bind("$1", id)
                    .execute())
                .flatMap(result -> Mono.from(result.getRowsUpdated()))
                .doFinally(sig -> connection.close())
            );
    }

    private User mapRowToUser(Row row, RowMetadata metadata) {
        User user = new User();
        user.setId(row.get("id", Integer.class));
        user.setNom(row.get("nom", String.class));
        user.setEmail(row.get("email", String.class));
        user.setAge(row.get("age", Integer.class));
        return user;
    }

    private Mono<User> executeAndMapSingle(Connection connection, String sql, User user) {
        return Mono.from(connection.createStatement(sql)
            .bind("$1", user.getNom())
            .bind("$2", user.getEmail())
            .bind("$3", user.getAge())
            .execute())
        .flatMap(result -> Mono.from(result.map(this::mapRowToUser)));
    }
}

// Utilisation
public class Main {
    public static void main(String[] args) {
        ConnectionPool pool = R2DBCPoolConfig.createConnectionPool();
        ReactiveUserRepository repo = new ReactiveUserRepository(pool);

        // Cr√©er un utilisateur
        User newUser = new User("Alice", "alice@example.com", 30);

        repo.create(newUser)
            .flatMap(created -> {
                System.out.println("Cr√©√© : " + created.getId());
                // R√©cup√©rer l'utilisateur
                return repo.findById(created.getId());
            })
            .flatMap(found -> {
                System.out.println("Trouv√© : " + found.getNom());
                // Modifier
                found.setAge(31);
                return repo.update(found.getId(), found)
                    .thenReturn(found);
            })
            .flatMapMany(updated -> {
                // Lister tous
                return repo.findAll();
            })
            .doOnNext(user -> System.out.println("User : " + user.getNom()))
            .then()
            .doFinally(sig -> pool.dispose())
            .block(); // Bloquer pour l'exemple (√©viter en prod)
    }
}
```

---

## Comparaison : JDBC vs JDBC+HikariCP vs R2DBC

### Performance

**Benchmark indicatif (1000 requ√™tes SELECT) :**
- **JDBC simple** : ~2000ms
- **JDBC + HikariCP** : ~300ms (6-7√ó plus rapide)
- **R2DBC** : ~250ms (8√ó plus rapide)

**Note :** Les gains R2DBC sont surtout visibles sous forte charge concurrente.

### Scalabilit√©

| Approche | Connexions concurrentes | Mod√®le |
|----------|------------------------|---------|
| JDBC simple | Limit√© (1 thread = 1 connexion) | Bloquant |
| JDBC + HikariCP | Bon (pool optimis√©) | Bloquant |
| R2DBC | Excellent (milliers) | Non-bloquant |

### Complexit√© du Code

**JDBC + HikariCP :**
```java
// Code imp√©ratif simple
try (Connection conn = pool.getConnection()) {
    PreparedStatement pstmt = conn.prepareStatement("SELECT * FROM users WHERE id = ?");
    pstmt.setInt(1, 1);
    ResultSet rs = pstmt.executeQuery();
    if (rs.next()) {
        return new User(rs.getInt("id"), rs.getString("nom"));
    }
}
```

**R2DBC :**
```java
// Code r√©actif (plus verbeux)
return Mono.from(pool.create())
    .flatMap(connection ->
        Mono.from(connection.createStatement("SELECT * FROM users WHERE id = $1")
            .bind("$1", 1)
            .execute())
        .flatMap(result -> Mono.from(result.map((row, meta) ->
            new User(row.get("id", Integer.class), row.get("nom", String.class))
        )))
        .doFinally(sig -> connection.close())
    );
```

### Quand Utiliser Chaque Approche

#### JDBC + HikariCP ‚úÖ

**Choisir si :**
- Application Spring Boot MVC classique
- √âquipe exp√©riment√©e en Java mais pas en r√©actif
- Application CRUD standard
- Migration depuis JDBC existant
- Besoin de stabilit√© et maturit√©

**Exemples :**
- API REST Spring Boot
- Application web e-commerce
- Syst√®me de gestion interne

#### R2DBC ‚úÖ

**Choisir si :**
- Application Spring WebFlux (r√©active)
- Besoin de haute scalabilit√© (milliers de connexions)
- Architecture event-driven
- Microservices haute performance
- √âquipe √† l'aise avec la programmation r√©active

**Exemples :**
- API Gateway r√©actif
- Syst√®me de streaming de donn√©es
- Chat en temps r√©el
- IoT avec millions de devices

---

## Bonnes Pratiques

### 1. Toujours Utiliser un Pool de Connexions

‚ùå **√âviter :**
```java
// Cr√©er une nouvelle connexion √† chaque requ√™te
Connection conn = DriverManager.getConnection(url, user, pass);
```

‚úÖ **Bon :**
```java
// Utiliser HikariCP
HikariDataSource dataSource = new HikariDataSource(config);
Connection conn = dataSource.getConnection();
```

### 2. Toujours Utiliser PreparedStatement

‚ùå **Dangereux :**
```java
Statement stmt = conn.createStatement();
stmt.executeQuery("SELECT * FROM users WHERE email = '" + email + "'");
```

‚úÖ **S√©curis√© :**
```java
PreparedStatement pstmt = conn.prepareStatement("SELECT * FROM users WHERE email = ?");
pstmt.setString(1, email);
```

### 3. Fermer les Ressources (try-with-resources)

‚ùå **√âviter :**
```java
Connection conn = dataSource.getConnection();
PreparedStatement pstmt = conn.prepareStatement(sql);
// Oubli de fermeture = fuite de ressources
```

‚úÖ **Bon :**
```java
try (Connection conn = dataSource.getConnection();
     PreparedStatement pstmt = conn.prepareStatement(sql)) {
    // Ressources ferm√©es automatiquement
}
```

### 4. Configurer Correctement le Pool

```java
// Configuration adapt√©e √† votre charge
config.setMaximumPoolSize(20);              // Pas trop haut (surcharge DB)
config.setMinimumIdle(5);                   // Connexions toujours pr√™tes
config.setConnectionTimeout(30000);         // Timeout raisonnable
config.setLeakDetectionThreshold(60000);    // D√©tecter les fuites
```

### 5. G√©rer les Erreurs Proprement

```java
try {
    // Op√©rations DB
} catch (SQLException e) {
    // Logger l'erreur
    logger.error("Erreur DB: {}", e.getMessage(), e);

    // Traiter selon le code d'erreur
    if ("23505".equals(e.getSQLState())) {
        throw new DuplicateKeyException("Valeur d√©j√† existante");
    }

    // Rethrow ou wrapper
    throw new DatabaseException("Erreur lors de l'op√©ration", e);
}
```

### 6. Utiliser des Transactions pour les Op√©rations Multiples

```java
try (Connection conn = dataSource.getConnection()) {
    conn.setAutoCommit(false);

    try {
        // Op√©ration 1
        // Op√©ration 2
        // Op√©ration 3

        conn.commit();
    } catch (Exception e) {
        conn.rollback();
        throw e;
    }
}
```

### 7. Monitoring et Logging

```java
// HikariCP : activer JMX monitoring
config.setRegisterMbeans(true);

// Log des requ√™tes lentes
config.setLeakDetectionThreshold(60000);

// Log p√©riodique des stats
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
scheduler.scheduleAtFixedRate(() -> {
    HikariPoolMXBean poolBean = dataSource.getHikariPoolMXBean();
    logger.info("Pool stats: Active={}, Idle={}, Total={}",
        poolBean.getActiveConnections(),
        poolBean.getIdleConnections(),
        poolBean.getTotalConnections());
}, 0, 60, TimeUnit.SECONDS);
```

---

## Ressources et Documentation

### JDBC
- **Documentation Oracle JDBC** : https://docs.oracle.com/javase/tutorial/jdbc/
- **PostgreSQL JDBC Driver** : https://jdbc.postgresql.org/

### HikariCP
- **Documentation officielle** : https://github.com/brettwooldridge/HikariCP
- **Configuration Guide** : https://github.com/brettwooldridge/HikariCP/wiki/Configuration

### R2DBC
- **Documentation officielle** : https://r2dbc.io/
- **R2DBC PostgreSQL** : https://github.com/pgjdbc/r2dbc-postgresql
- **Project Reactor** : https://projectreactor.io/

### Spring Boot
- **Spring Data JDBC** : https://spring.io/projects/spring-data-jdbc
- **Spring Data R2DBC** : https://spring.io/projects/spring-data-r2dbc

---

## R√©sum√© des Points Cl√©s

### JDBC

- ‚úÖ API standard Java pour bases de donn√©es
- ‚úÖ Utilisez **PreparedStatement** pour √©viter les injections SQL
- ‚úÖ **Try-with-resources** pour fermer automatiquement les ressources
- ‚úÖ Gestion des transactions avec `setAutoCommit(false)`, `commit()`, `rollback()`
- ‚úÖ Support complet de tous les types PostgreSQL

### HikariCP

- ‚úÖ **Pool de connexions** le plus performant en Java
- ‚úÖ Configuration simple et intuitive
- ‚úÖ **Obligatoire** pour les applications en production
- ‚úÖ Monitoring int√©gr√© (JMX)
- ‚úÖ Utilis√© par d√©faut dans Spring Boot

### R2DBC

- ‚úÖ API **r√©active** et non-bloquante
- ‚úÖ Bas√© sur **Reactor** (Mono/Flux)
- ‚úÖ Id√©al pour **Spring WebFlux** et architectures r√©actives
- ‚úÖ **Scalabilit√©** exceptionnelle (milliers de connexions)
- ‚úÖ Plus **complexe** que JDBC (courbe d'apprentissage)

### Choix Final

**Pour 90% des projets :** JDBC + HikariCP (stable, mature, performant)
**Pour applications r√©actives :** R2DBC (scalabilit√© maximale)
**Pour prototypes/scripts :** JDBC simple (sans pool)

---

**Prochaine √©tape :** Explorez les autres drivers (Go pgx, .NET Npgsql) pour comparer les approches et ma√Ætriser PostgreSQL dans tous les √©cosyst√®mes.

‚è≠Ô∏è [Go : pgx, GORM](/20-drivers-connexion-applicative/01.4-go-pgx-gorm.md)
