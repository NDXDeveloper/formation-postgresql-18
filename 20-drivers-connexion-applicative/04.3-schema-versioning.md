üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.4.3. Schema Versioning

## Introduction

Le **Schema Versioning** (versionnement de sch√©ma) est l'art de g√©rer et tracer l'√©volution de la structure de votre base de donn√©es PostgreSQL dans le temps. Alors que les migrations (chapitre pr√©c√©dent 20.4.2) sont les **m√©canismes** qui appliquent les changements, le schema versioning est la **strat√©gie** qui organise ces changements.

### M√©taphore : Le livre d'histoire de votre base de donn√©es

Imaginez votre base de donn√©es PostgreSQL comme un b√¢timent :
- **Les migrations** sont les travaux de r√©novation (ajouter une pi√®ce, changer une porte)
- **Le schema versioning** est le syst√®me de num√©rotation qui identifie chaque version du b√¢timent (v1.0, v1.1, v2.0)

Le schema versioning r√©pond √† des questions cruciales :
- Quelle version du sch√©ma est d√©ploy√©e en production ?
- Mon code en version 2.3 est-il compatible avec le sch√©ma en version 2.1 ?
- Comment documenter les breaking changes entre versions ?
- Comment g√©rer plusieurs versions simultan√©ment (migration progressive) ?

## Pourquoi le schema versioning est-il important ?

### Probl√®me 1 : Coordination Code ‚Üî Base de donn√©es

Votre application √©volue en parall√®le de votre base de donn√©es :

```plaintext
Situation sans versioning :
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Timeline:
  Lundi    : D√©ploiement application v1.5
  Mardi    : Quelqu'un applique une migration
  Mercredi : Application plante en production
  Jeudi    : Investigation : Quelle version du sch√©ma ?
  Vendredi : Impossible √† d√©terminer ‚Üí Chaos

Situation avec versioning :
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Timeline:
  Lundi    : D√©ploiement application v1.5 (requiert sch√©ma v1.4+)
  Mardi    : Migration appliqu√©e ‚Üí Sch√©ma passe √† v1.5
  Mercredi : Application fonctionne parfaitement

  ‚Üí Tra√ßabilit√© claire : App v1.5 ‚Üî Sch√©ma v1.5
```

### Probl√®me 2 : D√©ploiements progressifs

Dans les architectures modernes (microservices, blue/green deployment), plusieurs versions de votre application peuvent coexister :

```plaintext
Sans schema versioning :
  Production A : Application v2.0
  Production B : Application v2.1 (d√©ploiement en cours)
  ‚Üí Les deux versions doivent parler √† la m√™me base
  ‚Üí Quelle version du sch√©ma utiliser ? Myst√®re...

Avec schema versioning :
  Production A : App v2.0 (compatible sch√©ma v2.0 √† v2.2)
  Production B : App v2.1 (compatible sch√©ma v2.1 √† v2.2)
  Sch√©ma actuel : v2.1
  ‚Üí Compatibilit√© garantie pour les deux versions
```

### Probl√®me 3 : Communication d'√©quipe

```plaintext
D√©veloppeur Backend : "J'ai besoin de la colonne user_status dans users"
D√©veloppeur Frontend : "Quelle version de l'API dois-je utiliser ?"
DevOps : "Quelle version du sch√©ma est en staging ?"
DBA : "Quand peut-on supprimer l'ancienne colonne legacy_field ?"

‚Üí Sans versioning : Confusion totale
‚Üí Avec versioning : R√©ponses claires gr√¢ce aux num√©ros de version
```

### Probl√®me 4 : Rollback et d√©gradation

```plaintext
D√©ploiement v3.0 √©choue en production :

Sans versioning :
  ‚Üí On ne sait pas √† quelle version revenir
  ‚Üí Risque de casser d'autres services

Avec versioning :
  ‚Üí Sch√©ma v3.0 est incompatible
  ‚Üí Rollback au sch√©ma v2.5 (version stable connue)
  ‚Üí Application retourne en v2.5 aussi
  ‚Üí Service restaur√© en toute confiance
```

## Les strat√©gies de versionnement

### 1. Sequential Versioning (Versionnement s√©quentiel)

C'est l'approche la plus simple : chaque migration incr√©mente un compteur.

```plaintext
Format : Version = Num√©ro s√©quentiel

Exemples :
  Version 1  : Cr√©ation initiale des tables
  Version 2  : Ajout colonne email
  Version 3  : Ajout table orders
  Version 4  : Ajout index sur email
  Version 5  : Renommage colonne name ‚Üí full_name
  ...
  Version 247 : √âtat actuel
```

#### Avantages
- ‚úÖ **Simplicit√©** : Facile √† comprendre (1, 2, 3, 4...)
- ‚úÖ **Ordre clair** : On sait toujours quelle version vient avant/apr√®s
- ‚úÖ **Peu de conflits** : Les num√©ros ne se chevauchent pas

#### Inconv√©nients
- ‚ùå **Pas de signification** : Le num√©ro 247 ne dit rien sur l'importance des changements
- ‚ùå **Difficile pour les branches** : Si deux d√©veloppeurs cr√©ent la version 50 en parall√®le ‚Üí conflit
- ‚ùå **Pas d'indication de compatibilit√©** : Impossible de savoir si v100 casse v99

#### Cas d'usage
- Projets simples avec une seule √©quipe
- D√©veloppement lin√©aire (pas de branches parall√®les)
- Petites applications

**Exemple avec Flyway :**
```plaintext
V1__create_users_table.sql
V2__add_email_to_users.sql
V3__create_orders_table.sql
V4__add_foreign_key_orders_users.sql
```

### 2. Timestamp Versioning (Versionnement par date)

Utilise la date et l'heure comme num√©ro de version.

```plaintext
Format : Version = YYYYMMDDHHmmSS

Exemples :
  Version 20250115103000  : 15 janvier 2025, 10h30
  Version 20250115143000  : 15 janvier 2025, 14h30
  Version 20250120091500  : 20 janvier 2025, 09h15
  Version 20250203140000  : 3 f√©vrier 2025, 14h00
```

#### Avantages
- ‚úÖ **Unicit√© garantie** : Deux d√©veloppeurs ne peuvent pas cr√©er le m√™me timestamp
- ‚úÖ **Contexte temporel** : On sait quand la migration a √©t√© cr√©√©e
- ‚úÖ **Ordre chronologique** : Tri naturel par date

#### Inconv√©nients
- ‚ùå **Num√©ros longs** : 20250115103000 est moins lisible que 5
- ‚ùå **Pas de signification s√©mantique** : Impossible de savoir si c'est un changement majeur ou mineur
- ‚ùå **Conflits possibles** : Si deux d√©veloppeurs cr√©ent une migration √† la m√™me seconde

#### Cas d'usage
- √âquipes distribu√©es travaillant en parall√®le
- Projets avec beaucoup de branches de d√©veloppement
- Besoin de tra√ßabilit√© temporelle

**Exemple avec Alembic :**
```plaintext
20250115103000_create_users_table.py
20250115143000_add_email_to_users.py
20250120091500_create_orders_table.py
```

### 3. Semantic Versioning (Versionnement s√©mantique)

Utilise le standard **SemVer** : `MAJOR.MINOR.PATCH`

```plaintext
Format : MAJOR.MINOR.PATCH

Exemples :
  Version 1.0.0  : Premi√®re version stable
  Version 1.1.0  : Ajout de fonctionnalit√©s compatibles
  Version 1.1.1  : Correction de bug (pas de changement de sch√©ma)
  Version 2.0.0  : Breaking change (incompatible avec v1.x)
  Version 2.1.0  : Nouvelles fonctionnalit√©s (compatible v2.0.0)
```

#### R√®gles SemVer pour les bases de donn√©es

**MAJOR (X.0.0)** - Breaking change
```plaintext
Changements qui cassent la compatibilit√© :
  - Renommer une table ou colonne
  - Supprimer une table ou colonne
  - Changer le type d'une colonne (VARCHAR ‚Üí INTEGER)
  - Modifier une contrainte (nullable ‚Üí NOT NULL)
  - Supprimer un index utilis√©

Exemple :
  v1.5.2 ‚Üí v2.0.0
  ALTER TABLE users RENAME COLUMN name TO full_name;
  ‚Üí Les applications lisant "name" vont planter
```

**MINOR (0.X.0)** - Ajout r√©trocompatible
```plaintext
Changements qui ajoutent sans casser :
  - Ajouter une nouvelle table
  - Ajouter une colonne nullable
  - Ajouter un index
  - Cr√©er une vue
  - Ajouter une fonction

Exemple :
  v1.4.0 ‚Üí v1.5.0
  ALTER TABLE users ADD COLUMN phone VARCHAR(20);
  ‚Üí Les applications existantes continuent de fonctionner
```

**PATCH (0.0.X)** - Corrections
```plaintext
Corrections sans impact sur le sch√©ma :
  - Correction de donn√©es (UPDATE)
  - Optimisation d'index existant
  - Correction de commentaires
  - Mise √† jour de statistiques (ANALYZE)

Exemple :
  v1.4.2 ‚Üí v1.4.3
  UPDATE users SET status = 'active' WHERE status IS NULL;
  ‚Üí Pas de changement structurel
```

#### Avantages
- ‚úÖ **Signification claire** : On comprend imm√©diatement l'impact du changement
- ‚úÖ **Compatibilit√© pr√©visible** : v2.3.0 est compatible avec toute app supportant v2.0.0+
- ‚úÖ **Standard reconnu** : SemVer est utilis√© partout (npm, Maven, etc.)
- ‚úÖ **Communication facilit√©e** : "On passe √† la v2.0" = breaking change √©vident

#### Inconv√©nients
- ‚ùå **Complexit√©** : N√©cessite de comprendre SemVer
- ‚ùå **Subjectivit√©** : D√©bats sur ce qui est "breaking" ou pas
- ‚ùå **Gestion manuelle** : Il faut d√©cider consciemment du num√©ro de version

#### Cas d'usage
- Projets avec plusieurs √©quipes consommatrices (APIs, microservices)
- Applications n√©cessitant une compatibilit√© stricte
- Documentation et communication importantes
- Projets matures avec cycle de release structur√©

**Exemple d'organisation :**
```plaintext
migrations/
‚îú‚îÄ‚îÄ v1/
‚îÇ   ‚îú‚îÄ‚îÄ 1.0.0__initial_schema.sql
‚îÇ   ‚îú‚îÄ‚îÄ 1.1.0__add_orders_table.sql
‚îÇ   ‚îú‚îÄ‚îÄ 1.2.0__add_payments_table.sql
‚îÇ   ‚îî‚îÄ‚îÄ 1.2.1__fix_payment_constraints.sql
‚îú‚îÄ‚îÄ v2/
‚îÇ   ‚îú‚îÄ‚îÄ 2.0.0__rename_users_columns.sql  ‚Üê Breaking
‚îÇ   ‚îú‚îÄ‚îÄ 2.1.0__add_notifications.sql
‚îÇ   ‚îî‚îÄ‚îÄ 2.2.0__add_audit_logging.sql
‚îî‚îÄ‚îÄ current_version.txt ‚Üí "2.2.0"
```

### 4. Hybrid Versioning (Versionnement hybride)

Combine plusieurs approches : SemVer + Timestamp ou Sequential + SemVer.

```plaintext
Format : MAJOR.MINOR.PATCH-TIMESTAMP

Exemples :
  Version 1.0.0-20250115
  Version 1.1.0-20250120
  Version 2.0.0-20250203

Ou : MAJOR.MINOR-SEQUENTIAL

Exemples :
  Version 1.0-001
  Version 1.0-002
  Version 1.1-001
  Version 2.0-001
```

#### Avantages
- ‚úÖ **Meilleur des deux mondes** : S√©mantique + unicit√© temporelle
- ‚úÖ **Flexibilit√©** : Adapt√© aux besoins sp√©cifiques

#### Inconv√©nients
- ‚ùå **Complexit√© accrue** : Plus difficile √† maintenir
- ‚ùå **Conventions √† d√©finir** : L'√©quipe doit cr√©er ses propres r√®gles

#### Cas d'usage
- Grands projets avec multiples √©quipes
- Besoins de tra√ßabilit√© extr√™me
- D√©ploiements complexes multi-environnements

## Compatibilit√© entre versions

### Backward Compatibility (R√©trocompatibilit√©)

Une nouvelle version de sch√©ma est **r√©trocompatible** si les anciennes versions de l'application continuent de fonctionner.

```plaintext
Sch√©ma v1.0 :
  Table users (id, name, email)

Application v1.0 :
  SELECT id, name, email FROM users;  ‚úÖ

Migration vers Sch√©ma v1.1 :
  ALTER TABLE users ADD COLUMN phone VARCHAR(20);

Application v1.0 (inchang√©e) :
  SELECT id, name, email FROM users;  ‚úÖ Fonctionne toujours !
  ‚Üí Phone est ignor√©, pas de probl√®me

‚Üí Sch√©ma v1.1 est BACKWARD COMPATIBLE avec App v1.0
```

**Principe :** Ajouter sans supprimer ni modifier.

#### Changements r√©trocompatibles

‚úÖ **Ajouter une colonne nullable**
```sql
ALTER TABLE users ADD COLUMN phone VARCHAR(20);
-- Anciennes requ√™tes fonctionnent (ignorent phone)
```

‚úÖ **Ajouter une nouvelle table**
```sql
CREATE TABLE notifications (...);
-- Anciennes requ√™tes ne touchent pas cette table
```

‚úÖ **Ajouter un index**
```sql
CREATE INDEX idx_users_email ON users(email);
-- Transparent pour l'application
```

‚úÖ **Cr√©er une vue**
```sql
CREATE VIEW active_users AS SELECT * FROM users WHERE deleted_at IS NULL;
-- Les requ√™tes sur users continuent de fonctionner
```

#### Changements NON r√©trocompatibles (Breaking changes)

‚ùå **Renommer une colonne**
```sql
ALTER TABLE users RENAME COLUMN name TO full_name;
-- SELECT name FROM users; ‚Üí ERREUR : colonne "name" n'existe plus
```

‚ùå **Supprimer une colonne**
```sql
ALTER TABLE users DROP COLUMN phone;
-- SELECT phone FROM users; ‚Üí ERREUR
```

‚ùå **Changer le type d'une colonne**
```sql
ALTER TABLE users ALTER COLUMN age TYPE VARCHAR(10);
-- Requ√™tes attendant un INTEGER vont √©chouer
```

‚ùå **Ajouter une contrainte NOT NULL**
```sql
ALTER TABLE users ALTER COLUMN email SET NOT NULL;
-- INSERT INTO users (name) VALUES ('John'); ‚Üí ERREUR : email manquant
```

### Forward Compatibility (Compatibilit√© future)

Une ancienne version de sch√©ma est **compatible avec les futures versions** de l'application.

```plaintext
Sch√©ma v1.0 :
  Table users (id, name, email)

Application v1.1 (nouvelle) :
  SELECT id, name, email, phone FROM users;
  ‚Üí ERREUR si phone n'existe pas dans sch√©ma v1.0

‚Üí Sch√©ma v1.0 n'est PAS FORWARD COMPATIBLE avec App v1.1

Solution :
  Application v1.1 g√®re gracieusement l'absence de phone :
  SELECT id, name, email, COALESCE(phone, '') as phone FROM users;
```

**Principe :** Le code doit √™tre tol√©rant aux changements futurs du sch√©ma.

### Strat√©gie de compatibilit√© id√©ale

```plaintext
Golden Rule : Expand-Migrate-Contract

Phase 1 - EXPAND (√âtendre) :
  Sch√©ma v1.1 : Ajouter nouvelle colonne full_name (nullable)
  Application v1.0 : Continue d'utiliser name
  Application v1.1 : Utilise full_name si disponible, sinon name
  ‚Üí Les deux versions coexistent

Phase 2 - MIGRATE (Migrer) :
  Sch√©ma v1.1 : Copier les donn√©es de name vers full_name
  Application v1.2 : Utilise uniquement full_name
  ‚Üí Migration progressive

Phase 3 - CONTRACT (Retirer) :
  Sch√©ma v2.0 : Supprimer l'ancienne colonne name
  ‚Üí Breaking change contr√¥l√©, tout le monde est pr√™t
```

Cette strat√©gie permet des **d√©ploiements sans interruption**.

## Tra√ßabilit√© et documentation

### 1. Fichier de version central

Cr√©ez un fichier qui documente la version actuelle du sch√©ma :

**Fichier : schema_version.txt**
```plaintext
CURRENT_VERSION=2.5.0
LAST_MIGRATION=20250203_add_notifications_table
COMPATIBLE_APP_VERSIONS=2.3.0,2.4.0,2.5.0
BREAKING_CHANGES_FROM=1.x
```

Ce fichier doit √™tre :
- ‚úÖ Versionn√© dans Git
- ‚úÖ Mis √† jour automatiquement par les migrations
- ‚úÖ Consult√© par les scripts de d√©ploiement

### 2. Table de m√©tadonn√©es PostgreSQL

Cr√©ez une table d√©di√©e au versionnement :

```sql
CREATE TABLE schema_version (
    version VARCHAR(20) PRIMARY KEY,
    applied_at TIMESTAMPTZ DEFAULT NOW(),
    description TEXT,
    breaking_change BOOLEAN DEFAULT false,
    compatible_with VARCHAR(100),  -- Versions compatibles
    migration_script VARCHAR(255),
    applied_by VARCHAR(100)
);
```

**Exemple de contenu :**
```sql
INSERT INTO schema_version (version, description, breaking_change, compatible_with) VALUES
('1.0.0', 'Initial schema', false, 'app>=1.0.0'),
('1.1.0', 'Added orders table', false, 'app>=1.0.0'),
('1.2.0', 'Added payments', false, 'app>=1.0.0'),
('2.0.0', 'Renamed users.name to full_name', true, 'app>=2.0.0'),
('2.1.0', 'Added notifications', false, 'app>=2.0.0');
```

**Requ√™te pour v√©rifier la version :**
```sql
SELECT version, applied_at, breaking_change
FROM schema_version
ORDER BY applied_at DESC
LIMIT 1;
```

### 3. Changelog structur√©

Maintenez un fichier CHANGELOG.md qui documente chaque version :

**Fichier : CHANGELOG.md**
```markdown
# Changelog - Database Schema

## [2.1.0] - 2025-02-03
### Added
- Table `notifications` pour le syst√®me de notifications push
- Index `idx_notifications_user_id` pour optimiser les requ√™tes
- Trigger `update_notifications_timestamp` pour mise √† jour automatique

### Compatible avec
- Application v2.0.0+
- API v2.x

---

## [2.0.0] - 2025-01-25 ‚ö†Ô∏è BREAKING CHANGE
### Changed
- Renomm√© `users.name` ‚Üí `users.full_name`
- Modifi√© type `orders.amount` : INTEGER ‚Üí NUMERIC(10,2)

### Removed
- Colonne `users.legacy_field` (deprecated depuis v1.5.0)

### Migration Path
Pour migrer depuis v1.x :
1. Mettre √† jour l'application vers v2.0.0+
2. Appliquer les migrations v2.0.0
3. Tester sur staging avant production

### Compatible avec
- Application v2.0.0+ uniquement
- ‚ö†Ô∏è INCOMPATIBLE avec app v1.x

---

## [1.2.0] - 2025-01-15
### Added
- Table `payments` avec foreign key vers `orders`
- Vue `pending_payments` pour les paiements en attente

### Compatible avec
- Application v1.0.0+
```

### 4. Tags Git pour les versions majeures

Utilisez les tags Git pour marquer les versions importantes du sch√©ma :

```bash
# Cr√©er un tag pour une version majeure
git tag -a schema-v2.0.0 -m "Schema version 2.0.0 - Breaking changes"
git push origin schema-v2.0.0

# Lister tous les tags de sch√©ma
git tag -l "schema-v*"
```

Cela permet de retrouver facilement l'√©tat du sch√©ma √† n'importe quelle version.

### 5. Commentaires PostgreSQL

Utilisez les commentaires natifs PostgreSQL pour documenter :

```sql
-- Documenter une table
COMMENT ON TABLE users IS
'User accounts. Schema version: 2.0.0.
Breaking change from v1.x: column "name" renamed to "full_name".';

-- Documenter une colonne
COMMENT ON COLUMN users.full_name IS
'User full name. Added in v2.0.0 (renamed from "name").
Required for all new users.';

-- Documenter une contrainte
COMMENT ON CONSTRAINT users_email_unique ON users IS
'Email must be unique. Enforced since v1.0.0.';
```

**Avantage :** Ces commentaires sont stock√©s directement dans PostgreSQL et visibles via `\d+` dans psql.

## Gestion multi-environnements

### Strat√©gie de d√©ploiement progressif

```plaintext
Environnements avec versions diff√©rentes :

D√©veloppement local :
  Sch√©ma v2.2.0 (bleeding edge)
  Application v2.2.0-dev
  ‚Üí D√©veloppeurs testent les derni√®res features

CI/CD :
  Sch√©ma v2.2.0
  Application v2.2.0
  ‚Üí Tests automatis√©s

Staging :
  Sch√©ma v2.1.0
  Application v2.1.0
  ‚Üí R√©plique de production pour tests finaux

Production :
  Sch√©ma v2.0.0
  Application v2.0.0
  ‚Üí Version stable √©prouv√©e

‚Üí D√©ploiement progressif : Dev ‚Üí CI ‚Üí Staging ‚Üí Production
```

### Matrice de compatibilit√©

Documentez quelle version d'application fonctionne avec quelle version de sch√©ma :

```plaintext
Matrice de Compatibilit√© :

| Schema Version | App v2.0 | App v2.1 | App v2.2 | App v3.0 |
|----------------|----------|----------|----------|----------|
| Schema v2.0    | ‚úÖ       | ‚úÖ       | ‚úÖ       | ‚ùå       |
| Schema v2.1    | ‚úÖ       | ‚úÖ       | ‚úÖ       | ‚ùå       |
| Schema v2.2    | ‚ö†Ô∏è       | ‚úÖ       | ‚úÖ       | ‚ùå       |
| Schema v3.0    | ‚ùå       | ‚ùå       | ‚ùå       | ‚úÖ       |

‚úÖ Compatible
‚ö†Ô∏è Compatible avec limitations
‚ùå Incompatible
```

Cette matrice aide √† planifier les d√©ploiements et √©viter les incompatibilit√©s.

### Scripts de v√©rification de version

Cr√©ez des scripts qui v√©rifient la compatibilit√© avant d√©ploiement :

**Exemple conceptuel : verify_compatibility.sh**
```bash
#!/bin/bash
# Script de v√©rification de compatibilit√©

APP_VERSION="2.1.0"
SCHEMA_VERSION=$(psql -t -c "SELECT version FROM schema_version ORDER BY applied_at DESC LIMIT 1")

if [ "$SCHEMA_VERSION" = "2.0.0" ] || [ "$SCHEMA_VERSION" = "2.1.0" ]; then
    echo "‚úÖ Compatible : App $APP_VERSION avec Schema $SCHEMA_VERSION"
    exit 0
else
    echo "‚ùå INCOMPATIBLE : App $APP_VERSION requiert Schema v2.0.0 ou v2.1.0"
    echo "   Schema actuel : $SCHEMA_VERSION"
    exit 1
fi
```

Ce script peut √™tre int√©gr√© dans votre pipeline CI/CD.

## Patterns et bonnes pratiques

### Pattern 1 : Version Pinning (√âpinglage de version)

L'application d√©clare explicitement quelle version de sch√©ma elle requiert.

**Dans le code de l'application :**
```plaintext
Configuration de l'application :

REQUIRED_SCHEMA_VERSION = "2.1.0"
MINIMUM_SCHEMA_VERSION = "2.0.0"
MAXIMUM_SCHEMA_VERSION = "2.3.0"

Au d√©marrage de l'application :
  1. Se connecter √† PostgreSQL
  2. V√©rifier la version du sch√©ma
  3. Si version < MINIMUM ou > MAXIMUM ‚Üí ERREUR et arr√™t
  4. Sinon ‚Üí D√©marrage normal
```

**Avantages :**
- ‚úÖ Pr√©vient les incompatibilit√©s silencieuses
- ‚úÖ √âchec rapide (fail-fast) en cas de probl√®me
- ‚úÖ Documentation explicite des d√©pendances

### Pattern 2 : Feature Flags sur le sch√©ma

Activer/d√©sactiver des fonctionnalit√©s selon la version du sch√©ma.

**Exemple conceptuel :**
```plaintext
Dans l'application :

if (schemaVersion >= "2.1.0") {
    // Utiliser la nouvelle colonne full_name
    query = "SELECT id, full_name FROM users";
} else {
    // Fallback sur l'ancienne colonne name
    query = "SELECT id, name as full_name FROM users";
}

‚Üí L'application s'adapte √† la version du sch√©ma
```

**Avantages :**
- ‚úÖ Permet la coexistence de versions
- ‚úÖ D√©ploiement progressif facilit√©
- ‚úÖ Rollback sans casse

**Inconv√©nients :**
- ‚ùå Code plus complexe
- ‚ùå Maintenance de legacy code
- ‚ùå Dette technique si non nettoy√©

### Pattern 3 : Schema Adapters

Cr√©er des adaptateurs qui traduisent entre versions de sch√©ma.

```plaintext
Architecture :

Application (attend sch√©ma v2.0)
    ‚Üì
SchemaAdapter
    ‚Üì (d√©tecte sch√©ma v1.5)
    ‚Üì (adapte automatiquement)
PostgreSQL (sch√©ma v1.5)

Exemple :
  Application demande : SELECT full_name FROM users
  Adapter d√©tecte : sch√©ma v1.5 n'a que "name"
  Adapter traduit : SELECT name as full_name FROM users
  Application re√ßoit : full_name (transparence totale)
```

**Avantages :**
- ‚úÖ D√©couplage total entre code et sch√©ma
- ‚úÖ Tr√®s flexible

**Inconv√©nients :**
- ‚ùå Complexit√© √©lev√©e
- ‚ùå Performance (overhead de traduction)
- ‚ùå Maintenance difficile

### Pattern 4 : Blue-Green Schema Deployment

D√©ployer une nouvelle version de sch√©ma en parall√®le de l'ancienne.

```plaintext
√âtat initial :
  Schema v1.0 dans namespace "public"
  Application pointe vers "public"

√âtape 1 : Cr√©er nouveau sch√©ma
  CREATE SCHEMA public_v2;
  -- Appliquer migrations dans public_v2

√âtape 2 : Tester
  Application de test pointe vers "public_v2"
  Validation compl√®te

√âtape 3 : Basculer
  Renommer public ‚Üí public_v1_old
  Renommer public_v2 ‚Üí public
  ‚Üí Bascule instantan√©e !

√âtape 4 : Rollback facile si probl√®me
  Renommer public ‚Üí public_v2_failed
  Renommer public_v1_old ‚Üí public
  ‚Üí Retour √† l'ancien sch√©ma
```

**Avantages :**
- ‚úÖ Zero-downtime
- ‚úÖ Rollback instantan√©
- ‚úÖ Tests en conditions r√©elles

**Inconv√©nients :**
- ‚ùå Double espace disque
- ‚ùå Synchronisation des donn√©es complexe
- ‚ùå Ne fonctionne pas pour tous les changements

### Pattern 5 : Deprecation Policy (Politique de d√©pr√©ciation)

D√©finir un processus clair pour supprimer des √©l√©ments de sch√©ma.

```plaintext
Cycle de vie d'une colonne deprecated :

Version 1.5.0 :
  - Ajouter nouvelle colonne "full_name"
  - Marquer "name" comme deprecated
  - Documentation : "name sera supprim√© en v2.0.0"

Version 1.6.0 - 1.9.0 :
  - Les deux colonnes coexistent
  - Logs de warning si "name" est utilis√©
  - Migration progressive du code

Version 2.0.0 :
  - Suppression de "name"
  - Breaking change document√© et annonc√© depuis v1.5.0

‚Üí Minimum 3-6 mois entre deprecation et suppression
```

**Exemple de table de deprecation :**
```sql
CREATE TABLE schema_deprecations (
    element_type VARCHAR(50),  -- 'column', 'table', 'function'
    element_name VARCHAR(255),
    deprecated_in_version VARCHAR(20),
    removal_planned_version VARCHAR(20),
    reason TEXT,
    replacement TEXT
);

INSERT INTO schema_deprecations VALUES
('column', 'users.name', '1.5.0', '2.0.0',
 'Consolidation naming', 'Use users.full_name instead');
```

### Pattern 6 : Semantic Commit Messages

Utiliser des messages de commit Git pour automatiquement d√©duire la version.

```plaintext
Commit messages avec convention :

feat(schema): add notifications table
  ‚Üí MINOR version bump (1.0.0 ‚Üí 1.1.0)

fix(schema): correct payment_status constraint
  ‚Üí PATCH version bump (1.1.0 ‚Üí 1.1.1)

BREAKING CHANGE: rename users.name to full_name
  ‚Üí MAJOR version bump (1.1.1 ‚Üí 2.0.0)

‚Üí Scripts automatiques calculent la prochaine version
```

## Int√©gration avec CI/CD

### Pipeline de d√©ploiement avec versioning

```plaintext
Pipeline CI/CD id√©al :

1. ‚úÖ Commit & Push
   ‚îî‚îÄ> Git tag : migrations/v2.1.0

2. ‚úÖ CI - Tests
   ‚îú‚îÄ> Linter migrations
   ‚îú‚îÄ> V√©rifier ordre des versions
   ‚îî‚îÄ> Tests automatis√©s sur base propre

3. ‚úÖ Build & Package
   ‚îî‚îÄ> Empaqueter migrations avec application

4. ‚úÖ Deploy Staging
   ‚îú‚îÄ> V√©rifier version actuelle du sch√©ma
   ‚îú‚îÄ> Appliquer migrations (dry-run)
   ‚îú‚îÄ> Appliquer migrations (r√©el)
   ‚îú‚îÄ> V√©rifier nouvelle version
   ‚îî‚îÄ> Tests d'int√©gration

5. ‚úÖ Validation Humaine
   ‚îî‚îÄ> QA approuve le d√©ploiement

6. ‚úÖ Deploy Production
   ‚îú‚îÄ> Backup de la base
   ‚îú‚îÄ> V√©rifier compatibilit√© (version matrix)
   ‚îú‚îÄ> Appliquer migrations
   ‚îú‚îÄ> V√©rifier succ√®s
   ‚îú‚îÄ> Update schema_version table
   ‚îî‚îÄ> Notifier √©quipe

7. ‚úÖ Post-Deploy
   ‚îú‚îÄ> Tests smoke
   ‚îú‚îÄ> Monitoring
   ‚îî‚îÄ> Tag Git : production/v2.1.0
```

### Checks automatiques

**Exemple de checks √† automatiser :**

```plaintext
Check 1 : Version sequence
  ‚Üí V√©rifier que v2.1.0 ne vient pas avant v2.0.0

Check 2 : Breaking changes marqu√©s
  ‚Üí V√©rifier que les breaking changes incr√©mentent MAJOR

Check 3 : Rollback d√©fini
  ‚Üí Pour Liquibase/Alembic, v√©rifier que downgrade() existe

Check 4 : Documentation √† jour
  ‚Üí CHANGELOG.md contient la nouvelle version

Check 5 : Tests de compatibilit√©
  ‚Üí Application v2.1.0 test√©e avec sch√©ma v2.0.0, v2.1.0, v2.2.0

Check 6 : Dry-run r√©ussi
  ‚Üí Migration test√©e sur une copie de production (anonymis√©e)
```

## Cas d'usage avanc√©s

### Cas 1 : API versionn√©e avec sch√©ma versionn√©e

```plaintext
Architecture :

API v1 (/v1/users)
  ‚îî‚îÄ> Sch√©ma v1.x (utilise users.name)

API v2 (/v2/users)
  ‚îî‚îÄ> Sch√©ma v2.x (utilise users.full_name)

Strat√©gie :
  1. Sch√©ma v1.5 : Ajouter full_name (nullable)
  2. Sch√©ma v1.6 : Copier name ‚Üí full_name
  3. D√©ployer API v2 (utilise full_name)
  4. API v1 continue de fonctionner (utilise name)
  5. Sch√©ma v2.0 : Supprimer name (API v1 deprecated)
  6. Retirer API v1

‚Üí Coexistence pacifique des versions
```

### Cas 2 : Microservices avec sch√©ma partag√©

```plaintext
Probl√®me :
  Service A v1.0 ‚Üí PostgreSQL (sch√©ma v2.0)
  Service B v1.5 ‚Üí PostgreSQL (sch√©ma v2.0)
  Service C v2.0 ‚Üí PostgreSQL (sch√©ma v2.0)

Tous partagent la m√™me base, mais ont des versions diff√©rentes.

Solution :
  Sch√©ma v2.0 doit √™tre compatible avec :
    - Service A v1.0+ (minimum)
    - Service B v1.5+ (minimum)
    - Service C v2.0+ (minimum)

  Matrice de compatibilit√© obligatoire :
    schema_version table contient :
      compatible_services = "A>=1.0,B>=1.5,C>=2.0"

  Before deploying schema v2.1:
    1. V√©rifier que tous les services supportent v2.1
    2. Sinon, mettre √† jour les services d'abord
    3. Puis migrer le sch√©ma
```

### Cas 3 : Multi-tenant avec versions diff√©rentes

```plaintext
Base de donn√©es multi-tenant :

Tenant A (schema_a) ‚Üí Version 2.0.0
Tenant B (schema_b) ‚Üí Version 2.1.0
Tenant C (schema_c) ‚Üí Version 1.9.0

Chaque tenant peut √™tre √† une version diff√©rente.

Gestion :
  Table globale : tenant_schema_versions
    tenant_id | schema_version | last_updated
    ----------|----------------|-------------
    A         | 2.0.0          | 2025-01-15
    B         | 2.1.0          | 2025-02-01
    C         | 1.9.0          | 2024-12-20

  Application d√©tecte le tenant :
    1. Identifier le tenant (ex: tenant_id dans JWT)
    2. Consulter tenant_schema_versions
    3. Adapter le code selon la version du sch√©ma
    4. Ex√©cuter les requ√™tes appropri√©es

  Migration progressive :
    - Migrer tenant par tenant
    - Rollback facile par tenant
    - Flexibilit√© maximale
```

## Outils et automatisation

### 1. Scripts de versionnement

**Script pour incr√©menter la version (conceptuel) :**

```bash
#!/bin/bash
# bump_version.sh

CURRENT_VERSION=$(cat schema_version.txt)
CHANGE_TYPE=$1  # major | minor | patch

# Parser la version actuelle
IFS='.' read -r -a version <<< "$CURRENT_VERSION"
MAJOR=${version[0]}
MINOR=${version[1]}
PATCH=${version[2]}

# Incr√©menter selon le type
case $CHANGE_TYPE in
  major)
    MAJOR=$((MAJOR + 1))
    MINOR=0
    PATCH=0
    ;;
  minor)
    MINOR=$((MINOR + 1))
    PATCH=0
    ;;
  patch)
    PATCH=$((PATCH + 1))
    ;;
esac

NEW_VERSION="$MAJOR.$MINOR.$PATCH"
echo $NEW_VERSION > schema_version.txt

echo "Version incr√©ment√©e : $CURRENT_VERSION ‚Üí $NEW_VERSION"
```

### 2. Hooks Git

**Hook pre-commit pour v√©rifier la coh√©rence :**

```bash
#!/bin/bash
# .git/hooks/pre-commit

# V√©rifier que CHANGELOG.md est √† jour
if git diff --cached --name-only | grep -q "migrations/"; then
    if ! git diff --cached --name-only | grep -q "CHANGELOG.md"; then
        echo "‚ùå Erreur : Migration d√©tect√©e mais CHANGELOG.md non modifi√©"
        exit 1
    fi
fi

# V√©rifier que schema_version.txt est √† jour
if git diff --cached --name-only | grep -q "migrations/"; then
    if ! git diff --cached --name-only | grep -q "schema_version.txt"; then
        echo "‚ùå Erreur : Migration d√©tect√©e mais schema_version.txt non modifi√©"
        exit 1
    fi
fi

echo "‚úÖ Checks passed"
exit 0
```

### 3. G√©n√©ration automatique de documentation

**Script pour g√©n√©rer la matrice de compatibilit√© :**

```python
# generate_compatibility_matrix.py (conceptuel)

def generate_matrix():
    # Lire toutes les versions de sch√©ma
    schema_versions = read_schema_versions()

    # Lire toutes les versions d'application
    app_versions = read_app_versions()

    # G√©n√©rer la matrice
    matrix = []
    for schema_v in schema_versions:
        row = [schema_v]
        for app_v in app_versions:
            compatible = check_compatibility(schema_v, app_v)
            row.append('‚úÖ' if compatible else '‚ùå')
        matrix.append(row)

    # G√©n√©rer Markdown
    return format_as_markdown(matrix)
```

### 4. Dashboard de monitoring

**Informations √† afficher sur un dashboard :**

```plaintext
Dashboard : Schema Version Monitoring

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Environment Status                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Production    : v2.0.0  ‚úÖ             ‚îÇ
‚îÇ  Staging       : v2.1.0  ‚úÖ             ‚îÇ
‚îÇ  Development   : v2.2.0  ‚úÖ             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Compatibility Alerts                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚ö†Ô∏è Service A (v1.9) incompatible avec  ‚îÇ
‚îÇ     schema v2.1 en staging              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Upcoming Changes                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  v2.2.0 scheduled : 2025-02-15          ‚îÇ
‚îÇ  Breaking changes : No                  ‚îÇ
‚îÇ  Migrations pending : 3                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Erreurs courantes √† √©viter

### ‚ùå Erreur 1 : Modifier une migration appliqu√©e

```plaintext
Mauvais :
  V001__create_users.sql d√©j√† appliqu√© en production
  ‚Üí Quelqu'un modifie V001__create_users.sql
  ‚Üí Checksum mismatch ‚Üí Erreur

Bon :
  Cr√©er V005__fix_users_table.sql pour corriger
```

### ‚ùå Erreur 2 : Sauter des versions

```plaintext
Mauvais :
  v1.0.0 ‚Üí v1.2.0 (o√π est v1.1.0 ?)

Bon :
  v1.0.0 ‚Üí v1.1.0 ‚Üí v1.2.0 (s√©quence compl√®te)
```

### ‚ùå Erreur 3 : Breaking change en MINOR/PATCH

```plaintext
Mauvais :
  v1.2.0 ‚Üí v1.3.0 : DROP COLUMN users.name (breaking !)

Bon :
  v1.2.0 ‚Üí v2.0.0 : DROP COLUMN users.name (MAJOR bump)
```

### ‚ùå Erreur 4 : Pas de rollback test√©

```plaintext
Mauvais :
  D√©ployer v2.0.0 sans tester le rollback
  ‚Üí Probl√®me en production ‚Üí Impossible de revenir

Bon :
  Avant d√©ploiement :
    1. Appliquer v2.0.0 en staging
    2. Tester le rollback vers v1.9.0
    3. R√©-appliquer v2.0.0
    4. Valider ‚Üí D√©ployer en production
```

### ‚ùå Erreur 5 : Documentation obsol√®te

```plaintext
Mauvais :
  CHANGELOG.md : derni√®re entr√©e v1.5.0
  Sch√©ma r√©el : v2.3.0
  ‚Üí Personne ne sait ce qui a chang√©

Bon :
  CHANGELOG.md synchronis√© avec chaque migration
  Automatiser la mise √† jour si possible
```

### ‚ùå Erreur 6 : Versions incoh√©rentes entre environnements

```plaintext
Mauvais :
  Dev : v2.5.0
  Staging : v2.2.0
  Production : v2.4.0
  ‚Üí Chaos total

Bon :
  Dev >= Staging >= Production
  Flow unidirectionnel : Dev ‚Üí Staging ‚Üí Production
```

## Checklist du schema versioning

### ‚úÖ Avant de cr√©er une migration

- [ ] D√©terminer le type de changement (MAJOR/MINOR/PATCH)
- [ ] V√©rifier la compatibilit√© backward/forward
- [ ] Planifier le rollback si n√©cessaire
- [ ] Documenter dans CHANGELOG.md
- [ ] Mettre √† jour schema_version.txt
- [ ] Ajouter des commentaires PostgreSQL
- [ ] Tester localement

### ‚úÖ Avant de d√©ployer en production

- [ ] Tester sur une copie de production (anonymis√©e)
- [ ] V√©rifier la matrice de compatibilit√©
- [ ] Backup de la base de donn√©es
- [ ] Tester le rollback
- [ ] Pr√©parer un plan de communication (si breaking)
- [ ] Valider par l'√©quipe (code review)
- [ ] Dry-run sur staging

### ‚úÖ Apr√®s d√©ploiement

- [ ] V√©rifier la version appliqu√©e (SELECT * FROM schema_version)
- [ ] Tests smoke sur l'application
- [ ] Monitoring des erreurs
- [ ] Tag Git (schema-vX.Y.Z)
- [ ] Notifier l'√©quipe
- [ ] Mettre √† jour la documentation

## Conclusion

Le **schema versioning** est un pilier fondamental de la gestion professionnelle de bases de donn√©es PostgreSQL. Il transforme une base de donn√©es "bo√Æte noire" en un syst√®me **tra√ßable, pr√©visible et collaboratif**.

### Principes cl√©s √† retenir

1. **Choisissez une strat√©gie** : Sequential, Timestamp, ou Semantic (SemVer recommand√©)
2. **Documentez tout** : CHANGELOG.md, commentaires, table de m√©tadonn√©es
3. **Compatibilit√© d'abord** : Expand-Migrate-Contract pour √©viter les breaking changes brutaux
4. **Automatisez** : CI/CD, checks, g√©n√©ration de documentation
5. **Testez les rollbacks** : M√™me si vous ne les utilisez jamais, ils doivent fonctionner
6. **Communiquez** : Matrice de compatibilit√©, deprecation policy, notifications

### Recommandations finales

**Pour les petits projets :**
- Sequential versioning (simple et efficace)
- Migrations Flyway ou Alembic
- Documentation minimale (CHANGELOG.md)

**Pour les projets moyens :**
- Semantic Versioning (MAJOR.MINOR.PATCH)
- Table schema_version dans PostgreSQL
- CI/CD avec checks automatiques
- Matrice de compatibilit√©

**Pour les grands projets / microservices :**
- Semantic Versioning strict
- Deprecation policy formalis√©e
- Schema adapters ou Feature flags
- Dashboard de monitoring
- Documentation exhaustive et automatis√©e
- Blue-Green deployments

Le schema versioning n'est pas une contrainte, c'est une **lib√©ration** : il vous permet de faire √©voluer votre base de donn√©es en toute confiance, de collaborer efficacement, et de dormir tranquille sachant que vous pouvez toujours revenir en arri√®re.

---

**Prochaines √©tapes sugg√©r√©es :**
- 20.4.4. Zero-downtime deployments
- 19.3. Migrations majeures PostgreSQL
- 17. Haute Disponibilit√© et R√©plication

**Ressources compl√©mentaires :**
- Semantic Versioning : https://semver.org/
- Martin Fowler : "Evolutionary Database Design"
- Livre : "Refactoring Databases" par Scott W. Ambler

‚è≠Ô∏è [Zero-downtime deployments](/20-drivers-connexion-applicative/04.4-zero-downtime-deployments.md)
