üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.2.1. Connection Pooling C√¥t√© Application

## Introduction

Le **connection pooling c√¥t√© application** est une technique fondamentale pour optimiser les performances de vos applications utilisant PostgreSQL. Cette section vous expliquera pourquoi cette approche est essentielle et comment l'impl√©menter efficacement.

---

## Qu'est-ce qu'une connexion √† une base de donn√©es ?

Avant de parler de pooling, commen√ßons par les bases.

### Le concept de connexion

Lorsqu'une application veut communiquer avec PostgreSQL, elle doit √©tablir une **connexion** :

1. **Initiation** : L'application envoie une demande de connexion au serveur PostgreSQL
2. **Authentification** : PostgreSQL v√©rifie les identifiants (utilisateur, mot de passe)
3. **√âtablissement** : Une fois valid√©e, la connexion est active et utilisable
4. **Communication** : L'application peut maintenant envoyer des requ√™tes SQL
5. **Fermeture** : Quand l'application a fini, elle ferme la connexion

### Le co√ªt d'une connexion

Cr√©er une connexion n'est **pas gratuit** en termes de ressources :

- **Temps** : L'√©tablissement prend entre 10 et 100 ms (millisecondes)
- **M√©moire** : Chaque connexion consomme ~10 MB de RAM c√¥t√© serveur
- **CPU** : L'authentification et l'initialisation consomment du processeur
- **Processus** : PostgreSQL cr√©e un processus syst√®me pour chaque connexion

**Analogie** : Imaginez que vous allez au restaurant. √Ä chaque fois, vous devez :
1. Faire la queue √† l'entr√©e
2. Montrer votre r√©servation
3. √ätre install√© √† une table
4. Commander et manger
5. Payer et partir

Si vous faites √ßa 100 fois par heure pour chaque petit plat, c'est extr√™mement inefficace !

---

## Le probl√®me : L'approche na√Øve

### Sc√©nario classique sans pooling

Voici ce qui se passe dans une application **sans** connection pooling :

```
Requ√™te 1 arrive ‚Üí Ouvrir connexion ‚Üí Ex√©cuter SQL ‚Üí Fermer connexion
Requ√™te 2 arrive ‚Üí Ouvrir connexion ‚Üí Ex√©cuter SQL ‚Üí Fermer connexion
Requ√™te 3 arrive ‚Üí Ouvrir connexion ‚Üí Ex√©cuter SQL ‚Üí Fermer connexion
...
```

### Les cons√©quences

#### 1. **Performance d√©grad√©e**
- Chaque requ√™te attend l'√©tablissement de la connexion
- Latence ajout√©e de 10-100 ms par requ√™te
- L'utilisateur attend plus longtemps

#### 2. **Surcharge du serveur**
- Cr√©ation/destruction constante de processus
- Consommation excessive de CPU et RAM
- Le serveur peut saturer avec seulement quelques dizaines d'utilisateurs

#### 3. **Limite de connexions**
PostgreSQL a une limite de connexions simultan√©es (param√®tre `max_connections`, souvent 100-200 par d√©faut).

**Exemple concret** :
```
Votre application web a 50 utilisateurs simultan√©s.
Chaque page fait 20 requ√™tes SQL.
Sans pooling : 50 √ó 20 = 1000 connexions n√©cessaires !
‚Üí PostgreSQL va refuser les connexions ‚Üí Erreurs applicatives
```

---

## La solution : Connection Pooling

### Principe fondamental

Le **connection pooling** consiste √† maintenir un ensemble (un "pool") de connexions **r√©utilisables** :

```
Application d√©marrage ‚Üí Cr√©er 10 connexions ‚Üí Les garder ouvertes dans un pool

Requ√™te 1 arrive ‚Üí Emprunter une connexion du pool ‚Üí Ex√©cuter SQL ‚Üí Rendre la connexion au pool
Requ√™te 2 arrive ‚Üí Emprunter une connexion du pool ‚Üí Ex√©cuter SQL ‚Üí Rendre la connexion au pool
Requ√™te 3 arrive ‚Üí Emprunter une connexion du pool ‚Üí Ex√©cuter SQL ‚Üí Rendre la connexion au pool
```

**Analogie** : C'est comme un parking de taxis. Les taxis (connexions) attendent au parking (pool). Quand un client arrive, il prend un taxi disponible, fait son trajet, et le taxi retourne au parking pour le prochain client.

### Avantages imm√©diats

- ‚úÖ **Performance** : Pas de d√©lai de cr√©ation de connexion pour chaque requ√™te
- ‚úÖ **Efficacit√©** : R√©utilisation des ressources existantes
- ‚úÖ **Scalabilit√©** : 10 connexions peuvent servir 1000 requ√™tes
- ‚úÖ **Stabilit√©** : Pas de saturation du serveur PostgreSQL

---

## Configuration du Pool : Les param√®tres cl√©s

### 1. Taille du pool (Pool Size)

C'est le nombre de connexions **maintenues ouvertes** dans le pool.

**Exemple de configuration** :
```
pool_size = 10  ‚Üí Le pool maintient 10 connexions actives
```

**Comment choisir la taille ?**

**R√®gle g√©n√©rale** :
```
pool_size = nombre_de_cores_CPU √ó 2 + nombre_de_disques
```

**Exemples pratiques** :
- Serveur avec 4 cores CPU et 1 disque : `4 √ó 2 + 1 = 9` ‚Üí **pool_size = 10**
- Serveur avec 8 cores CPU et 2 disques : `8 √ó 2 + 2 = 18` ‚Üí **pool_size = 20**

‚ö†Ô∏è **Attention** : Plus n'est pas toujours mieux ! Trop de connexions saturent PostgreSQL.

### 2. Max overflow (D√©bordement maximum)

Nombre de connexions **suppl√©mentaires** cr√©√©es temporairement si le pool est satur√©.

**Exemple** :
```
pool_size = 10
max_overflow = 5

‚Üí Maximum absolu : 10 + 5 = 15 connexions
```

**Comportement** :
- Les 10 connexions du pool sont prises ‚Üí Cr√©er jusqu'√† 5 connexions temporaires
- Ces connexions temporaires sont **ferm√©es** apr√®s utilisation (pas r√©utilis√©es)

### 3. Timeout (D√©lai d'attente)

Temps maximum qu'une requ√™te attend pour obtenir une connexion disponible.

**Exemple** :
```
pool_timeout = 30  ‚Üí Attendre 30 secondes maximum
```

**Comportement** :
- Le pool est plein (toutes les connexions utilis√©es)
- Une nouvelle requ√™te arrive
- Elle attend jusqu'√† 30 secondes qu'une connexion se lib√®re
- Si timeout expir√© ‚Üí **Erreur** : "Timeout waiting for connection from pool"

### 4. Connection lifetime (Dur√©e de vie)

Dur√©e maximale qu'une connexion peut rester dans le pool avant d'√™tre renouvel√©e.

**Exemple** :
```
max_lifetime = 3600  ‚Üí Renouveler les connexions toutes les heures (3600 secondes)
```

**Pourquoi ?**
- √âviter les connexions "stale" (p√©rim√©es)
- Forcer la reconnexion pour r√©cup√©rer les changements de configuration
- Lib√©rer les ressources accumul√©es c√¥t√© serveur

---

## Impl√©mentations par langage

### Python : psycopg3 avec pool int√©gr√©

**Installation** :
```bash
pip install psycopg[pool]
```

**Code exemple** :
```python
from psycopg_pool import ConnectionPool

# Cr√©er le pool au d√©marrage de l'application
pool = ConnectionPool(
    conninfo="postgresql://user:password@localhost/mydb",
    min_size=5,        # Minimum 5 connexions maintenues
    max_size=20,       # Maximum 20 connexions au total
    timeout=30,        # Attendre 30s pour une connexion
    max_idle=600,      # Fermer connexions inactives apr√®s 10 min
    max_lifetime=3600  # Renouveler apr√®s 1 heure
)

# Utiliser une connexion du pool
def get_users():
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute("SELECT * FROM users")
            return cur.fetchall()
    # La connexion retourne automatiquement au pool ici

# Fermer le pool √† l'arr√™t de l'application
pool.close()
```

**Points cl√©s** :
- `with pool.connection()` : Emprunte une connexion
- La connexion est **automatiquement rendue** au pool √† la fin du bloc `with`
- Pas besoin de fermer manuellement (`conn.close()` ne ferme pas vraiment, mais rend au pool)

---

### Node.js : node-postgres (pg)

**Installation** :
```bash
npm install pg
```

**Code exemple** :
```javascript
const { Pool } = require('pg');

// Cr√©er le pool au d√©marrage
const pool = new Pool({
  host: 'localhost',
  database: 'mydb',
  user: 'user',
  password: 'password',
  port: 5432,

  // Configuration du pool
  max: 20,                    // Maximum 20 connexions
  min: 5,                     // Minimum 5 connexions maintenues
  idleTimeoutMillis: 30000,   // Fermer connexions inactives apr√®s 30s
  connectionTimeoutMillis: 5000, // Timeout d'attente 5s
  maxLifetimeSeconds: 3600    // Renouveler apr√®s 1h
});

// Utiliser une connexion du pool
async function getUsers() {
  const client = await pool.connect(); // Emprunter une connexion

  try {
    const result = await client.query('SELECT * FROM users');
    return result.rows;
  } finally {
    client.release(); // IMPORTANT : Rendre la connexion au pool
  }
}

// Alternative plus simple avec pool.query()
async function getUsersSimple() {
  // pool.query() g√®re automatiquement connect() et release()
  const result = await pool.query('SELECT * FROM users');
  return result.rows;
}

// Fermer le pool √† l'arr√™t
await pool.end();
```

**Points cl√©s** :
- `pool.connect()` : Emprunte une connexion (retourne une Promise)
- `client.release()` : **CRITIQUE** - Rend la connexion au pool
- `pool.query()` : Shortcut qui g√®re automatiquement connect/release

‚ö†Ô∏è **Erreur fr√©quente** : Oublier `client.release()` ‚Üí Fuite de connexions ‚Üí Pool satur√©

---

### Java : HikariCP (Le pool le plus performant)

**Maven dependency** :
```xml
<dependency>
    <groupId>com.zaxxer</groupId>
    <artifactId>HikariCP</artifactId>
    <version>5.1.0</version>
</dependency>
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>42.7.0</version>
</dependency>
```

**Code exemple** :
```java
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;

public class DatabasePool {
    private static HikariDataSource dataSource;

    static {
        // Configuration du pool au d√©marrage
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:postgresql://localhost:5432/mydb");
        config.setUsername("user");
        config.setPassword("password");

        // Configuration du pool
        config.setMaximumPoolSize(20);           // Max 20 connexions
        config.setMinimumIdle(5);                // Min 5 connexions en attente
        config.setConnectionTimeout(30000);      // Timeout 30s
        config.setIdleTimeout(600000);           // Inactivit√© 10 min
        config.setMaxLifetime(1800000);          // Dur√©e de vie 30 min
        config.setAutoCommit(true);              // Auto-commit activ√©
        config.setPoolName("PostgreSQL-Pool");

        dataSource = new HikariDataSource(config);
    }

    public static List<User> getUsers() throws SQLException {
        // Emprunter une connexion avec try-with-resources
        try (Connection conn = dataSource.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery("SELECT * FROM users")) {

            List<User> users = new ArrayList<>();
            while (rs.next()) {
                users.add(new User(rs.getInt("id"), rs.getString("name")));
            }
            return users;
        }
        // La connexion retourne automatiquement au pool ici
    }

    // Fermer le pool √† l'arr√™t de l'application
    public static void shutdown() {
        if (dataSource != null) {
            dataSource.close();
        }
    }
}
```

**Points cl√©s** :
- `try-with-resources` : Rend automatiquement la connexion au pool
- HikariCP est **extr√™mement performant** (le plus rapide du march√©)
- Configuration via `HikariConfig` ou fichier properties

---

### Go : pgx (Pool natif)

**Installation** :
```bash
go get github.com/jackc/pgx/v5/pgxpool
```

**Code exemple** :
```go
package main

import (
    "context"
    "log"
    "github.com/jackc/pgx/v5/pgxpool"
)

var pool *pgxpool.Pool

func initPool() {
    // Configuration du pool
    config, err := pgxpool.ParseConfig(
        "postgres://user:password@localhost:5432/mydb" +
        "?pool_max_conns=20" +           // Max 20 connexions
        "&pool_min_conns=5" +             // Min 5 connexions
        "&pool_max_conn_lifetime=1h" +   // Dur√©e de vie 1h
        "&pool_max_conn_idle_time=30m",  // Inactivit√© 30 min
    )
    if err != nil {
        log.Fatal(err)
    }

    pool, err = pgxpool.NewWithConfig(context.Background(), config)
    if err != nil {
        log.Fatal(err)
    }
}

func getUsers(ctx context.Context) ([]User, error) {
    // Ex√©cuter une requ√™te (g√®re automatiquement le pool)
    rows, err := pool.Query(ctx, "SELECT id, name FROM users")
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var users []User
    for rows.Next() {
        var u User
        err := rows.Scan(&u.ID, &u.Name)
        if err != nil {
            return nil, err
        }
        users = append(users, u)
    }

    return users, rows.Err()
}

func main() {
    initPool()
    defer pool.Close() // Fermer √† l'arr√™t

    users, err := getUsers(context.Background())
    if err != nil {
        log.Fatal(err)
    }
    // ...
}
```

**Points cl√©s** :
- `pool.Query()` et `pool.Exec()` : G√®rent automatiquement le pool
- Pas besoin d'acqu√©rir/rel√¢cher manuellement les connexions
- Support natif du context Go pour les timeouts

---

### .NET : Npgsql avec pool int√©gr√©

**Installation (NuGet)** :
```bash
dotnet add package Npgsql
```

**Code exemple** :
```csharp
using Npgsql;
using System.Collections.Generic;

public class DatabaseService
{
    // Connection string avec param√®tres de pool
    private const string ConnectionString =
        "Host=localhost;" +
        "Database=mydb;" +
        "Username=user;" +
        "Password=password;" +
        "Pooling=true;" +              // Activer le pooling (true par d√©faut)
        "Minimum Pool Size=5;" +       // Min 5 connexions
        "Maximum Pool Size=20;" +      // Max 20 connexions
        "Connection Idle Lifetime=600;" + // Inactivit√© 10 min (secondes)
        "Connection Pruning Interval=10;" // V√©rification toutes les 10s
        "Connection Lifetime=3600;";   // Dur√©e de vie 1h

    public List<User> GetUsers()
    {
        var users = new List<User>();

        // using garantit que la connexion retourne au pool
        using (var conn = new NpgsqlConnection(ConnectionString))
        {
            conn.Open();

            using (var cmd = new NpgsqlCommand("SELECT id, name FROM users", conn))
            using (var reader = cmd.ExecuteReader())
            {
                while (reader.Read())
                {
                    users.Add(new User
                    {
                        Id = reader.GetInt32(0),
                        Name = reader.GetString(1)
                    });
                }
            }
        } // La connexion retourne au pool ici

        return users;
    }
}
```

**Points cl√©s** :
- Le pooling est **activ√© par d√©faut** dans Npgsql
- Configuration via connection string
- `using` statement : Lib√®re automatiquement la connexion vers le pool

---

## Bonnes pratiques

### 1. ‚úÖ Toujours lib√©rer les connexions

**Mauvais exemple (Node.js)** :
```javascript
async function badExample() {
  const client = await pool.connect();
  const result = await client.query('SELECT * FROM users');
  return result.rows;
  // OUBLI : client.release() non appel√© ‚Üí Fuite de connexion !
}
```

**Bon exemple** :
```javascript
async function goodExample() {
  const client = await pool.connect();
  try {
    const result = await client.query('SELECT * FROM users');
    return result.rows;
  } finally {
    client.release(); // TOUJOURS dans un finally
  }
}
```

### 2. ‚úÖ Utiliser les m√©thodes de haut niveau quand possible

**Pr√©f√©rez** :
```javascript
// Pool g√®re tout automatiquement
const result = await pool.query('SELECT * FROM users');
```

**Au lieu de** :
```javascript
// Gestion manuelle (plus de risques d'erreur)
const client = await pool.connect();
try {
  const result = await client.query('SELECT * FROM users');
  return result;
} finally {
  client.release();
}
```

### 3. ‚úÖ Dimensionner correctement le pool

**Formule de base** :
```
pool_size ‚âà nombre_de_CPU_cores √ó 2
```

**Exemple** : Serveur avec 4 cores ‚Üí **pool_size = 8 √† 10**

‚ö†Ô∏è **√âviter** :
- Pool trop petit ‚Üí Requ√™tes en attente, timeouts
- Pool trop grand ‚Üí Surcharge PostgreSQL, performances d√©grad√©es

### 4. ‚úÖ Surveiller les m√©triques du pool

**M√©triques importantes √† monitorer** :
- Nombre de connexions actives
- Nombre de connexions en attente
- Temps d'attente moyen pour obtenir une connexion
- Nombre de timeouts

**Exemple avec HikariCP (Java)** :
```java
HikariPoolMXBean poolMBean = dataSource.getHikariPoolMXBean();
System.out.println("Active: " + poolMBean.getActiveConnections());
System.out.println("Idle: " + poolMBean.getIdleConnections());
System.out.println("Waiting: " + poolMBean.getThreadsAwaitingConnection());
System.out.println("Total: " + poolMBean.getTotalConnections());
```

### 5. ‚úÖ Configurer des timeouts appropri√©s

**Recommandations** :
- `connection_timeout` : 5-30 secondes (temps d'attente pour obtenir une connexion)
- `statement_timeout` : 30-60 secondes (temps max d'ex√©cution d'une requ√™te)
- `idle_timeout` : 10-30 minutes (fermer les connexions inactives)
- `max_lifetime` : 30-60 minutes (renouveler les connexions p√©riodiquement)

### 6. ‚úÖ G√©rer les erreurs de pool satur√©

**Exemple de gestion d'erreur (Python)** :
```python
from psycopg_pool import PoolTimeout

try:
    with pool.connection() as conn:
        # Votre code ici
        pass
except PoolTimeout:
    # Pool satur√© - loguer et alerter
    logger.error("Pool exhausted - too many concurrent requests")
    # Possiblement : augmenter pool_size ou max_overflow
    raise
```

### 7. ‚úÖ Utiliser un seul pool par application

**Architecture recommand√©e** :
```
Application (1 instance)
    ‚îî‚îÄ‚îÄ Connection Pool (1 seul pool, singleton)
        ‚îî‚îÄ‚îÄ PostgreSQL (1 serveur)
```

**√Ä √©viter** : Cr√©er plusieurs pools dans la m√™me application
```
Application
    ‚îú‚îÄ‚îÄ Pool 1 (10 connexions)
    ‚îú‚îÄ‚îÄ Pool 2 (10 connexions)
    ‚îî‚îÄ‚îÄ Pool 3 (10 connexions)
        ‚Üí Total : 30 connexions gaspill√©es !
```

### 8. ‚úÖ Fermer le pool √† l'arr√™t de l'application

**Exemple (Node.js avec graceful shutdown)** :
```javascript
const pool = new Pool({...});

// G√©rer les signaux d'arr√™t
process.on('SIGTERM', async () => {
  console.log('SIGTERM received, closing pool...');
  await pool.end();
  process.exit(0);
});

process.on('SIGINT', async () => {
  console.log('SIGINT received, closing pool...');
  await pool.end();
  process.exit(0);
});
```

---

## Diagnostic : Comment savoir si votre pool fonctionne bien ?

### Indicateurs de probl√®mes

#### üî¥ **Pool trop petit**
**Sympt√¥mes** :
- Erreurs "Timeout waiting for connection"
- Requ√™tes qui prennent soudainement beaucoup plus de temps
- Pics de latence inexpliqu√©s

**Solution** : Augmenter `pool_size` et/ou `max_overflow`

#### üî¥ **Pool trop grand**
**Sympt√¥mes** :
- PostgreSQL montre beaucoup de connexions idle
- CPU √©lev√© c√¥t√© PostgreSQL sans raison
- Performances qui se d√©gradent avec plus de connexions

**Solution** : R√©duire `pool_size`

#### üî¥ **Fuites de connexions**
**Sympt√¥mes** :
- Connexions actives qui augmentent constamment
- Pool qui finit par √™tre satur√© m√™me avec peu de requ√™tes
- Application qui devient lente avec le temps

**Solution** : Chercher les `client.release()` manquants ou les `conn.close()` oubli√©s

### Commandes PostgreSQL pour diagnostic

**Voir toutes les connexions actives** :
```sql
SELECT
    pid,
    usename,
    application_name,
    client_addr,
    state,
    state_change,
    query,
    now() - state_change AS duration
FROM pg_stat_activity
WHERE datname = 'mydb'
ORDER BY state_change;
```

**Compter les connexions par √©tat** :
```sql
SELECT
    state,
    COUNT(*) as count
FROM pg_stat_activity
WHERE datname = 'mydb'
GROUP BY state;
```

**√âtats possibles** :
- `active` : Connexion en train d'ex√©cuter une requ√™te
- `idle` : Connexion inactive (dans le pool, en attente)
- `idle in transaction` : ‚ö†Ô∏è Transaction ouverte mais inactive (probl√®me !)

---

## Cas d'usage : Application web typique

### Sc√©nario

Vous d√©veloppez une **API REST** avec :
- 100 requ√™tes HTTP par seconde en moyenne
- Chaque requ√™te fait 1-3 requ√™tes SQL
- Serveur avec 4 cores CPU

### Configuration recommand√©e

**Node.js (express + pg)** :
```javascript
const { Pool } = require('pg');

const pool = new Pool({
  host: 'localhost',
  database: 'api_db',
  user: 'api_user',
  password: 'secure_password',

  // Configuration optimale pour ce cas
  max: 10,                          // 4 cores √ó 2 = 8, arrondi √† 10
  min: 2,                           // Toujours 2 connexions pr√™tes
  idleTimeoutMillis: 30000,         // Fermer inactives apr√®s 30s
  connectionTimeoutMillis: 5000,    // Timeout 5s
  maxLifetimeSeconds: 3600          // Renouveler apr√®s 1h
});

// Middleware express pour v√©rifier le pool
app.use((req, res, next) => {
  console.log('Pool stats:', {
    total: pool.totalCount,
    idle: pool.idleCount,
    waiting: pool.waitingCount
  });
  next();
});

// Route exemple
app.get('/api/users', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM users LIMIT 100');
    res.json(result.rows);
  } catch (error) {
    console.error('Database error:', error);
    res.status(500).json({ error: 'Database error' });
  }
});
```

### R√©sultats attendus

Avec cette configuration :
- ‚úÖ Les 10 connexions peuvent traiter **1000+ requ√™tes/seconde**
- ‚úÖ Latence moyenne : 2-5 ms (vs 10-100 ms sans pool)
- ‚úÖ Utilisation CPU PostgreSQL : ~20-30% (vs 80-90% sans pool)
- ‚úÖ Pas de saturation de connexions

---

## R√©sum√© : Points cl√©s √† retenir

### ‚ú® Pourquoi le connection pooling est essentiel
1. **Performance** : √âvite le co√ªt de cr√©ation/fermeture de connexions
2. **Scalabilit√©** : Permet de servir beaucoup de requ√™tes avec peu de connexions
3. **Stabilit√©** : √âvite la saturation du serveur PostgreSQL

### üîß Configuration de base
- `pool_size` : Nombre de CPU cores √ó 2
- `max_overflow` : 25-50% du pool_size
- `timeout` : 5-30 secondes
- `max_lifetime` : 30-60 minutes

### üí° Bonnes pratiques
1. **Toujours** lib√©rer les connexions (try/finally, using, with)
2. **Utiliser** les m√©thodes de haut niveau quand possible
3. **Monitorer** les m√©triques du pool
4. **Configurer** des timeouts appropri√©s
5. **Fermer** le pool √† l'arr√™t de l'application

### ‚ö†Ô∏è Erreurs √† √©viter
- Oublier de lib√©rer les connexions ‚Üí Fuites
- Pool trop grand ‚Üí Surcharge PostgreSQL
- Pool trop petit ‚Üí Timeouts et latence
- Cr√©er plusieurs pools dans la m√™me application
- Ne pas g√©rer les erreurs de pool satur√©

---

## Pour aller plus loin

### Documentation officielle des biblioth√®ques

**Python - psycopg3** :
- [Documentation du pool](https://www.psycopg.org/psycopg3/docs/advanced/pool.html)

**Node.js - node-postgres** :
- [Guide du pooling](https://node-postgres.com/features/pooling)

**Java - HikariCP** :
- [GitHub officiel](https://github.com/brettwooldridge/HikariCP)
- [Wiki de configuration](https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing)

**Go - pgx** :
- [Documentation pgxpool](https://pkg.go.dev/github.com/jackc/pgx/v5/pgxpool)

**.NET - Npgsql** :
- [Documentation pooling](https://www.npgsql.org/doc/connection-string-parameters.html#pooling)

### Articles recommand√©s

- [HikariCP - About Pool Sizing](https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing) - Excellent article sur le dimensionnement (applicable √† tous les langages)
- [PostgreSQL Connection Pooling: Part 1](https://scalegrid.io/blog/postgresql-connection-pooling-part-1-pros-and-cons/) - Vue d'ensemble approfondie

---


‚è≠Ô∏è [PgBouncer : Transaction vs Session pooling](/20-drivers-connexion-applicative/02.2-pgbouncer-transaction-session.md)
