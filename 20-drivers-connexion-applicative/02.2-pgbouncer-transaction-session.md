ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 20.2.2. PgBouncer : Transaction vs Session Pooling

## Introduction

Dans la section prÃ©cÃ©dente (20.2.1), nous avons vu le **connection pooling cÃ´tÃ© application**. Maintenant, nous allons dÃ©couvrir **PgBouncer**, un outil de pooling **externe** qui se place entre votre application et PostgreSQL.

### Pourquoi un pooling externe ?

Le pooling cÃ´tÃ© application a des limites :
- Chaque instance d'application a son propre pool
- En microservices : multiplication des pools
- Difficile de gÃ©rer globalement les connexions

**PgBouncer** rÃ©sout ces problÃ¨mes en centralisant le pooling.

---

## Qu'est-ce que PgBouncer ?

### DÃ©finition

**PgBouncer** est un **connection pooler lÃ©ger** qui agit comme un **proxy** entre vos applications et PostgreSQL.

### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             â”‚      â”‚             â”‚      â”‚             â”‚
â”‚ Application â”‚â”€â”€â”€â”€â”€â–¶â”‚  PgBouncer  â”‚â”€â”€â”€â”€â”€â–¶â”‚ PostgreSQL  â”‚
â”‚             â”‚      â”‚   (Proxy)   â”‚      â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   1000 clients         100 connexions       10 connexions
                        virtuelles           rÃ©elles
```

**Analogie** : PgBouncer est comme un standard tÃ©lÃ©phonique :
- 1000 tÃ©lÃ©phones (clients) peuvent appeler
- Le standard n'a que 10 lignes sortantes (connexions PostgreSQL)
- Il gÃ¨re intelligemment qui obtient une ligne et quand

### Avantages de PgBouncer

- âœ… **Centralisation** : Un seul point de pooling pour toutes les applications
- âœ… **EfficacitÃ©** : RÃ©utilisation maximale des connexions PostgreSQL
- âœ… **ScalabilitÃ©** : Supporte des milliers de connexions clientes avec peu de connexions serveur
- âœ… **LÃ©ger** : Consomme trÃ¨s peu de ressources (RAM, CPU)
- âœ… **Transparent** : L'application ne voit pas la diffÃ©rence

---

## Installation de PgBouncer

### Sur Ubuntu/Debian

```bash
# Installation
sudo apt update
sudo apt install pgbouncer

# VÃ©rifier la version
pgbouncer --version
```

### Sur Red Hat/CentOS/Fedora

```bash
# Installation
sudo dnf install pgbouncer

# Ou avec yum
sudo yum install pgbouncer
```

### Sur macOS

```bash
# Avec Homebrew
brew install pgbouncer
```

### Via Docker

```bash
# Lancer PgBouncer dans un conteneur
docker run -d \
  --name pgbouncer \
  -p 6432:6432 \
  -v /path/to/pgbouncer.ini:/etc/pgbouncer/pgbouncer.ini \
  -v /path/to/userlist.txt:/etc/pgbouncer/userlist.txt \
  pgbouncer/pgbouncer
```

---

## Les trois modes de pooling

PgBouncer propose **trois modes** de pooling, chacun avec des caractÃ©ristiques diffÃ©rentes.

### Vue d'ensemble

| Mode | GranularitÃ© | Performance | CompatibilitÃ© | Cas d'usage |
|------|-------------|-------------|---------------|-------------|
| **Session** | Par session | â­â­ | â­â­â­â­â­ | Applications complexes |
| **Transaction** | Par transaction | â­â­â­â­â­ | â­â­â­ | Applications web/API |
| **Statement** | Par requÃªte | â­â­â­â­â­ | â­ | Cas trÃ¨s spÃ©cifiques |

Nous allons nous concentrer sur les deux modes principaux : **Session** et **Transaction**.

---

## Mode Session Pooling

### Principe de fonctionnement

En mode **session**, une connexion PostgreSQL est attribuÃ©e Ã  un client **pour toute la durÃ©e de sa session**.

```
Client connecte â†’ Obtient une connexion PostgreSQL
                â†’ Garde cette connexion jusqu'Ã  dÃ©connexion
                â†’ La connexion retourne au pool
```

**Analogie** : Comme louer une voiture pour toute la journÃ©e. Vous l'utilisez ou non, elle reste Ã  vous jusqu'Ã  ce que vous la rendiez le soir.

### Diagramme

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Session du Client (jusqu'Ã  dÃ©connexion)                  â”‚
â”‚                                                          â”‚
â”‚  BEGIN; SELECT...; UPDATE...; COMMIT;                    â”‚
â”‚  BEGIN; DELETE...; COMMIT;                               â”‚
â”‚  SELECT...;                                              â”‚
â”‚  (pause de 10 secondes)                                  â”‚
â”‚  INSERT...;                                              â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†• (mÃªme connexion PostgreSQL tout le long)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Connexion PostgreSQL dÃ©diÃ©e                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Comportement

**Quand le client se connecte** :
1. PgBouncer attribue une connexion PostgreSQL du pool
2. Le client garde cette connexion

**Quand le client se dÃ©connecte** :
1. PgBouncer libÃ¨re la connexion PostgreSQL
2. La connexion retourne au pool pour un autre client

### Avantages

- âœ… **CompatibilitÃ© maximale** : Supporte toutes les fonctionnalitÃ©s PostgreSQL
- âœ… **Variables de session** : ConservÃ©es (SET search_path, SET timezone, etc.)
- âœ… **Transactions longues** : Pas de problÃ¨me
- âœ… **Prepared statements** : Fonctionnent parfaitement
- âœ… **LISTEN/NOTIFY** : SupportÃ©
- âœ… **Advisory locks** : SupportÃ©

### InconvÃ©nients

- âŒ **EfficacitÃ© limitÃ©e** : Une connexion par client connectÃ©
- âŒ **ScalabilitÃ© rÃ©duite** : Si 100 clients connectÃ©s = 100 connexions PostgreSQL
- âŒ **Gaspillage** : Clients inactifs gardent leur connexion

### Configuration

**Fichier pgbouncer.ini** :
```ini
[databases]
mydb = host=localhost port=5432 dbname=mydb

[pgbouncer]
listen_addr = 0.0.0.0
listen_port = 6432
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt

# MODE SESSION
pool_mode = session

# Taille du pool
default_pool_size = 25        # 25 connexions PostgreSQL par base
max_client_conn = 1000        # Maximum 1000 clients connectÃ©s

# Timeouts
server_idle_timeout = 600     # Fermer connexions inactives aprÃ¨s 10 min
server_lifetime = 3600        # Renouveler aprÃ¨s 1h
```

### Cas d'usage

**âœ… Utiliser le mode session si** :
- Vous utilisez des **prepared statements** nommÃ©s
- Vous utilisez **LISTEN/NOTIFY**
- Vous utilisez des **advisory locks**
- Vous modifiez des **variables de session** (SET commands)
- Vous avez des **transactions longues**
- Vous utilisez des **temporary tables**

**Exemple typique** : Application batch avec transactions longues

---

## Mode Transaction Pooling

### Principe de fonctionnement

En mode **transaction**, une connexion PostgreSQL est attribuÃ©e Ã  un client **seulement pendant la durÃ©e d'une transaction**.

```
Client: BEGIN;           â†’ Obtient connexion PostgreSQL
Client: SELECT...;       â†’ Utilise la connexion
Client: UPDATE...;       â†’ Utilise la connexion
Client: COMMIT;          â†’ LibÃ¨re la connexion immÃ©diatement
Client: (fait autre chose) â†’ Pas de connexion PostgreSQL
Client: BEGIN;           â†’ Obtient connexion (peut-Ãªtre diffÃ©rente)
Client: INSERT...;       â†’ Utilise la connexion
Client: COMMIT;          â†’ LibÃ¨re la connexion
```

**Analogie** : Comme prendre un taxi. Vous prenez un taxi pour un trajet, descendez, et quelqu'un d'autre peut prendre le mÃªme taxi immÃ©diatement aprÃ¨s.

### Diagramme

```
Client                      PgBouncer               PostgreSQL

BEGIN;                     â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Attribue Connexion #1
SELECT...;                                         Connexion #1
UPDATE...;                                         Connexion #1
COMMIT;                    â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ LibÃ¨re Connexion #1

(pas de transaction)       (pas de connexion)
SELECT...; (autocommit)    â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Attribue Connexion #2
                           â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ LibÃ¨re Connexion #2

BEGIN;                     â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Attribue Connexion #3
INSERT...;                                         Connexion #3
COMMIT;                    â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ LibÃ¨re Connexion #3
```

### Comportement

**Pendant une transaction** :
1. Le client exÃ©cute `BEGIN;`
2. PgBouncer attribue une connexion PostgreSQL
3. Toutes les commandes de la transaction utilisent cette connexion
4. Le client exÃ©cute `COMMIT;` ou `ROLLBACK;`
5. **ImmÃ©diatement**, PgBouncer libÃ¨re la connexion

**Entre les transactions** :
- Le client n'a **pas** de connexion PostgreSQL
- La connexion est disponible pour d'autres clients
- Maximum de rÃ©utilisation

### Avantages

- âœ… **EfficacitÃ© maximale** : 10 connexions PostgreSQL peuvent servir 1000 clients
- âœ… **ScalabilitÃ©** : Supporte Ã©normÃ©ment de clients simultanÃ©s
- âœ… **Performance** : Les connexions sont constamment utilisÃ©es
- âœ… **Ã‰conomie de ressources** : Minimal de connexions cÃ´tÃ© PostgreSQL

### InconvÃ©nients

- âŒ **Variables de session perdues** : `SET` commands rÃ©initialisÃ©s entre transactions
- âŒ **Prepared statements** : Seulement les unnamed (automatiques)
- âŒ **LISTEN/NOTIFY** : Non supportÃ©
- âŒ **Advisory locks** : Non supportÃ©
- âŒ **Temporary tables** : Ne survivent pas entre transactions

### Configuration

**Fichier pgbouncer.ini** :
```ini
[databases]
mydb = host=localhost port=5432 dbname=mydb

[pgbouncer]
listen_addr = 0.0.0.0
listen_port = 6432
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt

# MODE TRANSACTION
pool_mode = transaction

# Taille du pool (peut Ãªtre trÃ¨s petit)
default_pool_size = 10        # Seulement 10 connexions PostgreSQL !
max_client_conn = 5000        # Peut servir 5000 clients

# Timeouts
server_idle_timeout = 600
server_lifetime = 3600

# RecommandÃ© en mode transaction
server_reset_query = DISCARD ALL
```

### Cas d'usage

**âœ… Utiliser le mode transaction si** :
- Vous avez une **application web/API REST** classique
- Chaque requÃªte HTTP = 1 ou plusieurs transactions courtes
- Vous n'utilisez **pas** de variables de session
- Vous n'utilisez **pas** de prepared statements nommÃ©s
- Vous avez besoin de **haute scalabilitÃ©**
- Vous voulez **minimiser** les connexions PostgreSQL

**Exemple typique** : API REST avec Node.js/Express, Python/FastAPI, Java/Spring Boot

---

## Comparaison dÃ©taillÃ©e : Session vs Transaction

### Tableau comparatif

| FonctionnalitÃ© | Session | Transaction |
|----------------|---------|-------------|
| **Transactions longues** | âœ… SupportÃ© | âŒ DÃ©conseillÃ© |
| **SET variables** | âœ… PersistÃ©es | âŒ Perdues |
| **Prepared statements (named)** | âœ… SupportÃ© | âŒ Non supportÃ© |
| **Prepared statements (unnamed)** | âœ… SupportÃ© | âœ… SupportÃ© |
| **LISTEN/NOTIFY** | âœ… SupportÃ© | âŒ Non supportÃ© |
| **Advisory locks** | âœ… SupportÃ© | âŒ Non supportÃ© |
| **Temporary tables** | âœ… PersistÃ©es | âŒ Perdues |
| **DISCARD ALL** | Pas nÃ©cessaire | âœ… RecommandÃ© |
| **Ratio client/connexion** | 1:1 ou 2:1 | 100:1 ou plus |
| **ScalabilitÃ©** | â­â­ Moyenne | â­â­â­â­â­ Excellente |
| **EfficacitÃ©** | â­â­ Moyenne | â­â­â­â­â­ Excellente |
| **ComplexitÃ©** | â­ Simple | â­â­â­ ModÃ©rÃ©e |

### Exemple concret : API REST

#### ScÃ©nario

Une API REST qui :
- ReÃ§oit 500 requÃªtes/seconde
- Chaque requÃªte fait 1-5 transactions SQL
- Temps moyen de traitement : 50ms

#### Avec Session Pooling

```
500 requÃªtes/sec Ã— 0.05 sec = 25 requÃªtes simultanÃ©es en moyenne

â†’ Besoin d'au moins 25-30 connexions PostgreSQL
â†’ En pics : peut-Ãªtre 50-100 connexions
```

**Configuration** :
```ini
pool_mode = session
default_pool_size = 50
max_client_conn = 200
```

#### Avec Transaction Pooling

```
Chaque transaction dure ~10ms (pas 50ms, car temps sans connexion)
500 req/sec Ã— 2 transactions Ã— 0.01 sec = 10 transactions simultanÃ©es

â†’ Besoin d'environ 10 connexions PostgreSQL !
```

**Configuration** :
```ini
pool_mode = transaction
default_pool_size = 10
max_client_conn = 2000
```

**RÃ©sultat** :
- Transaction pooling = **5Ã— moins de connexions PostgreSQL**
- Peut gÃ©rer **10Ã— plus de clients**
- Performance Ã©quivalente ou meilleure

---

## Configuration complÃ¨te de PgBouncer

### Fichier pgbouncer.ini complet

```ini
;; Fichier de configuration PgBouncer
;; Emplacement typique : /etc/pgbouncer/pgbouncer.ini

;;
;; Section [databases] : DÃ©finir les bases de donnÃ©es
;;
[databases]
; Format: dbname = paramÃ¨tres de connexion
myapp_db = host=127.0.0.1 port=5432 dbname=myapp user=myapp_user
analytics_db = host=10.0.1.5 port=5432 dbname=analytics

; Base spÃ©ciale : * = configuration par dÃ©faut pour toutes les bases
; * = host=127.0.0.1 port=5432

;;
;; Section [pgbouncer] : Configuration principale
;;
[pgbouncer]

;;;
;;; Configuration rÃ©seau
;;;

; Adresse d'Ã©coute (0.0.0.0 = toutes les interfaces)
listen_addr = 0.0.0.0

; Port d'Ã©coute (par dÃ©faut : 6432)
listen_port = 6432

; Socket Unix (optionnel, pour connexions locales)
unix_socket_dir = /var/run/postgresql

;;;
;;; Authentification
;;;

; Type d'authentification
; Valeurs possibles: md5, scram-sha-256, plain, trust, cert
auth_type = scram-sha-256

; Fichier contenant les utilisateurs et mots de passe
auth_file = /etc/pgbouncer/userlist.txt

; RequÃªte pour obtenir les mots de passe depuis PostgreSQL (optionnel)
; auth_query = SELECT usename, passwd FROM pg_shadow WHERE usename=$1

;;;
;;; Mode de pooling (CRITIQUE)
;;;

; Mode: session, transaction, ou statement
pool_mode = transaction

;;;
;;; Configuration du pool
;;;

; Taille par dÃ©faut du pool par base de donnÃ©es
default_pool_size = 10

; Taille minimale du pool (connexions toujours maintenues)
min_pool_size = 2

; Pool de rÃ©serve (connexions supplÃ©mentaires si nÃ©cessaire)
reserve_pool_size = 5

; DÃ©lai avant d'utiliser le reserve pool (secondes)
reserve_pool_timeout = 5

;;;
;;; Limites de connexions
;;;

; Nombre maximum de connexions clientes
max_client_conn = 1000

; Nombre maximum de connexions par utilisateur
; max_user_connections = 100

; Nombre maximum de connexions par base de donnÃ©es
; max_db_connections = 50

;;;
;;; Timeouts (en secondes)
;;;

; Timeout pour obtenir une connexion serveur du pool
server_connect_timeout = 15

; Temps d'inactivitÃ© avant de fermer une connexion serveur
server_idle_timeout = 600

; DurÃ©e de vie maximale d'une connexion serveur (secondes)
server_lifetime = 3600

; Temps d'inactivitÃ© avant de fermer une connexion client
client_idle_timeout = 0

; Timeout pour une requÃªte (0 = dÃ©sactivÃ©)
query_timeout = 0

; Timeout d'attente client pour obtenir connexion
query_wait_timeout = 120

;;;
;;; Comportement en mode transaction
;;;

; Commande exÃ©cutÃ©e lors de la libÃ©ration d'une connexion
; DISCARD ALL nettoie : prepared statements, LISTEN, temp tables, etc.
server_reset_query = DISCARD ALL

; Alternative moins stricte (plus rapide)
; server_reset_query = RESET ALL

;;;
;;; Logging
;;;

; Emplacement des logs
logfile = /var/log/pgbouncer/pgbouncer.log

; Niveau de log: debug, info, warning, error
log_connections = 1
log_disconnections = 1
log_pooler_errors = 1

; Statistiques
stats_period = 60

;;;
;;; SÃ©curitÃ©
;;;

; Utilisateur systÃ¨me sous lequel PgBouncer s'exÃ©cute
; user = pgbouncer

; Ignorer les erreurs de dÃ©marrage pour certaines bases
ignore_startup_parameters = extra_float_digits

;;;
;;; Administration
;;;

; Base de donnÃ©es d'administration (virtuelle)
; Connexion: psql -h localhost -p 6432 -U admin pgbouncer
admin_users = admin, pgbouncer

; Utilisateurs avec privilÃ¨ges de stats
stats_users = admin, monitoring
```

### Fichier userlist.txt

Le fichier `userlist.txt` contient les utilisateurs et leurs mots de passe :

```txt
; Format: "username" "mot_de_passe_hashÃ©"

; Pour md5: md5 + md5(password + username)
"myapp_user" "md5d8578edf8458ce06fbc5bb76a58c5ca4"

; Pour scram-sha-256: utiliser SCRAM-SHA-256$<iterations>:<salt>$<StoredKey>:<ServerKey>
"api_user" "SCRAM-SHA-256$4096:rGbSEfZ+..."

; Pour plain text (NON RECOMMANDÃ‰ en production)
; "dev_user" "plain_password_123"
```

**GÃ©nÃ©ration d'un hash md5** :
```bash
# Formule: md5(password + username)
echo -n "mypasswordmyapp_user" | md5sum
# Ajouter "md5" devant le rÃ©sultat
```

**Meilleure pratique** : Utiliser `auth_query` pour rÃ©cupÃ©rer les mots de passe depuis PostgreSQL.

---

## DÃ©marrage et gestion de PgBouncer

### DÃ©marrer PgBouncer

```bash
# DÃ©marrer avec le fichier de configuration
pgbouncer -d /etc/pgbouncer/pgbouncer.ini

# -d = mode daemon (arriÃ¨re-plan)
```

### Avec systemd (recommandÃ©)

```bash
# DÃ©marrer
sudo systemctl start pgbouncer

# ArrÃªter
sudo systemctl stop pgbouncer

# RedÃ©marrer
sudo systemctl restart pgbouncer

# Recharger la configuration sans redÃ©marrage
sudo systemctl reload pgbouncer

# Activer au dÃ©marrage
sudo systemctl enable pgbouncer

# Voir les logs
sudo journalctl -u pgbouncer -f
```

### VÃ©rifier l'Ã©tat

```bash
# Status du service
sudo systemctl status pgbouncer

# VÃ©rifier que PgBouncer Ã©coute
sudo netstat -tlnp | grep 6432
# Ou
sudo ss -tlnp | grep 6432
```

---

## Administration de PgBouncer

### Console d'administration

PgBouncer expose une **base de donnÃ©es virtuelle** appelÃ©e `pgbouncer` pour l'administration :

```bash
# Se connecter Ã  la console d'administration
psql -h localhost -p 6432 -U admin pgbouncer
```

### Commandes essentielles

#### Voir les bases de donnÃ©es

```sql
SHOW DATABASES;
```

**RÃ©sultat** :
```
 name      | host      | port | database | force_user | pool_size | ...
-----------+-----------+------+----------+------------+-----------+-----
 myapp_db  | 127.0.0.1 | 5432 | myapp    |            | 10        | ...
 pgbouncer | pgbouncer | 6432 | pgbouncer|            | 2         | ...
```

#### Voir les pools actifs

```sql
SHOW POOLS;
```

**RÃ©sultat** :
```
 database  | user      | cl_active | cl_waiting | sv_active | sv_idle | ...
-----------+-----------+-----------+------------+-----------+---------+-----
 myapp_db  | myapp_user| 45        | 2          | 8         | 2       | ...
```

**Colonnes importantes** :
- `cl_active` : Clients actifs (avec connexion)
- `cl_waiting` : Clients en attente d'une connexion
- `sv_active` : Connexions PostgreSQL actives
- `sv_idle` : Connexions PostgreSQL inactives (disponibles)
- `sv_used` : Connexions PostgreSQL utilisÃ©es rÃ©cemment
- `sv_tested` : Connexions en cours de test
- `sv_login` : Connexions en cours d'authentification

#### Voir les connexions clientes

```sql
SHOW CLIENTS;
```

#### Voir les connexions serveur

```sql
SHOW SERVERS;
```

#### Statistiques

```sql
SHOW STATS;
```

**RÃ©sultat** :
```
 database  | total_xact_count | total_query_count | total_bytes_received | avg_xact_time | ...
-----------+------------------+-------------------+----------------------+---------------+-----
 myapp_db  | 125830          | 542301            | 1252567890           | 2500          | ...
```

#### Recharger la configuration

```sql
RELOAD;
```

**Usage** : AprÃ¨s modification du fichier `pgbouncer.ini`, recharge la config sans redÃ©marrage.

#### Suspendre temporairement

```sql
-- Suspendre toutes les bases
PAUSE;

-- Reprendre
RESUME;

-- Suspendre une base spÃ©cifique
PAUSE myapp_db;
RESUME myapp_db;
```

**Usage** : Pour maintenance, migrations, etc.

#### Vider les pools

```sql
-- Fermer toutes les connexions inactives
KILL;

-- Attendre que toutes les transactions se terminent puis fermer tout
SHUTDOWN;
```

---

## Migration d'application vers PgBouncer

### Ã‰tape 1 : Configuration de PgBouncer

**Avant (application se connecte directement Ã  PostgreSQL)** :
```
Application â†’ PostgreSQL (localhost:5432)
```

**AprÃ¨s (avec PgBouncer)** :
```
Application â†’ PgBouncer (localhost:6432) â†’ PostgreSQL (localhost:5432)
```

### Ã‰tape 2 : CrÃ©er la configuration

**pgbouncer.ini** :
```ini
[databases]
myapp = host=localhost port=5432 dbname=myapp

[pgbouncer]
listen_addr = 127.0.0.1
listen_port = 6432
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt
pool_mode = transaction
default_pool_size = 10
max_client_conn = 1000
```

**userlist.txt** :
```txt
"myapp_user" "md5d8578edf8458ce06fbc5bb76a58c5ca4"
```

### Ã‰tape 3 : Modifier la connection string de l'application

**Avant** :
```
postgresql://myapp_user:password@localhost:5432/myapp
```

**AprÃ¨s** :
```
postgresql://myapp_user:password@localhost:6432/myapp
```

**C'est tout !** L'application ne voit pas la diffÃ©rence.

### Ã‰tape 4 : Tester

```bash
# Test de connexion via PgBouncer
psql -h localhost -p 6432 -U myapp_user myapp

# VÃ©rifier les pools
psql -h localhost -p 6432 -U admin pgbouncer -c "SHOW POOLS;"
```

### Ã‰tape 5 : Surveiller

```sql
-- Connexions en attente (signe de sous-dimensionnement)
SELECT * FROM pgbouncer.show_pools WHERE cl_waiting > 0;

-- Utilisation du pool
SELECT
    database,
    cl_active,
    sv_active,
    sv_idle,
    (sv_active::float / (sv_active + sv_idle)) * 100 as utilization_pct
FROM pgbouncer.show_pools;
```

---

## Cas pratiques et recommandations

### Cas 1 : API REST avec microservices

**Contexte** :
- 5 microservices Node.js
- Chaque service a 3 instances (total : 15 instances)
- Chaque instance sans PgBouncer aurait un pool de 10 connexions

**Sans PgBouncer** :
```
15 instances Ã— 10 connexions = 150 connexions PostgreSQL
```

**Avec PgBouncer (transaction mode)** :
```ini
pool_mode = transaction
default_pool_size = 20
max_client_conn = 500

â†’ Seulement 20 connexions PostgreSQL pour 500 clients possibles !
â†’ Ã‰conomie : 150 â†’ 20 = 86% de connexions en moins
```

**Configuration recommandÃ©e** :
```ini
[databases]
myapp = host=postgres-server port=5432 dbname=myapp

[pgbouncer]
pool_mode = transaction
default_pool_size = 20
max_client_conn = 500
server_reset_query = DISCARD ALL
server_idle_timeout = 300
server_lifetime = 3600
```

### Cas 2 : Application legacy avec prepared statements

**Contexte** :
- Application Java avec JDBC
- Utilise des prepared statements nommÃ©s
- Transactions longues (plusieurs secondes)

**Configuration recommandÃ©e** :
```ini
[databases]
legacy_db = host=postgres-server port=5432 dbname=legacy

[pgbouncer]
pool_mode = session        # MODE SESSION obligatoire
default_pool_size = 50     # Plus de connexions nÃ©cessaires
max_client_conn = 200
server_idle_timeout = 1800 # 30 min (transactions longues)
server_lifetime = 7200     # 2h
```

### Cas 3 : Application mixte (web + batch)

**Contexte** :
- Partie web : transactions courtes
- Partie batch : transactions longues

**Solution** : **Deux instances de PgBouncer**

**PgBouncer Web (port 6432)** :
```ini
[databases]
webapp = host=postgres-server port=5432 dbname=myapp

[pgbouncer]
listen_port = 6432
pool_mode = transaction
default_pool_size = 10
```

**PgBouncer Batch (port 6433)** :
```ini
[databases]
batch = host=postgres-server port=5432 dbname=myapp

[pgbouncer]
listen_port = 6433
pool_mode = session
default_pool_size = 5
```

**Connexions applicatives** :
```python
# Web app
web_pool = ConnectionPool("postgresql://user:pass@localhost:6432/webapp")

# Batch jobs
batch_conn = psycopg.connect("postgresql://user:pass@localhost:6433/batch")
```

### Cas 4 : Serverless (AWS Lambda, Cloud Functions)

**ProblÃ¨me** :
- Chaque invocation Lambda = nouvelle connexion
- Saturation rapide de PostgreSQL

**Solution avec PgBouncer** :
```
Lambda â†’ PgBouncer (EC2/ECS) â†’ RDS PostgreSQL
```

**Configuration PgBouncer** :
```ini
[databases]
lambda_db = host=my-rds.amazonaws.com port=5432 dbname=mydb

[pgbouncer]
pool_mode = transaction
default_pool_size = 5      # TrÃ¨s petit pool
max_client_conn = 1000     # Beaucoup de Lambdas
server_reset_query = DISCARD ALL
server_idle_timeout = 60   # Courte durÃ©e
```

**Alternative** : AWS RDS Proxy (Ã©quivalent managÃ© de PgBouncer)

---

## Monitoring et troubleshooting

### MÃ©triques Ã  surveiller

#### 1. Clients en attente (cl_waiting)

```sql
-- Voir les clients en attente
SHOW POOLS;
```

**ProblÃ¨me si** : `cl_waiting > 0` de maniÃ¨re rÃ©currente

**Solutions** :
- Augmenter `default_pool_size`
- Augmenter `reserve_pool_size`
- VÃ©rifier les slow queries cÃ´tÃ© PostgreSQL

#### 2. Utilisation du pool

```sql
-- Taux d'utilisation
SELECT
    database,
    user,
    sv_active,
    sv_idle,
    sv_used,
    ROUND((sv_active::float / (sv_active + sv_idle + sv_used)) * 100, 2) as utilization
FROM pgbouncer.show_pools
WHERE database != 'pgbouncer';
```

**Sain** : 60-80% d'utilisation en charge normale
**ProblÃ¨me** : >90% constamment â†’ Pool trop petit

#### 3. Transactions longues en mode transaction

```sql
-- Connexions avec transactions longues (> 1 sec)
SHOW SERVERS;
```

En mode `transaction`, si vous voyez des connexions actives pendant plusieurs secondes, c'est suspect.

**Solution** :
- Optimiser les requÃªtes lentes
- ConsidÃ©rer le mode `session` si nÃ©cessaire

#### 4. Statistiques globales

```sql
-- Performance globale
SHOW STATS;
```

**Colonnes importantes** :
- `avg_xact_time` : Temps moyen de transaction (doit Ãªtre <100ms)
- `avg_query_time` : Temps moyen de requÃªte
- `avg_wait_time` : Temps d'attente pour obtenir une connexion (doit Ãªtre ~0)

### ProblÃ¨mes courants

#### ProblÃ¨me 1 : "no more connections allowed"

**SymptÃ´me** :
```
FATAL: no more connections allowed (max_client_conn)
```

**Cause** : Trop de clients essaient de se connecter

**Solution** :
```ini
# Augmenter la limite
max_client_conn = 2000  # Au lieu de 1000
```

#### ProblÃ¨me 2 : "sorry, too many clients already"

**SymptÃ´me** : Erreur venant de PostgreSQL

**Cause** : PgBouncer envoie trop de connexions Ã  PostgreSQL

**Solution** :
```ini
# RÃ©duire le pool cÃ´tÃ© PgBouncer
default_pool_size = 10  # Au lieu de 50

# Ou augmenter max_connections cÃ´tÃ© PostgreSQL (dans postgresql.conf)
max_connections = 200
```

#### ProblÃ¨me 3 : Transactions qui Ã©chouent en mode transaction

**SymptÃ´me** :
```
ERROR: prepared statement "..." does not exist
ERROR: cursor "..." does not exist
```

**Cause** : Utilisation de features incompatibles avec le mode transaction

**Solution** :
- Passer en mode `session`
- Ou modifier le code pour Ã©viter prepared statements nommÃ©s

#### ProblÃ¨me 4 : Performance dÃ©gradÃ©e aprÃ¨s passage Ã  PgBouncer

**Causes possibles** :
1. Pool trop petit â†’ Augmenter `default_pool_size`
2. `server_reset_query` trop lourd â†’ Utiliser `RESET ALL` au lieu de `DISCARD ALL`
3. Latence rÃ©seau ajoutÃ©e â†’ DÃ©ployer PgBouncer sur le mÃªme serveur que l'app

---

## PgBouncer vs Pooling applicatif

### Quand utiliser les deux ?

**Configuration optimale** :
```
Application (pool=5) â†’ PgBouncer (pool=20) â†’ PostgreSQL
```

**Avantages de la combinaison** :
- **Application** : RÃ©duit la latence (connexions locales)
- **PgBouncer** : Mutualise les connexions entre toutes les applications

### Dimensionnement combinÃ©

**RÃ¨gle** :
```
pool_size_app = 5-10 connexions par instance
pool_size_pgbouncer = nb_instances_app Ã— 2

Exemple:
- 10 instances d'application
- Pool app = 5
- Pool PgBouncer = 10 Ã— 2 = 20
```

---

## Haute disponibilitÃ© avec PgBouncer

### Architecture HA

```
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚   Load Balancer â”‚
                      â”‚   (HAProxy)     â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚              â”‚              â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
         â”‚ PgBouncer 1â”‚  â”‚ PgBouncer 2â”‚ â”‚ PgBouncer 3â”‚
         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                â”‚              â”‚              â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚   PostgreSQL    â”‚
                      â”‚   Primary       â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Configuration HAProxy pour PgBouncer

```conf
global
    maxconn 10000

defaults
    mode tcp
    timeout connect 5s
    timeout client 30s
    timeout server 30s

# Frontend pour les connexions PostgreSQL
frontend postgres_frontend
    bind *:5432
    default_backend pgbouncer_backend

# Backend avec plusieurs PgBouncer
backend pgbouncer_backend
    balance roundrobin
    option tcp-check

    server pgbouncer1 10.0.1.10:6432 check
    server pgbouncer2 10.0.1.11:6432 check
    server pgbouncer3 10.0.1.12:6432 check
```

---

## RÃ©sumÃ© : Points clÃ©s Ã  retenir

### âœ¨ Quand utiliser quel mode

| Votre cas | Mode recommandÃ© | Pourquoi |
|-----------|----------------|----------|
| API REST/Web moderne | **Transaction** | ScalabilitÃ© maximale |
| Microservices | **Transaction** | Mutualisation des connexions |
| Application avec prepared statements | **Session** | CompatibilitÃ© complÃ¨te |
| Transactions longues (>1s) | **Session** | Ã‰vite les timeouts |
| Batch jobs | **Session** | FlexibilitÃ© nÃ©cessaire |
| Serverless (Lambda) | **Transaction** | Gestion des pics |

### ğŸ¯ Configuration type : API REST

```ini
[pgbouncer]
pool_mode = transaction
default_pool_size = 10
max_client_conn = 2000
server_reset_query = DISCARD ALL
server_idle_timeout = 600
```

### ğŸ¯ Configuration type : Application legacy

```ini
[pgbouncer]
pool_mode = session
default_pool_size = 50
max_client_conn = 200
server_idle_timeout = 1800
```

### ğŸ’¡ Bonnes pratiques

1. **Commencer petit** : `default_pool_size = 10`, puis ajuster
2. **Monitorer** : Surveiller `cl_waiting` et `avg_wait_time`
3. **Tester** : Valider en dev avant la prod
4. **Documenter** : Noter la configuration et les raisons
5. **Sauvegarder** : Garder l'ancienne connection string en backup

### âš ï¸ PiÃ¨ges Ã  Ã©viter

- âŒ Pool trop grand en mode transaction (gaspillage)
- âŒ Pool trop petit â†’ clients en attente constante
- âŒ Mode transaction avec prepared statements nommÃ©s
- âŒ Oublier `server_reset_query` en mode transaction
- âŒ Ne pas monitorer les mÃ©triques PgBouncer

---

## Pour aller plus loin

### Documentation officielle

- [PgBouncer Official Documentation](https://www.pgbouncer.org/)
- [PgBouncer FAQ](https://www.pgbouncer.org/faq.html)
- [PgBouncer GitHub](https://github.com/pgbouncer/pgbouncer)

### Articles recommandÃ©s

- [PgBouncer Best Practices](https://www.enterprisedb.com/postgres-tutorials/how-use-pgbouncer-connection-pooling-postgresql) - EDB
- [Transaction vs Session Pooling](https://github.com/pgbouncer/pgbouncer/wiki/Configuration) - Wiki officiel

### Outils complÃ©mentaires

- **HAProxy** : Load balancing pour PgBouncer HA
- **pgBadger** : Analyse des logs PostgreSQL et PgBouncer
- **Prometheus + Grafana** : Monitoring avec pgbouncer_exporter

---


â­ï¸ [Dimensionnement (max_connections vs pool_size)](/20-drivers-connexion-applicative/02.3-dimensionnement-connexions.md)
