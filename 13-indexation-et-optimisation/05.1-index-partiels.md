üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.5.1. Index Partiels (WHERE clause)

## Introduction

Un **index partiel** est un index qui ne porte que sur un sous-ensemble des lignes d'une table, d√©fini par une condition WHERE. Contrairement √† un index classique qui indexe toutes les lignes de la table, un index partiel n'indexe que les lignes qui satisfont un pr√©dicat sp√©cifique.

Cette technique permet d'optimiser √† la fois la performance des requ√™tes et l'utilisation de l'espace disque, en ne cr√©ant un index que l√† o√π il est r√©ellement n√©cessaire.

---

## Concept Fondamental

### Index Classique vs Index Partiel

**Index classique :**
```sql
CREATE INDEX idx_commandes_statut ON commandes(statut);
```
‚Üí Indexe **toutes** les lignes de la table `commandes`, quel que soit leur statut.

**Index partiel :**
```sql
CREATE INDEX idx_commandes_statut_en_cours
ON commandes(statut)
WHERE statut = 'en_cours';
```
‚Üí N'indexe **que** les commandes dont le statut est 'en_cours'.

---

## Pourquoi Utiliser des Index Partiels ?

### 1. **R√©duction de la Taille de l'Index**

Un index partiel occupe moins d'espace disque car il contient moins d'entr√©es.

**Exemple concret :**
```sql
-- Table avec 1 million de commandes
-- 95% sont livr√©es, 5% sont en cours (50 000 lignes)

-- Index classique : indexe 1 000 000 de lignes
CREATE INDEX idx_all ON commandes(statut);

-- Index partiel : indexe seulement 50 000 lignes
CREATE INDEX idx_partial ON commandes(statut)
WHERE statut IN ('en_cours', 'en_preparation');
```

**Avantage :** L'index partiel sera environ 20 fois plus petit !

### 2. **Am√©lioration de la Performance**

Un index plus petit :
- Tient mieux en m√©moire (cache)
- Se parcourt plus rapidement
- N√©cessite moins de pages disque √† lire

### 3. **Maintenance Plus L√©g√®re**

Lors des op√©rations d'√©criture (INSERT, UPDATE, DELETE), PostgreSQL doit maintenir les index. Un index partiel :
- Est mis √† jour uniquement si la ligne satisfait la condition WHERE
- R√©duit le co√ªt des √©critures sur les lignes non index√©es

---

## Syntaxe et Utilisation

### Syntaxe G√©n√©rale

```sql
CREATE INDEX nom_index
ON nom_table(colonne1, colonne2, ...)
WHERE condition;
```

### R√®gles Importantes

1. **La condition WHERE doit √™tre simple et stable**
   - √âviter les fonctions volatiles (RANDOM(), NOW(), etc.)
   - Privil√©gier les comparaisons sur des valeurs constantes

2. **PostgreSQL utilise l'index partiel uniquement si la requ√™te contient la m√™me condition**
   - La condition de la requ√™te doit √™tre **identique ou plus restrictive** que celle de l'index

---

## Exemples Pratiques

### Exemple 1 : Indexer les Lignes Actives

**Contexte :** Une table d'utilisateurs o√π 99% sont actifs et 1% sont supprim√©s (soft delete).

```sql
-- Table utilisateurs
CREATE TABLE utilisateurs (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    email VARCHAR(255),
    est_actif BOOLEAN DEFAULT TRUE,
    date_creation TIMESTAMP DEFAULT NOW()
);

-- Index partiel : uniquement les utilisateurs actifs
CREATE INDEX idx_utilisateurs_actifs
ON utilisateurs(email)
WHERE est_actif = TRUE;
```

**Requ√™te qui utilisera l'index :**
```sql
-- ‚úÖ Utilise l'index partiel
SELECT * FROM utilisateurs
WHERE email = 'user@example.com'
AND est_actif = TRUE;
```

**Requ√™te qui N'utilisera PAS l'index :**
```sql
-- ‚ùå Ne peut pas utiliser l'index partiel (pas de condition sur est_actif)
SELECT * FROM utilisateurs
WHERE email = 'user@example.com';
```

### Exemple 2 : Indexer les Donn√©es R√©centes

**Contexte :** Une table de logs o√π on interroge principalement les 30 derniers jours.

```sql
-- Table de logs
CREATE TABLE logs (
    id BIGSERIAL PRIMARY KEY,
    niveau VARCHAR(20),
    message TEXT,
    date_creation TIMESTAMP DEFAULT NOW()
);

-- Index partiel : logs r√©cents (30 derniers jours)
CREATE INDEX idx_logs_recents
ON logs(niveau, date_creation)
WHERE date_creation > NOW() - INTERVAL '30 days';
```

**Probl√®me :** Cette approche a une limite ! La condition `NOW() - INTERVAL '30 days'` change chaque jour.

**Solution alternative :**
```sql
-- Meilleure approche : partitionner la table par date
-- Ou utiliser un index partiel avec une date fixe et le recr√©er p√©riodiquement
```

### Exemple 3 : Indexer les Valeurs Non-NULL

**Contexte :** Une colonne optionnelle qui est NULL dans 90% des cas.

```sql
-- Table de produits
CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    code_promo VARCHAR(50), -- NULL dans 90% des cas
    prix NUMERIC(10,2)
);

-- Index partiel : uniquement les produits avec promo
CREATE INDEX idx_produits_avec_promo
ON produits(code_promo)
WHERE code_promo IS NOT NULL;
```

**Requ√™te optimis√©e :**
```sql
-- ‚úÖ Utilise l'index partiel
SELECT * FROM produits
WHERE code_promo = 'NOEL2025';
```

### Exemple 4 : Combiner Plusieurs Conditions

```sql
-- Table de commandes
CREATE TABLE commandes (
    id SERIAL PRIMARY KEY,
    client_id INTEGER,
    statut VARCHAR(50),
    montant NUMERIC(10,2),
    date_commande TIMESTAMP DEFAULT NOW()
);

-- Index partiel : commandes √† traiter (non livr√©es et montant > 100‚Ç¨)
CREATE INDEX idx_commandes_a_traiter
ON commandes(client_id, date_commande)
WHERE statut IN ('en_cours', 'en_preparation', 'expedie')
AND montant > 100;
```

**Requ√™te qui utilise l'index :**
```sql
-- ‚úÖ Conditions compatibles avec l'index
SELECT * FROM commandes
WHERE client_id = 12345
AND statut = 'en_cours'
AND montant > 100
ORDER BY date_commande DESC;
```

---

## Cas d'Usage Typiques

### 1. **Soft Delete (Suppression Logique)**

```sql
CREATE INDEX idx_actifs ON utilisateurs(email)
WHERE est_supprime = FALSE;
```

**Sc√©nario :** 95% des lignes sont actives, 5% sont supprim√©es.

### 2. **√âtats Temporaires**

```sql
CREATE INDEX idx_en_attente ON taches(priorite, date_creation)
WHERE statut = 'en_attente';
```

**Sc√©nario :** On interroge principalement les t√¢ches en attente.

### 3. **Donn√©es Anormales ou Exceptionnelles**

```sql
CREATE INDEX idx_erreurs ON transactions(date_creation)
WHERE statut = 'erreur';
```

**Sc√©nario :** Seulement 0.1% des transactions √©chouent, mais on doit les retrouver rapidement.

### 4. **Valeurs Sp√©cifiques Fr√©quemment Recherch√©es**

```sql
CREATE INDEX idx_admin ON utilisateurs(date_derniere_connexion)
WHERE role = 'admin';
```

**Sc√©nario :** Les administrateurs repr√©sentent 1% des utilisateurs mais font 50% des requ√™tes.

### 5. **Exclusion de Valeurs Communes**

```sql
CREATE INDEX idx_prioritaire ON tickets(date_creation)
WHERE priorite != 'basse';
```

**Sc√©nario :** 80% des tickets sont de priorit√© basse et rarement consult√©s.

---

## V√©rifier l'Utilisation de l'Index

Pour v√©rifier si PostgreSQL utilise bien votre index partiel, utilisez `EXPLAIN` :

```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM commandes
WHERE statut = 'en_cours'
AND client_id = 12345;
```

**Sortie attendue :**
```
Index Scan using idx_commandes_statut_en_cours on commandes
  Index Cond: (client_id = 12345)
  Filter: (statut = 'en_cours'::text)
```

Si vous voyez `Seq Scan` au lieu d'`Index Scan`, l'index n'est pas utilis√© !

---

## Pi√®ges et Limitations

### ‚ùå Pi√®ge 1 : Condition de Requ√™te Incompatible

```sql
-- Index partiel
CREATE INDEX idx_actifs ON utilisateurs(email)
WHERE est_actif = TRUE;

-- ‚ùå Cette requ√™te N'utilisera PAS l'index
SELECT * FROM utilisateurs WHERE email = 'test@example.com';
-- Il manque la condition : AND est_actif = TRUE
```

**Solution :** Toujours inclure la condition de l'index partiel dans vos requ√™tes.

### ‚ùå Pi√®ge 2 : Fonctions Volatiles dans la Condition

```sql
-- ‚ùå MAUVAIS : NOW() change √† chaque appel
CREATE INDEX idx_recent ON logs(niveau)
WHERE date_creation > NOW() - INTERVAL '7 days';
```

**Solution :** Utiliser des valeurs fixes ou recr√©er l'index p√©riodiquement.

### ‚ùå Pi√®ge 3 : Index Partiel Trop Large

```sql
-- ‚ùå Cet index partiel indexe 90% de la table ‚Üí Peu d'int√©r√™t
CREATE INDEX idx_presque_tout ON commandes(client_id)
WHERE montant > 1;  -- Presque toutes les commandes sont > 1‚Ç¨
```

**R√®gle g√©n√©rale :** Un index partiel est pertinent quand il indexe **moins de 20-30%** de la table.

### ‚ùå Pi√®ge 4 : Condition Complexe

```sql
-- ‚ùå Condition trop complexe, difficile √† utiliser par le planificateur
CREATE INDEX idx_complexe ON produits(nom)
WHERE (prix > 100 AND categorie = 'Electronique')
OR (prix > 500 AND categorie = 'Mobilier');
```

**Solution :** Privil√©gier des conditions simples avec AND.

---

## Maintenance et Monitoring

### Lister les Index Partiels

```sql
SELECT
    schemaname,
    tablename,
    indexname,
    indexdef
FROM pg_indexes
WHERE indexdef LIKE '%WHERE%'
ORDER BY tablename, indexname;
```

### V√©rifier la Taille d'un Index

```sql
SELECT
    pg_size_pretty(pg_relation_size('nom_index')) AS taille_index;
```

### Comparer Index Classique vs Partiel

```sql
-- Index classique
SELECT pg_size_pretty(pg_relation_size('idx_classique'));
-- R√©sultat : 50 MB

-- Index partiel
SELECT pg_size_pretty(pg_relation_size('idx_partiel'));
-- R√©sultat : 5 MB  ‚Üí 10√ó plus petit !
```

---

## Quand Utiliser un Index Partiel ?

### ‚úÖ Utilisez un Index Partiel Si :

1. **Vous interrogez fr√©quemment un sous-ensemble sp√©cifique de donn√©es**
   - Exemple : Commandes en cours, utilisateurs actifs, tickets non r√©solus

2. **La condition filtre une petite portion de la table (< 20-30%)**
   - Plus le filtre est s√©lectif, plus l'index partiel est avantageux

3. **Vous connaissez √† l'avance les conditions de filtrage**
   - Les conditions doivent √™tre pr√©visibles et stables

4. **La table est volumineuse et la colonne contient peu de valeurs distinctes**
   - Exemple : Statut (5 valeurs), Type (10 valeurs)

### ‚ùå N'Utilisez PAS un Index Partiel Si :

1. **Les conditions de filtrage varient constamment**
   - Impossible de pr√©dire les requ√™tes futures

2. **La condition couvre > 50% de la table**
   - Un index classique serait plus simple et presque aussi efficace

3. **Les requ√™tes n'incluent pas syst√©matiquement la condition WHERE**
   - L'index ne serait jamais utilis√©

---

## Comparaison : Index Partiel vs Alternatives

| Technique | Cas d'Usage | Avantages | Inconv√©nients |
|-----------|-------------|-----------|---------------|
| **Index Partiel** | Filtrage sur valeurs sp√©cifiques | Compact, rapide | Requiert condition exacte |
| **Index Classique** | Toutes les valeurs | Simple, universel | Plus volumineux |
| **Partitionnement** | Archivage, donn√©es temporelles | Isolation des donn√©es | Complexit√© de gestion |
| **Index sur Expression** | Transformations (LOWER, etc.) | Flexibilit√© | Calcul √† l'indexation |

---

## Exemple Complet : Optimisation d'une Table de Commandes

### Contexte

```sql
-- Table avec 10 millions de commandes
CREATE TABLE commandes (
    id BIGSERIAL PRIMARY KEY,
    client_id INTEGER,
    statut VARCHAR(50), -- 'brouillon', 'en_cours', 'livree', 'annulee'
    montant NUMERIC(10,2),
    date_commande TIMESTAMP DEFAULT NOW()
);

-- Distribution des statuts :
-- brouillon : 5% (500 000)
-- en_cours : 3% (300 000)
-- livree : 90% (9 000 000)
-- annulee : 2% (200 000)
```

### Strat√©gie d'Indexation

```sql
-- ‚ùå MAUVAIS : Index classique sur statut
CREATE INDEX idx_statut ON commandes(statut);
-- Probl√®me : Indexe 10M de lignes, mais on interroge surtout 'en_cours'

-- ‚úÖ BON : Index partiel sur commandes actives
CREATE INDEX idx_commandes_actives
ON commandes(client_id, date_commande)
WHERE statut IN ('brouillon', 'en_cours');
-- Avantage : Indexe seulement 800 000 lignes (8% de la table)

-- ‚úÖ BON : Index partiel sur commandes livr√©es r√©centes
CREATE INDEX idx_commandes_livrees_recentes
ON commandes(client_id, date_commande DESC)
WHERE statut = 'livree'
AND date_commande > '2025-01-01';
-- Avantage : Optimise les recherches sur l'historique r√©cent
```

### Requ√™tes Optimis√©es

```sql
-- Requ√™te 1 : Commandes actives d'un client
-- ‚úÖ Utilise idx_commandes_actives
SELECT * FROM commandes
WHERE client_id = 12345
AND statut = 'en_cours'
ORDER BY date_commande DESC;

-- Requ√™te 2 : Historique r√©cent d'un client
-- ‚úÖ Utilise idx_commandes_livrees_recentes
SELECT * FROM commandes
WHERE client_id = 12345
AND statut = 'livree'
AND date_commande > '2025-01-01'
ORDER BY date_commande DESC;
```

### Gains Obtenus

- **Taille des index r√©duite de 80%**
- **Performance des requ√™tes am√©li√≥r√©e de 3-5√ó**
- **Co√ªt de maintenance (INSERT/UPDATE) r√©duit**

---

## Bonnes Pratiques

### ‚úÖ DO (√Ä Faire)

1. **Nommer explicitement vos index partiels**
   ```sql
   -- ‚úÖ Nom clair et descriptif
   CREATE INDEX idx_utilisateurs_actifs ON utilisateurs(email)
   WHERE est_actif = TRUE;
   ```

2. **Documenter la logique de l'index**
   ```sql
   COMMENT ON INDEX idx_commandes_actives IS
   'Index partiel pour requ√™tes sur commandes non livr√©es (8% de la table)';
   ```

3. **Tester avec EXPLAIN avant de cr√©er l'index**
   ```sql
   EXPLAIN SELECT * FROM commandes
   WHERE statut = 'en_cours' AND client_id = 12345;
   ```

4. **Monitorer l'utilisation de vos index**
   ```sql
   SELECT * FROM pg_stat_user_indexes
   WHERE indexrelname = 'idx_commandes_actives';
   ```

### ‚ùå DON'T (√Ä √âviter)

1. **Ne cr√©ez pas d'index partiels sur des conditions changeantes**
   ```sql
   -- ‚ùå NOW() change chaque jour
   WHERE date_creation > NOW() - INTERVAL '7 days'
   ```

2. **N'oubliez pas la condition WHERE dans vos requ√™tes**
   ```sql
   -- ‚ùå L'index ne sera pas utilis√©
   SELECT * FROM utilisateurs WHERE email = 'test@example.com';
   -- Il manque : AND est_actif = TRUE
   ```

3. **Ne cr√©ez pas trop d'index partiels concurrents**
   ```sql
   -- ‚ùå Trop d'index = confusion et co√ªt de maintenance
   CREATE INDEX idx1 ON table(col) WHERE statut = 'A';
   CREATE INDEX idx2 ON table(col) WHERE statut = 'B';
   CREATE INDEX idx3 ON table(col) WHERE statut = 'C';
   -- Mieux : Un index classique ou partitionner la table
   ```

---

## R√©sum√©

### Points Cl√©s

1. **Un index partiel n'indexe qu'un sous-ensemble de lignes d√©fini par une condition WHERE**

2. **Avantages :**
   - R√©duit la taille de l'index (espace disque)
   - Am√©liore la performance (cache, parcours)
   - Diminue le co√ªt de maintenance (√©critures)

3. **Condition d'utilisation :**
   - La requ√™te doit contenir la **m√™me condition** que l'index partiel

4. **Cas d'usage id√©aux :**
   - Soft delete (lignes actives)
   - √âtats temporaires (en_cours, en_attente)
   - Valeurs exceptionnelles (erreurs, priorit√©s hautes)
   - Donn√©es r√©centes ou sp√©cifiques

5. **R√®gle d'or :**
   - Un index partiel est pertinent quand il indexe **< 20-30%** de la table

---

## Pour Aller Plus Loin

### Lecture Compl√©mentaire

- **Documentation officielle :** [PostgreSQL - Partial Indexes](https://www.postgresql.org/docs/current/indexes-partial.html)
- **Livre recommand√© :** "PostgreSQL: Up and Running" - Chapitres sur l'indexation
- **Article avanc√© :** "The Art of PostgreSQL" - Strat√©gies d'indexation

### Prochaines √âtapes

Apr√®s avoir ma√Ætris√© les index partiels, explorez :
- **13.5.2. Index sur expressions** - Indexer des transformations de colonnes
- **13.5.3. Index multi-colonnes et INCLUDE** - Covering indexes
- **13.5.4. Index sur colonnes JSONB** - GIN et chemins JSON

---


‚è≠Ô∏è [Index sur expressions (CREATE INDEX ON table((lower(col))))](/13-indexation-et-optimisation/05.2-index-sur-expressions.md)
