üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.5.3. Index Multi-Colonnes et INCLUDE (Covering Index)

## Introduction

Un **index multi-colonnes** (√©galement appel√© **index composite** ou **index concat√©n√©**) est un index qui porte sur plusieurs colonnes simultan√©ment. Il permet d'optimiser les requ√™tes qui filtrent ou trient sur plusieurs colonnes √† la fois.

La clause **INCLUDE** (disponible depuis PostgreSQL 11) permet de cr√©er des **covering indexes** : des index qui contiennent des colonnes suppl√©mentaires non utilis√©es pour le tri ou la recherche, mais disponibles pour satisfaire la requ√™te sans acc√©der √† la table.

Ces techniques sont essentielles pour optimiser les requ√™tes complexes et r√©duire les acc√®s disque.

---

## Partie 1 : Index Multi-Colonnes

### Concept Fondamental

**Index simple (sur une seule colonne) :**
```sql
CREATE INDEX idx_nom ON utilisateurs(nom);
```
‚Üí Optimise les requ√™tes sur `nom` uniquement.

**Index multi-colonnes (sur plusieurs colonnes) :**
```sql
CREATE INDEX idx_nom_prenom ON utilisateurs(nom, prenom);
```
‚Üí Optimise les requ√™tes sur :
- `nom` seul
- `nom` ET `prenom`
- Mais **PAS** `prenom` seul (ordre important !)

### Pourquoi Utiliser des Index Multi-Colonnes ?

#### 1. **Requ√™tes avec Plusieurs Filtres**

```sql
-- Sans index multi-colonnes : Deux index s√©par√©s
CREATE INDEX idx_nom ON clients(nom);
CREATE INDEX idx_ville ON clients(ville);

-- Requ√™te : PostgreSQL doit combiner deux index (Bitmap Index Scan) ou scanner un seul index
SELECT * FROM clients WHERE nom = 'Dupont' AND ville = 'Paris';
```

```sql
-- Avec index multi-colonnes : Un seul index optimis√©
CREATE INDEX idx_nom_ville ON clients(nom, ville);

-- Requ√™te : Un seul Index Scan, beaucoup plus rapide !
SELECT * FROM clients WHERE nom = 'Dupont' AND ville = 'Paris';
```

#### 2. **Tri sur Plusieurs Colonnes**

```sql
-- Index multi-colonnes
CREATE INDEX idx_date_montant ON commandes(date_commande, montant);

-- Requ√™te avec tri : Utilise l'index pour √©viter un tri co√ªteux
SELECT * FROM commandes
WHERE date_commande >= '2025-01-01'
ORDER BY date_commande, montant;
```

#### 3. **S√©lectivit√© Progressive**

Un index multi-colonnes agit comme un **annuaire t√©l√©phonique** :
- Tri√© d'abord par **nom de famille**
- Puis par **pr√©nom** pour les personnes avec le m√™me nom

```sql
CREATE INDEX idx_nom_prenom ON personnes(nom, prenom);

-- ‚úÖ Tr√®s efficace : Cherche "Dupont" puis "Jean"
SELECT * FROM personnes WHERE nom = 'Dupont' AND prenom = 'Jean';

-- ‚úÖ Efficace : Cherche tous les "Dupont"
SELECT * FROM personnes WHERE nom = 'Dupont';

-- ‚ùå Peu efficace : Ne peut pas utiliser l'index efficacement
SELECT * FROM personnes WHERE prenom = 'Jean';
```

---

### Syntaxe et Structure

#### Syntaxe de Base

```sql
CREATE INDEX nom_index ON nom_table(colonne1, colonne2, colonne3, ...);
```

#### Limite de Colonnes

PostgreSQL permet jusqu'√† **32 colonnes** dans un index multi-colonnes.

En pratique, **2 √† 4 colonnes** est le plus courant.

#### Ordre des Colonnes : CRUCIAL !

**R√®gle d'or :** L'ordre des colonnes dans l'index d√©termine son efficacit√©.

**Principe de base :**
```sql
CREATE INDEX idx_a_b_c ON table(a, b, c);
```

Peut √™tre utilis√© pour :
- ‚úÖ `WHERE a = ...`
- ‚úÖ `WHERE a = ... AND b = ...`
- ‚úÖ `WHERE a = ... AND b = ... AND c = ...`
- ‚ö†Ô∏è  `WHERE a = ... AND c = ...` (partiellement, ignore `c`)
- ‚ùå `WHERE b = ...` (ne peut pas utiliser l'index)
- ‚ùå `WHERE c = ...` (ne peut pas utiliser l'index)

**Analogie : Annuaire t√©l√©phonique**

Un annuaire est tri√© par :
1. **Nom de famille** (A-Z)
2. **Pr√©nom** (A-Z pour chaque nom)

‚úÖ Facile : Trouver "Dupont Jean"
‚úÖ Facile : Trouver tous les "Dupont"
‚ùå Difficile : Trouver tous les "Jean" (il faut parcourir tout l'annuaire !)

---

### Exemples Pratiques : Index Multi-Colonnes

#### Exemple 1 : Table de Commandes

**Contexte :** E-commerce avec recherches fr√©quentes par client et date.

```sql
-- Table de commandes
CREATE TABLE commandes (
    id SERIAL PRIMARY KEY,
    client_id INTEGER,
    date_commande DATE,
    statut VARCHAR(50),
    montant NUMERIC(10,2)
);

-- Index multi-colonnes : client + date
CREATE INDEX idx_client_date ON commandes(client_id, date_commande DESC);
```

**Requ√™tes optimis√©es :**

```sql
-- ‚úÖ Utilise l'index parfaitement
SELECT * FROM commandes
WHERE client_id = 12345
ORDER BY date_commande DESC;

-- ‚úÖ Utilise l'index (client + date)
SELECT * FROM commandes
WHERE client_id = 12345
AND date_commande >= '2025-01-01';

-- ‚úÖ Utilise l'index (client uniquement)
SELECT * FROM commandes
WHERE client_id = 12345;

-- ‚ùå N'utilise PAS l'index efficacement
SELECT * FROM commandes
WHERE date_commande >= '2025-01-01';
-- Solution : Cr√©er un index s√©par√© sur date_commande
```

#### Exemple 2 : Table d'√âv√©nements (Logs)

**Contexte :** Logs applicatifs avec recherches par niveau et date.

```sql
-- Table de logs
CREATE TABLE logs (
    id BIGSERIAL PRIMARY KEY,
    niveau VARCHAR(20),  -- 'DEBUG', 'INFO', 'WARNING', 'ERROR'
    message TEXT,
    created_at TIMESTAMP
);

-- Strat√©gie : Ordre des colonnes selon s√©lectivit√©
-- niveau : 4 valeurs distinctes (faible s√©lectivit√©)
-- created_at : beaucoup de valeurs (haute s√©lectivit√©)

-- ‚ùå MAUVAIS ordre (moins s√©lectif en premier)
CREATE INDEX idx_bad ON logs(niveau, created_at);
-- Probl√®me : Le niveau filtre peu, l'index est moins efficace

-- ‚úÖ BON ordre (plus s√©lectif en premier)
CREATE INDEX idx_good ON logs(created_at DESC, niveau);
-- Avantage : La date filtre beaucoup, puis on affine par niveau
```

**Analyse des requ√™tes :**

```sql
-- Requ√™te typique : Logs r√©cents + niveau
SELECT * FROM logs
WHERE created_at >= NOW() - INTERVAL '1 hour'
AND niveau = 'ERROR'
ORDER BY created_at DESC;

-- Avec idx_good :
-- 1. Filtre rapidement sur created_at (tr√®s s√©lectif)
-- 2. Puis filtre sur niveau
-- 3. Pas besoin de tri (ORDER BY d√©j√† dans l'index)
```

#### Exemple 3 : Recherche Multi-Crit√®res (Immobilier)

```sql
-- Table de biens immobiliers
CREATE TABLE biens (
    id SERIAL PRIMARY KEY,
    ville VARCHAR(100),
    type VARCHAR(50),      -- 'appartement', 'maison', 'studio'
    prix NUMERIC(10,2),
    surface NUMERIC(6,2),
    nb_pieces INTEGER
);

-- Index multi-colonnes pour recherche typique
CREATE INDEX idx_recherche ON biens(ville, type, prix, surface);
```

**Requ√™tes optimis√©es :**

```sql
-- ‚úÖ Utilise l'index compl√®tement
SELECT * FROM biens
WHERE ville = 'Paris'
AND type = 'appartement'
AND prix BETWEEN 200000 AND 500000
ORDER BY surface DESC;

-- ‚úÖ Utilise l'index (ville + type)
SELECT * FROM biens
WHERE ville = 'Paris'
AND type = 'appartement';

-- ‚ö†Ô∏è Utilise l'index partiellement (ville uniquement)
SELECT * FROM biens
WHERE ville = 'Paris'
AND prix BETWEEN 200000 AND 500000;
-- Note : Saute 'type', donc n'utilise pas 'prix' efficacement

-- ‚ùå N'utilise PAS l'index efficacement
SELECT * FROM biens
WHERE type = 'appartement';
-- type est en 2e position, ne peut pas utiliser l'index sans ville
```

---

### Choisir l'Ordre des Colonnes

#### R√®gle 1 : S√©lectivit√© (R√®gle G√©n√©rale)

**Placez les colonnes les plus s√©lectives en premier.**

**S√©lectivit√© = Nombre de valeurs distinctes / Nombre total de lignes**

```sql
-- Exemple : Table de 1 000 000 de lignes

-- Colonne 'pays' : 5 valeurs distinctes (FR, US, UK, DE, ES)
-- S√©lectivit√© = 5 / 1,000,000 = 0.000005 (faible)

-- Colonne 'email' : 980,000 valeurs distinctes (presque uniques)
-- S√©lectivit√© = 980,000 / 1,000,000 = 0.98 (haute)

-- ‚úÖ BON : Colonne tr√®s s√©lective en premier
CREATE INDEX idx_good ON table(email, pays);

-- ‚ùå MAUVAIS : Colonne peu s√©lective en premier
CREATE INDEX idx_bad ON table(pays, email);
```

#### R√®gle 2 : Fr√©quence d'Utilisation dans les Requ√™tes

**Si une colonne est toujours utilis√©e dans les requ√™tes, placez-la en premier.**

```sql
-- Si 90% des requ√™tes filtrent par client_id
-- Et seulement 20% ajoutent un filtre sur statut

-- ‚úÖ BON : Colonne la plus utilis√©e en premier
CREATE INDEX idx ON commandes(client_id, statut);
```

#### R√®gle 3 : √âgalit√© vs Plage

**Colonnes avec √©galit√© (=) avant colonnes avec plage (>, <, BETWEEN).**

```sql
-- Requ√™te typique
SELECT * FROM transactions
WHERE type_compte = 'courant'        -- √âgalit√©
AND montant > 1000                   -- Plage
AND date_transaction >= '2025-01-01'; -- Plage

-- ‚úÖ BON : √âgalit√© en premier
CREATE INDEX idx ON transactions(type_compte, date_transaction, montant);

-- Explication : PostgreSQL utilise l'√©galit√© efficacement,
-- puis peut parcourir les plages de mani√®re ordonn√©e
```

#### R√®gle 4 : Exceptions et Cas Particuliers

Parfois, il faut **privil√©gier la fr√©quence** sur la s√©lectivit√© :

```sql
-- Cas : 99% des requ√™tes filtrent par statut = 'actif' (peu s√©lectif)
-- Et seulement 1% ajoutent un filtre sur email (tr√®s s√©lectif)

-- ‚úÖ BON pour ce cas : Colonne la plus fr√©quente en premier
CREATE INDEX idx ON table(statut, email);

-- Alternative : Index partiel
CREATE INDEX idx ON table(email) WHERE statut = 'actif';
```

---

### Strat√©gies Avanc√©es

#### 1. Index Multi-Colonnes avec Tri

```sql
-- Index pour tri sur plusieurs colonnes
CREATE INDEX idx_tri ON produits(categorie, prix DESC, nom);

-- Requ√™te : Pas de tri co√ªteux, utilise l'index directement
SELECT * FROM produits
WHERE categorie = 'Electronique'
ORDER BY prix DESC, nom;
```

#### 2. Index Multi-Colonnes avec Expression

```sql
-- Combiner multi-colonnes + expression
CREATE INDEX idx_combo ON utilisateurs(pays, (LOWER(email)));

-- Requ√™te optimis√©e
SELECT * FROM utilisateurs
WHERE pays = 'FR'
AND LOWER(email) = 'test@example.com';
```

#### 3. Index Multi-Colonnes Partiel

```sql
-- Combiner multi-colonnes + partiel
CREATE INDEX idx_actifs ON commandes(client_id, date_commande)
WHERE statut IN ('en_cours', 'en_preparation');

-- Tr√®s efficace pour requ√™tes cibl√©es
SELECT * FROM commandes
WHERE client_id = 12345
AND statut = 'en_cours'
ORDER BY date_commande DESC;
```

---

## Partie 2 : INCLUDE et Covering Index

### Qu'est-ce qu'un Covering Index ?

Un **covering index** (index couvrant) est un index qui contient **toutes les colonnes** n√©cessaires pour satisfaire une requ√™te, sans avoir besoin d'acc√©der √† la table principale.

**Avantage majeur :** √âvite l'acc√®s √† la table (Heap Fetch), ce qui r√©duit drastiquement les I/O.

### Index Sans INCLUDE (Comportement Classique)

```sql
-- Index classique sur client_id
CREATE INDEX idx_client ON commandes(client_id);

-- Requ√™te
SELECT client_id, montant FROM commandes WHERE client_id = 12345;
```

**Plan d'ex√©cution :**
```
Index Scan using idx_client on commandes
  Index Cond: (client_id = 12345)
  ‚Üí Heap Fetches: 150   ‚Üê Acc√®s √† la table pour r√©cup√©rer 'montant'
```

**Probl√®me :** PostgreSQL doit acc√©der √† la table pour lire la colonne `montant`.

### Index Avec INCLUDE (Covering Index)

```sql
-- Covering index : inclut 'montant' sans l'utiliser pour l'indexation
CREATE INDEX idx_client_include_montant
ON commandes(client_id)
INCLUDE (montant);

-- M√™me requ√™te
SELECT client_id, montant FROM commandes WHERE client_id = 12345;
```

**Plan d'ex√©cution :**
```
Index Only Scan using idx_client_include_montant on commandes
  Index Cond: (client_id = 12345)
  ‚Üí Heap Fetches: 0   ‚Üê Aucun acc√®s √† la table !
```

**Avantage :** Toutes les donn√©es sont dans l'index, pas besoin d'acc√©der √† la table.

---

### Syntaxe INCLUDE

```sql
CREATE INDEX nom_index
ON nom_table(colonnes_index√©es)
INCLUDE (colonnes_couvertes);
```

**Param√®tres :**
- **colonnes_index√©es** : Colonnes utilis√©es pour le tri, la recherche et le filtrage
- **colonnes_couvertes** : Colonnes suppl√©mentaires stock√©es dans l'index, mais pas utilis√©es pour l'indexation

### Diff√©rence Cl√© : Index vs INCLUDE

```sql
-- Option 1 : Index multi-colonnes classique
CREATE INDEX idx_classic ON table(col1, col2, col3);

-- Option 2 : Index avec INCLUDE
CREATE INDEX idx_include ON table(col1, col2) INCLUDE (col3);
```

**Diff√©rences :**

| Crit√®re | Index Multi-Colonnes | Index avec INCLUDE |
|---------|----------------------|---------------------|
| **Taille de l'index** | Plus grand (col3 participe √† l'arbre B-Tree) | Plus petit (col3 seulement en feuilles) |
| **Utilisation pour recherche** | col3 peut √™tre utilis√©e pour filtrer | col3 ne peut PAS √™tre utilis√©e pour filtrer |
| **Utilisation pour tri** | col3 peut √™tre utilis√©e pour trier | col3 ne peut PAS √™tre utilis√©e pour trier |
| **Covering queries** | Oui (si toutes colonnes SELECT sont index√©es) | Oui (colonnes INCLUDE disponibles) |
| **Performance** | Peut √™tre moins efficace (arbre plus profond) | Plus efficace (arbre plus compact) |

---

### Exemples Pratiques : INCLUDE

#### Exemple 1 : Table de Commandes (Optimisation SELECT)

```sql
-- Table de commandes
CREATE TABLE commandes (
    id SERIAL PRIMARY KEY,
    client_id INTEGER,
    date_commande DATE,
    statut VARCHAR(50),
    montant NUMERIC(10,2),
    note TEXT
);

-- Requ√™te fr√©quente : Lister commandes d'un client avec montant
-- Sans INCLUDE
CREATE INDEX idx_client ON commandes(client_id);

EXPLAIN (ANALYZE, BUFFERS)
SELECT client_id, date_commande, montant
FROM commandes
WHERE client_id = 12345;

-- R√©sultat :
-- Index Scan using idx_client on commandes
--   Index Cond: (client_id = 12345)
--   Heap Fetches: 150  ‚Üê Acc√®s table pour date_commande et montant
--   Buffers: shared hit=350
```

```sql
-- Avec INCLUDE : Covering index
CREATE INDEX idx_client_covering
ON commandes(client_id)
INCLUDE (date_commande, montant);

EXPLAIN (ANALYZE, BUFFERS)
SELECT client_id, date_commande, montant
FROM commandes
WHERE client_id = 12345;

-- R√©sultat :
-- Index Only Scan using idx_client_covering on commandes
--   Index Cond: (client_id = 12345)
--   Heap Fetches: 0  ‚Üê Aucun acc√®s table !
--   Buffers: shared hit=8  ‚Üê 40√ó moins de buffers !
```

**Gains :**
- **Heap Fetches : 150 ‚Üí 0**
- **Buffers : 350 ‚Üí 8** (44√ó moins d'I/O)
- **Performance : 3-10√ó plus rapide**

#### Exemple 2 : Recherche avec Agr√©gation

```sql
-- Requ√™te : Somme des montants par client
SELECT client_id, SUM(montant)
FROM commandes
GROUP BY client_id;

-- Sans INCLUDE : Doit acc√©der √† la table pour 'montant'
CREATE INDEX idx_client ON commandes(client_id);
-- R√©sultat : Index Scan + Heap Fetches (lent)

-- Avec INCLUDE : Tout dans l'index
CREATE INDEX idx_client_covering
ON commandes(client_id)
INCLUDE (montant);
-- R√©sultat : Index Only Scan (rapide !)
```

#### Exemple 3 : Tri + S√©lection de Colonnes

```sql
-- Table de produits
CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    categorie VARCHAR(100),
    nom VARCHAR(200),
    prix NUMERIC(10,2),
    stock INTEGER
);

-- Requ√™te : Top 10 produits par cat√©gorie
SELECT nom, prix
FROM produits
WHERE categorie = 'Electronique'
ORDER BY prix DESC
LIMIT 10;

-- Covering index parfait
CREATE INDEX idx_cat_prix_covering
ON produits(categorie, prix DESC)
INCLUDE (nom);

-- R√©sultat :
-- Index Only Scan using idx_cat_prix_covering
--   Index Cond: (categorie = 'Electronique'::text)
--   Heap Fetches: 0
-- Tout dans l'index : filtrage, tri, colonnes SELECT !
```

#### Exemple 4 : Jointure Optimis√©e

```sql
-- Table de d√©tails de commandes
CREATE TABLE details_commandes (
    id SERIAL PRIMARY KEY,
    commande_id INTEGER,
    produit_id INTEGER,
    quantite INTEGER,
    prix_unitaire NUMERIC(10,2)
);

-- Requ√™te fr√©quente : D√©tails d'une commande
SELECT produit_id, quantite, prix_unitaire
FROM details_commandes
WHERE commande_id = 12345;

-- Covering index
CREATE INDEX idx_commande_covering
ON details_commandes(commande_id)
INCLUDE (produit_id, quantite, prix_unitaire);

-- Index Only Scan : Toutes les donn√©es dans l'index
```

---

### Quand Utiliser INCLUDE ?

#### ‚úÖ Utilisez INCLUDE Si :

1. **Requ√™tes SELECT avec peu de colonnes**
   ```sql
   -- Typique : SELECT 3-5 colonnes, WHERE sur 1-2 colonnes
   SELECT col1, col2, col3, col4
   FROM table
   WHERE indexed_col = value;
   ```

2. **Colonnes de faible cardinalit√© dans SELECT**
   ```sql
   -- Inclure des colonnes simples : nombres, dates, textes courts
   INCLUDE (montant, date, statut)
   ```

3. **Requ√™tes fr√©quentes et critiques**
   - R√©duction des I/O importante
   - Impact sur performance significatif

4. **Index d√©j√† s√©lectif**
   ```sql
   -- Bon candidat : client_id tr√®s s√©lectif
   CREATE INDEX idx ON commandes(client_id) INCLUDE (montant, date);
   ```

#### ‚ùå N'Utilisez PAS INCLUDE Si :

1. **Colonnes tr√®s volumineuses**
   ```sql
   -- ‚ùå MAUVAIS : TEXT ou BYTEA volumineux
   CREATE INDEX idx ON table(id) INCLUDE (description_longue);
   -- Probl√®me : Index gigantesque, contre-productif
   ```

2. **Toutes les colonnes de la table**
   ```sql
   -- ‚ùå MAUVAIS : Dupliquer toute la table dans l'index
   CREATE INDEX idx ON table(id) INCLUDE (col1, col2, ..., col50);
   -- Probl√®me : Index aussi volumineux que la table !
   ```

3. **Colonnes utilis√©es pour filtrage ou tri**
   ```sql
   -- ‚ùå MAUVAIS : 'prix' utilis√© dans WHERE et ORDER BY
   CREATE INDEX idx ON produits(categorie) INCLUDE (prix);
   SELECT * FROM produits WHERE categorie = 'X' AND prix > 100 ORDER BY prix;

   -- ‚úÖ BON : 'prix' dans l'index multi-colonnes
   CREATE INDEX idx ON produits(categorie, prix);
   ```

4. **Requ√™tes vari√©es sans pattern clair**
   - Si chaque requ√™te SELECT des colonnes diff√©rentes, INCLUDE n'aide pas

---

### INCLUDE : Aspects Techniques

#### 1. Structure Interne

**Index B-Tree classique :**
```
N≈ìuds internes : contiennent (col1, col2, pointeur)
Feuilles : contiennent (col1, col2, pointeur vers heap)
```

**Index B-Tree avec INCLUDE :**
```
N≈ìuds internes : contiennent (col1, col2, pointeur)  ‚Üê INCLUDE absent
Feuilles : contiennent (col1, col2, col_include, pointeur vers heap)  ‚Üê INCLUDE pr√©sent
```

**Cons√©quence :** L'arbre est plus compact (n≈ìuds internes plus petits), donc :
- Moins de niveaux dans l'arbre
- Parcours plus rapide
- Meilleur taux de cache

#### 2. Taille de l'Index

```sql
-- Comparer les tailles
-- Option 1 : Multi-colonnes classique
CREATE INDEX idx_multi ON table(a, b, c, d);

-- Option 2 : Avec INCLUDE
CREATE INDEX idx_include ON table(a, b) INCLUDE (c, d);

-- V√©rifier la taille
SELECT
    pg_size_pretty(pg_relation_size('idx_multi')) AS "Multi-colonnes",
    pg_size_pretty(pg_relation_size('idx_include')) AS "Avec INCLUDE";
```

**R√©sultat typique :**
- Multi-colonnes : 150 MB
- Avec INCLUDE : 120 MB (20% plus petit)

#### 3. Maintenance (Vacuum, Insert, Update)

**INCLUDE n'augmente pas significativement le co√ªt de maintenance**, car :
- Les colonnes INCLUDE ne sont que dans les feuilles
- Moins d'impact sur la structure de l'arbre

```sql
-- Impact INSERT/UPDATE similaire entre :
CREATE INDEX idx1 ON table(a, b) INCLUDE (c);
-- Et :
CREATE INDEX idx2 ON table(a, b, c);
```

---

### Index Only Scan : Conditions de Succ√®s

Pour qu'un **Index Only Scan** (scan uniquement sur index) soit efficace, deux conditions :

#### 1. Toutes les Colonnes Doivent √ätre dans l'Index

```sql
CREATE INDEX idx ON table(col1) INCLUDE (col2, col3);

-- ‚úÖ Index Only Scan
SELECT col1, col2, col3 FROM table WHERE col1 = value;

-- ‚ùå Index Scan + Heap Fetch (col4 pas dans l'index)
SELECT col1, col2, col3, col4 FROM table WHERE col1 = value;
```

#### 2. Visibility Map Doit √ätre √Ä Jour (VACUUM)

PostgreSQL utilise une **Visibility Map** pour savoir quelles pages sont visibles sans v√©rifier le heap.

```sql
-- Si la table n'a pas √©t√© VACUUM r√©cemment :
EXPLAIN (ANALYZE, BUFFERS)
SELECT col1, col2 FROM table WHERE col1 = value;

-- R√©sultat :
-- Index Only Scan using idx on table
--   Heap Fetches: 500  ‚Üê Doit quand m√™me v√©rifier la visibilit√© !
```

**Solution : VACUUM r√©gulier**
```sql
VACUUM table;
-- Ou mieux : Autovacuum configur√© correctement
```

**Apr√®s VACUUM :**
```
Index Only Scan using idx on table
  Heap Fetches: 0  ‚Üê Parfait !
```

---

## Combinaisons Avanc√©es

### 1. Multi-Colonnes + INCLUDE + Partiel

```sql
-- L'index ultime : Toutes les techniques combin√©es !
CREATE INDEX idx_ultimate
ON commandes(client_id, date_commande DESC)
INCLUDE (montant, statut)
WHERE date_commande >= '2025-01-01';

-- Requ√™te parfaitement optimis√©e
SELECT client_id, date_commande, montant, statut
FROM commandes
WHERE client_id = 12345
AND date_commande >= '2025-01-01'
ORDER BY date_commande DESC;

-- R√©sultat :
-- Index Only Scan using idx_ultimate
--   Index Cond: (client_id = 12345) AND (date_commande >= '2025-01-01')
--   Heap Fetches: 0
-- Tout est parfait : filtrage, tri, covering, index compact !
```

### 2. Expression + INCLUDE

```sql
-- Index sur expression avec INCLUDE
CREATE INDEX idx_email_data
ON utilisateurs((LOWER(email)))
INCLUDE (nom, prenom, date_inscription);

-- Requ√™te couverte
SELECT nom, prenom, date_inscription
FROM utilisateurs
WHERE LOWER(email) = 'test@example.com';

-- Index Only Scan !
```

### 3. Index UNIQUE avec INCLUDE

```sql
-- UNIQUE index avec colonnes suppl√©mentaires
CREATE UNIQUE INDEX idx_email_unique
ON utilisateurs(email)
INCLUDE (nom, date_inscription);

-- Garantit unicit√© de 'email'
-- ET permet des covering queries
SELECT nom, date_inscription
FROM utilisateurs
WHERE email = 'test@example.com';
```

---

## Strat√©gies de Conception

### M√©thodologie : Analyser les Requ√™tes

**√âtape 1 : Identifier les requ√™tes fr√©quentes**
```sql
-- Utiliser pg_stat_statements
SELECT
    query,
    calls,
    total_exec_time / calls AS avg_time_ms
FROM pg_stat_statements
ORDER BY calls DESC
LIMIT 20;
```

**√âtape 2 : Analyser avec EXPLAIN**
```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT col1, col2, col3
FROM table
WHERE indexed_col = value;
```

**√âtape 3 : Identifier les opportunit√©s**

Cherchez :
- **Seq Scan** ‚Üí Besoin d'index
- **Index Scan + Heap Fetches** ‚Üí Candidat INCLUDE
- **Sort** co√ªteux ‚Üí Index multi-colonnes avec tri

**√âtape 4 : Cr√©er l'index optimis√©**

```sql
-- Exemple de transformation
-- Avant : Index simple
CREATE INDEX idx_old ON table(col1);
-- Heap Fetches: 1000, Buffers: 2500

-- Apr√®s : Index avec INCLUDE
CREATE INDEX idx_new ON table(col1) INCLUDE (col2, col3);
-- Heap Fetches: 0, Buffers: 150
-- 16√ó moins d'I/O !
```

**√âtape 5 : Mesurer l'impact**

```sql
-- Comparer avant/apr√®s
EXPLAIN (ANALYZE, BUFFERS)
SELECT ...;

-- V√©rifier l'utilisation
SELECT * FROM pg_stat_user_indexes
WHERE indexname = 'idx_new';
```

---

## Maintenance et Monitoring

### Lister les Index avec INCLUDE

```sql
SELECT
    schemaname,
    tablename,
    indexname,
    indexdef
FROM pg_indexes
WHERE indexdef LIKE '%INCLUDE%'
ORDER BY tablename, indexname;
```

### Analyser l'Efficacit√©

```sql
-- Requ√™te pour analyser les covering index
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan AS "Utilisations",
    pg_size_pretty(pg_relation_size(indexrelid)) AS "Taille",
    idx_tup_read AS "Tuples lus",
    idx_tup_fetch AS "Tuples r√©cup√©r√©s",
    ROUND(100.0 * idx_tup_fetch / NULLIF(idx_tup_read, 0), 2) AS "% Fetch"
FROM pg_stat_user_indexes
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY idx_scan DESC;
```

**Interpr√©tation :**
- **% Fetch proche de 0%** : Excellent ! Index Only Scan efficace
- **% Fetch > 80%** : Index peu couvrant, consid√©rer INCLUDE

### Identifier les Index Surdimensionn√©s

```sql
-- Index trop volumineux (> 1 GB) avec peu d'utilisation
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS "Taille",
    idx_scan AS "Utilisations"
FROM pg_stat_user_indexes
WHERE pg_relation_size(indexrelid) > 1073741824  -- 1 GB
AND idx_scan < 100
ORDER BY pg_relation_size(indexrelid) DESC;
```

---

## Pi√®ges et Limitations

### ‚ùå Pi√®ge 1 : INCLUDE avec Colonnes Volumineuses

```sql
-- ‚ùå MAUVAIS : INCLUDE sur colonne TEXT tr√®s volumineuse
CREATE INDEX idx_bad ON articles(categorie)
INCLUDE (contenu_complet);
-- Probl√®me : Index gigantesque (plusieurs Go), contre-productif

-- ‚úÖ BON : INCLUDE sur colonnes compactes uniquement
CREATE INDEX idx_good ON articles(categorie)
INCLUDE (titre, date_publication, nb_vues);
```

**R√®gle :** INCLUDE seulement des colonnes **< 100 octets** par ligne.

### ‚ùå Pi√®ge 2 : Ordre Incorrect dans Index Multi-Colonnes

```sql
-- Table : 1M de commandes
-- Requ√™te fr√©quente :
SELECT * FROM commandes
WHERE client_id = X AND statut = 'livree';

-- ‚ùå MAUVAIS ordre
CREATE INDEX idx_bad ON commandes(statut, client_id);
-- statut: 5 valeurs ‚Üí filtre mal
-- client_id: 50K valeurs ‚Üí tr√®s s√©lectif

-- ‚úÖ BON ordre
CREATE INDEX idx_good ON commandes(client_id, statut);
-- client_id en premier : filtrage efficace imm√©diat
```

### ‚ùå Pi√®ge 3 : INCLUDE au Lieu de Multi-Colonnes

```sql
-- Requ√™te avec filtrage sur 'prix'
SELECT nom, prix FROM produits
WHERE categorie = 'X' AND prix > 100;

-- ‚ùå MAUVAIS : 'prix' dans INCLUDE, ne peut pas filtrer
CREATE INDEX idx_bad ON produits(categorie) INCLUDE (prix, nom);

-- ‚úÖ BON : 'prix' dans index multi-colonnes
CREATE INDEX idx_good ON produits(categorie, prix) INCLUDE (nom);
```

**R√®gle :** Colonne utilis√©e dans WHERE, ORDER BY, ou JOIN ‚Üí **index**, pas INCLUDE.

### ‚ùå Pi√®ge 4 : Trop d'Index Couvrants

```sql
-- ‚ùå Cr√©er un index covering pour chaque requ√™te
CREATE INDEX idx1 ON table(a) INCLUDE (b, c);
CREATE INDEX idx2 ON table(a) INCLUDE (b, d);
CREATE INDEX idx3 ON table(a) INCLUDE (c, d);
-- Probl√®me : Maintenance co√ªteuse (3 index sur 'a')

-- ‚úÖ Compromis : Un index multi-colonnes + INCLUDE
CREATE INDEX idx ON table(a, b) INCLUDE (c, d);
-- Couvre plusieurs types de requ√™tes
```

### ‚ùå Pi√®ge 5 : Oublier VACUUM

```sql
CREATE INDEX idx ON table(col) INCLUDE (col2);

-- Sans VACUUM r√©cent
EXPLAIN ANALYZE SELECT col, col2 FROM table WHERE col = X;
-- Index Only Scan
-- Heap Fetches: 500  ‚Üê Doit v√©rifier la visibilit√© !

-- Apr√®s VACUUM
VACUUM table;
EXPLAIN ANALYZE SELECT col, col2 FROM table WHERE col = X;
-- Index Only Scan
-- Heap Fetches: 0  ‚Üê Parfait !
```

---

## Bonnes Pratiques

### ‚úÖ DO (√Ä Faire)

1. **Analyser les requ√™tes avant de cr√©er des index**
   ```sql
   -- Utiliser pg_stat_statements
   -- Identifier les Heap Fetches √©lev√©s
   EXPLAIN (ANALYZE, BUFFERS) SELECT ...;
   ```

2. **INCLUDE pour colonnes l√©g√®res uniquement**
   ```sql
   -- ‚úÖ Colonnes compactes
   INCLUDE (id, prix, date, statut)

   -- ‚ùå Colonnes volumineuses
   INCLUDE (description_longue, image_blob)
   ```

3. **Ordre des colonnes selon s√©lectivit√© + fr√©quence**
   ```sql
   -- Analyser la cardinalit√©
   SELECT
       COUNT(DISTINCT col1) AS card_col1,
       COUNT(DISTINCT col2) AS card_col2
   FROM table;
   ```

4. **Tester l'impact avec EXPLAIN**
   ```sql
   -- Avant
   EXPLAIN (ANALYZE, BUFFERS) SELECT ...;
   -- Cr√©er index
   -- Apr√®s
   EXPLAIN (ANALYZE, BUFFERS) SELECT ...;
   -- Comparer les m√©triques
   ```

5. **Documenter les index complexes**
   ```sql
   COMMENT ON INDEX idx_covering IS
   'Covering index pour requ√™te fr√©quente client + commandes r√©centes.
   R√©duit Heap Fetches de 1500 √† 0 (10√ó plus rapide).';
   ```

6. **VACUUM r√©gulier pour Index Only Scan efficace**
   ```sql
   -- Configuration autovacuum
   ALTER TABLE table SET (
       autovacuum_vacuum_scale_factor = 0.05,
       autovacuum_analyze_scale_factor = 0.02
   );
   ```

### ‚ùå DON'T (√Ä √âviter)

1. **Ne pas cr√©er d'index couvrants pour toutes les requ√™tes**
   - Limite : 2-3 index par table en moyenne

2. **Ne pas INCLUDE des colonnes d√©j√† dans l'index**
   ```sql
   -- ‚ùå Redondant
   CREATE INDEX idx ON table(a, b) INCLUDE (a, b, c);

   -- ‚úÖ Correct
   CREATE INDEX idx ON table(a, b) INCLUDE (c);
   ```

3. **Ne pas oublier de v√©rifier l'utilisation r√©elle**
   ```sql
   -- Index cr√©√© mais jamais utilis√© ?
   SELECT * FROM pg_stat_user_indexes
   WHERE indexname = 'idx_name' AND idx_scan = 0;
   ```

4. **Ne pas cr√©er des index multi-colonnes avec mauvais ordre**
   - Toujours tester avec EXPLAIN

---

## R√©sum√©

### Points Cl√©s

#### Index Multi-Colonnes

1. **Index sur plusieurs colonnes simultan√©ment**
   ```sql
   CREATE INDEX idx ON table(col1, col2, col3);
   ```

2. **L'ordre des colonnes est CRUCIAL**
   - Utilisable pour : `col1`, `col1+col2`, `col1+col2+col3`
   - Pas utilisable pour : `col2`, `col3`, `col2+col3`

3. **R√®gles d'ordre :**
   - S√©lectivit√© (haute ‚Üí basse)
   - Fr√©quence d'utilisation
   - √âgalit√© avant plages

4. **Limite pratique : 2-4 colonnes**

#### Clause INCLUDE (Covering Index)

1. **Colonnes suppl√©mentaires dans les feuilles uniquement**
   ```sql
   CREATE INDEX idx ON table(indexed_cols) INCLUDE (covered_cols);
   ```

2. **Avantages :**
   - Index Only Scan (pas de Heap Fetch)
   - R√©duction drastique des I/O (3-10√ó)
   - Index plus compact

3. **Utilisations :**
   - Colonnes dans SELECT mais pas WHERE/ORDER BY
   - Colonnes l√©g√®res (< 100 octets)
   - Requ√™tes fr√©quentes

4. **Condition : VACUUM r√©gulier pour Index Only Scan efficace**

#### Combinaisons

- Multi-colonnes + INCLUDE + Partiel + Expression
- **L'index ultime** pour optimisation maximale

---

## Pour Aller Plus Loin

### Lectures Recommand√©es

- **Documentation PostgreSQL :**
  - [Multicolumn Indexes](https://www.postgresql.org/docs/current/indexes-multicolumn.html)
  - [Index-Only Scans and Covering Indexes](https://www.postgresql.org/docs/current/indexes-index-only-scans.html)

- **Livres :**
  - "PostgreSQL Query Optimization" - Chapter on Indexing Strategies
  - "The Art of PostgreSQL" - Advanced Indexing

### Prochaines √âtapes

Apr√®s avoir ma√Ætris√© les index multi-colonnes et INCLUDE, explorez :
- **13.5.4. Index sur colonnes JSONB** - GIN avec jsonb_path_ops
- **13.6. Le planificateur de requ√™tes** - Comment PostgreSQL choisit les index
- **13.7. Lecture et analyse d'un EXPLAIN** - Optimisation avanc√©e

### Outils Pratiques

- **pg_stat_statements** - Analyser les requ√™tes fr√©quentes
- **HypoPG** - Tester des index hypoth√©tiques sans les cr√©er
- **pg_qualstats** - Statistiques sur les pr√©dicats WHERE
- **pgBadger** - Analyse de logs et requ√™tes lentes

---


‚è≠Ô∏è [Index sur colonnes JSONB (GIN avec jsonb_path_ops)](/13-indexation-et-optimisation/05.4-index-sur-colonnes-jsonb.md)
