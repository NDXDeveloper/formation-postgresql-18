üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.4.3. BRIN (Block Range Index) : Donn√©es s√©quentielles massives

## Introduction

Les index BRIN (Block Range Index) sont un type d'index r√©volutionnaire introduit dans PostgreSQL 9.5, con√ßu pour g√©rer **d'√©normes volumes de donn√©es** avec une empreinte m√©moire minimale. Contrairement aux index classiques qui indexent chaque ligne, BRIN indexe des **plages de blocs**, ce qui rend l'index extr√™mement compact.

### L'analogie du livre et des chapitres

Imaginez un livre :
- **Index B-Tree** : C'est comme un index d√©taill√© qui liste chaque mot et sa page exacte (pr√©cis mais volumineux)
- **Index BRIN** : C'est comme une table des mati√®res qui indique "le chapitre 1 couvre les pages 1-50 et parle de l'introduction" (compact mais moins pr√©cis)

### Principe de fonctionnement

BRIN ne stocke pas l'emplacement exact de chaque valeur, mais r√©sume le contenu de **groupes de pages** (appel√©s "ranges") :

```
Table de 1 million de lignes (ordonn√©es par date) :

Bloc 0-127   : dates entre 2024-01-01 et 2024-01-15
Bloc 128-255 : dates entre 2024-01-16 et 2024-01-31
Bloc 256-383 : dates entre 2024-02-01 et 2024-02-15
...

Index BRIN (seulement 3 entr√©es pour 1 million de lignes !) :
- Range 1 (blocs 0-127)   : min=2024-01-01, max=2024-01-15
- Range 2 (blocs 128-255) : min=2024-01-16, max=2024-01-31
- Range 3 (blocs 256-383) : min=2024-02-01, max=2024-02-15
```

### Quand utiliser BRIN ?

‚úÖ **Parfait pour :**
- Tables **tr√®s volumineuses** (plusieurs Go √† plusieurs To)
- Donn√©es **naturellement ordonn√©es** (dates, s√©quences, timestamps)
- Colonnes avec **forte corr√©lation physique** (les valeurs similaires sont stock√©es ensemble)
- Donn√©es **append-only** (insertion en fin de table)
- **Data warehouses** et **logs**

‚ùå **√Ä √©viter pour :**
- Petites tables (< 1 Go)
- Donn√©es **al√©atoires** ou **d√©sordonn√©es**
- Besoin de pr√©cision exacte rapide
- Mises √† jour fr√©quentes qui d√©sordonnent les donn√©es

### Avantages spectaculaires

- ‚úÖ **Taille minuscule** : Un index BRIN peut √™tre 1000√ó plus petit qu'un B-Tree
- ‚úÖ **Maintenance l√©g√®re** : Mise √† jour tr√®s rapide
- ‚úÖ **Parfait pour time-series** : Logs, m√©triques, √©v√©nements
- ‚úÖ **√âconomie d'espace** : Lib√®re de la RAM et du disque
- ‚úÖ **Scan rapide** : √âlimine rapidement les blocs non pertinents

### Limitations importantes

- ‚ö†Ô∏è **N√©cessite l'ordre physique** : Les donn√©es doivent √™tre ordonn√©es sur le disque
- ‚ö†Ô∏è **Moins pr√©cis** : Peut scanner plus de blocs que n√©cessaire
- ‚ö†Ô∏è **Pas pour tout** : Inefficace sur donn√©es d√©sordonn√©es
- ‚ö†Ô∏è **Maintenance manuelle** : Peut n√©cessiter des r√©organisations (`CLUSTER`)

---

## 1. Comprendre la Corr√©lation Physique

### Qu'est-ce que la corr√©lation physique ?

La **corr√©lation physique** mesure √† quel point l'ordre logique des donn√©es correspond √† leur ordre physique sur le disque. C'est **LE crit√®re crucial** pour l'efficacit√© d'un index BRIN.

### Visualisation de la corr√©lation

#### ‚úÖ Corr√©lation √©lev√©e (BRIN excellent)
```
Ordre logique :  1  2  3  4  5  6  7  8  9  10
Ordre physique : 1  2  3  4  5  6  7  8  9  10
Corr√©lation : +1.0 (parfait !)

Les donn√©es sont stock√©es dans l'ordre ‚Üí BRIN tr√®s efficace
```

#### ‚ùå Corr√©lation faible (BRIN inefficace)
```
Ordre logique :  1  2  3  4  5  6  7  8  9  10
Ordre physique : 5  2  9  1  7  3  10 6  4  8
Corr√©lation : 0.1 (al√©atoire)

Les donn√©es sont m√©lang√©es ‚Üí BRIN inutile, B-Tree pr√©f√©rable
```

### Mesurer la corr√©lation dans PostgreSQL

```sql
-- V√©rifier la corr√©lation d'une colonne
SELECT
    tablename,
    attname AS colonne,
    correlation
FROM pg_stats
WHERE tablename = 'ma_table'
  AND attname = 'ma_colonne';

-- Interpr√©tation :
-- correlation proche de +1.0 ou -1.0 ‚Üí EXCELLENT pour BRIN
-- correlation proche de 0 ‚Üí MAUVAIS pour BRIN, utilisez B-Tree
```

### Exemple pratique

```sql
-- Cr√©er une table avec des timestamps ordonn√©s
CREATE TABLE logs_ordonnees (
    id BIGSERIAL PRIMARY KEY,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    niveau TEXT,
    message TEXT
);

-- Ins√©rer des donn√©es dans l'ordre chronologique
INSERT INTO logs_ordonnees (niveau, message)
SELECT
    (ARRAY['INFO', 'WARN', 'ERROR'])[floor(random() * 3 + 1)],
    'Message ' || generate_series
FROM generate_series(1, 1000000);

-- Analyser pour obtenir les statistiques
ANALYZE logs_ordonnees;

-- V√©rifier la corr√©lation
SELECT attname, correlation
FROM pg_stats
WHERE tablename = 'logs_ordonnees' AND attname = 'timestamp';

-- R√©sultat attendu : correlation ‚âà 1.0
```

---

## 2. Cr√©ation et Syntaxe des Index BRIN

### Syntaxe de base

```sql
CREATE INDEX nom_index ON table USING BRIN (colonne);
```

### Cr√©ation d'un index BRIN simple

```sql
-- Table de logs massifs
CREATE TABLE logs_application (
    id BIGSERIAL PRIMARY KEY,
    timestamp TIMESTAMPTZ NOT NULL,
    user_id INTEGER,
    action TEXT,
    ip_address INET,
    response_time INTEGER
);

-- Ins√©rer 10 millions de lignes ordonn√©es par timestamp
INSERT INTO logs_application (timestamp, user_id, action, response_time)
SELECT
    NOW() - (generate_series * INTERVAL '1 second'),
    floor(random() * 10000)::INTEGER,
    (ARRAY['login', 'logout', 'view', 'create', 'update', 'delete'])[floor(random() * 6 + 1)],
    floor(random() * 500)::INTEGER
FROM generate_series(1, 10000000);

-- Cr√©er un index BRIN sur la colonne timestamp
CREATE INDEX idx_logs_timestamp_brin ON logs_application USING BRIN (timestamp);

-- Analyser la table
ANALYZE logs_application;
```

### Configuration : le param√®tre pages_per_range

Le param√®tre `pages_per_range` d√©finit combien de pages (blocs) sont r√©sum√©es par une seule entr√©e d'index.

```sql
-- Par d√©faut : 128 pages par range
CREATE INDEX idx_logs_default ON logs_application USING BRIN (timestamp);

-- Index plus compact (plus de pages par range = index plus petit mais moins pr√©cis)
CREATE INDEX idx_logs_compact ON logs_application
USING BRIN (timestamp) WITH (pages_per_range = 256);

-- Index plus pr√©cis (moins de pages par range = index plus gros mais plus pr√©cis)
CREATE INDEX idx_logs_precise ON logs_application
USING BRIN (timestamp) WITH (pages_per_range = 64);
```

#### Choisir pages_per_range

| Valeur | Taille Index | Pr√©cision | Cas d'usage |
|--------|--------------|-----------|-------------|
| 32-64 | Plus gros | Haute | Donn√©es tr√®s vari√©es dans chaque range |
| 128 (d√©faut) | √âquilibr√© | Moyenne | Usage g√©n√©ral recommand√© |
| 256-512 | Tr√®s compact | Faible | Tables massives, donn√©es tr√®s ordonn√©es |

### Formule pour estimer la taille

```
Nombre d'entr√©es BRIN ‚âà (Nombre total de pages) / pages_per_range

Exemple avec 10 millions de lignes (~80 000 pages) :
- pages_per_range = 128 ‚Üí ~625 entr√©es (~50 Ko)
- B-Tree √©quivalent ‚Üí ~150 Mo
BRIN est 3000√ó plus petit !
```

### Index BRIN multi-colonnes

```sql
-- Index BRIN sur plusieurs colonnes
CREATE INDEX idx_logs_multi_brin ON logs_application
USING BRIN (timestamp, user_id) WITH (pages_per_range = 128);

-- Utile pour requ√™tes avec plusieurs filtres ordonn√©s
SELECT * FROM logs_application
WHERE timestamp > '2024-01-01'
  AND user_id BETWEEN 1000 AND 2000;
```

---

## 3. Types de Donn√©es et Op√©rateurs Support√©s

### Types de donn√©es support√©s

BRIN fonctionne avec presque tous les types de donn√©es ordonnables :

| Cat√©gorie | Types support√©s |
|-----------|----------------|
| **Num√©riques** | INTEGER, BIGINT, SMALLINT, NUMERIC, REAL, DOUBLE PRECISION |
| **Temporels** | DATE, TIMESTAMP, TIMESTAMPTZ, TIME, TIMETZ |
| **Texte** | TEXT, VARCHAR, CHAR |
| **R√©seau** | INET, CIDR |
| **UUID** | UUID |
| **G√©om√©trie** | PostGIS geometry (avec extension) |
| **Binaire** | BYTEA |
| **Autres** | MONEY, OID |

### Op√©rateurs support√©s

BRIN supporte les op√©rateurs de comparaison et range :

```sql
-- √âgalit√©
SELECT * FROM logs_application WHERE timestamp = '2024-01-15 10:00:00';

-- Comparaisons
SELECT * FROM logs_application WHERE timestamp > '2024-01-01';
SELECT * FROM logs_application WHERE timestamp < NOW();
SELECT * FROM logs_application WHERE timestamp >= '2024-01-01';
SELECT * FROM logs_application WHERE timestamp <= '2024-12-31';

-- BETWEEN (tr√®s efficace avec BRIN)
SELECT * FROM logs_application
WHERE timestamp BETWEEN '2024-01-01' AND '2024-01-31';

-- IN (peut utiliser BRIN si valeurs dans m√™me range)
SELECT * FROM logs_application
WHERE timestamp IN ('2024-01-01', '2024-01-02', '2024-01-03');
```

### Classes d'op√©rateurs BRIN

PostgreSQL propose plusieurs "familles" d'op√©rateurs pour BRIN :

#### 1. minmax (par d√©faut) - Min/Max Range

```sql
-- Stocke le minimum et maximum de chaque range
CREATE INDEX idx_logs_minmax ON logs_application
USING BRIN (timestamp);  -- minmax implicite

-- Parfait pour : dates, nombres, timestamps
```

#### 2. inclusion - Op√©rateurs d'inclusion

```sql
-- Pour types g√©om√©triques (n√©cessite PostGIS)
CREATE INDEX idx_zones_inclusion ON zones_geo
USING BRIN (geom) WITH (pages_per_range = 128);

-- Supporte : @>, <@, &&, etc.
```

#### 3. bloom - Bloom filters

```sql
-- Pour colonnes avec beaucoup de valeurs distinctes
CREATE INDEX idx_logs_bloom ON logs_application
USING BRIN (action minmax_bloom_ops) WITH (pages_per_range = 128);

-- Plus pr√©cis que minmax standard
```

---

## 4. Cas d'Usage Typiques

### Cas 1 : Logs d'application (Time-Series)

```sql
-- Table de logs massifs
CREATE TABLE application_logs (
    id BIGSERIAL,
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    application TEXT,
    severity TEXT,
    message TEXT,
    user_id INTEGER,
    request_id UUID
);

-- Index BRIN sur timestamp (colonne la plus filtr√©e)
CREATE INDEX idx_app_logs_ts_brin ON application_logs USING BRIN (timestamp);

-- Requ√™tes typiques optimis√©es par BRIN
-- 1. Logs des derni√®res 24 heures
SELECT COUNT(*)
FROM application_logs
WHERE timestamp > NOW() - INTERVAL '24 hours';

-- 2. Logs d'erreurs du mois dernier
SELECT timestamp, message
FROM application_logs
WHERE timestamp BETWEEN '2024-10-01' AND '2024-10-31'
  AND severity = 'ERROR';

-- 3. Analyse par plage temporelle
SELECT
    date_trunc('hour', timestamp) AS heure,
    severity,
    COUNT(*) AS nombre
FROM application_logs
WHERE timestamp > NOW() - INTERVAL '7 days'
GROUP BY heure, severity
ORDER BY heure DESC;
```

### Cas 2 : Donn√©es IoT et T√©l√©m√©trie

```sql
-- Capteurs IoT avec millions de mesures
CREATE TABLE iot_mesures (
    capteur_id INTEGER NOT NULL,
    timestamp TIMESTAMPTZ NOT NULL,
    temperature NUMERIC(5,2),
    humidite NUMERIC(5,2),
    pression NUMERIC(7,2),
    batterie SMALLINT
);

-- Index BRIN sur timestamp ET capteur_id (si ordonn√©s)
CREATE INDEX idx_iot_ts_brin ON iot_mesures USING BRIN (timestamp, capteur_id);

-- Requ√™tes de time-series
-- Moyennes sur une p√©riode
SELECT
    capteur_id,
    AVG(temperature) AS temp_moy,
    AVG(humidite) AS hum_moy
FROM iot_mesures
WHERE timestamp BETWEEN '2024-01-01' AND '2024-01-31'
GROUP BY capteur_id;

-- D√©tection d'anomalies
SELECT
    capteur_id,
    timestamp,
    temperature
FROM iot_mesures
WHERE timestamp > NOW() - INTERVAL '1 hour'
  AND (temperature > 50 OR temperature < -10);
```

### Cas 3 : √âv√©nements et Audits

```sql
-- Table d'audit exhaustive
CREATE TABLE audit_trail (
    id BIGSERIAL,
    event_timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    user_id INTEGER NOT NULL,
    action TEXT NOT NULL,
    table_name TEXT,
    record_id BIGINT,
    old_values JSONB,
    new_values JSONB,
    ip_address INET
);

-- BRIN sur timestamp (chronologique)
CREATE INDEX idx_audit_ts_brin ON audit_trail USING BRIN (event_timestamp);

-- B-Tree sur user_id (recherches fr√©quentes par utilisateur)
CREATE INDEX idx_audit_user ON audit_trail (user_id);

-- Requ√™tes d'audit
-- Activit√© d'un utilisateur sur une p√©riode
SELECT
    event_timestamp,
    action,
    table_name,
    record_id
FROM audit_trail
WHERE user_id = 12345
  AND event_timestamp BETWEEN '2024-01-01' AND '2024-01-31'
ORDER BY event_timestamp DESC;

-- Toutes les modifications d'une table
SELECT COUNT(*)
FROM audit_trail
WHERE table_name = 'users'
  AND action IN ('UPDATE', 'DELETE')
  AND event_timestamp > '2024-01-01';
```

### Cas 4 : Data Warehouse et Analyses

```sql
-- Table de faits (fact table) avec des millions de ventes
CREATE TABLE ventes (
    vente_id BIGSERIAL,
    date_vente DATE NOT NULL,
    produit_id INTEGER,
    client_id INTEGER,
    quantite INTEGER,
    montant NUMERIC(10,2),
    region TEXT
);

-- Partitionnement par mois + BRIN sur date_vente
CREATE INDEX idx_ventes_date_brin ON ventes USING BRIN (date_vente)
WITH (pages_per_range = 256);

-- Requ√™tes analytiques
-- Ventes mensuelles
SELECT
    date_trunc('month', date_vente) AS mois,
    SUM(montant) AS chiffre_affaires,
    COUNT(*) AS nb_ventes
FROM ventes
WHERE date_vente BETWEEN '2024-01-01' AND '2024-12-31'
GROUP BY mois
ORDER BY mois;

-- Top produits sur une p√©riode
SELECT
    produit_id,
    SUM(quantite) AS quantite_totale,
    SUM(montant) AS ca_total
FROM ventes
WHERE date_vente BETWEEN '2024-10-01' AND '2024-10-31'
GROUP BY produit_id
ORDER BY ca_total DESC
LIMIT 10;
```

### Cas 5 : Archives et Donn√©es Historiques

```sql
-- Table d'archives avec r√©tention longue
CREATE TABLE transactions_historiques (
    id BIGSERIAL,
    transaction_date DATE NOT NULL,
    compte_source BIGINT,
    compte_destination BIGINT,
    montant NUMERIC(15,2),
    statut TEXT,
    reference TEXT
);

-- BRIN tr√®s efficace pour donn√©es anciennes rarement modifi√©es
CREATE INDEX idx_trans_hist_date_brin ON transactions_historiques
USING BRIN (transaction_date) WITH (pages_per_range = 512);

-- Requ√™tes d'archives
-- Transactions d'une ann√©e sp√©cifique
SELECT COUNT(*), SUM(montant)
FROM transactions_historiques
WHERE transaction_date BETWEEN '2020-01-01' AND '2020-12-31';

-- Recherche de transactions suspectes
SELECT *
FROM transactions_historiques
WHERE transaction_date > '2021-01-01'
  AND montant > 100000
  AND statut = 'COMPLETED';
```

---

## 5. Performance et Comparaisons

### Comparaison de taille : BRIN vs B-Tree

```sql
-- Cr√©er une grande table de test
CREATE TABLE test_performance (
    id BIGSERIAL PRIMARY KEY,
    created_at TIMESTAMPTZ NOT NULL,
    value INTEGER,
    description TEXT
);

-- Ins√©rer 10 millions de lignes ordonn√©es
INSERT INTO test_performance (created_at, value, description)
SELECT
    NOW() - (generate_series * INTERVAL '1 second'),
    floor(random() * 1000)::INTEGER,
    'Description ' || generate_series
FROM generate_series(1, 10000000);

ANALYZE test_performance;

-- Cr√©er les deux types d'index
CREATE INDEX idx_perf_brin ON test_performance USING BRIN (created_at);
CREATE INDEX idx_perf_btree ON test_performance USING BTREE (created_at);

-- Comparer les tailles
SELECT
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) AS taille
FROM pg_indexes
WHERE tablename = 'test_performance';

-- R√©sultat typique :
-- idx_perf_brin  : 48 KB
-- idx_perf_btree : 214 MB
-- BRIN est 4500√ó plus petit !
```

### Benchmarks de performance

```sql
-- Activer le timing
\timing on

-- Test 1 : Recherche dans une plage large (BRIN excellent)
EXPLAIN ANALYZE
SELECT COUNT(*)
FROM test_performance
WHERE created_at > NOW() - INTERVAL '30 days';

-- R√©sultat avec BRIN :
-- Bitmap Heap Scan : ~50-100 ms
-- Index BRIN utilis√©

-- R√©sultat avec B-Tree :
-- Index Scan : ~30-50 ms
-- L√©g√®rement plus rapide mais 4500√ó plus gros

-- Test 2 : Recherche pr√©cise (B-Tree meilleur)
EXPLAIN ANALYZE
SELECT *
FROM test_performance
WHERE created_at = '2024-01-15 10:30:00';

-- BRIN : doit scanner plusieurs blocs (~5-10 ms)
-- B-Tree : acc√®s direct (~1-2 ms)

-- Test 3 : Range query (BRIN comp√©titif)
EXPLAIN ANALYZE
SELECT AVG(value)
FROM test_performance
WHERE created_at BETWEEN '2024-01-01' AND '2024-01-31';

-- BRIN : ~80 ms
-- B-Tree : ~60 ms
-- Diff√©rence n√©gligeable pour √©conomie massive d'espace
```

### Comparaison d√©taill√©e

| Crit√®re | BRIN | B-Tree | Recommandation |
|---------|------|--------|----------------|
| **Taille** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Minuscule | ‚≠ê Volumineuse | BRIN pour √©conomiser |
| **Recherche pr√©cise** | ‚≠ê‚≠ê Acceptable | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellent | B-Tree si critique |
| **Range queries** | ‚≠ê‚≠ê‚≠ê‚≠ê Tr√®s bon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellent | BRIN si donn√©es ordonn√©es |
| **Insertion** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Ultra rapide | ‚≠ê‚≠ê‚≠ê Correct | BRIN pour writes intensifs |
| **Mise √† jour** | ‚≠ê‚≠ê‚≠ê‚≠ê Rapide | ‚≠ê‚≠ê Lent | BRIN si append-only |
| **Maintenance** | ‚≠ê‚≠ê‚≠ê‚≠ê L√©g√®re | ‚≠ê‚≠ê‚≠ê Moyenne | BRIN moins exigeant |
| **Corr√©lation requise** | ‚≠ê Critique | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Aucune | V√©rifier corr√©lation ! |

---

## 6. Maintenance et Optimisation

### Maintenance r√©guli√®re

```sql
-- Mettre √† jour l'index BRIN apr√®s insertions massives
-- (N√©cessaire car nouveaux ranges peuvent avoir √©t√© cr√©√©s)

-- V√©rifier les plages non r√©sum√©es
SELECT * FROM brin_summarize_new_values('idx_logs_timestamp_brin');

-- R√©sum√© manuel de ranges sp√©cifiques
SELECT brin_summarize_range('idx_logs_timestamp_brin', 0);  -- R√©sumer depuis le bloc 0

-- D√©summariser et re-r√©sumer (apr√®s r√©organisation)
SELECT brin_desummarize_range('idx_logs_timestamp_brin', 0);
SELECT brin_summarize_range('idx_logs_timestamp_brin', 0);
```

### Maintenance automatique (recommand√©)

```sql
-- PostgreSQL r√©sume automatiquement les nouveaux ranges lors du VACUUM

-- Configuration du VACUUM automatique
ALTER TABLE logs_application SET (
    autovacuum_enabled = true,
    autovacuum_vacuum_scale_factor = 0.1,  -- VACUUM quand 10% de la table change
    autovacuum_analyze_scale_factor = 0.05
);

-- Forcer un VACUUM manuel
VACUUM logs_application;
```

### R√©organisation pour am√©liorer la corr√©lation

Avec le temps, les insertions et mises √† jour peuvent **d√©sorganiser** les donn√©es physiquement, r√©duisant l'efficacit√© de BRIN.

```sql
-- V√©rifier la corr√©lation actuelle
SELECT attname, correlation
FROM pg_stats
WHERE tablename = 'logs_application' AND attname = 'timestamp';

-- Si corr√©lation < 0.9, r√©organiser la table
-- ATTENTION : Op√©ration lourde, bloque la table

-- M√©thode 1 : CLUSTER (r√©organise physiquement)
CLUSTER logs_application USING idx_logs_timestamp_brin;
-- Ou utiliser un index B-Tree existant pour le tri
-- CLUSTER logs_application USING idx_logs_timestamp_btree;

-- M√©thode 2 : Recr√©er la table tri√©e (sans verrouillage avec pg_repack)
-- N√©cessite l'extension pg_repack
CREATE EXTENSION IF NOT EXISTS pg_repack;

-- R√©organiser sans verrou (en production)
pg_repack -d ma_base -t logs_application --order-by=timestamp

-- Apr√®s r√©organisation, recr√©er l'index BRIN
REINDEX INDEX idx_logs_timestamp_brin;

-- V√©rifier l'am√©lioration
ANALYZE logs_application;
SELECT attname, correlation
FROM pg_stats
WHERE tablename = 'logs_application' AND attname = 'timestamp';
-- Corr√©lation devrait √™tre proche de 1.0
```

### Configuration pour append-only tables

Pour des tables o√π on n'ins√®re qu'en fin (logs, m√©triques), la corr√©lation reste naturellement √©lev√©e :

```sql
-- Optimisation pour tables append-only
CREATE TABLE metrics_append_only (
    id BIGSERIAL,
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    metric_name TEXT,
    value DOUBLE PRECISION
) WITH (
    fillfactor = 100  -- Remplir les pages √† 100% (pas de place pour UPDATEs)
);

-- Index BRIN avec pages_per_range √©lev√© (donn√©es tr√®s ordonn√©es)
CREATE INDEX idx_metrics_ts_brin ON metrics_append_only
USING BRIN (timestamp) WITH (pages_per_range = 512);

-- D√©sactiver autovacuum (optionnel pour append-only pur)
ALTER TABLE metrics_append_only SET (
    autovacuum_enabled = false
);
```

### Surveillance des index BRIN

```sql
-- Fonction pour surveiller l'efficacit√© BRIN
CREATE OR REPLACE FUNCTION check_brin_health(p_table TEXT, p_column TEXT)
RETURNS TABLE(
    correlation NUMERIC,
    nb_ranges BIGINT,
    taille_index TEXT,
    recommandation TEXT
) AS $$
BEGIN
    RETURN QUERY
    WITH stats AS (
        SELECT
            s.correlation,
            pg_relation_size(i.indexrelid) AS index_size,
            pg_relation_size(c.oid) AS table_size
        FROM pg_stats s
        JOIN pg_class c ON c.relname = p_table
        JOIN pg_index ix ON ix.indrelid = c.oid
        JOIN pg_class i ON i.oid = ix.indexrelid
        WHERE s.tablename = p_table
          AND s.attname = p_column
          AND i.relname LIKE '%brin%'
    )
    SELECT
        s.correlation,
        (s.table_size / (8192 * 128))::BIGINT AS estimated_ranges,
        pg_size_pretty(s.index_size),
        CASE
            WHEN ABS(s.correlation) > 0.95 THEN 'Excellent - BRIN optimal'
            WHEN ABS(s.correlation) > 0.8 THEN 'Bon - BRIN efficace'
            WHEN ABS(s.correlation) > 0.5 THEN 'Moyen - Consid√©rer CLUSTER'
            ELSE 'Faible - Envisager B-Tree ou r√©organisation'
        END
    FROM stats s;
END;
$$ LANGUAGE plpgsql;

-- Utilisation
SELECT * FROM check_brin_health('logs_application', 'timestamp');
```

---

## 7. BRIN avec Partitionnement

La combinaison de BRIN et du partitionnement est **extr√™mement puissante** pour les tr√®s grandes tables.

### Partitionnement par plage temporelle + BRIN

```sql
-- Table parent partitionn√©e par mois
CREATE TABLE logs_partitionnes (
    id BIGSERIAL,
    timestamp TIMESTAMPTZ NOT NULL,
    severity TEXT,
    message TEXT
) PARTITION BY RANGE (timestamp);

-- Cr√©er des partitions mensuelles
CREATE TABLE logs_2024_01 PARTITION OF logs_partitionnes
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE logs_2024_02 PARTITION OF logs_partitionnes
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

CREATE TABLE logs_2024_03 PARTITION OF logs_partitionnes
    FOR VALUES FROM ('2024-03-01') TO ('2024-04-01');

-- Index BRIN sur CHAQUE partition
CREATE INDEX idx_logs_2024_01_ts_brin ON logs_2024_01 USING BRIN (timestamp);
CREATE INDEX idx_logs_2024_02_ts_brin ON logs_2024_02 USING BRIN (timestamp);
CREATE INDEX idx_logs_2024_03_ts_brin ON logs_2024_03 USING BRIN (timestamp);

-- Ou cr√©er l'index sur la table parent (appliqu√© √† toutes les partitions)
CREATE INDEX idx_logs_ts_brin ON logs_partitionnes USING BRIN (timestamp);

-- Avantages combin√©s :
-- 1. Partition pruning √©limine les partitions hors p√©riode
-- 2. BRIN √©limine les blocs hors p√©riode dans les partitions pertinentes
-- 3. Maintenance par partition (DROP partition = suppression instantan√©e)
```

### Strat√©gie de r√©tention avec partitions

```sql
-- Script de maintenance automatique
CREATE OR REPLACE FUNCTION maintain_log_partitions()
RETURNS void AS $$
DECLARE
    partition_name TEXT;
BEGIN
    -- Supprimer les partitions de plus de 6 mois
    FOR partition_name IN
        SELECT tablename
        FROM pg_tables
        WHERE tablename LIKE 'logs_%'
          AND tablename < 'logs_' || to_char(NOW() - INTERVAL '6 months', 'YYYY_MM')
    LOOP
        EXECUTE 'DROP TABLE IF EXISTS ' || partition_name;
        RAISE NOTICE 'Partition supprim√©e : %', partition_name;
    END LOOP;

    -- Cr√©er les partitions pour les 2 prochains mois
    FOR i IN 0..2 LOOP
        partition_name := 'logs_' || to_char(NOW() + (i || ' months')::INTERVAL, 'YYYY_MM');

        IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = partition_name) THEN
            EXECUTE format(
                'CREATE TABLE %I PARTITION OF logs_partitionnes
                 FOR VALUES FROM (%L) TO (%L)',
                partition_name,
                date_trunc('month', NOW() + (i || ' months')::INTERVAL),
                date_trunc('month', NOW() + ((i+1) || ' months')::INTERVAL)
            );

            -- Cr√©er l'index BRIN sur la nouvelle partition
            EXECUTE format(
                'CREATE INDEX %I ON %I USING BRIN (timestamp)',
                'idx_' || partition_name || '_ts_brin',
                partition_name
            );

            RAISE NOTICE 'Partition cr√©√©e : %', partition_name;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Planifier avec pg_cron (extension)
SELECT cron.schedule('maintain-partitions', '0 0 1 * *', 'SELECT maintain_log_partitions()');
```

---

## 8. BRIN pour Autres Types de Donn√©es

### BRIN sur colonnes num√©riques s√©quentielles

```sql
-- Table avec IDs s√©quentiels g√©n√©r√©s
CREATE TABLE commandes (
    commande_id BIGSERIAL PRIMARY KEY,
    client_id INTEGER,
    montant NUMERIC(10,2),
    statut TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- BRIN sur commande_id (parfaitement s√©quentiel)
CREATE INDEX idx_commandes_id_brin ON commandes USING BRIN (commande_id);

-- Tr√®s efficace pour recherches par plage d'ID
SELECT * FROM commandes
WHERE commande_id BETWEEN 1000000 AND 1100000;
```

### BRIN sur adresses IP (INET)

```sql
-- Table de logs r√©seau
CREATE TABLE network_logs (
    id BIGSERIAL,
    timestamp TIMESTAMPTZ NOT NULL,
    source_ip INET NOT NULL,
    destination_ip INET NOT NULL,
    bytes BIGINT,
    protocol TEXT
);

-- Si les IPs sont ordonn√©es (ex: logs par subnet)
-- V√©rifier la corr√©lation d'abord
CREATE INDEX idx_network_src_ip_brin ON network_logs USING BRIN (source_ip);

-- Requ√™te optimis√©e
SELECT COUNT(*), SUM(bytes)
FROM network_logs
WHERE source_ip BETWEEN '192.168.1.0' AND '192.168.1.255';
```

### BRIN sur types g√©om√©triques (avec PostGIS)

```sql
-- Extension PostGIS
CREATE EXTENSION IF NOT EXISTS postgis;

-- Points GPS ordonn√©s g√©ographiquement
CREATE TABLE gps_traces (
    id BIGSERIAL,
    timestamp TIMESTAMPTZ NOT NULL,
    location geometry(Point, 4326),
    speed REAL,
    accuracy REAL
);

-- BRIN avec op√©rateur inclusion pour g√©om√©trie
CREATE INDEX idx_gps_location_brin ON gps_traces
USING BRIN (location) WITH (pages_per_range = 128);

-- Efficace si les points sont physiquement group√©s
SELECT * FROM gps_traces
WHERE ST_DWithin(location, ST_MakePoint(2.35, 48.86), 0.01);
```

---

## 9. Pi√®ges Courants et Solutions

### Pi√®ge 1 : Utiliser BRIN sur donn√©es d√©sordonn√©es

```sql
-- ‚ùå PROBL√àME : Donn√©es ins√©r√©es al√©atoirement
CREATE TABLE users_random (
    id SERIAL PRIMARY KEY,
    created_at TIMESTAMPTZ
);

-- Insertions dans le d√©sordre
INSERT INTO users_random (created_at)
SELECT NOW() - (random() * INTERVAL '365 days')
FROM generate_series(1, 1000000);

-- Index BRIN inefficace
CREATE INDEX idx_users_random_brin ON users_random USING BRIN (created_at);

-- V√©rifier la corr√©lation
SELECT correlation
FROM pg_stats
WHERE tablename = 'users_random' AND attname = 'created_at';
-- R√©sultat : ~0.02 (al√©atoire !)

-- ‚úÖ SOLUTION : Soit r√©organiser avec CLUSTER, soit utiliser B-Tree
-- Option 1 : R√©organiser
CLUSTER users_random USING une_colonne_ordonn√©e;

-- Option 2 : Utiliser B-Tree √† la place
DROP INDEX idx_users_random_brin;
CREATE INDEX idx_users_random_btree ON users_random (created_at);
```

### Pi√®ge 2 : Oublier brin_summarize_new_values

```sql
-- ‚ùå PROBL√àME : Apr√®s insertions massives, nouveaux blocs non index√©s
INSERT INTO logs_application
SELECT NOW() - (generate_series * INTERVAL '1 second'), 'INFO', 'Message'
FROM generate_series(1, 5000000);

-- Les requ√™tes sont lentes car nouveaux ranges non r√©sum√©s

-- ‚úÖ SOLUTION : R√©sumer manuellement ou VACUUM
SELECT brin_summarize_new_values('idx_logs_timestamp_brin');
-- Ou
VACUUM logs_application;
```

### Pi√®ge 3 : pages_per_range inadapt√©

```sql
-- ‚ùå PROBL√àME : pages_per_range trop √©lev√© pour donn√©es vari√©es
CREATE INDEX idx_bad_range ON ma_table
USING BRIN (colonne) WITH (pages_per_range = 1024);

-- Ranges trop larges ‚Üí beaucoup de faux positifs ‚Üí scans excessifs

-- ‚úÖ SOLUTION : Ajuster selon la distribution des donn√©es
DROP INDEX idx_bad_range;
CREATE INDEX idx_good_range ON ma_table
USING BRIN (colonne) WITH (pages_per_range = 128);  -- D√©faut √©quilibr√©
```

### Pi√®ge 4 : Utiliser BRIN pour petites tables

```sql
-- ‚ùå PROBL√àME : Table de 1000 lignes avec BRIN
CREATE TABLE small_table (id SERIAL, data TEXT);
INSERT INTO small_table SELECT generate_series, 'data' FROM generate_series(1, 1000);
CREATE INDEX idx_small_brin ON small_table USING BRIN (id);

-- BRIN overhead inutile pour si peu de donn√©es

-- ‚úÖ SOLUTION : B-Tree pour petites tables
DROP INDEX idx_small_brin;
CREATE INDEX idx_small_btree ON small_table (id);

-- R√®gle : BRIN pour tables > 1 Go minimum
```

### Pi√®ge 5 : N√©gliger la maintenance apr√®s UPDATEs

```sql
-- ‚ùå PROBL√àME : Beaucoup d'UPDATEs qui r√©ordonnent les donn√©es
UPDATE logs_application
SET timestamp = timestamp + INTERVAL '1 year'
WHERE id % 10 = 0;

-- Corr√©lation physique d√©truite

-- ‚úÖ SOLUTION : CLUSTER ou pg_repack r√©guli√®rement
SELECT correlation FROM pg_stats WHERE tablename = 'logs_application';

-- Si corr√©lation < 0.8, r√©organiser
CLUSTER logs_application USING idx_logs_timestamp_brin;
ANALYZE logs_application;
```

### Pi√®ge 6 : Mauvaise compr√©hension du scan

```sql
-- ‚ùå PROBL√àME : Penser que BRIN est toujours lent
-- BRIN n'est pas "lent", il scanne juste plus de blocs que B-Tree

-- Exemple : Range query large
EXPLAIN ANALYZE
SELECT COUNT(*)
FROM logs_application
WHERE timestamp > NOW() - INTERVAL '7 days';

-- BRIN : Scanne peut-√™tre 10% de la table (10 Go ‚Üí 1 Go scann√©)
-- B-Tree : Acc√®s index pr√©cis (mais index = 500 Mo en RAM)

-- ‚úÖ Pour tables massives, BRIN est souvent plus rapide car :
-- 1. Index minuscule (tient en cache)
-- 2. Scan s√©quentiel des blocs pertinents (tr√®s rapide sur SSD)
-- 3. Pas de random I/O comme B-Tree
```

---

## 10. Checklist et Bonnes Pratiques

### ‚úÖ Avant de cr√©er un index BRIN

- [ ] La table est-elle **volumineuse** (> 1 Go) ?
- [ ] Les donn√©es sont-elles **naturellement ordonn√©es** ?
- [ ] V√©rifier la **corr√©lation** avec `pg_stats` (> 0.9 id√©al)
- [ ] La colonne est-elle utilis√©e dans des **range queries** ?
- [ ] Les donn√©es sont-elles principalement **append-only** ?

### ‚úÖ Configuration

- [ ] Choisir `pages_per_range` adapt√© (128 par d√©faut)
- [ ] Consid√©rer le partitionnement pour tr√®s grandes tables
- [ ] Configurer `autovacuum` pour maintenance automatique
- [ ] Documenter la strat√©gie d'indexation

### ‚úÖ Maintenance

- [ ] Ex√©cuter `ANALYZE` apr√®s cr√©ation d'index
- [ ] Appeler `brin_summarize_new_values()` apr√®s gros imports
- [ ] Surveiller la corr√©lation avec `pg_stats`
- [ ] Planifier des `CLUSTER` si corr√©lation se d√©grade
- [ ] `REINDEX` si index corrompu ou fragment√©

### ‚úÖ Monitoring

- [ ] Surveiller la taille de l'index avec `pg_relation_size()`
- [ ] V√©rifier l'utilisation avec `pg_stat_user_indexes`
- [ ] Analyser les plans d'ex√©cution avec `EXPLAIN ANALYZE`
- [ ] Comparer avec B-Tree pour validation de choix

### ‚úÖ Performance

- [ ] Combiner avec partitionnement pour optimisations
- [ ] Utiliser avec `fillfactor=100` pour append-only
- [ ] Privil√©gier range queries sur recherches exactes
- [ ] D√©sactiver autovacuum si append-only pur (optionnel)

---

## 11. Quand Utiliser BRIN : Arbre de D√©cision

```
Votre table fait-elle > 1 Go ?
‚îú‚îÄ NON ‚Üí Utilisez B-Tree
‚îî‚îÄ OUI ‚Üí Continuez

Les donn√©es sont-elles ordonn√©es chronologiquement ou s√©quentiellement ?
‚îú‚îÄ NON ‚Üí V√©rifiez la corr√©lation
‚îÇ   ‚îî‚îÄ Corr√©lation < 0.7 ‚Üí Utilisez B-Tree ou r√©organisez avec CLUSTER
‚îî‚îÄ OUI ‚Üí Continuez

Les requ√™tes sont-elles principalement des range queries (BETWEEN, >, <) ?
‚îú‚îÄ NON ‚Üí Si recherches exactes fr√©quentes, envisagez B-Tree
‚îî‚îÄ OUI ‚Üí BRIN est excellent !

Les donn√©es changent-elles fr√©quemment ?
‚îú‚îÄ OUI (beaucoup d'UPDATEs d√©sordonn√©s) ‚Üí B-Tree probablement mieux
‚îî‚îÄ NON (append-only ou stables) ‚Üí BRIN parfait !

Avez-vous des contraintes d'espace disque ou RAM ?
‚îú‚îÄ OUI ‚Üí BRIN √©conomise √©norm√©ment d'espace
‚îî‚îÄ NON ‚Üí BRIN reste b√©n√©fique pour maintenance

‚Üí Cr√©ez un index BRIN !
```

---

## 12. Comparaison Finale : BRIN vs Autres Index

| Crit√®re | BRIN | B-Tree | GIN | GiST |
|---------|------|--------|-----|------|
| **Taille** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê | ‚≠ê‚≠ê |
| **Insertion** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê | ‚≠ê‚≠ê |
| **Range queries** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | N/A | ‚≠ê‚≠ê‚≠ê‚≠ê |
| **Recherche exacte** | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **Maintenance** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **Corr√©lation requise** | ‚≠ê Critique | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |
| **Best for** | Time-series massives | Usage g√©n√©ral | Arrays, JSONB | G√©om√©trie, ltree |

---

## 13. Ressources et Documentation

### Documentation officielle PostgreSQL 18

- [BRIN Indexes](https://www.postgresql.org/docs/18/brin.html)
- [BRIN Built-in Operator Classes](https://www.postgresql.org/docs/18/brin-builtin-opclasses.html)
- [Index Types Comparison](https://www.postgresql.org/docs/18/indexes-types.html)

### Articles et √©tudes de cas

- **"BRIN Indexes: How and When to Use Them"** - Blog Percona
- **"Massive Performance Improvements with BRIN"** - Blog 2ndQuadrant
- **"Time-Series Data at Scale with BRIN"** - Blog Timescale

### Extensions compl√©mentaires

- **TimescaleDB** : Optimisations time-series avec BRIN automatique
- **pg_repack** : R√©organisation sans verrouillage
- **pg_cron** : Planification de maintenance

### Outils de monitoring

- **pg_stat_statements** : Analyser les requ√™tes
- **pgBadger** : Analyser les logs
- **Grafana + postgres_exporter** : Dashboards de monitoring

---

## Conclusion

Les index BRIN repr√©sentent une **innovation majeure** dans l'indexation PostgreSQL, offrant une solution ultra-compacte et performante pour les **tables massives** avec des donn√©es **naturellement ordonn√©es**.

### Points cl√©s √† retenir

1. **BRIN = Efficacit√© spatiale** : Index 1000√ó plus petit que B-Tree
2. **Corr√©lation critique** : V√©rifier avec `pg_stats` avant utilisation
3. **Id√©al pour time-series** : Logs, m√©triques, IoT, √©v√©nements
4. **Combiner avec partitionnement** : Puissance d√©cupl√©e
5. **Maintenance l√©g√®re** : VACUUM et r√©sum√©s p√©riodiques

### Cas d'usage id√©aux

- üìä **Data warehouses** : Tables de faits chronologiques
- üìù **Logs d'application** : Millions de lignes par jour
- üå°Ô∏è **IoT et t√©l√©m√©trie** : Mesures continues ordonn√©es
- üìà **S√©ries temporelles** : M√©triques, analytics
- üóÑÔ∏è **Archives** : Donn√©es historiques rarement modifi√©es

### Formule magique

```
Si (table > 1 Go)
   ET (corr√©lation > 0.9)
   ET (range queries fr√©quentes)
   ‚Üí BRIN = Victoire !
```

Avec BRIN, PostgreSQL peut g√©rer des **p√©taoctets de donn√©es** avec des index qui tiennent dans quelques m√©gaoctets. C'est la magie de l'indexation par plages de blocs ! üöÄ

---


‚è≠Ô∏è [Hash : √âgalit√© stricte](/13-indexation-et-optimisation/04.4-hash-egalite-stricte.md)
