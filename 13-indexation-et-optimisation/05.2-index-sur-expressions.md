üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.5.2. Index sur Expressions (CREATE INDEX ON table((lower(col))))

## Introduction

Un **index sur expression** (√©galement appel√© **index fonctionnel**) est un index qui porte non pas directement sur une colonne, mais sur le **r√©sultat d'une expression ou d'une fonction** appliqu√©e √† une ou plusieurs colonnes.

Contrairement √† un index classique qui indexe les valeurs brutes d'une colonne, un index sur expression indexe les valeurs **transform√©es** par une fonction ou une expression.

Cette technique est particuli√®rement utile lorsque vos requ√™tes filtrent ou trient syst√©matiquement sur des transformations de colonnes.

---

## Concept Fondamental

### Index Classique vs Index sur Expression

**Index classique :**
```sql
CREATE INDEX idx_email ON utilisateurs(email);
```
‚Üí Indexe les valeurs brutes : `'John@Example.COM'`, `'alice@test.com'`

**Probl√®me :** Cette requ√™te ne peut pas utiliser l'index :
```sql
SELECT * FROM utilisateurs WHERE LOWER(email) = 'john@example.com';
```
‚Üí PostgreSQL doit calculer `LOWER(email)` pour chaque ligne (Seq Scan)

**Index sur expression :**
```sql
CREATE INDEX idx_email_lower ON utilisateurs(LOWER(email));
```
‚Üí Indexe les valeurs transform√©es : `'john@example.com'`, `'alice@test.com'`

**Maintenant, cette requ√™te utilise l'index :**
```sql
SELECT * FROM utilisateurs WHERE LOWER(email) = 'john@example.com';
```
‚Üí PostgreSQL utilise directement l'index sur `LOWER(email)` (Index Scan)

---

## Pourquoi Utiliser des Index sur Expressions ?

### 1. **Recherches Insensibles √† la Casse**

Sans index sur expression :
```sql
-- ‚ùå Scan s√©quentiel (lent sur grandes tables)
SELECT * FROM utilisateurs WHERE LOWER(email) = 'john@example.com';
```

Avec index sur expression :
```sql
CREATE INDEX idx_email_lower ON utilisateurs(LOWER(email));

-- ‚úÖ Utilise l'index (rapide)
SELECT * FROM utilisateurs WHERE LOWER(email) = 'john@example.com';
```

### 2. **Recherches sur Donn√©es Normalis√©es**

Exemple : Recherche sur num√©ros de t√©l√©phone sans espaces ni tirets
```sql
-- Cr√©er un index sur la version nettoy√©e
CREATE INDEX idx_tel_clean ON clients(REPLACE(REPLACE(telephone, ' ', ''), '-', ''));

-- Requ√™te optimis√©e
SELECT * FROM clients
WHERE REPLACE(REPLACE(telephone, ' ', ''), '-', '') = '0612345678';
```

### 3. **Calculs Fr√©quents**

Exemple : Indexer une colonne JSON extraite
```sql
CREATE INDEX idx_user_name ON commandes((data->>'user_name'));

-- Requ√™te rapide sur un champ JSON
SELECT * FROM commandes WHERE data->>'user_name' = 'John Doe';
```

### 4. **Tri sur Expressions**

```sql
CREATE INDEX idx_nom_prenom ON personnes((nom || ' ' || prenom));

-- Tri optimis√©
SELECT * FROM personnes ORDER BY nom || ' ' || prenom;
```

---

## Syntaxe et Utilisation

### Syntaxe G√©n√©rale

```sql
CREATE INDEX nom_index ON nom_table((expression));
```

**Note importante :** Les **doubles parenth√®ses** `(( ))` sont **obligatoires** pour les expressions !

### Exemples de Syntaxes

```sql
-- ‚úÖ Correct : doubles parenth√®ses
CREATE INDEX idx_lower_email ON users((LOWER(email)));

-- ‚ùå Incorrect : parenth√®ses simples
CREATE INDEX idx_lower_email ON users(LOWER(email));
-- Erreur : syntax error
```

### Expressions Support√©es

PostgreSQL supporte pratiquement toutes les expressions **immutables** :

1. **Fonctions de transformation de texte**
   ```sql
   LOWER(colonne)
   UPPER(colonne)
   TRIM(colonne)
   SUBSTRING(colonne, 1, 10)
   ```

2. **Op√©rations math√©matiques**
   ```sql
   (prix * 1.20)  -- Prix TTC
   (longueur * largeur)  -- Surface
   ABS(valeur)
   ROUND(montant, 2)
   ```

3. **Extraction de donn√©es**
   ```sql
   DATE(timestamp_col)
   EXTRACT(YEAR FROM date_col)
   data->>'field'  -- JSON
   ```

4. **Concat√©nation**
   ```sql
   (nom || ' ' || prenom)
   CONCAT(code_pays, '-', code_postal)
   ```

5. **Expressions conditionnelles simples**
   ```sql
   CASE WHEN statut = 'actif' THEN 1 ELSE 0 END
   COALESCE(colonne, 'd√©faut')
   ```

---

## Exemples Pratiques

### Exemple 1 : Recherche Insensible √† la Casse

**Contexte :** Table d'utilisateurs avec emails en casse mixte.

```sql
-- Table utilisateurs
CREATE TABLE utilisateurs (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    email VARCHAR(255) UNIQUE,
    date_inscription TIMESTAMP DEFAULT NOW()
);

-- Donn√©es exemples
INSERT INTO utilisateurs (nom, email) VALUES
    ('John Doe', 'John.Doe@Example.COM'),
    ('Alice Smith', 'alice.smith@test.com'),
    ('Bob Martin', 'BOB.MARTIN@COMPANY.FR');
```

**Sans index sur expression :**
```sql
-- ‚ùå Scan s√©quentiel
EXPLAIN ANALYZE
SELECT * FROM utilisateurs WHERE LOWER(email) = 'john.doe@example.com';

-- R√©sultat :
-- Seq Scan on utilisateurs  (cost=0.00..25.88 rows=6 width=...)
--   Filter: (lower((email)::text) = 'john.doe@example.com'::text)
```

**Avec index sur expression :**
```sql
-- Cr√©er l'index
CREATE INDEX idx_email_lower ON utilisateurs(LOWER(email));

-- ‚úÖ Index Scan
EXPLAIN ANALYZE
SELECT * FROM utilisateurs WHERE LOWER(email) = 'john.doe@example.com';

-- R√©sultat :
-- Index Scan using idx_email_lower on utilisateurs  (cost=0.15..8.17 rows=1 width=...)
--   Index Cond: (lower((email)::text) = 'john.doe@example.com'::text)
```

**Gain de performance :** 3√ó √† 100√ó plus rapide selon la taille de la table.

### Exemple 2 : Extraction de Date depuis un Timestamp

**Contexte :** Requ√™tes fr√©quentes group√©es par jour.

```sql
-- Table de logs
CREATE TABLE logs (
    id BIGSERIAL PRIMARY KEY,
    message TEXT,
    niveau VARCHAR(20),
    created_at TIMESTAMP DEFAULT NOW()
);

-- Requ√™te typique : logs d'une journ√©e sp√©cifique
SELECT * FROM logs
WHERE DATE(created_at) = '2025-11-20';
```

**Sans index :**
```sql
-- ‚ùå Scan s√©quentiel (calcule DATE() pour chaque ligne)
EXPLAIN ANALYZE
SELECT * FROM logs WHERE DATE(created_at) = '2025-11-20';
```

**Avec index sur expression :**
```sql
-- Cr√©er l'index sur DATE(created_at)
CREATE INDEX idx_logs_date ON logs((DATE(created_at)));

-- ‚úÖ Index Scan
EXPLAIN ANALYZE
SELECT * FROM logs WHERE DATE(created_at) = '2025-11-20';

-- R√©sultat :
-- Index Scan using idx_logs_date on logs
--   Index Cond: (date(created_at) = '2025-11-20'::date)
```

**Alternative plus performante (sans fonction) :**
```sql
-- Meilleure approche : utiliser un range sans fonction
SELECT * FROM logs
WHERE created_at >= '2025-11-20'::date
AND created_at < '2025-11-21'::date;

-- Index classique sur created_at suffit
CREATE INDEX idx_logs_timestamp ON logs(created_at);
```

### Exemple 3 : Recherche sur Colonnes JSON

**Contexte :** Table avec donn√©es JSON, recherche fr√©quente sur un champ.

```sql
-- Table de commandes avec m√©tadonn√©es JSON
CREATE TABLE commandes (
    id SERIAL PRIMARY KEY,
    client_id INTEGER,
    data JSONB,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Exemples de donn√©es
INSERT INTO commandes (client_id, data) VALUES
    (1, '{"user_name": "John Doe", "country": "FR", "total": 150.50}'),
    (2, '{"user_name": "Alice Smith", "country": "US", "total": 200.00}');
```

**Sans index :**
```sql
-- ‚ùå Scan s√©quentiel
SELECT * FROM commandes WHERE data->>'user_name' = 'John Doe';
```

**Avec index sur expression :**
```sql
-- Cr√©er index sur l'extraction du champ user_name
CREATE INDEX idx_data_user_name ON commandes((data->>'user_name'));

-- ‚úÖ Index Scan
SELECT * FROM commandes WHERE data->>'user_name' = 'John Doe';
```

**Alternative pour recherches multiples sur JSON :**
```sql
-- Index GIN pour toutes les cl√©s/valeurs
CREATE INDEX idx_data_gin ON commandes USING gin(data);

-- Permet des recherches plus flexibles
SELECT * FROM commandes WHERE data @> '{"country": "FR"}';
```

### Exemple 4 : Normalisation de Texte

**Contexte :** Recherche sur noms avec accents et casse.

```sql
-- Table de produits
CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    prix NUMERIC(10,2)
);

-- Fonction de normalisation (supprimer accents + minuscules)
CREATE EXTENSION IF NOT EXISTS unaccent;

-- Index sur texte normalis√©
CREATE INDEX idx_nom_normalized ON produits(
    (LOWER(unaccent(nom)))
);

-- Recherche normalis√©e
SELECT * FROM produits
WHERE LOWER(unaccent(nom)) = LOWER(unaccent('Caf√© Expresso'));
-- Trouvera : "Caf√© Expresso", "cafe expresso", "CAF√â EXPRESSO"
```

### Exemple 5 : Calculs Math√©matiques

**Contexte :** Recherche sur surface calcul√©e.

```sql
-- Table de biens immobiliers
CREATE TABLE biens (
    id SERIAL PRIMARY KEY,
    adresse TEXT,
    longueur NUMERIC(6,2),  -- en m√®tres
    largeur NUMERIC(6,2),   -- en m√®tres
    prix NUMERIC(10,2)
);

-- Index sur surface calcul√©e
CREATE INDEX idx_surface ON biens((longueur * largeur));

-- Requ√™te : trouver biens entre 80 et 120 m¬≤
SELECT * FROM biens
WHERE (longueur * largeur) BETWEEN 80 AND 120
ORDER BY longueur * largeur;
```

**Alternative : Colonne calcul√©e (PostgreSQL 12+) :**
```sql
-- Cr√©er une colonne g√©n√©r√©e stock√©e
ALTER TABLE biens ADD COLUMN surface NUMERIC(10,2)
GENERATED ALWAYS AS (longueur * largeur) STORED;

-- Index classique sur colonne g√©n√©r√©e
CREATE INDEX idx_surface_generated ON biens(surface);

-- Requ√™te simplifi√©e
SELECT * FROM biens
WHERE surface BETWEEN 80 AND 120
ORDER BY surface;
```

### Exemple 6 : Tri Personnalis√©

**Contexte :** Tri alphab√©tique sur nom complet.

```sql
-- Table de contacts
CREATE TABLE contacts (
    id SERIAL PRIMARY KEY,
    prenom VARCHAR(50),
    nom VARCHAR(50),
    email VARCHAR(255)
);

-- Index sur nom complet (nom + pr√©nom)
CREATE INDEX idx_nom_complet ON contacts(
    (nom || ' ' || prenom)
);

-- Tri optimis√©
SELECT * FROM contacts
ORDER BY nom || ' ' || prenom;
```

---

## Cas d'Usage Typiques

### 1. **Recherches Insensibles √† la Casse**

```sql
CREATE INDEX idx_lower ON table((LOWER(colonne)));
```

**Sc√©nario :** Emails, usernames, codes, r√©f√©rences.

### 2. **Extraction de Composants de Dates**

```sql
CREATE INDEX idx_year ON events((EXTRACT(YEAR FROM date_col)));
CREATE INDEX idx_month ON events((EXTRACT(MONTH FROM date_col)));
```

**Sc√©nario :** Rapports mensuels, statistiques annuelles.

### 3. **Recherches sur Donn√©es JSON**

```sql
CREATE INDEX idx_json_field ON table((data->>'field_name'));
```

**Sc√©nario :** M√©tadonn√©es, configurations, donn√©es semi-structur√©es.

### 4. **Normalisation de Cha√Ænes**

```sql
CREATE INDEX idx_clean_text ON table(
    (TRIM(LOWER(REPLACE(colonne, '-', ''))))
);
```

**Sc√©nario :** Codes produits, r√©f√©rences, num√©ros de s√©rie.

### 5. **Calculs M√©tier**

```sql
CREATE INDEX idx_prix_ttc ON produits((prix_ht * 1.20));
CREATE INDEX idx_age ON personnes((EXTRACT(YEAR FROM age(date_naissance))));
```

**Sc√©nario :** Prix TTC, √¢ge calcul√©, scores.

---

## R√®gles et Contraintes

### 1. **Immutabilit√© Requise**

PostgreSQL n'accepte que les fonctions **IMMUTABLE** dans les index sur expressions.

**Qu'est-ce qu'une fonction IMMUTABLE ?**
Une fonction qui retourne **toujours le m√™me r√©sultat** pour les m√™mes arguments.

```sql
-- ‚úÖ IMMUTABLE : Accept√©
LOWER('ABC')  ‚Üí toujours 'abc'
ABS(-5)       ‚Üí toujours 5
DATE('2025-11-20 15:30:00')  ‚Üí toujours '2025-11-20'

-- ‚ùå VOLATILE : Refus√©
NOW()          ‚Üí change √† chaque appel
RANDOM()       ‚Üí change √† chaque appel
CURRVAL()      ‚Üí d√©pend de l'√©tat
```

**Exemple d'erreur :**
```sql
-- ‚ùå Erreur : NOW() n'est pas IMMUTABLE
CREATE INDEX idx_recent ON logs((created_at > NOW() - INTERVAL '7 days'));

-- Erreur :
-- ERROR: functions in index expression must be marked IMMUTABLE
```

### 2. **Correspondance Exacte Requise**

Pour que l'index soit utilis√©, la requ√™te doit utiliser **exactement la m√™me expression**.

```sql
-- Index cr√©√©
CREATE INDEX idx_lower_email ON users((LOWER(email)));

-- ‚úÖ Utilise l'index
SELECT * FROM users WHERE LOWER(email) = 'test@example.com';

-- ‚ùå N'utilise PAS l'index (expression diff√©rente)
SELECT * FROM users WHERE UPPER(email) = 'TEST@EXAMPLE.COM';
```

### 3. **Performance de l'Expression**

L'expression est calcul√©e √† chaque INSERT/UPDATE. √âvitez les expressions co√ªteuses.

```sql
-- ‚ùå MAUVAIS : Expression tr√®s co√ªteuse
CREATE INDEX idx_expensive ON table(
    (
        SELECT COUNT(*) FROM autre_table
        WHERE autre_table.ref = table.id
    )
);

-- ‚úÖ BON : Expression simple et rapide
CREATE INDEX idx_simple ON table((LOWER(colonne)));
```

### 4. **Taille de l'Index**

Les index sur expressions peuvent √™tre plus volumineux que les index classiques.

```sql
-- Comparer les tailles
SELECT
    pg_size_pretty(pg_relation_size('idx_email')) AS "Index classique",
    pg_size_pretty(pg_relation_size('idx_email_lower')) AS "Index expression";
```

**G√©n√©ralement :** La diff√©rence est n√©gligeable (< 10%).

---

## V√©rifier l'Utilisation de l'Index

### Avec EXPLAIN

```sql
-- V√©rifier si l'index est utilis√©
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM utilisateurs WHERE LOWER(email) = 'test@example.com';
```

**Sortie attendue avec l'index :**
```
Index Scan using idx_email_lower on utilisateurs
  Index Cond: (lower((email)::text) = 'test@example.com'::text)
  Buffers: shared hit=3
```

**Sortie sans l'index (probl√®me) :**
```
Seq Scan on utilisateurs
  Filter: (lower((email)::text) = 'test@example.com'::text)
  Rows Removed by Filter: 999999
```

### Monitoring de l'Index

```sql
-- V√©rifier l'utilisation d'un index
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,  -- Nombre d'utilisations
    idx_tup_read,  -- Lignes lues
    idx_tup_fetch  -- Lignes retourn√©es
FROM pg_stat_user_indexes
WHERE indexname = 'idx_email_lower';
```

---

## Pi√®ges et Limitations

### ‚ùå Pi√®ge 1 : Expression Non-Correspondante

```sql
-- Index cr√©√©
CREATE INDEX idx_lower ON users((LOWER(email)));

-- ‚ùå N'utilise PAS l'index (UPPER au lieu de LOWER)
SELECT * FROM users WHERE UPPER(email) = 'TEST@EXAMPLE.COM';
```

**Solution :** Utiliser la **m√™me expression** que dans l'index.

### ‚ùå Pi√®ge 2 : Fonctions Non-Immutables

```sql
-- ‚ùå Erreur : NOW() est VOLATILE
CREATE INDEX idx_recent ON logs((NOW() - created_at));

-- Erreur : functions in index expression must be marked IMMUTABLE
```

**Solution :** Utiliser des fonctions IMMUTABLE uniquement.

### ‚ùå Pi√®ge 3 : Expression Complexe et Co√ªteuse

```sql
-- ‚ùå Tr√®s co√ªteux √† maintenir
CREATE INDEX idx_expensive ON products(
    (
        (LOWER(TRIM(REGEXP_REPLACE(name, '[^a-zA-Z0-9]', '', 'g'))))
    )
);
```

**Solution :** Simplifier l'expression ou utiliser une colonne g√©n√©r√©e.

### ‚ùå Pi√®ge 4 : Oublier les Doubles Parenth√®ses

```sql
-- ‚ùå Syntax Error
CREATE INDEX idx_lower ON users(LOWER(email));

-- ‚úÖ Correct
CREATE INDEX idx_lower ON users((LOWER(email)));
```

### ‚ùå Pi√®ge 5 : Type de Donn√©es Diff√©rent

```sql
-- Index cr√©√© sur INTEGER
CREATE INDEX idx_str_id ON table((id::TEXT));

-- ‚ùå N'utilise pas l'index (VARCHAR au lieu de TEXT)
SELECT * FROM table WHERE id::VARCHAR = '123';

-- ‚úÖ Utilise l'index (m√™me type : TEXT)
SELECT * FROM table WHERE id::TEXT = '123';
```

---

## Alternatives aux Index sur Expressions

### Alternative 1 : Colonnes G√©n√©r√©es (PostgreSQL 12+)

**Avantage :** Syntaxe de requ√™te simplifi√©e.

```sql
-- Cr√©er une colonne g√©n√©r√©e
ALTER TABLE users
ADD COLUMN email_lower TEXT
GENERATED ALWAYS AS (LOWER(email)) STORED;

-- Index classique sur la colonne g√©n√©r√©e
CREATE INDEX idx_email_lower ON users(email_lower);

-- Requ√™te simplifi√©e
SELECT * FROM users WHERE email_lower = 'test@example.com';
```

**Comparaison :**

| Crit√®re | Index sur Expression | Colonne G√©n√©r√©e + Index |
|---------|----------------------|-------------------------|
| Espace disque | Index uniquement | Index + Colonne stock√©e |
| Requ√™te | `WHERE LOWER(col) = ...` | `WHERE col_lower = ...` |
| Maintenance | Automatique | Automatique |
| Lisibilit√© | Moins claire | Plus claire |

### Alternative 2 : Normalisation en Amont

```sql
-- Normaliser √† l'insertion
INSERT INTO users (email)
VALUES (LOWER('John@Example.COM'));  -- Stocke d√©j√† en minuscules

-- Index classique suffit
CREATE INDEX idx_email ON users(email);

-- Requ√™te simple
SELECT * FROM users WHERE email = 'john@example.com';
```

**Avantage :** Simplicit√© maximale.

**Inconv√©nient :** N√©cessite de normaliser dans l'application.

### Alternative 3 : Index de Texte Complet (Full-Text Search)

Pour recherches textuelles avanc√©es :

```sql
-- Index GIN pour full-text search
CREATE INDEX idx_fts ON articles USING gin(to_tsvector('french', contenu));

-- Recherche avec op√©rateur @@
SELECT * FROM articles
WHERE to_tsvector('french', contenu) @@ to_tsquery('french', 'PostgreSQL');
```

---

## Index sur Expressions avec Types d'Index Sp√©cialis√©s

### Avec GIN (Texte, JSON, Arrays)

```sql
-- Index GIN sur expression JSON
CREATE INDEX idx_tags ON posts USING gin((data->'tags'));

-- Recherche dans array JSON
SELECT * FROM posts WHERE data->'tags' ? 'postgresql';
```

### Avec GiST (G√©om√©trie, Texte)

```sql
-- Index GiST sur texte normalis√©
CREATE INDEX idx_text_gist ON documents
USING gist((to_tsvector('english', contenu)));
```

### Avec BRIN (Donn√©es S√©quentielles)

```sql
-- Index BRIN sur date extraite
CREATE INDEX idx_year_brin ON logs
USING brin((EXTRACT(YEAR FROM created_at)));
```

---

## Combinaison : Index Partiel + Expression

Vous pouvez combiner index partiel et expression pour une optimisation maximale !

```sql
-- Index sur expression + condition partielle
CREATE INDEX idx_email_lower_actifs ON utilisateurs(
    (LOWER(email))
)
WHERE est_actif = TRUE;
```

**Avantages combin√©s :**
- Expression : Recherche insensible √† la casse
- Partiel : Indexe uniquement les utilisateurs actifs

**Requ√™te optimis√©e :**
```sql
-- ‚úÖ Utilise l'index combin√©
SELECT * FROM utilisateurs
WHERE LOWER(email) = 'test@example.com'
AND est_actif = TRUE;
```

---

## Exemple Complet : Optimisation d'une Table de Produits

### Contexte

```sql
-- Table de produits e-commerce
CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    reference VARCHAR(50),
    prix_ht NUMERIC(10,2),
    categorie VARCHAR(100),
    date_ajout TIMESTAMP DEFAULT NOW()
);

-- 1 million de produits
-- Requ√™tes fr√©quentes :
-- 1. Recherche insensible √† la casse sur nom
-- 2. Recherche sur prix TTC (TVA 20%)
-- 3. Recherche sur ann√©e d'ajout
```

### Strat√©gie d'Indexation

```sql
-- Index 1 : Nom en minuscules
CREATE INDEX idx_nom_lower ON produits((LOWER(nom)));

-- Index 2 : Prix TTC calcul√©
CREATE INDEX idx_prix_ttc ON produits((prix_ht * 1.20));

-- Index 3 : Ann√©e d'ajout
CREATE INDEX idx_annee ON produits((EXTRACT(YEAR FROM date_ajout)));

-- Index 4 : R√©f√©rence nettoy√©e (sans tirets ni espaces)
CREATE INDEX idx_ref_clean ON produits(
    (REPLACE(REPLACE(LOWER(reference), '-', ''), ' ', ''))
);
```

### Requ√™tes Optimis√©es

```sql
-- Requ√™te 1 : Recherche produit par nom
-- ‚úÖ Utilise idx_nom_lower
EXPLAIN ANALYZE
SELECT * FROM produits
WHERE LOWER(nom) = 'iphone 15 pro';

-- Requ√™te 2 : Produits dans une fourchette de prix TTC
-- ‚úÖ Utilise idx_prix_ttc
EXPLAIN ANALYZE
SELECT * FROM produits
WHERE (prix_ht * 1.20) BETWEEN 500 AND 1000
ORDER BY prix_ht * 1.20;

-- Requ√™te 3 : Produits ajout√©s en 2024
-- ‚úÖ Utilise idx_annee
EXPLAIN ANALYZE
SELECT * FROM produits
WHERE EXTRACT(YEAR FROM date_ajout) = 2024;

-- Requ√™te 4 : Recherche par r√©f√©rence nettoy√©e
-- ‚úÖ Utilise idx_ref_clean
EXPLAIN ANALYZE
SELECT * FROM produits
WHERE REPLACE(REPLACE(LOWER(reference), '-', ''), ' ', '') = 'ref123456';
```

### Gains de Performance

**Avant optimisation :**
- Requ√™te 1 : 2500 ms (Seq Scan)
- Requ√™te 2 : 3200 ms (Seq Scan)
- Requ√™te 3 : 1800 ms (Seq Scan)

**Apr√®s optimisation :**
- Requ√™te 1 : 12 ms (Index Scan) ‚Üí **208√ó plus rapide**
- Requ√™te 2 : 25 ms (Index Scan) ‚Üí **128√ó plus rapide**
- Requ√™te 3 : 8 ms (Index Scan) ‚Üí **225√ó plus rapide**

---

## Maintenance et Monitoring

### Lister les Index sur Expressions

```sql
SELECT
    schemaname,
    tablename,
    indexname,
    indexdef
FROM pg_indexes
WHERE indexdef LIKE '%(%(%'  -- D√©tecte les doubles parenth√®ses
ORDER BY tablename, indexname;
```

### Analyser l'Utilisation

```sql
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan AS "Nb utilisations",
    pg_size_pretty(pg_relation_size(indexrelid)) AS "Taille",
    indexdef
FROM pg_stat_user_indexes
JOIN pg_indexes USING (schemaname, tablename, indexname)
WHERE indexdef LIKE '%(%(%'
ORDER BY idx_scan DESC;
```

### Identifier les Index Inutilis√©s

```sql
-- Index sur expressions jamais utilis√©s
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS "Taille gaspill√©e"
FROM pg_stat_user_indexes
JOIN pg_indexes USING (schemaname, tablename, indexname)
WHERE indexdef LIKE '%(%(%'
AND idx_scan = 0
ORDER BY pg_relation_size(indexrelid) DESC;
```

---

## Bonnes Pratiques

### ‚úÖ DO (√Ä Faire)

1. **Utiliser des fonctions IMMUTABLE uniquement**
   ```sql
   -- ‚úÖ IMMUTABLE
   CREATE INDEX idx ON table((LOWER(col)));
   CREATE INDEX idx ON table((DATE(timestamp_col)));
   ```

2. **Garder les expressions simples**
   ```sql
   -- ‚úÖ Simple et performant
   CREATE INDEX idx ON table((LOWER(email)));

   -- ‚ùå Complexe et co√ªteux
   CREATE INDEX idx ON table((LOWER(TRIM(REGEXP_REPLACE(email, '...', '')))));
   ```

3. **Documenter les index sur expressions**
   ```sql
   COMMENT ON INDEX idx_email_lower IS
   'Index sur email en minuscules pour recherches insensibles √† la casse';
   ```

4. **Tester avec EXPLAIN avant de cr√©er**
   ```sql
   -- Sans index
   EXPLAIN SELECT * FROM table WHERE LOWER(col) = 'value';

   -- Cr√©er l'index
   CREATE INDEX ...

   -- V√©rifier l'utilisation
   EXPLAIN SELECT * FROM table WHERE LOWER(col) = 'value';
   ```

5. **Pr√©f√©rer les colonnes g√©n√©r√©es pour les cas complexes**
   ```sql
   -- Au lieu d'un index sur expression complexe
   ALTER TABLE table ADD COLUMN computed_col
   GENERATED ALWAYS AS (expression_complexe) STORED;

   CREATE INDEX idx ON table(computed_col);
   ```

### ‚ùå DON'T (√Ä √âviter)

1. **Ne pas utiliser de fonctions VOLATILE ou STABLE**
   ```sql
   -- ‚ùå Erreur
   CREATE INDEX idx ON table((NOW() - created_at));
   ```

2. **Ne pas oublier les doubles parenth√®ses**
   ```sql
   -- ‚ùå Syntax Error
   CREATE INDEX idx ON table(LOWER(col));

   -- ‚úÖ Correct
   CREATE INDEX idx ON table((LOWER(col)));
   ```

3. **Ne pas cr√©er d'index sur expressions co√ªteuses**
   ```sql
   -- ‚ùå Trop co√ªteux √† maintenir
   CREATE INDEX idx ON table((fonction_tres_complexe(col)));
   ```

4. **Ne pas utiliser des expressions diff√©rentes dans les requ√™tes**
   ```sql
   CREATE INDEX idx ON table((LOWER(col)));

   -- ‚ùå N'utilise pas l'index
   SELECT * FROM table WHERE UPPER(col) = 'VALUE';
   ```

---

## Comparaison des Approches

| Approche | Avantages | Inconv√©nients | Quand l'utiliser |
|----------|-----------|---------------|------------------|
| **Index sur Expression** | - Transparent<br>- Pas de colonne suppl√©mentaire | - Expression obligatoire dans requ√™tes<br>- Peut √™tre moins lisible | Transformations ponctuelles |
| **Colonne G√©n√©r√©e** | - Requ√™tes simples<br>- Plus lisible | - Espace disque (colonne stock√©e)<br>- PG 12+ uniquement | Calculs fr√©quents, lisibilit√© importante |
| **Normalisation Applicative** | - Simplicit√© maximale<br>- Index classique suffit | - Logique dans application<br>- Risque d'incoh√©rence | Donn√©es contr√¥l√©es √† la source |
| **Colonne D√©normalis√©e Manuelle** | - Contr√¥le total<br>- R√©trocompatible | - Maintenance manuelle (triggers)<br>- Risque de d√©synchronisation | Applications legacy |

---

## R√©sum√©

### Points Cl√©s

1. **Un index sur expression indexe le r√©sultat d'une fonction ou expression, pas la valeur brute**

2. **Syntaxe : Doubles parenth√®ses obligatoires**
   ```sql
   CREATE INDEX idx ON table((expression));
   ```

3. **Condition d'utilisation : La requ√™te doit utiliser la m√™me expression**

4. **Restrictions :**
   - Fonctions IMMUTABLE uniquement
   - Expressions simples recommand√©es

5. **Cas d'usage principaux :**
   - Recherches insensibles √† la casse (LOWER, UPPER)
   - Extraction de composants (DATE, EXTRACT)
   - Normalisation de texte (TRIM, REPLACE)
   - Calculs m√©tier (prix TTC, surface)
   - Extraction JSON (data->>'field')

6. **Alternatives :**
   - Colonnes g√©n√©r√©es (PG 12+)
   - Normalisation applicative
   - Index sp√©cialis√©s (GIN, GiST)

---

## Pour Aller Plus Loin

### Lectures Recommand√©es

- **Documentation officielle :** [PostgreSQL - Indexes on Expressions](https://www.postgresql.org/docs/current/indexes-expressional.html)
- **Livre :** "The Art of PostgreSQL" - Chapitre sur l'indexation avanc√©e
- **Article :** "PostgreSQL Query Optimization" - Use Case Studies

### Prochaines √âtapes

Apr√®s avoir ma√Ætris√© les index sur expressions, explorez :
- **13.5.3. Index multi-colonnes et INCLUDE** - Covering indexes
- **13.5.4. Index sur colonnes JSONB** - GIN avec jsonb_path_ops
- **11.6. Colonnes g√©n√©r√©es virtuelles** - Alternative moderne (PG 18)

### Outils Utiles

- **pg_stat_statements** - Analyser les requ√™tes utilisant expressions
- **HypoPG** - Tester des index hypoth√©tiques
- **pgBadger** - Analyser l'utilisation des index

---


‚è≠Ô∏è [Index multi-colonnes et INCLUDE (covering index)](/13-indexation-et-optimisation/05.3-index-multi-colonnes-include.md)
