üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.4.1. GIN (Generalized Inverted Index) : JSONB, Full-Text, Arrays

## Introduction

Les index GIN (Generalized Inverted Index) sont un type d'index sp√©cialis√© de PostgreSQL con√ßu pour indexer des **donn√©es composites** - c'est-√†-dire des donn√©es qui contiennent plusieurs valeurs ou √©l√©ments √† l'int√©rieur d'une seule colonne.

### Pourquoi "Inverted" (Invers√©) ?

Contrairement aux index B-Tree classiques qui associent une valeur √† une position (ligne), les index GIN font l'inverse : ils associent chaque √©l√©ment √† l'ensemble des lignes qui le contiennent. C'est le m√™me principe qu'un index dans un livre : on cherche un mot-cl√© et on trouve toutes les pages o√π il appara√Æt.

### Cas d'usage principaux

Les index GIN excellent dans trois domaines :
1. **JSONB** : Recherche dans des documents JSON
2. **Full-Text Search** : Recherche textuelle avanc√©e
3. **Arrays** : Recherche dans des tableaux

---

## 1. Comprendre le Fonctionnement des Index GIN

### Structure conceptuelle

Un index GIN ressemble √† un dictionnaire invers√© :

```
Donn√©es dans la table :
  Ligne 1: tags = ['postgresql', 'database', 'sql']
  Ligne 2: tags = ['database', 'nosql']
  Ligne 3: tags = ['postgresql', 'performance']

Index GIN cr√©√© :
  'database'    ‚Üí [Ligne 1, Ligne 2]
  'nosql'       ‚Üí [Ligne 2]
  'performance' ‚Üí [Ligne 3]
  'postgresql'  ‚Üí [Ligne 1, Ligne 3]
  'sql'         ‚Üí [Ligne 1]
```

### Avantages des index GIN

- ‚úÖ **Performance exceptionnelle** pour rechercher des √©l√©ments dans des collections
- ‚úÖ **Polyvalence** : supporte plusieurs types de donn√©es complexes
- ‚úÖ **Optimisation automatique** des requ√™tes par PostgreSQL
- ‚úÖ **Recherche rapide** de pr√©sence d'√©l√©ments (op√©rateurs `@>`, `&&`, `@`)

### Limitations √† conna√Ætre

- ‚ö†Ô∏è **Taille importante** : les index GIN sont g√©n√©ralement plus volumineux que les B-Tree
- ‚ö†Ô∏è **Mise √† jour lente** : l'insertion/modification peut √™tre plus co√ªteuse
- ‚ö†Ô∏è **Maintenance** : n√©cessite parfois des maintenances sp√©cifiques

---

## 2. GIN pour les Arrays (Tableaux)

### Principe

Les arrays PostgreSQL permettent de stocker plusieurs valeurs dans une seule colonne. Les index GIN permettent de rechercher efficacement dans ces tableaux.

### Cr√©ation d'un index GIN sur un array

```sql
-- Cr√©ation d'une table avec un array
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    titre TEXT NOT NULL,
    tags TEXT[]  -- Array de texte
);

-- Insertion de donn√©es
INSERT INTO articles (titre, tags) VALUES
    ('Introduction √† PostgreSQL', ARRAY['postgresql', 'database', 'sql', 'd√©butant']),
    ('Optimisation des requ√™tes', ARRAY['postgresql', 'performance', 'index']),
    ('NoSQL vs SQL', ARRAY['database', 'nosql', 'comparaison']),
    ('Guide MongoDB', ARRAY['mongodb', 'nosql', 'document']);

-- Cr√©ation de l'index GIN
CREATE INDEX idx_articles_tags_gin ON articles USING GIN (tags);
```

### Requ√™tes optimis√©es par l'index GIN

#### Rechercher les articles contenant un tag sp√©cifique (`@>` - contains)

```sql
-- Trouve tous les articles ayant le tag 'postgresql'
SELECT * FROM articles
WHERE tags @> ARRAY['postgresql'];

-- R√©sultat :
-- Introduction √† PostgreSQL
-- Optimisation des requ√™tes
```

#### Rechercher les articles contenant TOUS les tags d'une liste

```sql
-- Articles ayant √† la fois 'postgresql' ET 'performance'
SELECT * FROM articles
WHERE tags @> ARRAY['postgresql', 'performance'];

-- R√©sultat :
-- Optimisation des requ√™tes
```

#### Rechercher les articles contenant AU MOINS UN des tags (`&&` - overlap)

```sql
-- Articles ayant soit 'nosql' soit 'mongodb'
SELECT * FROM articles
WHERE tags && ARRAY['nosql', 'mongodb'];

-- R√©sultat :
-- NoSQL vs SQL
-- Guide MongoDB
```

#### V√©rifier si un array est contenu dans un autre (`<@` - contained by)

```sql
-- Articles dont TOUS les tags sont dans une liste autoris√©e
SELECT * FROM articles
WHERE tags <@ ARRAY['postgresql', 'database', 'sql', 'performance', 'index'];

-- R√©sultat :
-- Introduction √† PostgreSQL (ses tags sont tous dans la liste)
-- Optimisation des requ√™tes (ses tags sont tous dans la liste)
```

### Op√©rateurs support√©s pour les arrays

| Op√©rateur | Signification | Exemple |
|-----------|---------------|---------|
| `@>` | Contient (contains) | `tags @> ARRAY['sql']` |
| `<@` | Est contenu dans (contained by) | `tags <@ ARRAY['sql', 'db']` |
| `&&` | Chevauche (overlap) | `tags && ARRAY['sql', 'nosql']` |
| `=` | √âgalit√© exacte | `tags = ARRAY['sql']` |

### Bonnes pratiques pour les arrays

```sql
-- ‚úÖ BON : Utiliser l'index GIN
SELECT * FROM articles WHERE tags @> ARRAY['postgresql'];

-- ‚ùå MAUVAIS : Utilise un scan s√©quentiel (l'index ne peut pas aider)
SELECT * FROM articles WHERE 'postgresql' = ANY(tags);  -- Moins optimal

-- ‚úÖ BON : V√©rifier la pr√©sence d'un √©l√©ment avec l'op√©rateur d√©di√©
SELECT * FROM articles WHERE tags @> ARRAY['postgresql'];
```

---

## 3. GIN pour JSONB

### Principe

JSONB est un format binaire pour stocker des documents JSON dans PostgreSQL. Les index GIN permettent de rechercher efficacement dans ces structures, que ce soit par cl√©s ou par valeurs.

### Deux types d'index GIN pour JSONB

PostgreSQL propose deux strat√©gies d'indexation pour JSONB :

1. **GIN standard** (`jsonb_ops`) : Indexe toutes les cl√©s et valeurs
2. **GIN optimis√©** (`jsonb_path_ops`) : Indexe uniquement les chemins de valeurs (plus compact)

### Cr√©ation d'index GIN sur JSONB

```sql
-- Cr√©ation d'une table avec JSONB
CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    nom TEXT NOT NULL,
    specs JSONB  -- Sp√©cifications en JSON
);

-- Insertion de donn√©es
INSERT INTO produits (nom, specs) VALUES
    ('Laptop Pro', '{"marque": "TechCorp", "ram": 16, "cpu": "Intel i7", "prix": 1200, "disponible": true}'),
    ('Laptop Basic', '{"marque": "TechCorp", "ram": 8, "cpu": "Intel i5", "prix": 800, "disponible": true}'),
    ('Desktop Gaming', '{"marque": "GamePC", "ram": 32, "cpu": "AMD Ryzen 9", "prix": 2000, "disponible": false}'),
    ('Tablette', '{"marque": "TabletCo", "stockage": 128, "prix": 400, "disponible": true}');

-- INDEX GIN STANDARD (indexe tout)
CREATE INDEX idx_produits_specs_gin ON produits USING GIN (specs);

-- OU INDEX GIN OPTIMIS√â (plus compact, pour recherches par valeur uniquement)
CREATE INDEX idx_produits_specs_path_gin ON produits USING GIN (specs jsonb_path_ops);
```

### Diff√©rence entre `jsonb_ops` et `jsonb_path_ops`

```sql
-- jsonb_ops (par d√©faut) : supporte tous les op√©rateurs
CREATE INDEX idx_specs ON produits USING GIN (specs);

-- Supporte : @>, ?, ?&, ?|

-- jsonb_path_ops : plus compact, mais uniquement pour @>
CREATE INDEX idx_specs_path ON produits USING GIN (specs jsonb_path_ops);

-- Supporte uniquement : @>
-- Mais l'index est 30-50% plus petit et parfois plus rapide
```

### Requ√™tes optimis√©es par l'index GIN JSONB

#### Rechercher par cl√© existante (`?`)

```sql
-- Produits ayant une cl√© 'cpu'
SELECT nom, specs FROM produits
WHERE specs ? 'cpu';

-- R√©sultat :
-- Laptop Pro, Laptop Basic, Desktop Gaming
-- (La tablette n'a pas de cl√© 'cpu')
```

#### Rechercher par contenu exact (`@>`)

```sql
-- Produits de la marque 'TechCorp'
SELECT nom, specs FROM produits
WHERE specs @> '{"marque": "TechCorp"}';

-- R√©sultat :
-- Laptop Pro
-- Laptop Basic
```

#### Rechercher par plusieurs crit√®res

```sql
-- Produits avec 16 Go de RAM et disponibles
SELECT nom, specs FROM produits
WHERE specs @> '{"ram": 16, "disponible": true}';

-- R√©sultat :
-- Laptop Pro
```

#### Rechercher avec des valeurs num√©riques

```sql
-- Attention : JSONB conserve les types !
-- ‚úÖ BON
SELECT nom FROM produits WHERE specs @> '{"prix": 800}';

-- ‚ùå MAUVAIS (ne fonctionnera pas si prix est stock√© comme nombre)
SELECT nom FROM produits WHERE specs @> '{"prix": "800"}';
```

#### Rechercher dans des objets imbriqu√©s

```sql
-- Supposons des specs plus complexes
INSERT INTO produits (nom, specs) VALUES
    ('Laptop Ultra', '{
        "marque": "TechCorp",
        "hardware": {
            "cpu": "Intel i9",
            "ram": 32
        },
        "prix": 2500
    }');

-- Rechercher par objet imbriqu√©
SELECT nom FROM produits
WHERE specs @> '{"hardware": {"ram": 32}}';

-- R√©sultat :
-- Laptop Ultra
```

#### Utiliser l'op√©rateur de chemin (`@>`)

```sql
-- Rechercher toutes les cl√©s avec l'op√©rateur ?&
SELECT nom FROM produits
WHERE specs ?& ARRAY['marque', 'prix', 'disponible'];

-- Produits ayant AU MOINS UNE de ces cl√©s (?|)
SELECT nom FROM produits
WHERE specs ?| ARRAY['cpu', 'stockage'];
```

### Extraction de valeurs JSONB

```sql
-- Extraire une valeur (retourne JSONB)
SELECT nom, specs -> 'marque' AS marque
FROM produits;

-- Extraire une valeur (retourne TEXT)
SELECT nom, specs ->> 'marque' AS marque
FROM produits;

-- Extraire depuis un chemin imbriqu√©
SELECT nom, specs #> '{hardware, ram}' AS ram
FROM produits;

-- Extraire en TEXT depuis un chemin imbriqu√©
SELECT nom, specs #>> '{hardware, ram}' AS ram
FROM produits;
```

### Op√©rateurs JSONB support√©s

| Op√©rateur | Signification | Index√© par GIN ? |
|-----------|---------------|------------------|
| `@>` | Contient | ‚úÖ Oui (les deux types) |
| `<@` | Est contenu dans | ‚úÖ Oui (jsonb_ops uniquement) |
| `?` | A la cl√© | ‚úÖ Oui (jsonb_ops uniquement) |
| `?&` | A toutes les cl√©s | ‚úÖ Oui (jsonb_ops uniquement) |
| `?|` | A au moins une cl√© | ‚úÖ Oui (jsonb_ops uniquement) |
| `->` | Extraction (JSONB) | ‚ùå Non |
| `->>` | Extraction (TEXT) | ‚ùå Non |

### Bonnes pratiques pour JSONB

```sql
-- ‚úÖ BON : Utiliser @> pour les recherches
SELECT * FROM produits WHERE specs @> '{"marque": "TechCorp"}';

-- ‚ùå MAUVAIS : Extraire puis comparer (n'utilise pas l'index)
SELECT * FROM produits WHERE specs->>'marque' = 'TechCorp';

-- ‚úÖ BON : Index jsonb_path_ops si vous ne recherchez que par valeurs
CREATE INDEX idx_specs_path ON produits USING GIN (specs jsonb_path_ops);

-- ‚úÖ BON : Normaliser les donn√©es fr√©quemment recherch√©es
-- Si vous cherchez souvent par marque, cr√©ez une colonne d√©di√©e :
ALTER TABLE produits ADD COLUMN marque TEXT GENERATED ALWAYS AS (specs->>'marque') STORED;
CREATE INDEX idx_marque ON produits(marque);
```

---

## 4. GIN pour Full-Text Search (Recherche Textuelle)

### Principe

La recherche full-text permet de rechercher des mots ou expressions dans du texte avec une intelligence linguistique (gestion des pluriels, synonymes, etc.). PostgreSQL utilise les index GIN pour acc√©l√©rer ces recherches.

### Concepts de base

Deux types sp√©ciaux sont utilis√©s :
- **`tsvector`** : Repr√©sentation optimis√©e d'un document (liste de mots normalis√©s)
- **`tsquery`** : Repr√©sentation d'une requ√™te de recherche

### Cr√©ation d'un index GIN pour la recherche textuelle

```sql
-- Cr√©ation d'une table de documents
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    titre TEXT NOT NULL,
    contenu TEXT NOT NULL
);

-- Insertion de donn√©es
INSERT INTO documents (titre, contenu) VALUES
    ('Introduction PostgreSQL', 'PostgreSQL est un syst√®me de gestion de base de donn√©es relationnelle open-source tr√®s puissant.'),
    ('Optimisation SQL', 'Les requ√™tes SQL peuvent √™tre optimis√©es en utilisant des index appropri√©s et en analysant les plans d''ex√©cution.'),
    ('NoSQL vs SQL', 'La diff√©rence principale entre SQL et NoSQL r√©side dans la structure des donn√©es et les garanties transactionnelles.'),
    ('Guide Python', 'Python est un langage de programmation tr√®s populaire pour le d√©veloppement web et l''analyse de donn√©es.');

-- Ajout d'une colonne tsvector (optionnel mais recommand√©)
ALTER TABLE documents ADD COLUMN contenu_tsv tsvector;

-- Mise √† jour de la colonne tsvector
UPDATE documents
SET contenu_tsv = to_tsvector('french', titre || ' ' || contenu);

-- Cr√©ation de l'index GIN sur tsvector
CREATE INDEX idx_documents_fts_gin ON documents USING GIN (contenu_tsv);
```

### Recherche full-text avec index GIN

#### Recherche simple d'un mot

```sql
-- Rechercher les documents contenant 'postgresql'
SELECT titre, contenu
FROM documents
WHERE contenu_tsv @@ to_tsquery('french', 'postgresql');

-- R√©sultat :
-- Introduction PostgreSQL
```

#### Recherche avec plusieurs mots (ET logique)

```sql
-- Documents contenant 'sql' ET 'optimisation'
SELECT titre
FROM documents
WHERE contenu_tsv @@ to_tsquery('french', 'sql & optimisation');

-- R√©sultat :
-- Optimisation SQL
```

#### Recherche avec OU logique

```sql
-- Documents contenant 'python' OU 'postgresql'
SELECT titre
FROM documents
WHERE contenu_tsv @@ to_tsquery('french', 'python | postgresql');

-- R√©sultat :
-- Introduction PostgreSQL
-- Guide Python
```

#### Recherche avec n√©gation

```sql
-- Documents contenant 'sql' mais PAS 'nosql'
SELECT titre
FROM documents
WHERE contenu_tsv @@ to_tsquery('french', 'sql & !nosql');

-- R√©sultat :
-- Introduction PostgreSQL
-- Optimisation SQL
```

#### Recherche de phrase

```sql
-- Rechercher une phrase exacte (avec <->)
SELECT titre
FROM documents
WHERE contenu_tsv @@ phraseto_tsquery('french', 'base de donn√©es');

-- R√©sultat :
-- Introduction PostgreSQL
```

### Ranking et pertinence

PostgreSQL peut calculer un score de pertinence pour trier les r√©sultats :

```sql
-- Recherche avec ranking
SELECT
    titre,
    ts_rank(contenu_tsv, query) AS pertinence
FROM
    documents,
    to_tsquery('french', 'sql | donn√©es') AS query
WHERE
    contenu_tsv @@ query
ORDER BY
    pertinence DESC;

-- Les r√©sultats sont tri√©s par pertinence
```

### Recherche sans colonne tsvector pr√©-calcul√©e

Si vous n'avez pas de colonne `tsvector`, vous pouvez cr√©er un index sur une expression :

```sql
-- Index fonctionnel GIN
CREATE INDEX idx_documents_fts ON documents
USING GIN (to_tsvector('french', titre || ' ' || contenu));

-- Requ√™te (doit utiliser exactement la m√™me expression)
SELECT titre
FROM documents
WHERE to_tsvector('french', titre || ' ' || contenu) @@ to_tsquery('french', 'postgresql');
```

### Dictionnaires et langues

PostgreSQL supporte plusieurs langues avec leurs r√®gles linguistiques :

```sql
-- Fran√ßais
to_tsvector('french', 'Les bases de donn√©es sont essentielles')
-- R√©sultat : 'bas':2 'donn':4 'essentiell':6

-- Anglais
to_tsvector('english', 'Databases are essential')
-- R√©sultat : 'databas':1 'essenti':3

-- Simple (sans r√®gles linguistiques)
to_tsvector('simple', 'Les bases de donn√©es')
-- R√©sultat : 'bases':2 'de':3 'donn√©es':4 'les':1
```

### Maintenir √† jour le tsvector automatiquement

```sql
-- Cr√©er un trigger pour mettre √† jour automatiquement
CREATE OR REPLACE FUNCTION documents_tsv_trigger() RETURNS trigger AS $$
BEGIN
    NEW.contenu_tsv := to_tsvector('french', NEW.titre || ' ' || NEW.contenu);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tsvector_update
BEFORE INSERT OR UPDATE ON documents
FOR EACH ROW EXECUTE FUNCTION documents_tsv_trigger();

-- Maintenant, les insertions et mises √† jour mettent √† jour le tsvector automatiquement
INSERT INTO documents (titre, contenu) VALUES
    ('Nouveau document', 'Contenu du nouveau document sur PostgreSQL');
-- contenu_tsv est automatiquement calcul√©
```

### Pond√©ration et recherche multi-champs

```sql
-- Donner plus d'importance au titre qu'au contenu
ALTER TABLE documents ADD COLUMN tsv_weighted tsvector;

UPDATE documents
SET tsv_weighted =
    setweight(to_tsvector('french', titre), 'A') ||
    setweight(to_tsvector('french', contenu), 'B');

CREATE INDEX idx_documents_weighted ON documents USING GIN (tsv_weighted);

-- Recherche avec pond√©ration
SELECT
    titre,
    ts_rank(tsv_weighted, query) AS score
FROM
    documents,
    to_tsquery('french', 'postgresql') AS query
WHERE
    tsv_weighted @@ query
ORDER BY
    score DESC;
```

### Op√©rateurs de recherche textuelle

| Op√©rateur | Syntaxe tsquery | Signification | Exemple |
|-----------|----------------|---------------|---------|
| AND | `&` | ET logique | `'sql & base'` |
| OR | `|` | OU logique | `'sql | nosql'` |
| NOT | `!` | N√©gation | `'sql & !nosql'` |
| Phrase | `<->` | Mots adjacents | `'base <-> donn√©es'` |
| Proximit√© | `<N>` | N mots d'√©cart max | `'base <2> donn√©es'` |

### Fonctions utiles pour Full-Text Search

```sql
-- Convertir texte en tsvector
to_tsvector('french', 'texte')

-- Convertir cha√Æne en tsquery
to_tsquery('french', 'mot1 & mot2')

-- Convertir phrase en tsquery
phraseto_tsquery('french', 'phrase exacte')

-- Convertir recherche simple en tsquery (tol√©rant)
plainto_tsquery('french', 'mots quelconques')

-- Calculer le ranking
ts_rank(tsvector, tsquery)
ts_rank_cd(tsvector, tsquery)  -- Ranking avec densit√©

-- Mettre en √©vidence les termes trouv√©s
ts_headline('french', texte, tsquery)
```

### Exemple complet avec mise en √©vidence

```sql
-- Recherche avec mise en √©vidence des r√©sultats
SELECT
    titre,
    ts_headline('french', contenu, query, 'MaxWords=50, MinWords=20') AS extrait,
    ts_rank(contenu_tsv, query) AS score
FROM
    documents,
    to_tsquery('french', 'postgresql | base') AS query
WHERE
    contenu_tsv @@ query
ORDER BY
    score DESC;

-- R√©sultat :
-- titre: Introduction PostgreSQL
-- extrait: <b>PostgreSQL</b> est un syst√®me de gestion de <b>base</b> de donn√©es...
-- score: 0.0607927
```

---

## 5. Comparaison et Choix d'Index GIN

### Quand utiliser un index GIN ?

‚úÖ **Utilisez GIN pour :**
- Colonnes contenant des **arrays**
- Colonnes **JSONB** avec recherches fr√©quentes
- Recherche **full-text** (tsvector)
- Colonnes avec **plusieurs valeurs** par ligne
- Op√©rateurs sp√©cifiques : `@>`, `&&`, `?`, `@@`

‚ùå **N'utilisez PAS GIN pour :**
- Colonnes simples (pr√©f√©rez B-Tree)
- Recherches d'√©galit√© stricte (B-Tree est plus efficace)
- Colonnes fr√©quemment mises √† jour (GIN est co√ªteux en √©criture)
- Recherches de range (utiliser B-Tree ou BRIN)

### Comparaison : GIN vs B-Tree

| Crit√®re | B-Tree | GIN |
|---------|--------|-----|
| **Type de donn√©es** | Scalaires simples | Composites (arrays, JSONB, tsvector) |
| **Taille index** | Compact | Volumineux (2-3√ó les donn√©es) |
| **Performance lecture** | Excellente (√©galit√©, range) | Excellente (containment) |
| **Performance √©criture** | Rapide | Lente |
| **Cas d'usage** | WHERE id = 42, WHERE date > '2024-01-01' | WHERE tags @> ARRAY['sql'], WHERE doc @@ 'search' |

### Comparaison : GIN vs GiST

| Crit√®re | GIN | GiST |
|---------|-----|------|
| **Performance recherche** | Plus rapide | L√©g√®rement plus lent |
| **Taille index** | Plus volumineux | Plus compact |
| **Performance √©criture** | Plus lente | Plus rapide |
| **Utilisation** | JSONB, arrays, full-text (privil√©gier) | Donn√©es g√©om√©triques, full-text (alternatif) |
| **Recommandation** | Par d√©faut pour JSONB/arrays | Si beaucoup d'√©critures |

---

## 6. Performance et Optimisations

### Param√®tres de configuration GIN

PostgreSQL offre des param√®tres pour optimiser le comportement des index GIN :

```sql
-- Param√®tres au niveau de l'index (lors de la cr√©ation)
CREATE INDEX idx_documents_fts ON documents
USING GIN (contenu_tsv)
WITH (fastupdate = on, gin_pending_list_limit = 4096);
```

#### `fastupdate`
- **Par d√©faut** : `on`
- **Description** : Les mises √† jour sont bufferis√©es avant d'√™tre int√©gr√©es √† l'index
- **Avantage** : Am√©liore les performances d'√©criture
- **Inconv√©nient** : Recherches l√©g√®rement plus lentes tant que le buffer n'est pas vid√©

#### `gin_pending_list_limit`
- **Par d√©faut** : 4 Mo
- **Description** : Taille maximale du buffer de mises √† jour en attente
- **Recommandation** : Augmenter pour les syst√®mes avec beaucoup d'√©critures

### Maintenance des index GIN

```sql
-- Vider manuellement le buffer des mises √† jour en attente
VACUUM documents;

-- Reconstruire compl√®tement l'index (si fragment√©)
REINDEX INDEX idx_documents_fts_gin;

-- Analyser les statistiques (important pour le planificateur)
ANALYZE documents;
```

### Surveiller la taille et l'utilisation

```sql
-- Taille de l'index
SELECT
    pg_size_pretty(pg_relation_size('idx_documents_fts_gin')) AS taille_index;

-- Statistiques d'utilisation
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan AS nombre_utilisations,
    idx_tup_read AS lignes_lues,
    idx_tup_fetch AS lignes_retournees
FROM
    pg_stat_user_indexes
WHERE
    indexname = 'idx_documents_fts_gin';
```

### Optimiser les requ√™tes

```sql
-- ‚úÖ BON : Utilise l'index GIN
EXPLAIN ANALYZE
SELECT * FROM produits WHERE specs @> '{"marque": "TechCorp"}';

-- Plan d'ex√©cution attendu :
-- Bitmap Index Scan on idx_produits_specs_gin

-- ‚ùå MAUVAIS : Ne peut pas utiliser l'index
EXPLAIN ANALYZE
SELECT * FROM produits WHERE specs->>'marque' = 'TechCorp';

-- Plan d'ex√©cution :
-- Seq Scan (scan s√©quentiel, tr√®s lent sur grandes tables)
```

### Strat√©gies d'optimisation

1. **Utiliser les bons op√©rateurs**
   ```sql
   -- ‚úÖ Optimis√©
   WHERE tags @> ARRAY['postgresql']

   -- ‚ùå Non optimis√©
   WHERE 'postgresql' = ANY(tags)
   ```

2. **Pr√©-calculer les tsvector**
   ```sql
   -- ‚úÖ Plus rapide (colonne pr√©-calcul√©e)
   ALTER TABLE documents ADD COLUMN tsv tsvector;
   CREATE INDEX ON documents USING GIN (tsv);

   -- ‚ùå Plus lent (calcul √† chaque requ√™te)
   CREATE INDEX ON documents USING GIN (to_tsvector('french', contenu));
   ```

3. **Choisir le bon type d'index GIN pour JSONB**
   ```sql
   -- Pour recherches uniquement par @>
   CREATE INDEX idx_path ON produits USING GIN (specs jsonb_path_ops);

   -- Pour recherches vari√©es (?, ?&, ?|, @>)
   CREATE INDEX idx_ops ON produits USING GIN (specs jsonb_ops);
   ```

---

## 7. Exemples Concrets et Cas d'Usage

### Cas 1 : Application de blog avec tags

```sql
-- Table d'articles avec tags
CREATE TABLE blog_articles (
    id SERIAL PRIMARY KEY,
    titre TEXT NOT NULL,
    contenu TEXT NOT NULL,
    tags TEXT[],
    date_publication TIMESTAMPTZ DEFAULT NOW()
);

-- Index GIN sur les tags
CREATE INDEX idx_blog_tags ON blog_articles USING GIN (tags);

-- Rechercher tous les articles sur PostgreSQL
SELECT titre, tags, date_publication
FROM blog_articles
WHERE tags @> ARRAY['postgresql']
ORDER BY date_publication DESC;

-- Rechercher des articles ayant plusieurs tags
SELECT titre
FROM blog_articles
WHERE tags @> ARRAY['postgresql', 'performance'];

-- Rechercher des articles li√©s √† la base de donn√©es (plusieurs tags possibles)
SELECT titre, tags
FROM blog_articles
WHERE tags && ARRAY['postgresql', 'mysql', 'mongodb', 'database'];
```

### Cas 2 : E-commerce avec catalogue produit en JSONB

```sql
-- Catalogue produit avec sp√©cifications flexibles
CREATE TABLE catalogue (
    id SERIAL PRIMARY KEY,
    nom TEXT NOT NULL,
    categorie TEXT NOT NULL,
    specifications JSONB,
    prix NUMERIC(10,2)
);

-- Index GIN optimis√© pour recherche par valeurs
CREATE INDEX idx_catalogue_specs ON catalogue USING GIN (specifications jsonb_path_ops);

-- Rechercher des ordinateurs portables avec au moins 16 Go de RAM
SELECT nom, specifications->>'ram' AS ram, prix
FROM catalogue
WHERE specifications @> '{"type": "laptop", "ram": 16}';

-- Rechercher des produits disponibles d'une marque
SELECT nom, prix
FROM catalogue
WHERE specifications @> '{"marque": "Dell", "disponible": true}';

-- Rechercher des produits avec certaines caract√©ristiques
SELECT nom, prix
FROM catalogue
WHERE specifications @> '{"couleur": "noir"}'
  AND specifications @> '{"garantie": 3}';

-- Compter les produits par disponibilit√©
SELECT
    specifications->>'disponible' AS disponible,
    COUNT(*) AS nombre
FROM catalogue
WHERE specifications ? 'disponible'
GROUP BY specifications->>'disponible';
```

### Cas 3 : Base de connaissances avec recherche full-text

```sql
-- Base de connaissances
CREATE TABLE kb_articles (
    id SERIAL PRIMARY KEY,
    titre TEXT NOT NULL,
    contenu TEXT NOT NULL,
    categorie TEXT,
    auteur TEXT,
    date_creation TIMESTAMPTZ DEFAULT NOW(),
    tsv tsvector
);

-- Trigger pour maintenir tsvector √† jour
CREATE OR REPLACE FUNCTION kb_tsv_trigger() RETURNS trigger AS $$
BEGIN
    NEW.tsv := setweight(to_tsvector('french', COALESCE(NEW.titre, '')), 'A') ||
               setweight(to_tsvector('french', COALESCE(NEW.contenu, '')), 'B');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tsv_update
BEFORE INSERT OR UPDATE ON kb_articles
FOR EACH ROW EXECUTE FUNCTION kb_tsv_trigger();

-- Index GIN pour recherche
CREATE INDEX idx_kb_fts ON kb_articles USING GIN (tsv);

-- Recherche avec ranking
SELECT
    titre,
    categorie,
    ts_rank(tsv, query) AS score,
    ts_headline('french', contenu, query, 'MaxWords=50') AS extrait
FROM
    kb_articles,
    plainto_tsquery('french', 'postgresql performance index') AS query
WHERE
    tsv @@ query
ORDER BY
    score DESC
LIMIT 10;

-- Recherche par cat√©gorie avec full-text
SELECT titre, auteur
FROM kb_articles
WHERE categorie = 'Database'
  AND tsv @@ to_tsquery('french', 'optimisation & requ√™te');

-- Compter les articles par terme de recherche
SELECT
    COUNT(*) FILTER (WHERE tsv @@ to_tsquery('french', 'postgresql')) AS articles_postgresql,
    COUNT(*) FILTER (WHERE tsv @@ to_tsquery('french', 'mysql')) AS articles_mysql,
    COUNT(*) FILTER (WHERE tsv @@ to_tsquery('french', 'mongodb')) AS articles_mongodb
FROM kb_articles;
```

### Cas 4 : Syst√®me de permissions avec arrays

```sql
-- Utilisateurs avec permissions
CREATE TABLE utilisateurs (
    id SERIAL PRIMARY KEY,
    nom TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    permissions TEXT[]
);

-- Index GIN sur permissions
CREATE INDEX idx_users_perms ON utilisateurs USING GIN (permissions);

-- V√©rifier si un utilisateur a une permission
SELECT nom, email
FROM utilisateurs
WHERE permissions @> ARRAY['admin'];

-- Trouver les utilisateurs ayant toutes ces permissions
SELECT nom, permissions
FROM utilisateurs
WHERE permissions @> ARRAY['read', 'write', 'delete'];

-- Trouver les utilisateurs ayant au moins une permission d'administration
SELECT nom, email
FROM utilisateurs
WHERE permissions && ARRAY['admin', 'superadmin', 'moderator'];

-- Compter les permissions par utilisateur
SELECT
    nom,
    array_length(permissions, 1) AS nb_permissions,
    permissions
FROM utilisateurs
ORDER BY nb_permissions DESC;
```

---

## 8. Pi√®ges Courants et Solutions

### Pi√®ge 1 : Mauvais op√©rateur

```sql
-- ‚ùå PROBL√àME : N'utilise pas l'index GIN
SELECT * FROM articles WHERE 'postgresql' = ANY(tags);

-- ‚úÖ SOLUTION : Utiliser l'op√©rateur appropri√©
SELECT * FROM articles WHERE tags @> ARRAY['postgresql'];
```

### Pi√®ge 2 : Type incorrect dans JSONB

```sql
-- ‚ùå PROBL√àME : Le prix est un nombre, pas une cha√Æne
SELECT * FROM produits WHERE specs @> '{"prix": "1200"}';

-- ‚úÖ SOLUTION : Respecter le type
SELECT * FROM produits WHERE specs @> '{"prix": 1200}';
```

### Pi√®ge 3 : Expression diff√©rente de l'index

```sql
-- Index cr√©√© sur une expression
CREATE INDEX idx_docs_fts ON documents USING GIN (to_tsvector('french', contenu));

-- ‚ùå PROBL√àME : Expression diff√©rente
SELECT * FROM documents WHERE to_tsvector('english', contenu) @@ to_tsquery('english', 'postgresql');

-- ‚úÖ SOLUTION : Utiliser exactement la m√™me expression et langue
SELECT * FROM documents WHERE to_tsvector('french', contenu) @@ to_tsquery('french', 'postgresql');
```

### Pi√®ge 4 : Index non utilis√© sur JSONB

```sql
-- ‚ùå PROBL√àME : Extraction puis comparaison
SELECT * FROM produits WHERE specs->>'marque' = 'TechCorp';

-- ‚úÖ SOLUTION : Utiliser l'op√©rateur @>
SELECT * FROM produits WHERE specs @> '{"marque": "TechCorp"}';
```

### Pi√®ge 5 : Choix du mauvais type d'index GIN pour JSONB

```sql
-- Si vous avez cr√©√© un index jsonb_path_ops
CREATE INDEX idx_specs ON produits USING GIN (specs jsonb_path_ops);

-- ‚ùå PROBL√àME : Cet index ne supporte pas l'op√©rateur ?
SELECT * FROM produits WHERE specs ? 'marque';
-- Erreur ou scan s√©quentiel

-- ‚úÖ SOLUTION : Utiliser jsonb_ops si vous avez besoin de ?
DROP INDEX idx_specs;
CREATE INDEX idx_specs ON produits USING GIN (specs jsonb_ops);
```

---

## 9. Checklist de Bonnes Pratiques

### ‚úÖ Conception

- [ ] Utiliser GIN pour arrays, JSONB et tsvector uniquement
- [ ] Choisir `jsonb_path_ops` si seul `@>` est n√©cessaire
- [ ] Pr√©-calculer les colonnes tsvector avec des triggers
- [ ] Donner des noms explicites aux index (`idx_[table]_[colonne]_gin`)

### ‚úÖ Performance

- [ ] V√©rifier avec `EXPLAIN ANALYZE` que l'index est utilis√©
- [ ] Configurer `gin_pending_list_limit` pour syst√®mes avec √©critures fr√©quentes
- [ ] Ex√©cuter `ANALYZE` apr√®s cr√©ation/modification d'index
- [ ] Monitorer la taille des index avec `pg_relation_size`

### ‚úÖ Maintenance

- [ ] Ex√©cuter `VACUUM` r√©guli√®rement (automatique ou manuel)
- [ ] Planifier des `REINDEX` si fragmentation importante
- [ ] Surveiller les statistiques d'utilisation (`pg_stat_user_indexes`)
- [ ] Documenter les index et leur raison d'√™tre

### ‚úÖ Requ√™tes

- [ ] Utiliser les op√©rateurs natifs (`@>`, `&&`, `?`, `@@`)
- [ ] Respecter les types dans JSONB (nombres, bool√©ens)
- [ ] Utiliser la m√™me expression que l'index pour les index fonctionnels
- [ ] √âviter les extractions puis comparaisons (`->>`  puis `=`)

---

## 10. Ressources et Pour Aller Plus Loin

### Documentation officielle PostgreSQL 18

- [Index Types - GIN](https://www.postgresql.org/docs/18/gin.html)
- [Full-Text Search](https://www.postgresql.org/docs/18/textsearch.html)
- [JSONB Functions and Operators](https://www.postgresql.org/docs/18/functions-json.html)
- [Array Functions and Operators](https://www.postgresql.org/docs/18/functions-array.html)

### Lectures compl√©mentaires recommand√©es

- **"The Art of PostgreSQL"** - Dimitri Fontaine : Chapitre sur les index avanc√©s
- **"Mastering PostgreSQL"** - Hans-J√ºrgen Sch√∂nig : Optimisation avec GIN
- Blog officiel PostgreSQL : Articles sur les nouveaut√©s et optimisations

### Outils de monitoring

- **pg_stat_statements** : Analyser les requ√™tes les plus co√ªteuses
- **pgBadger** : Analyser les logs PostgreSQL
- **pgAdmin 4** : Interface graphique pour visualiser les index

### Communaut√©

- **Mailing list pgsql-performance** : Questions de performance
- **Reddit r/PostgreSQL** : Discussions et conseils
- **Stack Overflow** : Tag `postgresql`

---

## Conclusion

Les index GIN sont un outil puissant et essentiel dans PostgreSQL pour g√©rer efficacement les **donn√©es composites**. Que ce soit pour indexer des **arrays**, rechercher dans du **JSONB** ou effectuer du **full-text search**, les index GIN offrent des performances exceptionnelles pour des cas d'usage impossibles avec des index B-Tree classiques.

### Points cl√©s √† retenir

1. **GIN = Index invers√©** : Chaque √©l√©ment pointe vers les lignes qui le contiennent
2. **Trois domaines principaux** : Arrays, JSONB, Full-Text Search
3. **Op√©rateurs sp√©cifiques** : `@>`, `&&`, `?`, `@@` - utiliser les bons op√©rateurs est crucial
4. **Trade-off** : Excellent en lecture, plus co√ªteux en √©criture
5. **Maintenance** : VACUUM et ANALYZE r√©guliers pour performance optimale

### Quand utiliser GIN ?

‚úÖ **OUI** : Colonnes avec arrays, JSONB, recherche textuelle
‚ùå **NON** : Colonnes scalaires simples (pr√©f√©rer B-Tree)

Avec une bonne compr√©hension des index GIN, vous pouvez concevoir des syst√®mes PostgreSQL performants capables de g√©rer des requ√™tes complexes sur des donn√©es semi-structur√©es avec une grande efficacit√© !

---


‚è≠Ô∏è [GiST (Generalized Search Tree) : G√©om√©trie, Texte, ltree](/13-indexation-et-optimisation/04.2-gist-generalized-search-tree.md)
