üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.5.4. Index sur Colonnes JSONB (GIN avec jsonb_path_ops)

## Introduction

PostgreSQL offre un support natif et puissant pour les donn√©es **JSON** et **JSONB** (JSON Binary). Le type JSONB permet de stocker des donn√©es semi-structur√©es tout en b√©n√©ficiant de capacit√©s d'indexation avanc√©es gr√¢ce aux **index GIN** (Generalized Inverted Index).

Ce chapitre explore comment indexer efficacement les colonnes JSONB, notamment avec l'op√©rateur de classe **jsonb_path_ops**, pour optimiser les requ√™tes sur des donn√©es JSON complexes.

---

## JSON vs JSONB : Rappel Essentiel

### Diff√©rences Fondamentales

```sql
-- JSON : Stockage textuel (comme du VARCHAR)
CREATE TABLE logs_json (
    id SERIAL PRIMARY KEY,
    data JSON
);

-- JSONB : Stockage binaire (d√©compos√© et optimis√©)
CREATE TABLE logs_jsonb (
    id SERIAL PRIMARY KEY,
    data JSONB
);
```

| Crit√®re | JSON | JSONB |
|---------|------|-------|
| **Stockage** | Texte brut | Format binaire d√©compos√© |
| **Performance lecture** | Lente (parsing √† chaque fois) | Rapide (d√©j√† pars√©) |
| **Performance √©criture** | Rapide (pas de traitement) | Plus lente (d√©composition) |
| **Indexation** | Limit√©e | Compl√®te (GIN, GiST) |
| **Ordre des cl√©s** | Pr√©serv√© | Non pr√©serv√© |
| **Espaces blancs** | Pr√©serv√©s | Supprim√©s |
| **Doublons de cl√©s** | Permis | Derni√®re valeur conserv√©e |

**Recommandation :** Utilisez **JSONB** sauf si vous devez absolument pr√©server l'ordre exact du JSON d'origine.

### Exemple de Donn√©es JSONB

```sql
-- Table de produits avec m√©tadonn√©es JSON
CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    prix NUMERIC(10,2),
    metadata JSONB
);

-- Ins√©rer des donn√©es
INSERT INTO produits (nom, prix, metadata) VALUES
    ('Laptop Pro', 1299.99, '{
        "marque": "TechCorp",
        "specs": {
            "cpu": "Intel i7",
            "ram": "16GB",
            "storage": "512GB SSD"
        },
        "tags": ["professionnel", "portable", "performant"],
        "disponible": true,
        "stock": 45
    }'),
    ('Souris Gaming', 79.99, '{
        "marque": "GamerGear",
        "specs": {
            "dpi": 16000,
            "boutons": 8,
            "sans_fil": true
        },
        "tags": ["gaming", "sans-fil", "rgb"],
        "disponible": true,
        "stock": 120
    }');
```

---

## Pourquoi Indexer les Colonnes JSONB ?

### Sans Index : Probl√®me de Performance

```sql
-- Recherche sans index : Scan s√©quentiel
SELECT * FROM produits
WHERE metadata->>'marque' = 'TechCorp';

-- EXPLAIN ANALYZE :
-- Seq Scan on produits  (cost=0.00..1250.00 rows=50 width=...)
--   Filter: ((metadata ->> 'marque'::text) = 'TechCorp'::text)
--   Rows Removed by Filter: 99950
-- Planning Time: 0.123 ms
-- Execution Time: 2847.456 ms  ‚Üê TR√àS LENT sur 100K lignes !
```

**Probl√®me :** PostgreSQL doit :
1. Parcourir **toutes les lignes** (Seq Scan)
2. D√©coder chaque colonne JSONB
3. Extraire la cl√© `marque`
4. Comparer la valeur

### Avec Index : Performance Optimale

```sql
-- Cr√©er un index GIN
CREATE INDEX idx_metadata_gin ON produits USING gin(metadata);

-- M√™me requ√™te
SELECT * FROM produits
WHERE metadata @> '{"marque": "TechCorp"}';

-- EXPLAIN ANALYZE :
-- Bitmap Index Scan on idx_metadata_gin  (cost=4.43..104.43 rows=50 width=...)
--   Index Cond: (metadata @> '{"marque": "TechCorp"}'::jsonb)
-- Planning Time: 0.098 ms
-- Execution Time: 12.345 ms  ‚Üê 230√ó PLUS RAPIDE !
```

---

## Op√©rateurs JSONB Essentiels

Avant d'aborder l'indexation, comprenons les op√©rateurs JSONB :

### 1. Op√©rateurs d'Extraction

```sql
-- -> : Obtenir un objet JSON (r√©sultat : JSONB)
SELECT metadata->'specs' FROM produits;
-- R√©sultat : {"cpu": "Intel i7", "ram": "16GB", ...}

-- ->> : Obtenir une valeur texte (r√©sultat : TEXT)
SELECT metadata->>'marque' FROM produits;
-- R√©sultat : TechCorp

-- #> : Chemin dans l'objet (r√©sultat : JSONB)
SELECT metadata#>'{specs, cpu}' FROM produits;
-- R√©sultat : "Intel i7"

-- #>> : Chemin dans l'objet (r√©sultat : TEXT)
SELECT metadata#>>'{specs, cpu}' FROM produits;
-- R√©sultat : Intel i7
```

### 2. Op√©rateurs de Recherche (Indexables avec GIN)

```sql
-- @> : Contient (l'objet √† gauche contient celui de droite)
SELECT * FROM produits
WHERE metadata @> '{"marque": "TechCorp"}';

-- <@ : Est contenu dans (inverse de @>)
SELECT * FROM produits
WHERE '{"marque": "TechCorp"}' <@ metadata;

-- ? : Cl√© existe
SELECT * FROM produits
WHERE metadata ? 'marque';

-- ?| : Au moins une des cl√©s existe (OR)
SELECT * FROM produits
WHERE metadata ?| ARRAY['marque', 'fabricant'];

-- ?& : Toutes les cl√©s existent (AND)
SELECT * FROM produits
WHERE metadata ?& ARRAY['marque', 'specs', 'tags'];

-- @? : JSONPath query (PostgreSQL 12+)
SELECT * FROM produits
WHERE metadata @? '$.specs.ram == "16GB"';
```

**Important :** Les op√©rateurs `@>`, `?`, `?|`, `?&` sont **optimis√©s** par les index GIN.

---

## Index GIN : Concept

### Qu'est-ce qu'un Index GIN ?

**GIN** (Generalized Inverted Index) est un index invers√©, similaire √† un index de livre :

**Analogie avec un index de livre :**
- **Livre normal :** Page 1 ‚Üí Contenu, Page 2 ‚Üí Contenu, etc.
- **Index de livre :** "PostgreSQL" ‚Üí Pages 12, 45, 78, 134

**GIN pour JSONB :**
- Indexe **toutes les cl√©s et valeurs** du JSON
- Cr√©e une correspondance : `cl√©/valeur ‚Üí lignes contenant cette cl√©/valeur`

### Structure Interne Simplifi√©e

```
Index GIN sur metadata :

"marque" -> "TechCorp"   ‚Üí lignes [1, 45, 123, 456]
"marque" -> "GamerGear"  ‚Üí lignes [2, 67, 234, 789]
"specs" -> "cpu"         ‚Üí lignes [1, 3, 5, 7, ...]
"tags" -> "gaming"       ‚Üí lignes [2, 4, 8, 12, ...]
"disponible" -> true     ‚Üí lignes [1, 2, 3, 4, ...]
...
```

**Avantage :** Recherche ultra-rapide par cl√©/valeur.

**Inconv√©nient :** Index plus volumineux (indexe toutes les cl√©s et valeurs).

---

## Types d'Index GIN pour JSONB

PostgreSQL offre **deux classes d'op√©rateurs** pour les index GIN sur JSONB :

### 1. GIN Standard (jsonb_ops) - Par D√©faut

```sql
CREATE INDEX idx_metadata_gin ON produits USING gin(metadata);
-- √âquivalent √† :
CREATE INDEX idx_metadata_gin ON produits USING gin(metadata jsonb_ops);
```

**Caract√©ristiques :**
- Indexe **toutes les cl√©s et valeurs** r√©cursivement
- Supporte **tous les op√©rateurs JSONB**
- Index plus volumineux
- Plus flexible

**Op√©rateurs support√©s :**
- `@>` (contient)
- `?` (cl√© existe)
- `?|` (au moins une cl√© existe)
- `?&` (toutes les cl√©s existent)
- `@?` (JSONPath)

### 2. GIN Optimis√© (jsonb_path_ops)

```sql
CREATE INDEX idx_metadata_path_ops ON produits USING gin(metadata jsonb_path_ops);
```

**Caract√©ristiques :**
- Indexe uniquement les **chemins complets cl√©‚Üívaleur**
- Supporte **uniquement l'op√©rateur @>**
- Index **3√ó plus compact**
- **Plus rapide** pour les requ√™tes `@>`
- **Moins flexible** (pas de `?`, `?|`, `?&`)

**Op√©rateur support√© :**
- `@>` (contient) uniquement

---

## GIN Standard (jsonb_ops) : D√©tails

### Quand l'Utiliser ?

Utilisez GIN standard si vous avez besoin de :
- V√©rifier l'**existence de cl√©s** (`?`, `?|`, `?&`)
- Requ√™tes **vari√©es** sur le JSON
- Flexibilit√© maximale

### Exemples d'Utilisation

```sql
-- Cr√©er l'index
CREATE INDEX idx_metadata_gin ON produits USING gin(metadata);
```

**Requ√™tes support√©es :**

```sql
-- 1. Contient (@>)
SELECT * FROM produits
WHERE metadata @> '{"marque": "TechCorp"}';

-- 2. Cl√© existe (?)
SELECT * FROM produits
WHERE metadata ? 'marque';

-- 3. Au moins une cl√© existe (?|)
SELECT * FROM produits
WHERE metadata ?| ARRAY['marque', 'fabricant', 'constructeur'];

-- 4. Toutes les cl√©s existent (?&)
SELECT * FROM produits
WHERE metadata ?& ARRAY['marque', 'specs', 'tags'];

-- 5. Recherche dans sous-objet
SELECT * FROM produits
WHERE metadata @> '{"specs": {"cpu": "Intel i7"}}';

-- 6. Recherche dans tableau
SELECT * FROM produits
WHERE metadata @> '{"tags": ["gaming"]}';
```

### Taille de l'Index

```sql
-- V√©rifier la taille
SELECT pg_size_pretty(pg_relation_size('idx_metadata_gin'));
-- R√©sultat typique : 45 MB pour 100K lignes
```

---

## GIN Optimis√© (jsonb_path_ops) : D√©tails

### Quand l'Utiliser ?

Utilisez `jsonb_path_ops` si :
- Vous utilisez **uniquement l'op√©rateur @>**
- Vous cherchez des **valeurs sp√©cifiques** dans le JSON
- L'**espace disque** est une contrainte
- Vous voulez le **maximum de performance** pour `@>`

### Diff√©rence Technique

**jsonb_ops indexe :**
```
"marque"           ‚Üí lignes [1, 2, 3, ...]
"TechCorp"         ‚Üí lignes [1, 45, 123, ...]
"specs"            ‚Üí lignes [1, 2, 3, ...]
"cpu"              ‚Üí lignes [1, 3, 7, ...]
"Intel i7"         ‚Üí lignes [1, 12, 34, ...]
...
```

**jsonb_path_ops indexe :**
```
marque ‚Üí TechCorp           ‚Üí lignes [1, 45, 123, ...]
specs ‚Üí cpu ‚Üí Intel i7      ‚Üí lignes [1, 12, 34, ...]
tags ‚Üí [0] ‚Üí gaming         ‚Üí lignes [2, 4, 8, ...]
...
```

**Cons√©quence :**
- `jsonb_path_ops` ne peut pas r√©pondre √† "Quelles lignes ont la cl√© 'marque' ?" (`?`)
- Mais il r√©pond tr√®s bien √† "Quelles lignes ont marque = 'TechCorp' ?" (`@>`)

### Exemples d'Utilisation

```sql
-- Cr√©er l'index optimis√©
CREATE INDEX idx_metadata_path_ops ON produits USING gin(metadata jsonb_path_ops);
```

**Requ√™tes support√©es :**

```sql
-- ‚úÖ Support√© : Contient (@>)
SELECT * FROM produits
WHERE metadata @> '{"marque": "TechCorp"}';

-- ‚úÖ Support√© : Sous-objet
SELECT * FROM produits
WHERE metadata @> '{"specs": {"cpu": "Intel i7"}}';

-- ‚úÖ Support√© : Valeur dans tableau
SELECT * FROM produits
WHERE metadata @> '{"tags": ["gaming"]}';

-- ‚úÖ Support√© : Multiples conditions
SELECT * FROM produits
WHERE metadata @> '{"marque": "TechCorp", "disponible": true}';

-- ‚ùå NON support√© : Existence de cl√© (?)
SELECT * FROM produits
WHERE metadata ? 'marque';
-- Erreur ou Seq Scan (l'index n'est pas utilis√©)

-- ‚ùå NON support√© : Existence multiple (?|, ?&)
SELECT * FROM produits
WHERE metadata ?| ARRAY['marque', 'fabricant'];
```

### Taille de l'Index

```sql
-- Comparer les tailles
SELECT
    pg_size_pretty(pg_relation_size('idx_metadata_gin')) AS "jsonb_ops",
    pg_size_pretty(pg_relation_size('idx_metadata_path_ops')) AS "jsonb_path_ops";

-- R√©sultat typique :
-- jsonb_ops     | jsonb_path_ops
-- 45 MB         | 15 MB
```

**Gain d'espace : 3√ó plus compact !**

---

## Comparaison : jsonb_ops vs jsonb_path_ops

| Crit√®re | jsonb_ops (Standard) | jsonb_path_ops (Optimis√©) |
|---------|----------------------|---------------------------|
| **Taille index** | Plus volumineux | **3√ó plus compact** |
| **Performance @>** | Rapide | **Plus rapide** (10-20% gain) |
| **Op√©rateur @>** | ‚úÖ Support√© | ‚úÖ Support√© |
| **Op√©rateur ?** | ‚úÖ Support√© | ‚ùå Non support√© |
| **Op√©rateurs ?| et ?&** | ‚úÖ Support√©s | ‚ùå Non support√©s |
| **Op√©rateur @?** | ‚úÖ Support√© | ‚ö†Ô∏è Partiel |
| **Flexibilit√©** | Maximale | Limit√©e √† @> |
| **Cas d'usage** | Requ√™tes vari√©es | Recherches de valeurs sp√©cifiques |
| **Maintenance** | Co√ªt normal | Co√ªt l√©g√®rement r√©duit |

### Recommandation

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Utilisez jsonb_path_ops si :        ‚îÇ
‚îÇ ‚Ä¢ Vous utilisez uniquement @>       ‚îÇ
‚îÇ ‚Ä¢ Performance max est prioritaire   ‚îÇ
‚îÇ ‚Ä¢ Espace disque limit√©              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Utilisez jsonb_ops si :             ‚îÇ
‚îÇ ‚Ä¢ Vous utilisez ?, ?|, ?&           ‚îÇ
‚îÇ ‚Ä¢ Requ√™tes vari√©es                  ‚îÇ
‚îÇ ‚Ä¢ Flexibilit√© importante            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Exemples Pratiques Complets

### Exemple 1 : E-Commerce avec M√©tadonn√©es Produits

**Contexte :** Catalogue de 500K produits avec attributs variables.

```sql
-- Table de produits
CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    categorie VARCHAR(100),
    prix NUMERIC(10,2),
    attributs JSONB  -- Attributs variables selon la cat√©gorie
);

-- Exemples de donn√©es
INSERT INTO produits (nom, categorie, prix, attributs) VALUES
    ('Laptop Dell XPS', 'Informatique', 1499.99, '{
        "marque": "Dell",
        "processeur": "Intel i7-12700H",
        "ram": "16GB",
        "stockage": "512GB SSD",
        "ecran": "15.6 pouces",
        "os": "Windows 11",
        "couleurs": ["argent", "noir"],
        "garantie_ans": 2,
        "en_stock": true
    }'),
    ('T-Shirt Nike', 'V√™tements', 29.99, '{
        "marque": "Nike",
        "matiere": "Coton 100%",
        "tailles": ["S", "M", "L", "XL"],
        "couleurs": ["blanc", "noir", "bleu"],
        "entretien": "Lavage 30¬∞C",
        "en_stock": true
    }');
```

**Strat√©gie d'indexation :**

```sql
-- Cas 1 : Si vous cherchez principalement des valeurs sp√©cifiques
CREATE INDEX idx_attributs_path_ops ON produits
USING gin(attributs jsonb_path_ops);

-- Cas 2 : Si vous v√©rifiez souvent l'existence d'attributs
CREATE INDEX idx_attributs_standard ON produits
USING gin(attributs jsonb_ops);
```

**Requ√™tes typiques :**

```sql
-- Recherche 1 : Produits d'une marque
SELECT nom, prix FROM produits
WHERE attributs @> '{"marque": "Dell"}';

-- Recherche 2 : Ordinateurs avec 16GB RAM
SELECT nom, prix FROM produits
WHERE attributs @> '{"ram": "16GB"}';

-- Recherche 3 : Produits en stock avec garantie
SELECT nom, prix FROM produits
WHERE attributs @> '{"en_stock": true, "garantie_ans": 2}';

-- Recherche 4 : Produits avec couleur sp√©cifique
SELECT nom, prix FROM produits
WHERE attributs @> '{"couleurs": ["noir"]}';

-- Recherche 5 (n√©cessite jsonb_ops) : Produits avec attribut 'garantie_ans'
SELECT nom, prix FROM produits
WHERE attributs ? 'garantie_ans';
```

### Exemple 2 : Application avec Logs JSON

**Contexte :** Syst√®me de logs avec √©v√©nements JSON.

```sql
-- Table de logs
CREATE TABLE logs_application (
    id BIGSERIAL PRIMARY KEY,
    timestamp TIMESTAMP DEFAULT NOW(),
    niveau VARCHAR(20),
    evenement JSONB
);

-- Exemples de logs
INSERT INTO logs_application (niveau, evenement) VALUES
    ('INFO', '{
        "user_id": 12345,
        "action": "login",
        "ip": "192.168.1.100",
        "user_agent": "Chrome/120.0",
        "pays": "France",
        "duree_ms": 245
    }'),
    ('ERROR', '{
        "user_id": 67890,
        "action": "payment_failed",
        "error_code": "CARD_DECLINED",
        "montant": 99.99,
        "devise": "EUR",
        "tentatives": 3
    }');
```

**Indexation :**

```sql
-- Index optimis√© pour recherches d'√©v√©nements sp√©cifiques
CREATE INDEX idx_evenement_path_ops ON logs_application
USING gin(evenement jsonb_path_ops);

-- Index composite pour combiner timestamp + JSON
CREATE INDEX idx_timestamp_evenement ON logs_application(timestamp DESC, evenement jsonb_path_ops);
```

**Requ√™tes d'analyse :**

```sql
-- Analyse 1 : Tous les √©v√©nements d'un utilisateur
SELECT * FROM logs_application
WHERE evenement @> '{"user_id": 12345}'
ORDER BY timestamp DESC;

-- Analyse 2 : Erreurs de paiement sp√©cifiques
SELECT * FROM logs_application
WHERE niveau = 'ERROR'
AND evenement @> '{"action": "payment_failed"}';

-- Analyse 3 : Actions depuis un pays
SELECT * FROM logs_application
WHERE evenement @> '{"pays": "France"}';

-- Analyse 4 : Erreurs avec code sp√©cifique (derni√®res 24h)
SELECT * FROM logs_application
WHERE timestamp > NOW() - INTERVAL '24 hours'
AND evenement @> '{"error_code": "CARD_DECLINED"}';
```

### Exemple 3 : CRM avec Contacts Flexibles

**Contexte :** Syst√®me CRM avec donn√©es de contact variables.

```sql
-- Table de contacts
CREATE TABLE contacts (
    id SERIAL PRIMARY KEY,
    nom_complet VARCHAR(200),
    entreprise VARCHAR(200),
    informations JSONB
);

-- Donn√©es vari√©es
INSERT INTO contacts (nom_complet, entreprise, informations) VALUES
    ('Jean Dupont', 'TechCorp', '{
        "email": "jean.dupont@techcorp.fr",
        "telephone": "+33612345678",
        "poste": "Directeur IT",
        "interets": ["cloud", "kubernetes", "postgresql"],
        "derniere_interaction": "2025-11-15",
        "score_lead": 85,
        "budget": "50k-100k"
    }'),
    ('Marie Martin', 'StartupInno', '{
        "email": "marie@startupinno.com",
        "linkedin": "linkedin.com/in/mariemartin",
        "poste": "CEO",
        "interets": ["innovation", "fintech"],
        "derniere_interaction": "2025-11-18",
        "score_lead": 92
    }');
```

**Indexation adapt√©e :**

```sql
-- Index pour recherches cibl√©es (jsonb_path_ops)
CREATE INDEX idx_infos_path ON contacts
USING gin(informations jsonb_path_ops);

-- Index pour v√©rifier pr√©sence d'infos (jsonb_ops)
CREATE INDEX idx_infos_standard ON contacts
USING gin(informations jsonb_ops);
```

**Cas d'usage :**

```sql
-- CU 1 : Contacts int√©ress√©s par PostgreSQL
SELECT nom_complet, entreprise FROM contacts
WHERE informations @> '{"interets": ["postgresql"]}';

-- CU 2 : Leads avec score > 80
SELECT nom_complet, informations->>'score_lead' as score
FROM contacts
WHERE (informations->>'score_lead')::int > 80;

-- CU 3 : Contacts avec LinkedIn (n√©cessite jsonb_ops)
SELECT nom_complet FROM contacts
WHERE informations ? 'linkedin';

-- CU 4 : Contacts avec budget √©lev√©
SELECT nom_complet, entreprise FROM contacts
WHERE informations @> '{"budget": "50k-100k"}';
```

---

## Index sur Extraction JSON Sp√©cifique

### Index sur Expression avec JSONB

Si vous interrogez toujours la **m√™me cl√© JSON**, cr√©ez un index sur l'extraction :

```sql
-- Au lieu d'indexer tout le JSON
CREATE INDEX idx_metadata_gin ON produits USING gin(metadata);

-- Indexer uniquement une cl√© sp√©cifique
CREATE INDEX idx_marque ON produits((metadata->>'marque'));

-- Requ√™te optimis√©e
SELECT * FROM produits WHERE metadata->>'marque' = 'TechCorp';
-- Utilise idx_marque (B-Tree) au lieu de GIN
```

**Avantages :**
- Index **beaucoup plus compact** (B-Tree)
- **Plus rapide** pour requ√™tes sur une cl√© unique
- Fonctionne avec √©galit√©, tri, plages

**Quand l'utiliser :**
- Requ√™tes sur **une seule cl√© JSON** r√©currente
- Cl√© avec **haute cardinalit√©**
- Besoin de **tri** sur la valeur extraite

### Index Composite : Colonne + JSON

```sql
-- Combiner colonne classique + extraction JSON
CREATE INDEX idx_categorie_marque
ON produits(categorie, (metadata->>'marque'));

-- Requ√™te ultra-optimis√©e
SELECT * FROM produits
WHERE categorie = 'Informatique'
AND metadata->>'marque' = 'Dell'
ORDER BY prix;
```

---

## Index GIN sur Tableaux JSON

### Tableaux dans JSONB

```sql
-- Table avec tags JSON
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(200),
    tags JSONB  -- ["postgresql", "database", "tutorial"]
);

-- Donn√©es
INSERT INTO articles (titre, tags) VALUES
    ('Guide PostgreSQL', '["postgresql", "database", "sql", "tutorial"]'),
    ('Introduction JSON', '["json", "nosql", "postgresql"]');
```

**Index GIN pour recherche dans tableaux :**

```sql
-- Index pour rechercher dans les tableaux
CREATE INDEX idx_tags_gin ON articles USING gin(tags jsonb_path_ops);

-- Recherche : Articles avec tag 'postgresql'
SELECT * FROM articles
WHERE tags @> '["postgresql"]';

-- Recherche : Articles avec tag 'postgresql' OU 'database'
SELECT * FROM articles
WHERE tags @> '["postgresql"]' OR tags @> '["database"]';

-- Alternative avec op√©rateur ?|
CREATE INDEX idx_tags_standard ON articles USING gin(tags jsonb_ops);
SELECT * FROM articles
WHERE tags ?| ARRAY['postgresql', 'database'];
```

---

## Performance : Benchmarks

### Test de Performance Comparatif

**Contexte :** Table de 1 million de produits avec JSONB.

```sql
-- Configuration de test
CREATE TABLE produits_test (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    metadata JSONB
);

-- G√©n√©rer 1M de lignes (simplifi√©)
INSERT INTO produits_test (nom, metadata)
SELECT
    'Produit ' || i,
    jsonb_build_object(
        'marque', 'Marque' || (i % 100),
        'prix', (random() * 1000)::numeric(10,2),
        'categorie', 'Cat' || (i % 20),
        'en_stock', random() > 0.1,
        'attributs', jsonb_build_object('couleur', 'Couleur' || (i % 10))
    )
FROM generate_series(1, 1000000) i;
```

**Test 1 : Sans Index**
```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM produits_test
WHERE metadata @> '{"marque": "Marque42"}';

-- R√©sultat :
-- Seq Scan on produits_test  (cost=0.00..52500.00 rows=10000 width=...)
-- Execution Time: 3842.567 ms
```

**Test 2 : Avec GIN Standard (jsonb_ops)**
```sql
CREATE INDEX idx_meta_standard ON produits_test USING gin(metadata);

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM produits_test
WHERE metadata @> '{"marque": "Marque42"}';

-- R√©sultat :
-- Bitmap Heap Scan on produits_test  (cost=245.23..4582.15 rows=10000 width=...)
-- Execution Time: 67.234 ms
-- Index size: 156 MB
```

**Test 3 : Avec GIN Optimis√© (jsonb_path_ops)**
```sql
CREATE INDEX idx_meta_path_ops ON produits_test USING gin(metadata jsonb_path_ops);

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM produits_test
WHERE metadata @> '{"marque": "Marque42"}';

-- R√©sultat :
-- Bitmap Heap Scan on produits_test  (cost=198.45..4124.78 rows=10000 width=...)
-- Execution Time: 48.123 ms
-- Index size: 52 MB
```

**R√©sultats :**

| Configuration | Temps (ms) | Taille Index | Gain |
|---------------|------------|--------------|------|
| Sans index | 3842 | - | R√©f√©rence |
| jsonb_ops | 67 | 156 MB | **57√ó plus rapide** |
| jsonb_path_ops | 48 | 52 MB | **80√ó plus rapide** |

**Conclusion :** `jsonb_path_ops` est **28% plus rapide** et **3√ó plus compact** que `jsonb_ops`.

---

## Index GIN Partiel sur JSONB

### Combiner GIN + Partiel

```sql
-- Index uniquement sur produits en stock
CREATE INDEX idx_metadata_en_stock
ON produits USING gin(metadata jsonb_path_ops)
WHERE (metadata->>'en_stock')::boolean = true;

-- Requ√™te optimis√©e
SELECT * FROM produits
WHERE metadata @> '{"marque": "TechCorp"}'
AND (metadata->>'en_stock')::boolean = true;
```

**Avantages :**
- Index **beaucoup plus petit**
- **Plus rapide** (moins d'entr√©es √† parcourir)
- Utile si 80%+ des requ√™tes filtrent sur une condition commune

---

## Maintenance des Index GIN

### Taille et Croissance

```sql
-- V√©rifier la taille d'un index GIN
SELECT
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS taille,
    idx_scan AS utilisations,
    idx_tup_read AS tuples_lus
FROM pg_stat_user_indexes
WHERE indexname LIKE 'idx_metadata%';
```

### VACUUM et Index GIN

Les index GIN n√©cessitent une maintenance r√©guli√®re :

```sql
-- VACUUM pour nettoyer les "pending list"
VACUUM ANALYZE produits;

-- V√©rifier les statistiques
SELECT * FROM pg_stat_user_indexes WHERE indexrelname = 'idx_metadata_gin';
```

**Note :** GIN utilise une "pending list" pour les insertions rapides. VACUUM les int√®gre dans l'index principal.

### Reindexation

Si l'index GIN devient fragment√© :

```sql
-- Option 1 : REINDEX (bloque la table)
REINDEX INDEX CONCURRENTLY idx_metadata_gin;

-- Option 2 : Recr√©er l'index (PostgreSQL 12+)
CREATE INDEX CONCURRENTLY idx_metadata_gin_new
ON produits USING gin(metadata jsonb_path_ops);

DROP INDEX idx_metadata_gin;
ALTER INDEX idx_metadata_gin_new RENAME TO idx_metadata_gin;
```

---

## Cas d'Usage Avanc√©s

### 1. Full-Text Search dans JSON

```sql
-- Recherche textuelle dans champs JSON
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    contenu JSONB
);

-- Index pour recherche full-text
CREATE INDEX idx_contenu_fts ON documents
USING gin((contenu->>'texte') gin_trgm_ops);
-- N√©cessite : CREATE EXTENSION pg_trgm;

-- Recherche floue dans JSON
SELECT * FROM documents
WHERE contenu->>'texte' ILIKE '%postgresql%';
```

### 2. Index sur Chemin JSON Profond

```sql
-- Index sur chemin profond
CREATE INDEX idx_cpu ON produits
USING gin((metadata#>'{specs, cpu}') jsonb_path_ops);

-- Requ√™te optimis√©e
SELECT * FROM produits
WHERE metadata#>'{specs, cpu}' @> '"Intel i7"';
```

### 3. Index Multi-Colonnes avec JSONB

```sql
-- Combiner colonnes classiques + JSONB
CREATE INDEX idx_categorie_metadata
ON produits(categorie)
INCLUDE ((metadata->>'marque'));

-- Ou avec GIN multi-colonnes
CREATE INDEX idx_cat_meta_gin
ON produits USING gin(categorie gin_trgm_ops, metadata jsonb_path_ops);
-- Note : N√©cessite pg_trgm pour gin_trgm_ops sur TEXT
```

---

## Pi√®ges et Limitations

### ‚ùå Pi√®ge 1 : Confusion d'Op√©rateurs

```sql
-- Index cr√©√©
CREATE INDEX idx ON produits USING gin(metadata jsonb_path_ops);

-- ‚ùå N'utilise PAS l'index (op√©rateur ->>, pas @>)
SELECT * FROM produits WHERE metadata->>'marque' = 'TechCorp';

-- ‚úÖ Utilise l'index
SELECT * FROM produits WHERE metadata @> '{"marque": "TechCorp"}';
```

**Solution :** Utilisez `@>` avec `jsonb_path_ops`.

### ‚ùå Pi√®ge 2 : jsonb_path_ops sans Support de ?

```sql
-- Index optimis√©
CREATE INDEX idx ON produits USING gin(metadata jsonb_path_ops);

-- ‚ùå Seq Scan (op√©rateur ? non support√©)
SELECT * FROM produits WHERE metadata ? 'marque';

-- Solution : Utiliser jsonb_ops
CREATE INDEX idx_standard ON produits USING gin(metadata jsonb_ops);
```

### ‚ùå Pi√®ge 3 : Types de Donn√©es dans JSON

```sql
-- Donn√©es avec types mixtes
INSERT INTO produits (metadata) VALUES
    ('{"prix": 99.99}'),   -- nombre
    ('{"prix": "99.99"}'); -- texte

-- ‚ùå Ne trouve qu'une version
SELECT * FROM produits WHERE metadata @> '{"prix": 99.99}';
-- Trouve uniquement celle avec nombre, pas texte !

-- ‚úÖ Solution : Normaliser les types
```

### ‚ùå Pi√®ge 4 : Index GIN Trop Large

```sql
-- ‚ùå MAUVAIS : JSONB gigantesque (>1MB par ligne)
CREATE TABLE logs (
    id BIGSERIAL PRIMARY KEY,
    data JSONB  -- Contient des arrays de 100K √©l√©ments
);

CREATE INDEX idx ON logs USING gin(data);
-- Index de plusieurs centaines de GB, inutilisable !

-- ‚úÖ Solution : Index partiel ou sur cl√©s sp√©cifiques
CREATE INDEX idx_key ON logs((data->>'important_field'));
```

### ‚ùå Pi√®ge 5 : Oublier les Casts

```sql
-- Requ√™te avec cast
SELECT * FROM produits
WHERE (metadata->>'prix')::numeric > 100;

-- ‚ùå N'utilise pas l'index GIN (cast n√©cessaire)

-- ‚úÖ Solution : Index sur expression
CREATE INDEX idx_prix ON produits(((metadata->>'prix')::numeric));
```

---

## Bonnes Pratiques

### ‚úÖ DO (√Ä Faire)

1. **Choisir le bon type d'index GIN selon usage**
   ```sql
   -- Uniquement @> : jsonb_path_ops
   CREATE INDEX idx ON table USING gin(col jsonb_path_ops);

   -- Op√©rateurs vari√©s (?, ?|, ?&) : jsonb_ops
   CREATE INDEX idx ON table USING gin(col jsonb_ops);
   ```

2. **Pr√©f√©rer jsonb_path_ops quand possible**
   - Plus compact (3√ó moins d'espace)
   - Plus rapide pour @>

3. **Index sur extraction pour cl√©s fr√©quentes**
   ```sql
   -- Plus efficace qu'un GIN complet
   CREATE INDEX idx ON table((jsonb_col->>'frequent_key'));
   ```

4. **Combiner avec index partiels**
   ```sql
   CREATE INDEX idx ON table USING gin(col jsonb_path_ops)
   WHERE (col->>'status') = 'active';
   ```

5. **Analyser avec EXPLAIN avant de cr√©er**
   ```sql
   EXPLAIN (ANALYZE, BUFFERS) SELECT ...;
   ```

6. **VACUUM r√©gulier pour GIN**
   ```sql
   -- Configuration autovacuum adapt√©e
   ALTER TABLE table SET (
       autovacuum_vacuum_scale_factor = 0.05
   );
   ```

7. **Documenter les index GIN**
   ```sql
   COMMENT ON INDEX idx_metadata_gin IS
   'GIN jsonb_path_ops pour recherches @> sur metadata.
   R√©duit temps requ√™te de 3800ms √† 48ms (80√ó plus rapide).';
   ```

### ‚ùå DON'T (√Ä √âviter)

1. **Ne pas utiliser JSON au lieu de JSONB**
   ```sql
   -- ‚ùå MAUVAIS
   CREATE TABLE t (data JSON);

   -- ‚úÖ BON
   CREATE TABLE t (data JSONB);
   ```

2. **Ne pas cr√©er d'index GIN sur JSON √©normes**
   - Limite pratique : < 100KB par document JSON

3. **Ne pas confondre les op√©rateurs**
   ```sql
   -- ‚ùå ->>'key' avec GIN ne fonctionne pas bien
   -- ‚úÖ Utiliser @> √† la place
   ```

4. **Ne pas oublier VACUUM sur tables avec GIN**

5. **Ne pas sur-indexer**
   ```sql
   -- ‚ùå Inutile d'avoir les deux sur la m√™me colonne
   CREATE INDEX idx1 ON table USING gin(col jsonb_ops);
   CREATE INDEX idx2 ON table USING gin(col jsonb_path_ops);

   -- ‚úÖ Choisir un seul selon besoin
   ```

---

## Monitoring et Diagnostic

### Identifier les Requ√™tes Lentes sur JSONB

```sql
-- Avec pg_stat_statements
SELECT
    query,
    calls,
    mean_exec_time,
    total_exec_time
FROM pg_stat_statements
WHERE query LIKE '%metadata%@>%'
OR query LIKE '%metadata%?%'
ORDER BY mean_exec_time DESC
LIMIT 10;
```

### Analyser l'Utilisation des Index GIN

```sql
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan AS "Utilisations",
    idx_tup_read AS "Tuples lus",
    pg_size_pretty(pg_relation_size(indexrelid)) AS "Taille"
FROM pg_stat_user_indexes
WHERE indexdef LIKE '%gin%'
ORDER BY idx_scan DESC;
```

### V√©rifier les Pending Lists GIN

```sql
-- Taille de la pending list (n√©cessite pg_stat_statements)
SELECT
    schemaname || '.' || tablename AS table,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS taille_index
FROM pg_stat_user_indexes
WHERE indexdef LIKE '%gin%'
ORDER BY pg_relation_size(indexrelid) DESC;
```

---

## R√©sum√©

### Points Cl√©s

1. **JSONB > JSON pour indexation**
   - Stockage binaire optimis√©
   - Support complet des index GIN

2. **Deux types d'index GIN pour JSONB :**
   - **jsonb_ops** : Flexible, tous op√©rateurs, plus volumineux
   - **jsonb_path_ops** : Optimis√©, uniquement @>, 3√ó plus compact

3. **Op√©rateurs principaux :**
   - `@>` : Contient (le plus utilis√©)
   - `?` : Cl√© existe
   - `?|`, `?&` : Existence multiple

4. **Performances :**
   - Index GIN : 50-200√ó plus rapide que Seq Scan
   - jsonb_path_ops : 20-30% plus rapide que jsonb_ops
   - Taille : jsonb_path_ops 3√ó plus compact

5. **Quand utiliser quoi :**
   ```
   Uniquement @> ‚Üí jsonb_path_ops
   Op√©rateurs ?, ?|, ?& ‚Üí jsonb_ops
   Une cl√© fr√©quente ‚Üí Index B-Tree sur extraction
   ```

6. **Maintenance :**
   - VACUUM r√©gulier important pour GIN
   - Surveiller la taille des index
   - Reindexer si fragment√©

---

## Pour Aller Plus Loin

### Lectures Recommand√©es

- **Documentation PostgreSQL :**
  - [JSON Types](https://www.postgresql.org/docs/current/datatype-json.html)
  - [GIN Indexes](https://www.postgresql.org/docs/current/gin.html)
  - [JSONB Indexing](https://www.postgresql.org/docs/current/datatype-json.html#JSON-INDEXING)

- **Articles avanc√©s :**
  - "JSON Performance in PostgreSQL" - Bruce Momjian
  - "Understanding JSONB Performance" - 2ndQuadrant

### Prochaines √âtapes

Apr√®s avoir ma√Ætris√© les index GIN sur JSONB, explorez :
- **13.4.1. GIN pour Full-Text Search** - tsvector et recherche textuelle
- **13.4.2. GiST pour donn√©es g√©ospatiales** - PostGIS
- **18.3. Full-Text Search Avanc√©** - Ranking et pond√©ration

### Extensions Utiles

- **pg_trgm** - Recherche floue dans JSON
- **jsonb_plpython** - Manipulation JSON avec Python
- **jsquery** - Langage de requ√™te JSON avanc√©

---


‚è≠Ô∏è [Le planificateur de requ√™tes et les statistiques (pg_stats)](/13-indexation-et-optimisation/06-planificateur-et-statistiques.md)
