üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.4.4. Hash : √âgalit√© stricte

## Introduction

Les index **Hash** sont un type d'index sp√©cialis√© de PostgreSQL con√ßu exclusivement pour les **comparaisons d'√©galit√© stricte**. Contrairement aux index B-Tree qui peuvent g√©rer les √©galit√©s ET les comparaisons (>, <, BETWEEN), les index Hash ne savent faire qu'une seule chose : r√©pondre √† la question "cette valeur existe-t-elle ?".

### L'analogie du casier postal

Imaginez un bureau de poste avec des casiers num√©rot√©s :
- Vous avez un nom (la valeur √† chercher)
- Une formule math√©matique transforme ce nom en num√©ro de casier (fonction de hachage)
- Vous allez directement au bon casier sans chercher ailleurs

C'est exactement ce que fait un index Hash : il transforme une valeur en position, permettant un acc√®s direct et ultra-rapide.

### Principe de fonctionnement

```
Valeur ‚Üí [Fonction de Hachage] ‚Üí Position dans l'index ‚Üí Donn√©es

Exemple :
'alice@example.com' ‚Üí hash() ‚Üí 42857 ‚Üí Ligne dans la table
'bob@example.com'   ‚Üí hash() ‚Üí 18923 ‚Üí Ligne dans la table
'alice@example.com' ‚Üí hash() ‚Üí 42857 ‚Üí M√™me position = trouv√© !
```

### Caract√©ristiques essentielles

- ‚úÖ **Ultra-rapide** pour recherche d'√©galit√© exacte (th√©oriquement O(1))
- ‚úÖ **Compact** : Taille similaire ou l√©g√®rement inf√©rieure √† B-Tree
- ‚úÖ **Simple** : Une seule op√©ration support√©e (=)
- ‚úÖ **D√©terministe** : M√™me valeur = m√™me hash = m√™me position

- ‚ùå **Aucune comparaison** : Ne supporte pas >, <, >=, <=, BETWEEN
- ‚ùå **Pas d'ordre** : Ne peut pas √™tre utilis√© pour ORDER BY
- ‚ùå **Pas de LIKE** : Aucune recherche partielle
- ‚ùå **Collisions** : Plusieurs valeurs peuvent avoir le m√™me hash

### Quand utiliser un index Hash ?

‚úÖ **√Ä utiliser pour :**
- Recherches d'√©galit√© stricte uniquement (WHERE colonne = valeur)
- Colonnes avec beaucoup de valeurs uniques (haute cardinalit√©)
- Jointures par √©galit√© (JOIN ... ON a = b)
- Cl√©s primaires ou uniques (th√©oriquement)

‚ùå **√Ä √©viter pour :**
- Toute comparaison autre que l'√©galit√©
- ORDER BY ou GROUP BY
- Colonnes avec peu de valeurs distinctes
- LIKE, IN avec plages, BETWEEN

---

## 1. Fonctions de Hachage : Le C≈ìur du Syst√®me

### Qu'est-ce qu'une fonction de hachage ?

Une **fonction de hachage** (hash function) est un algorithme math√©matique qui transforme une valeur (de n'importe quelle taille) en un nombre entier de taille fixe, appel√© "hash code" ou "empreinte".

### Propri√©t√©s importantes

1. **D√©terministe** : M√™me entr√©e ‚Üí Toujours m√™me sortie
   ```
   hash('alice') = 42857 (toujours)
   hash('alice') = 42857 (toujours)
   ```

2. **Distribution uniforme** : Les hash sont r√©partis uniform√©ment
   ```
   hash('alice') = 42857
   hash('alicf') = 91234  (tr√®s diff√©rent malgr√© 1 caract√®re de diff√©rence)
   hash('bob')   = 15678
   ```

3. **Rapide √† calculer** : L'algorithme doit √™tre ultra-performant

4. **Sensible aux changements** : Petite modification ‚Üí Hash compl√®tement diff√©rent
   ```
   hash('Alice')  = 42857
   hash('alice')  = 88291  (sensible √† la casse)
   hash('alice ') = 63442  (espace en plus)
   ```

### Visualisation simplifi√©e

```
Table : users (1 million de lignes)
Colonne : email (avec index Hash)

Sans index Hash :
WHERE email = 'alice@example.com'
‚Üí Scan s√©quentiel : v√©rifier 1 million de lignes (LENT)

Avec index Hash :
WHERE email = 'alice@example.com'
‚Üí hash('alice@example.com') = 42857
‚Üí Aller directement au bucket 42857
‚Üí V√©rifier seulement les lignes dans ce bucket (RAPIDE)
```

### Gestion des collisions

Une **collision** se produit quand deux valeurs diff√©rentes produisent le m√™me hash.

```
hash('alice@example.com') = 42857
hash('xyz@domain.org')    = 42857  ‚Üê Collision !

PostgreSQL utilise le cha√Ænage :
Bucket 42857 ‚Üí [alice@example.com] ‚Üí [xyz@domain.org]
                     ‚Üì                       ‚Üì
                  Ligne 100              Ligne 58392
```

Lorsqu'une collision se produit, PostgreSQL stocke plusieurs valeurs dans le m√™me "bucket" et les v√©rifie toutes lors de la recherche.

---

## 2. Cr√©ation et Syntaxe des Index Hash

### Syntaxe de base

```sql
CREATE INDEX nom_index ON table USING HASH (colonne);
```

### Exemple simple

```sql
-- Cr√©er une table d'utilisateurs
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    username TEXT UNIQUE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Ins√©rer des donn√©es de test
INSERT INTO users (email, username)
SELECT
    'user' || generate_series || '@example.com',
    'user' || generate_series
FROM generate_series(1, 1000000);

-- Cr√©er un index Hash sur email
CREATE INDEX idx_users_email_hash ON users USING HASH (email);

-- Analyser la table
ANALYZE users;
```

### Comparaison avec B-Tree (syntaxe)

```sql
-- Index Hash (√©galit√© uniquement)
CREATE INDEX idx_email_hash ON users USING HASH (email);

-- Index B-Tree (d√©faut, toutes op√©rations)
CREATE INDEX idx_email_btree ON users USING BTREE (email);
-- Ou simplement :
CREATE INDEX idx_email_btree ON users (email);  -- B-Tree par d√©faut
```

### Index Hash sur diff√©rents types de donn√©es

```sql
-- Sur INTEGER
CREATE INDEX idx_user_id_hash ON users USING HASH (id);

-- Sur TEXT
CREATE INDEX idx_username_hash ON users USING HASH (username);

-- Sur UUID
CREATE TABLE sessions (
    session_id UUID PRIMARY KEY,
    user_id INTEGER,
    data JSONB
);
CREATE INDEX idx_session_id_hash ON sessions USING HASH (session_id);

-- Sur INET (adresse IP)
CREATE TABLE access_logs (
    id BIGSERIAL PRIMARY KEY,
    ip_address INET NOT NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX idx_ip_hash ON access_logs USING HASH (ip_address);
```

### Types support√©s par les index Hash

PostgreSQL 18 supporte les index Hash pour la plupart des types de donn√©es :

| Cat√©gorie | Types support√©s |
|-----------|-----------------|
| **Num√©riques** | INTEGER, BIGINT, SMALLINT, NUMERIC, REAL, DOUBLE PRECISION |
| **Texte** | TEXT, VARCHAR, CHAR, NAME |
| **Binaire** | BYTEA |
| **R√©seau** | INET, CIDR, MACADDR |
| **UUID** | UUID |
| **Temporels** | DATE, TIMESTAMP, TIMESTAMPTZ, TIME |
| **Bool√©en** | BOOLEAN |
| **Autres** | OID, JSON (comme TEXT) |

### Index Hash multi-colonnes

**Important** : Contrairement √† B-Tree, les index Hash **ne supportent PAS** les index multi-colonnes dans PostgreSQL.

```sql
-- ‚ùå ERREUR : Index Hash ne peut avoir qu'une seule colonne
CREATE INDEX idx_multi_hash ON users USING HASH (email, username);
-- ERROR: access method "hash" does not support multicolumn indexes

-- ‚úÖ Solution : Cr√©er des index s√©par√©s
CREATE INDEX idx_email_hash ON users USING HASH (email);
CREATE INDEX idx_username_hash ON users USING HASH (username);
```

---

## 3. Requ√™tes Optimis√©es par les Index Hash

### Recherche d'√©galit√© stricte

```sql
-- ‚úÖ PARFAIT : √âgalit√© exacte (utilise l'index Hash)
SELECT * FROM users WHERE email = 'user123456@example.com';

-- V√©rifier avec EXPLAIN
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM users WHERE email = 'user123456@example.com';

-- R√©sultat attendu :
-- Index Scan using idx_users_email_hash on users
-- Time: 0.05 ms
```

### Jointures par √©galit√©

```sql
-- Table de commandes
CREATE TABLE orders (
    id BIGSERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    total NUMERIC(10,2),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index Hash sur user_id
CREATE INDEX idx_orders_user_id_hash ON orders USING HASH (user_id);

-- ‚úÖ Jointure optimis√©e par Hash
SELECT
    u.username,
    o.id AS order_id,
    o.total
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.email = 'user123456@example.com';

-- PostgreSQL peut utiliser Hash Join avec l'index Hash
```

### Clause IN avec valeurs explicites

```sql
-- ‚úÖ Peut utiliser l'index Hash (une √©galit√© par valeur)
SELECT * FROM users
WHERE email IN ('user1@example.com', 'user2@example.com', 'user3@example.com');

-- PostgreSQL transforme en :
-- WHERE email = 'user1@example.com' OR email = 'user2@example.com' OR ...
```

### Op√©rateurs support√©s

Les index Hash ne supportent **QUE** l'op√©rateur d'√©galit√© :

| Op√©rateur | Support√© ? | Exemple |
|-----------|------------|---------|
| `=` | ‚úÖ Oui | `WHERE email = 'alice@example.com'` |
| `!=` ou `<>` | ‚ùå Non | `WHERE email != 'alice@example.com'` |
| `<` | ‚ùå Non | `WHERE id < 1000` |
| `>` | ‚ùå Non | `WHERE id > 1000` |
| `<=` | ‚ùå Non | `WHERE id <= 1000` |
| `>=` | ‚ùå Non | `WHERE id >= 1000` |
| `BETWEEN` | ‚ùå Non | `WHERE id BETWEEN 100 AND 1000` |
| `LIKE` | ‚ùå Non | `WHERE email LIKE '%@example.com'` |
| `IN` | ‚úÖ Partiel | `WHERE email IN (...)` (transform√© en √©galit√©s) |
| `IS NULL` | ‚ùå Non | `WHERE email IS NULL` |

### Cas o√π l'index Hash N'EST PAS utilis√©

```sql
-- ‚ùå Comparaison (n√©cessite B-Tree)
SELECT * FROM users WHERE id > 50000;

-- ‚ùå Plage (n√©cessite B-Tree)
SELECT * FROM users WHERE id BETWEEN 1000 AND 2000;

-- ‚ùå Tri (n√©cessite B-Tree)
SELECT * FROM users ORDER BY email;

-- ‚ùå LIKE (n√©cessite B-Tree ou GIN/GiST)
SELECT * FROM users WHERE email LIKE '%@example.com';

-- ‚ùå Pattern matching
SELECT * FROM users WHERE email ~ '^user[0-9]+';

-- ‚ùå IS NULL / IS NOT NULL
SELECT * FROM users WHERE email IS NULL;

-- Dans tous ces cas, PostgreSQL :
-- - Ignore l'index Hash
-- - Utilise un autre index (B-Tree) si disponible
-- - Fait un Seq Scan sinon
```

---

## 4. Comparaison : Hash vs B-Tree

### Tableau comparatif d√©taill√©

| Crit√®re | Hash | B-Tree | Recommandation |
|---------|------|--------|----------------|
| **√âgalit√© (=)** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Ultra-rapide | ‚≠ê‚≠ê‚≠ê‚≠ê Tr√®s rapide | Hash l√©g√®rement meilleur |
| **Comparaison (>, <)** | ‚ùå Non support√© | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellent | B-Tree obligatoire |
| **BETWEEN** | ‚ùå Non support√© | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellent | B-Tree obligatoire |
| **ORDER BY** | ‚ùå Non support√© | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellent | B-Tree obligatoire |
| **Taille index** | ‚≠ê‚≠ê‚≠ê‚≠ê Compact | ‚≠ê‚≠ê‚≠ê‚≠ê Compact | Similaire |
| **Insertion** | ‚≠ê‚≠ê‚≠ê‚≠ê Rapide | ‚≠ê‚≠ê‚≠ê‚≠ê Rapide | Similaire |
| **Maintenance** | ‚≠ê‚≠ê‚≠ê Correcte | ‚≠ê‚≠ê‚≠ê‚≠ê Bonne | B-Tree plus mature |
| **WAL logging** | ‚≠ê‚≠ê‚≠ê‚≠ê Depuis PG 10 | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Complet | B-Tree plus fiable |
| **Multi-colonnes** | ‚ùå Non support√© | ‚úÖ Support√© | B-Tree obligatoire |
| **Cl√© √©trang√®re** | ‚ùå Non utilisable | ‚úÖ Utilisable | B-Tree obligatoire |

### Benchmark de performance

```sql
-- Cr√©er une table de test
CREATE TABLE benchmark (
    id INTEGER PRIMARY KEY,
    code TEXT NOT NULL UNIQUE,
    data TEXT
);

-- Ins√©rer 1 million de lignes
INSERT INTO benchmark
SELECT
    generate_series,
    'CODE_' || lpad(generate_series::TEXT, 10, '0'),
    'data'
FROM generate_series(1, 1000000);

-- Cr√©er les deux types d'index
CREATE INDEX idx_code_hash ON benchmark USING HASH (code);
CREATE INDEX idx_code_btree ON benchmark USING BTREE (code);

ANALYZE benchmark;

-- Test 1 : Recherche d'√©galit√© exacte
\timing on

-- Avec Hash
SET enable_indexscan = off;  -- Forcer Bitmap Scan
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM benchmark WHERE code = 'CODE_0000500000';

-- Avec B-Tree
DROP INDEX idx_code_hash;
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM benchmark WHERE code = 'CODE_0000500000';

-- R√©sultats typiques :
-- Hash :   Index Scan ‚Üí 0.03 ms
-- B-Tree : Index Scan ‚Üí 0.04 ms
-- Diff√©rence : N√©gligeable en pratique
```

### Taille comparative

```sql
-- Comparer la taille des index
SELECT
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) AS taille
FROM pg_indexes
WHERE tablename = 'benchmark'
  AND indexname LIKE 'idx_code%';

-- R√©sultat typique sur 1M lignes :
-- idx_code_hash  : 22 MB
-- idx_code_btree : 21 MB
-- Taille : Quasi identique
```

### Quand pr√©f√©rer Hash √† B-Tree ?

En r√©alit√©, dans PostgreSQL moderne (depuis la version 10 avec le WAL logging), **B-Tree est g√©n√©ralement pr√©f√©rable** car :

1. **Performance similaire** : B-Tree est presque aussi rapide pour l'√©galit√©
2. **Plus polyvalent** : Supporte toutes les op√©rations
3. **Plus mature** : Meilleure optimisation et maintenance
4. **Support d'unicit√©** : Peut √™tre utilis√© pour UNIQUE et PRIMARY KEY
5. **Multi-colonnes** : Supporte les index composites

**Utilisez Hash uniquement si** :
- Vous √™tes **absolument certain** de ne jamais avoir besoin de comparaisons
- Vous avez des mesures montrant un gain r√©el
- La colonne a une **tr√®s haute cardinalit√©** (beaucoup de valeurs uniques)

---

## 5. Cas d'Usage Sp√©cifiques

### Cas 1 : Recherche par UUID

```sql
-- Sessions avec UUID
CREATE TABLE user_sessions (
    session_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id INTEGER NOT NULL,
    expires_at TIMESTAMPTZ NOT NULL,
    data JSONB
);

-- Index Hash sur session_id (recherche d'√©galit√© uniquement)
CREATE INDEX idx_sessions_id_hash ON user_sessions USING HASH (session_id);

-- Requ√™te typique : v√©rifier si session existe
SELECT * FROM user_sessions
WHERE session_id = 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11';

-- Alternative avec B-Tree (recommand√©)
CREATE INDEX idx_sessions_id_btree ON user_sessions (session_id);
```

### Cas 2 : Lookup par cl√© externe

```sql
-- Table de traduction de codes
CREATE TABLE code_mapping (
    external_code TEXT PRIMARY KEY,
    internal_id INTEGER NOT NULL,
    description TEXT
);

-- Index Hash pour lookup rapide
CREATE INDEX idx_mapping_code_hash ON code_mapping USING HASH (external_code);

-- Requ√™te de traduction
SELECT internal_id
FROM code_mapping
WHERE external_code = 'EXT_CODE_12345';

-- Utilis√© dans les jointures
SELECT
    o.order_id,
    m.internal_id,
    m.description
FROM orders o
JOIN code_mapping m ON o.external_reference = m.external_code;
```

### Cas 3 : D√©duplication par hash

```sql
-- Table avec hash du contenu pour d√©duplication
CREATE TABLE documents (
    id BIGSERIAL PRIMARY KEY,
    title TEXT,
    content TEXT,
    content_hash TEXT NOT NULL,  -- SHA256 du contenu
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index Hash pour d√©tecter doublons rapidement
CREATE INDEX idx_docs_hash ON documents USING HASH (content_hash);

-- V√©rifier si document existe d√©j√†
SELECT id
FROM documents
WHERE content_hash = 'abc123...def';

-- √âviter les doublons √† l'insertion
INSERT INTO documents (title, content, content_hash)
SELECT 'Mon document', 'Contenu...', 'abc123...def'
WHERE NOT EXISTS (
    SELECT 1 FROM documents WHERE content_hash = 'abc123...def'
);
```

### Cas 4 : Cache lookup

```sql
-- Table de cache simple
CREATE TABLE app_cache (
    cache_key TEXT PRIMARY KEY,
    cache_value JSONB NOT NULL,
    expires_at TIMESTAMPTZ NOT NULL
);

-- Index Hash sur cache_key
CREATE INDEX idx_cache_key_hash ON app_cache USING HASH (cache_key);

-- R√©cup√©ration depuis le cache
SELECT cache_value
FROM app_cache
WHERE cache_key = 'user:profile:12345'
  AND expires_at > NOW();

-- Invalidation
DELETE FROM app_cache WHERE cache_key = 'user:profile:12345';
```

### Cas 5 : V√©rification d'existence

```sql
-- Whitelist/Blacklist
CREATE TABLE email_whitelist (
    email TEXT PRIMARY KEY,
    added_at TIMESTAMPTZ DEFAULT NOW(),
    added_by TEXT
);

CREATE INDEX idx_whitelist_email_hash ON email_whitelist USING HASH (email);

-- V√©rifier rapidement si email est autoris√©
SELECT EXISTS (
    SELECT 1 FROM email_whitelist WHERE email = 'user@example.com'
) AS is_whitelisted;

-- Dans une fonction
CREATE OR REPLACE FUNCTION is_email_allowed(p_email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM email_whitelist WHERE email = p_email
    );
END;
$$ LANGUAGE plpgsql STABLE;
```

---

## 6. Limitations et Contraintes

### Limitation 1 : Pas de support UNIQUE

```sql
-- ‚ùå IMPOSSIBLE : Index Hash ne peut pas √™tre UNIQUE
CREATE UNIQUE INDEX idx_email_unique_hash ON users USING HASH (email);
-- ERROR: access method "hash" does not support unique indexes

-- ‚úÖ Solution : Utiliser B-Tree pour UNIQUE
CREATE UNIQUE INDEX idx_email_unique_btree ON users (email);
```

### Limitation 2 : Pas de support PRIMARY KEY

```sql
-- ‚ùå IMPOSSIBLE : PRIMARY KEY utilise toujours B-Tree
CREATE TABLE test (
    id INTEGER PRIMARY KEY USING HASH  -- Syntaxe invalide
);

-- PostgreSQL cr√©e automatiquement un index B-Tree pour PK
CREATE TABLE test (
    id INTEGER PRIMARY KEY  -- Index B-Tree automatique
);
```

### Limitation 3 : Pas de support FOREIGN KEY

```sql
-- Les FOREIGN KEY n√©cessitent B-Tree (pour v√©rifications de range)
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id)  -- N√©cessite B-Tree sur users(id)
);

-- L'index Hash ne peut pas √™tre utilis√© pour FK
```

### Limitation 4 : Pas d'index multi-colonnes

```sql
-- ‚ùå IMPOSSIBLE
CREATE INDEX idx_multi_hash ON users USING HASH (email, username);
-- ERROR: access method "hash" does not support multicolumn indexes

-- ‚úÖ Solution : Index s√©par√©s ou B-Tree multi-colonnes
CREATE INDEX idx_email_hash ON users USING HASH (email);
CREATE INDEX idx_username_hash ON users USING HASH (username);
-- Ou
CREATE INDEX idx_multi_btree ON users (email, username);
```

### Limitation 5 : Pas de REINDEX CONCURRENTLY avant PG 12

```sql
-- Dans PostgreSQL 11 et ant√©rieurs :
-- ‚ùå REINDEX CONCURRENTLY ne fonctionnait pas avec Hash

-- Dans PostgreSQL 12+ (dont PG 18) :
-- ‚úÖ Support√©
REINDEX INDEX CONCURRENTLY idx_users_email_hash;
```

---

## 7. Maintenance et Monitoring

### V√©rifier l'utilisation d'un index Hash

```sql
-- Statistiques d'utilisation
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan AS utilisations,
    idx_tup_read AS lignes_lues,
    idx_tup_fetch AS lignes_retournees,
    pg_size_pretty(pg_relation_size(indexrelid)) AS taille
FROM pg_stat_user_indexes
WHERE indexname = 'idx_users_email_hash';

-- Si idx_scan = 0 apr√®s un certain temps, l'index n'est jamais utilis√©
```

### V√©rifier qu'une requ√™te utilise l'index Hash

```sql
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM users WHERE email = 'user12345@example.com';

-- Cherchez dans le plan :
-- "Index Scan using idx_users_email_hash on users"
-- ou
-- "Bitmap Index Scan on idx_users_email_hash"
```

### Maintenance des index Hash

```sql
-- Reconstruire l'index (si probl√®mes ou fragmentation)
REINDEX INDEX idx_users_email_hash;

-- Avec PostgreSQL 12+ : reconstruction sans verrouillage
REINDEX INDEX CONCURRENTLY idx_users_email_hash;

-- Reconstruire tous les index d'une table
REINDEX TABLE users;

-- Analyser les statistiques
ANALYZE users;
```

### Surveiller la taille et la fragmentation

```sql
-- Taille de l'index
SELECT
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS taille,
    pg_size_pretty(pg_table_size(tablename::regclass)) AS taille_table,
    round(100.0 * pg_relation_size(indexrelid) /
          NULLIF(pg_table_size(tablename::regclass), 0), 2) AS pct_taille
FROM pg_stat_user_indexes
WHERE indexname = 'idx_users_email_hash';

-- V√©rifier le bloat (fragmentation)
-- N√©cessite l'extension pgstattuple
CREATE EXTENSION IF NOT EXISTS pgstattuple;

SELECT * FROM pgstatindex('idx_users_email_hash');
-- Regarder : avg_leaf_density, leaf_fragmentation
```

### Quand reconstruire un index Hash ?

Reconstruisez l'index si :
- ‚úÖ Beaucoup de suppressions/mises √† jour (bloat √©lev√©)
- ‚úÖ Performance d√©grad√©e au fil du temps
- ‚úÖ Apr√®s une op√©ration massive (COPY, bulk INSERT)
- ‚úÖ Migration de version PostgreSQL majeure

---

## 8. Pi√®ges Courants et Solutions

### Pi√®ge 1 : Choisir Hash alors que B-Tree suffit

```sql
-- ‚ùå PROBL√àME : Index Hash pour une colonne qui sera parfois filtr√©e par range
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    sku TEXT UNIQUE,
    price NUMERIC(10,2)
);

CREATE INDEX idx_sku_hash ON products USING HASH (sku);

-- Requ√™tes actuelles (√©galit√©) :
SELECT * FROM products WHERE sku = 'PROD-12345';  -- ‚úÖ OK avec Hash

-- Mais plus tard, besoin de :
SELECT * FROM products WHERE sku LIKE 'PROD-%';  -- ‚ùå Hash inutile

-- ‚úÖ SOLUTION : Utiliser B-Tree par d√©faut (plus flexible)
DROP INDEX idx_sku_hash;
CREATE INDEX idx_sku_btree ON products (sku);
```

### Pi√®ge 2 : Oublier que Hash ne supporte pas NULL

```sql
-- ‚ùå PROBL√àME : Rechercher les valeurs NULL
SELECT * FROM users WHERE email IS NULL;
-- L'index Hash ne sera PAS utilis√©

-- ‚úÖ SOLUTION :
-- 1. Utiliser B-Tree si NULL est fr√©quent
-- 2. Ou ajouter une contrainte NOT NULL
ALTER TABLE users ALTER COLUMN email SET NOT NULL;
```

### Pi√®ge 3 : Index Hash sur colonne de cl√© √©trang√®re

```sql
-- ‚ùå PROBL√àME : Index Hash sur FK
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id)
);

CREATE INDEX idx_orders_user_hash ON orders USING HASH (user_id);

-- Probl√®mes :
-- 1. FK n√©cessite B-Tree sur users(id)
-- 2. Souvent besoin de ranges : WHERE user_id IN (...)
-- 3. Peut-√™tre ORDER BY user_id

-- ‚úÖ SOLUTION : B-Tree sur les FK
CREATE INDEX idx_orders_user_btree ON orders (user_id);
```

### Pi√®ge 4 : M√©langer sensibilit√© √† la casse

```sql
-- ‚ùå PROBL√àME : Hash est sensible √† la casse
CREATE INDEX idx_username_hash ON users USING HASH (username);

-- Ces deux requ√™tes produisent des hash diff√©rents :
SELECT * FROM users WHERE username = 'Alice';  -- hash('Alice')
SELECT * FROM users WHERE username = 'alice';  -- hash('alice') ‚â† hash('Alice')

-- ‚úÖ SOLUTION 1 : Index sur LOWER()
CREATE INDEX idx_username_lower_hash ON users USING HASH (LOWER(username));
SELECT * FROM users WHERE LOWER(username) = LOWER('Alice');

-- ‚úÖ SOLUTION 2 : Utiliser CITEXT
CREATE EXTENSION IF NOT EXISTS citext;
ALTER TABLE users ALTER COLUMN username TYPE CITEXT;
CREATE INDEX idx_username_hash ON users USING HASH (username);
```

### Pi√®ge 5 : Ne pas v√©rifier l'utilisation r√©elle

```sql
-- ‚ùå PROBL√àME : Cr√©er un index Hash "au cas o√π"
CREATE INDEX idx_some_col_hash ON big_table USING HASH (some_col);

-- Apr√®s 6 mois, l'index n'a jamais √©t√© utilis√©
SELECT idx_scan FROM pg_stat_user_indexes
WHERE indexname = 'idx_some_col_hash';
-- idx_scan = 0

-- ‚úÖ SOLUTION : Supprimer les index inutilis√©s
DROP INDEX idx_some_col_hash;
```

### Pi√®ge 6 : Index Hash sur colonne avec peu de valeurs distinctes

```sql
-- ‚ùå PROBL√àME : Index Hash sur colonne avec faible cardinalit√©
CREATE TABLE orders (
    id BIGSERIAL PRIMARY KEY,
    status TEXT  -- Seulement 5 valeurs : pending, processing, shipped, delivered, cancelled
);

CREATE INDEX idx_status_hash ON orders USING HASH (status);

-- Probl√®mes :
-- 1. Beaucoup de collisions (5 buckets diff√©rents)
-- 2. B-Tree ou Bitmap scan serait mieux
-- 3. Pas de b√©n√©fice r√©el

-- ‚úÖ SOLUTION : Pas d'index ou B-Tree
-- Pour faible cardinalit√©, souvent pas besoin d'index du tout
```

---

## 9. Hash vs B-Tree : Arbre de D√©cision

```
Avez-vous UNIQUEMENT besoin de recherches d'√©galit√© stricte (=) ?
‚îú‚îÄ NON (besoin de >, <, BETWEEN, ORDER BY, LIKE) ‚Üí B-Tree
‚îî‚îÄ OUI ‚Üí Continuez

Avez-vous besoin de UNIQUE ou PRIMARY KEY ?
‚îú‚îÄ OUI ‚Üí B-Tree (Hash ne supporte pas)
‚îî‚îÄ NON ‚Üí Continuez

Avez-vous besoin d'index multi-colonnes ?
‚îú‚îÄ OUI ‚Üí B-Tree (Hash ne supporte pas)
‚îî‚îÄ NON ‚Üí Continuez

La colonne contient-elle beaucoup de valeurs distinctes (haute cardinalit√©) ?
‚îú‚îÄ NON (peu de valeurs) ‚Üí B-Tree ou pas d'index
‚îî‚îÄ OUI ‚Üí Continuez

Avez-vous des benchmarks montrant que Hash est plus rapide ?
‚îú‚îÄ NON ‚Üí B-Tree (par d√©faut, plus s√ªr)
‚îî‚îÄ OUI ‚Üí Hash peut √™tre envisag√©

‚Üí Dans 95% des cas : B-Tree est le meilleur choix
‚Üí Hash uniquement pour cas tr√®s sp√©cifiques
```

---

## 10. Bonnes Pratiques et Recommandations

### ‚úÖ Checklist avant de cr√©er un index Hash

- [ ] Ai-je **uniquement** besoin d'√©galit√© stricte ?
- [ ] La colonne a-t-elle une **haute cardinalit√©** ?
- [ ] Suis-je **certain** de ne jamais avoir besoin de comparaisons ?
- [ ] Ai-je **test√©** avec B-Tree et Hash ?
- [ ] L'index Hash apporte-t-il un **gain mesurable** ?

### ‚úÖ Recommandations g√©n√©rales

1. **Par d√©faut : B-Tree**
   - Plus polyvalent, performances similaires
   - Support√© par toutes les contraintes
   - Mieux optimis√© dans le temps

2. **Hash uniquement si** :
   - Besoin prouv√© par benchmarks
   - Cas d'usage tr√®s sp√©cifique (UUID lookup, cache key)
   - Haute cardinalit√© confirm√©e

3. **Surveiller l'utilisation** :
   - V√©rifier `pg_stat_user_indexes` r√©guli√®rement
   - Supprimer les index inutilis√©s

4. **Documenter le choix** :
   ```sql
   COMMENT ON INDEX idx_users_email_hash IS
   'Index Hash pour lookup UUID uniquement (√©galit√© stricte)';
   ```

5. **Maintenir r√©guli√®rement** :
   - REINDEX apr√®s bulk operations
   - ANALYZE pour statistiques √† jour

---

## 11. Histoire et √âvolution des Index Hash

### √âvolution dans PostgreSQL

| Version | Changement majeur |
|---------|-------------------|
| **PG 8.x et avant** | Hash disponibles mais non recommand√©s (pas de WAL logging) |
| **PG 10 (2017)** | üéâ **WAL logging ajout√©** ‚Üí Hash enfin fiables pour production |
| **PG 12 (2019)** | Support REINDEX CONCURRENTLY |
| **PG 13 (2020)** | Am√©liorations de performance |
| **PG 18 (2025)** | Optimisations continues, mais B-Tree reste dominant |

### Pourquoi B-Tree a gagn√© ?

Malgr√© les am√©liorations, B-Tree reste pr√©f√©r√© car :
1. **Polyvalence** : Supporte tous les op√©rateurs
2. **Maturit√©** : 40+ ans d'optimisations
3. **Performance** : Quasi √©gal √† Hash pour l'√©galit√©
4. **Fiabilit√©** : Historique plus long en production

---

## 12. Exemples Concrets : Quand Hash EST Justifi√©

### Exemple 1 : API Token Verification

```sql
-- Table de tokens d'API
CREATE TABLE api_tokens (
    token TEXT PRIMARY KEY,  -- SHA256 hash
    user_id INTEGER NOT NULL,
    scopes TEXT[],
    expires_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index Hash justifi√© : uniquement v√©rification d'√©galit√©
CREATE INDEX idx_api_tokens_hash ON api_tokens USING HASH (token);

-- Requ√™te typique : v√©rifier token
SELECT user_id, scopes, expires_at
FROM api_tokens
WHERE token = 'abc123...xyz'  -- Hash direct
  AND expires_at > NOW();

-- Jamais besoin de : LIKE, >, <, ORDER BY sur token
```

### Exemple 2 : Distributed Cache Key Lookup

```sql
-- Table de cache distribu√©
CREATE TABLE distributed_cache (
    cache_key TEXT PRIMARY KEY,
    cache_value BYTEA NOT NULL,
    ttl INTEGER NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Hash optimal : lookup ultra-rapide par cl√© exacte
CREATE INDEX idx_cache_key_hash ON distributed_cache USING HASH (cache_key);

-- Pattern d'utilisation :
-- GET /cache/{key}
SELECT cache_value FROM distributed_cache WHERE cache_key = $1;

-- SET /cache/{key}
INSERT INTO distributed_cache (cache_key, cache_value, ttl)
VALUES ($1, $2, $3)
ON CONFLICT (cache_key) DO UPDATE SET cache_value = EXCLUDED.cache_value;

-- DELETE /cache/{key}
DELETE FROM distributed_cache WHERE cache_key = $1;
```

### Exemple 3 : Fingerprint Deduplication

```sql
-- D√©tection de doublons par empreinte
CREATE TABLE file_uploads (
    id BIGSERIAL PRIMARY KEY,
    filename TEXT NOT NULL,
    content_fingerprint TEXT NOT NULL,  -- MD5/SHA256
    file_size BIGINT,
    upload_date TIMESTAMPTZ DEFAULT NOW()
);

-- Hash pour d√©duplication rapide
CREATE INDEX idx_uploads_fingerprint_hash ON file_uploads
USING HASH (content_fingerprint);

-- Avant upload : v√©rifier si fichier existe d√©j√†
SELECT id, filename
FROM file_uploads
WHERE content_fingerprint = 'abc123def456...';

-- Si EXISTS ‚Üí fichier d√©j√† pr√©sent, ne pas uploader
```

---

## 13. Conclusion

### Points cl√©s √† retenir

1. **Hash = √âgalit√© uniquement** : Aucune autre op√©ration support√©e
2. **B-Tree g√©n√©ralement meilleur** : Performance similaire + polyvalence
3. **Hash rarement justifi√©** : Cas tr√®s sp√©cifiques uniquement
4. **Depuis PG 10 : fiable** : WAL logging r√©sout les anciens probl√®mes
5. **Simple mais limit√©** : Conception minimaliste, usage restreint

### Quand utiliser Hash (r√©capitulatif)

‚úÖ **Utilisez Hash si** :
- √âgalit√© stricte **uniquement**
- Haute cardinalit√© (UUID, tokens, hashes)
- Benchmarks montrent un gain
- Jamais besoin de comparaisons

‚ùå **N'utilisez PAS Hash si** :
- Besoin de >, <, BETWEEN
- Besoin de ORDER BY
- UNIQUE ou PRIMARY KEY
- Index multi-colonnes
- FOREIGN KEY
- Doute sur usage futur

### Recommandation finale

**Dans 95% des cas : utilisez B-Tree**

B-Tree est :
- ‚úÖ Aussi rapide pour l'√©galit√©
- ‚úÖ Supporte toutes les op√©rations
- ‚úÖ Plus mature et optimis√©
- ‚úÖ Standard de l'industrie

Hash n'est utile que pour des cas tr√®s sp√©cifiques o√π vous avez :
- Besoin prouv√© par benchmarks
- Contraintes d'usage strictes (√©galit√© uniquement)
- Haute cardinalit√© confirm√©e

### L'avenir des index Hash

Les index Hash resteront probablement un **outil de niche** dans PostgreSQL. Le B-Tree a tellement √©volu√© qu'il est devenu le couteau suisse universel, laissant Hash pour des micro-optimisations sp√©cifiques.

**En production** : Commencez toujours par B-Tree, ne passez √† Hash que si vous avez une raison mesur√©e et document√©e.

---

## 14. Ressources et Documentation

### Documentation officielle PostgreSQL 18

- [Hash Indexes](https://www.postgresql.org/docs/18/hash-intro.html)
- [Index Types Overview](https://www.postgresql.org/docs/18/indexes-types.html)
- [CREATE INDEX](https://www.postgresql.org/docs/18/sql-createindex.html)

### Articles de r√©f√©rence

- **"Hash Indexes: How and When to Use Them"** - Blog PostgreSQL
- **"The Return of Hash Indexes in PostgreSQL 10"** - 2ndQuadrant
- **"B-Tree vs Hash: Performance Analysis"** - Percona Blog

### Outils de monitoring

- **pg_stat_user_indexes** : Statistiques d'utilisation
- **EXPLAIN (ANALYZE)** : V√©rifier l'utilisation d'index
- **pgstattuple** : Analyser la fragmentation

### Lectures compl√©mentaires

- **"PostgreSQL: Up and Running"** - Regina Obe & Leo Hsu
- **"The Art of PostgreSQL"** - Dimitri Fontaine
- **PostgreSQL Wiki** : Index Types Comparison

---


‚è≠Ô∏è [SP-GiST (Space-Partitioned GiST) : Structures non-√©quilibr√©es](/13-indexation-et-optimisation/04.5-spgist-space-partitioned.md)
