üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.4.5. SP-GiST (Space-Partitioned GiST) : Structures non-√©quilibr√©es

## Introduction

Les index **SP-GiST** (Space-Partitioned Generalized Search Tree) sont un type d'index avanc√© de PostgreSQL con√ßu pour des **structures de donn√©es partitionn√©es dans l'espace**. Contrairement √† GiST qui cr√©e des arbres √©quilibr√©s, SP-GiST supporte des structures **non-√©quilibr√©es** qui refl√®tent mieux certains types de donn√©es.

### L'analogie de l'arbre g√©n√©alogique vs l'organigramme

Pour comprendre la diff√©rence :

- **GiST (√©quilibr√©)** : C'est comme un organigramme d'entreprise o√π tous les niveaux sont bien d√©finis et √©quilibr√©s (direction ‚Üí d√©partements ‚Üí √©quipes)
- **SP-GiST (non-√©quilibr√©)** : C'est comme un arbre g√©n√©alogique o√π certaines branches peuvent √™tre tr√®s longues (arri√®re-arri√®re-grands-parents) et d'autres courtes

### Qu'est-ce que "non-√©quilibr√©" signifie ?

Un arbre **√©quilibr√©** (comme B-Tree ou GiST) maintient une profondeur similaire pour toutes les branches :
```
        Racine
       /  |  \
      A   B   C     ‚Üê Niveau 1
     /|   |   |\
    D E   F   G H   ‚Üê Niveau 2
```

Un arbre **non-√©quilibr√©** (SP-GiST) peut avoir des branches de profondeurs diff√©rentes :
```
        Racine
       /  |  \
      A   B   C     ‚Üê Niveau 1
     /    |
    D     E          ‚Üê Niveau 2
   /     /|\
  F     G H I        ‚Üê Niveau 3
 /
J                    ‚Üê Niveau 4
```

Cette flexibilit√© est id√©ale pour certaines structures de donn√©es naturellement d√©s√©quilibr√©es.

### Caract√©ristiques essentielles

- ‚úÖ **Structures non-√©quilibr√©es** : Arbres naturellement d√©s√©quilibr√©s
- ‚úÖ **Partitionnement spatial** : Divise l'espace en r√©gions
- ‚úÖ **Quadtrees** : Pour donn√©es g√©ospatiales (2D)
- ‚úÖ **K-d trees** : Pour recherche multidimensionnelle
- ‚úÖ **Radix trees** : Pour pr√©fixes de texte
- ‚úÖ **Performance pr√©visible** : Pas de r√©√©quilibrage co√ªteux

### Quand utiliser SP-GiST ?

‚úÖ **√Ä utiliser pour :**
- Recherche de **pr√©fixes** dans du texte (tel%, email@%)
- Donn√©es **g√©ospatiales** avec quadtree
- Points dans un **espace multidimensionnel** (k-d tree)
- Adresses **IP** et **CIDR** (routage r√©seau)
- Structures naturellement **hi√©rarchiques** et d√©s√©quilibr√©es

‚ùå **√Ä √©viter pour :**
- Donn√©es purement unidimensionnelles (pr√©f√©rer B-Tree)
- Recherches full-text compl√®tes (pr√©f√©rer GIN)
- Donn√©es sans structure spatiale ou hi√©rarchique

---

## 1. Comprendre les Structures de Donn√©es SP-GiST

### Structure 1 : Quadtree (Arbre Quaternaire)

Un **quadtree** divise r√©cursivement un espace 2D en quatre quadrants.

#### Visualisation d'un quadtree

```
Espace 2D divis√© en quadrants :

    +-------+-------+
    |  NW   |  NE   |  Nord-Ouest | Nord-Est
    |   ‚Ä¢   |       |
    +-------+-------+
    |  SW   |  SE   |  Sud-Ouest  | Sud-Est
    |       |   ‚Ä¢   |
    +-------+-------+

Si trop de points dans un quadrant ‚Üí subdivision :

    +---+---+-------+
    |NW1|NW2|  NE   |
    +---+---+       |
    |NW3|NW4|       |
    +-------+-------+
    |  SW   |  SE   |
    |       |   ‚Ä¢   |
    +-------+-------+
```

**Cas d'usage** : Points GPS, coordonn√©es spatiales, donn√©es cartographiques

### Structure 2 : K-d Tree (K-dimensional Tree)

Un **k-d tree** partitionne l'espace en s√©parant alternativement selon diff√©rentes dimensions.

#### Exemple avec des points 2D (x, y)

```
Points : A(2,3), B(5,4), C(9,6), D(4,7), E(8,1), F(7,2)

Division altern√©e X puis Y puis X...

Niveau 1 (X) : diviser par x=5
    x < 5          |     x >= 5
  A(2,3), D(4,7)   |   C(9,6), E(8,1), F(7,2), B(5,4)

Niveau 2 (Y) : diviser par y
    y < 5          |     y >= 5
  A(2,3), E(8,1)   |   D(4,7), C(9,6)
  F(7,2), B(5,4)
```

**Cas d'usage** : Recherche de voisins les plus proches, clustering spatial

### Structure 3 : Radix Tree (Prefix Tree)

Un **radix tree** stocke des cha√Ænes en partageant les pr√©fixes communs.

#### Visualisation d'un radix tree

```
Mots : "test", "tea", "ted", "to", "inn", "in"

        [root]
       /      \
    "te"      "in"
    / \         \
  "a" "d"      "n"
  /   /
"st" ""

R√©sultat :
- "tea"  : te ‚Üí a
- "ted"  : te ‚Üí d
- "test" : te ‚Üí st
- "to"   : to
- "in"   : in
- "inn"  : in ‚Üí n
```

**Cas d'usage** : Autocompl√©tion, recherche de pr√©fixes, suggestions de recherche

### Structure 4 : Suffix Tree

Un **suffix tree** stocke tous les suffixes d'une cha√Æne pour recherche rapide.

**Cas d'usage** : Recherche de motifs, bioinformatique (s√©quences ADN)

---

## 2. Diff√©rence entre GiST et SP-GiST

### Comparaison conceptuelle

| Crit√®re | GiST | SP-GiST |
|---------|------|---------|
| **Structure** | Arbre √©quilibr√© | Arbre non-√©quilibr√© |
| **Profondeur** | Uniforme pour toutes les branches | Variable selon les donn√©es |
| **Partitionnement** | R√©gions qui se chevauchent | Partitionnement strict (disjoints) |
| **R√©√©quilibrage** | Co√ªteux lors d'insertions | Pas de r√©√©quilibrage n√©cessaire |
| **Cas d'usage** | Donn√©es multidimensionnelles g√©n√©rales | Donn√©es avec structure hi√©rarchique naturelle |

### Visualisation : Partitionnement GiST vs SP-GiST

#### GiST : R√©gions qui se chevauchent
```
    +-------+
    | Zone1 |
    |   +-------+
    +---|Zone2  |
        |       |
        +-------+

Les zones peuvent se chevaucher
‚Üí Recherche peut v√©rifier plusieurs zones
```

#### SP-GiST : Partitionnement strict
```
    +-------+-------+
    | Zone1 | Zone2 |
    +-------+-------+
    | Zone3 | Zone4 |
    +-------+-------+

Les zones sont disjointes
‚Üí Recherche va directement √† la bonne zone
```

### Quand pr√©f√©rer SP-GiST √† GiST ?

**Choisissez SP-GiST si** :
- ‚úÖ Donn√©es avec **structure naturelle** (pr√©fixes, quadrants)
- ‚úÖ Besoin de **partitionnement strict** (pas de chevauchement)
- ‚úÖ Recherches de **pr√©fixes** ou **suffixes**
- ‚úÖ Points dans un **espace multidimensionnel** r√©gulier

**Choisissez GiST si** :
- ‚úÖ Donn√©es **g√©om√©triques complexes** (polygones, lignes)
- ‚úÖ Chevauchement de **r√©gions in√©vitable**
- ‚úÖ Hi√©rarchies avec **ltree**

---

## 3. Cr√©ation et Syntaxe des Index SP-GiST

### Syntaxe de base

```sql
CREATE INDEX nom_index ON table USING SPGIST (colonne);
```

### Classes d'op√©rateurs SP-GiST

SP-GiST supporte diff√©rentes classes d'op√©rateurs selon le type de donn√©es :

| Type de donn√©es | Classe d'op√©rateur | Structure utilis√©e | Cas d'usage |
|----------------|-------------------|-------------------|-------------|
| `TEXT`, `VARCHAR` | `text_ops` | Radix tree | Recherche de pr√©fixes |
| `INET`, `CIDR` | `inet_ops` | Radix tree | Adresses r√©seau |
| `geometry(Point)` | `kd_point_ops` | K-d tree | Points 2D |
| `box` | `quad_box_ops` | Quadtree | Rectangles 2D |
| `point` | `quad_point_ops` | Quadtree | Points natifs PostgreSQL |
| `range types` | `range_ops` | Radix tree | Intervalles |

---

## 4. SP-GiST pour la Recherche de Pr√©fixes (Texte)

### Principe

SP-GiST avec un radix tree est **excellent** pour les recherches de pr√©fixes car il partage les pr√©fixes communs.

### Cr√©ation d'un index SP-GiST sur TEXT

```sql
-- Table d'utilisateurs avec emails
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email TEXT NOT NULL,
    username TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Ins√©rer des donn√©es de test
INSERT INTO users (email, username)
SELECT
    'user' || generate_series || '@example.com',
    'user' || generate_series
FROM generate_series(1, 100000);

-- Ajouter des emails avec pr√©fixes vari√©s
INSERT INTO users (email, username) VALUES
    ('admin@example.com', 'admin'),
    ('admin.john@example.com', 'admin_john'),
    ('admin.jane@example.com', 'admin_jane'),
    ('support@example.com', 'support'),
    ('support.tech@example.com', 'support_tech');

-- Cr√©er un index SP-GiST pour recherche de pr√©fixes
CREATE INDEX idx_users_email_spgist ON users USING SPGIST (email);

ANALYZE users;
```

### Requ√™tes optimis√©es par SP-GiST

#### Recherche de pr√©fixe avec LIKE

```sql
-- ‚úÖ EXCELLENT : Pr√©fixe au d√©but (utilise SP-GiST)
SELECT email, username
FROM users
WHERE email LIKE 'admin%';

-- Plan d'ex√©cution :
-- Index Scan using idx_users_email_spgist on users

-- R√©sultat :
-- admin@example.com
-- admin.john@example.com
-- admin.jane@example.com
```

#### Recherche de pr√©fixe avec op√©rateurs texte

```sql
-- ‚úÖ Op√©rateur ^@ (starts with) - sp√©cifique √† SP-GiST
SELECT email
FROM users
WHERE email ^@ 'support';

-- √âquivalent √† LIKE 'support%'
```

#### Comparaison avec B-Tree et GiST

```sql
-- Cr√©er les trois types d'index pour comparaison
CREATE INDEX idx_email_btree ON users USING BTREE (email);
CREATE INDEX idx_email_gist ON users USING GIST (email);
CREATE INDEX idx_email_spgist ON users USING SPGIST (email);

-- Test de performance : recherche de pr√©fixe
EXPLAIN (ANALYZE, BUFFERS)
SELECT COUNT(*) FROM users WHERE email LIKE 'user1%';

-- R√©sultats typiques :
-- SP-GiST : ~2 ms   (optimal pour pr√©fixes)
-- B-Tree :  ~3 ms   (bon aussi)
-- GiST :    ~15 ms  (moins efficace)
```

### Cas d'usage : Autocompl√©tion

```sql
-- Fonction d'autocompl√©tion
CREATE OR REPLACE FUNCTION autocomplete_email(prefix TEXT, max_results INTEGER DEFAULT 10)
RETURNS TABLE(email TEXT, username TEXT) AS $$
BEGIN
    RETURN QUERY
    SELECT u.email, u.username
    FROM users u
    WHERE u.email LIKE prefix || '%'
    ORDER BY u.email
    LIMIT max_results;
END;
$$ LANGUAGE plpgsql STABLE;

-- Utilisation
SELECT * FROM autocomplete_email('admin');

-- R√©sultat :
-- admin.jane@example.com | admin_jane
-- admin.john@example.com | admin_john
-- admin@example.com      | admin
```

### Limitations importantes

```sql
-- ‚úÖ SP-GiST est utilis√©
SELECT * FROM users WHERE email LIKE 'admin%';

-- ‚ùå SP-GiST N'EST PAS utilis√© (pr√©fixe manquant)
SELECT * FROM users WHERE email LIKE '%admin%';  -- Scan s√©quentiel
SELECT * FROM users WHERE email LIKE '%@example.com';  -- Scan s√©quentiel

-- ‚úÖ Possible mais moins optimal
SELECT * FROM users WHERE email LIKE 'admin.%';  -- Utilise SP-GiST
```

---

## 5. SP-GiST pour les Adresses R√©seau (INET/CIDR)

### Principe

Les adresses IP et les plages CIDR ont une structure hi√©rarchique naturelle (pr√©fixes de bits), parfaite pour SP-GiST.

### Cr√©ation d'un index SP-GiST sur INET

```sql
-- Table de logs r√©seau
CREATE TABLE network_logs (
    id BIGSERIAL PRIMARY KEY,
    source_ip INET NOT NULL,
    destination_ip INET NOT NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    bytes_transferred BIGINT,
    protocol TEXT
);

-- Ins√©rer des donn√©es de test
INSERT INTO network_logs (source_ip, destination_ip, bytes_transferred, protocol)
SELECT
    ('192.168.' || (random() * 255)::INTEGER || '.' || (random() * 255)::INTEGER)::INET,
    ('10.0.' || (random() * 255)::INTEGER || '.' || (random() * 255)::INTEGER)::INET,
    (random() * 10000000)::BIGINT,
    (ARRAY['TCP', 'UDP', 'ICMP'])[floor(random() * 3 + 1)]
FROM generate_series(1, 1000000);

-- Index SP-GiST sur source_ip
CREATE INDEX idx_network_source_spgist ON network_logs USING SPGIST (source_ip);

ANALYZE network_logs;
```

### Table de routage avec CIDR

```sql
-- Table de routage r√©seau
CREATE TABLE routing_table (
    id SERIAL PRIMARY KEY,
    network CIDR NOT NULL,
    gateway INET NOT NULL,
    interface TEXT,
    metric INTEGER
);

-- Ins√©rer des routes
INSERT INTO routing_table (network, gateway, interface, metric) VALUES
    ('192.168.0.0/16', '10.0.0.1', 'eth0', 10),
    ('192.168.1.0/24', '10.0.0.2', 'eth0', 20),
    ('192.168.1.0/25', '10.0.0.3', 'eth1', 15),
    ('10.0.0.0/8', '172.16.0.1', 'eth2', 50),
    ('172.16.0.0/12', '192.168.1.1', 'eth0', 30);

-- Index SP-GiST pour recherche de route
CREATE INDEX idx_routing_network_spgist ON routing_table USING SPGIST (network);
```

### Requ√™tes r√©seau optimis√©es

#### Recherche de containment (IP dans r√©seau)

```sql
-- Trouver √† quel r√©seau appartient une IP
SELECT network, gateway, interface
FROM routing_table
WHERE network >>= '192.168.1.50'::INET  -- Op√©rateur "contient ou √©gal"
ORDER BY masklen(network) DESC  -- Plus sp√©cifique d'abord
LIMIT 1;

-- R√©sultat : 192.168.1.0/25 (plus sp√©cifique que /24 ou /16)
```

#### Op√©rateurs r√©seau support√©s par SP-GiST

```sql
-- << : strictement contenu dans
SELECT * FROM routing_table WHERE '192.168.1.0/25'::CIDR << '192.168.0.0/16'::CIDR;

-- <<= : contenu dans ou √©gal
SELECT * FROM routing_table WHERE network <<= '192.168.0.0/16'::CIDR;

-- >> : strictement contient
SELECT * FROM routing_table WHERE '192.168.0.0/16'::CIDR >> network;

-- >>= : contient ou √©gal
SELECT * FROM routing_table WHERE '192.168.0.0/16'::CIDR >>= network;

-- && : chevauche
SELECT * FROM routing_table WHERE network && '192.168.1.0/24'::CIDR;
```

#### Cas d'usage : Filtrage de logs par subnet

```sql
-- Tous les logs d'un subnet sp√©cifique
SELECT
    source_ip,
    destination_ip,
    bytes_transferred,
    timestamp
FROM network_logs
WHERE source_ip <<= '192.168.1.0/24'::CIDR  -- IPs dans ce subnet
ORDER BY timestamp DESC
LIMIT 100;

-- SP-GiST parcourt efficacement l'arbre de pr√©fixes
```

### Exemple : G√©olocalisation IP

```sql
-- Table de g√©olocalisation IP
CREATE TABLE ip_geolocation (
    id SERIAL PRIMARY KEY,
    ip_range CIDR NOT NULL,
    country TEXT,
    city TEXT,
    latitude NUMERIC(9,6),
    longitude NUMERIC(9,6)
);

-- Index SP-GiST
CREATE INDEX idx_ipgeo_range_spgist ON ip_geolocation USING SPGIST (ip_range);

-- Donn√©es exemple
INSERT INTO ip_geolocation (ip_range, country, city, latitude, longitude) VALUES
    ('8.8.8.0/24', 'US', 'Mountain View', 37.386, -122.084),
    ('1.1.1.0/24', 'AU', 'Sydney', -33.868, 151.207),
    ('208.67.222.0/24', 'US', 'San Francisco', 37.775, -122.419);

-- Lookup g√©ographique
CREATE OR REPLACE FUNCTION geolocate_ip(p_ip INET)
RETURNS TABLE(country TEXT, city TEXT, latitude NUMERIC, longitude NUMERIC) AS $$
BEGIN
    RETURN QUERY
    SELECT g.country, g.city, g.latitude, g.longitude
    FROM ip_geolocation g
    WHERE g.ip_range >>= p_ip
    ORDER BY masklen(g.ip_range) DESC
    LIMIT 1;
END;
$$ LANGUAGE plpgsql STABLE;

-- Utilisation
SELECT * FROM geolocate_ip('8.8.8.8');
-- R√©sultat : US | Mountain View | 37.386000 | -122.084000
```

---

## 6. SP-GiST pour les Donn√©es G√©om√©triques (Points)

### Quadtree pour points 2D

SP-GiST peut indexer des points g√©om√©triques avec une structure de quadtree, particuli√®rement efficace pour des donn√©es distribu√©es uniform√©ment.

```sql
-- Table de points d'int√©r√™t
CREATE TABLE poi_points (
    id SERIAL PRIMARY KEY,
    nom TEXT NOT NULL,
    location point NOT NULL,  -- Type natif PostgreSQL
    categorie TEXT
);

-- Ins√©rer des points al√©atoires
INSERT INTO poi_points (nom, location, categorie)
SELECT
    'POI_' || generate_series,
    point(random() * 100, random() * 100),
    (ARRAY['restaurant', 'hotel', 'musee', 'parc'])[floor(random() * 4 + 1)]
FROM generate_series(1, 100000);

-- Index SP-GiST avec quadtree
CREATE INDEX idx_poi_location_spgist ON poi_points USING SPGIST (location);

ANALYZE poi_points;
```

### Requ√™tes spatiales avec SP-GiST

```sql
-- Recherche dans une bo√Æte (rectangle)
SELECT nom, location
FROM poi_points
WHERE location <@ box '((10,10),(20,20))';  -- Points dans la bo√Æte

-- Recherche de proximit√© (moins efficace que GiST pour cela)
SELECT nom, location
FROM poi_points
ORDER BY location <-> point '(50, 50)'  -- Distance au point
LIMIT 10;
```

### K-d Tree pour points (avec PostGIS)

```sql
-- Avec PostGIS (plus puissant que le type natif)
CREATE EXTENSION IF NOT EXISTS postgis;

CREATE TABLE poi_postgis (
    id SERIAL PRIMARY KEY,
    nom TEXT NOT NULL,
    geom geometry(Point, 4326)  -- WGS84
);

-- Ins√©rer des points GPS (Paris)
INSERT INTO poi_postgis (nom, geom) VALUES
    ('Tour Eiffel', ST_Point(2.2945, 48.8584, 4326)),
    ('Louvre', ST_Point(2.3376, 48.8606, 4326)),
    ('Arc de Triomphe', ST_Point(2.2950, 48.8738, 4326));

-- Index SP-GiST avec k-d tree (disponible avec PostGIS)
CREATE INDEX idx_poi_geom_spgist ON poi_postgis USING SPGIST (geom);

-- Note : Pour PostGIS, GiST reste g√©n√©ralement pr√©f√©r√©
-- SP-GiST est utile pour des distributions sp√©cifiques de points
```

---

## 7. SP-GiST pour les Types Range

### Principe

Les types range (intervalles) ont une structure hi√©rarchique naturelle, adapt√©e √† SP-GiST.

```sql
-- Table de r√©servations avec ranges temporels
CREATE TABLE reservations (
    id SERIAL PRIMARY KEY,
    ressource_id INTEGER NOT NULL,
    periode tstzrange NOT NULL,  -- Range de timestamps
    utilisateur TEXT,
    EXCLUDE USING GIST (ressource_id WITH =, periode WITH &&)
);

-- Index SP-GiST sur la p√©riode
CREATE INDEX idx_reservations_periode_spgist ON reservations USING SPGIST (periode);

-- Ins√©rer des r√©servations
INSERT INTO reservations (ressource_id, periode, utilisateur) VALUES
    (1, tstzrange('2024-01-15 09:00', '2024-01-15 11:00'), 'Alice'),
    (1, tstzrange('2024-01-15 14:00', '2024-01-15 16:00'), 'Bob'),
    (2, tstzrange('2024-01-15 10:00', '2024-01-15 12:00'), 'Charlie'),
    (1, tstzrange('2024-01-16 09:00', '2024-01-16 11:00'), 'Diana');
```

### Requ√™tes sur ranges

```sql
-- Trouver les r√©servations qui chevauchent une p√©riode
SELECT *
FROM reservations
WHERE periode && tstzrange('2024-01-15 10:00', '2024-01-15 15:00');

-- Trouver les r√©servations contenues dans une p√©riode
SELECT *
FROM reservations
WHERE periode <@ tstzrange('2024-01-15 00:00', '2024-01-16 00:00');

-- Disponibilit√©s (ranges qui ne chevauchent pas)
SELECT *
FROM reservations
WHERE NOT (periode && tstzrange('2024-01-15 12:00', '2024-01-15 13:00'));
```

### Autres types range

```sql
-- Ranges num√©riques
CREATE TABLE promotions (
    id SERIAL PRIMARY KEY,
    nom TEXT,
    prix_range numrange  -- Prix entre X et Y
);

CREATE INDEX idx_promo_range_spgist ON promotions USING SPGIST (prix_range);

-- Ranges de dates
CREATE TABLE events (
    id SERIAL PRIMARY KEY,
    titre TEXT,
    periode daterange  -- Du DD/MM/YYYY au DD/MM/YYYY
);

CREATE INDEX idx_events_periode_spgist ON events USING SPGIST (periode);
```

---

## 8. Performance et Comparaisons

### Comparaison : SP-GiST vs B-Tree vs GiST

#### Pour recherche de pr√©fixes (texte)

```sql
CREATE TABLE test_text (
    id SERIAL PRIMARY KEY,
    email TEXT NOT NULL
);

INSERT INTO test_text (email)
SELECT 'user' || generate_series || '@' ||
       (ARRAY['gmail.com', 'yahoo.com', 'hotmail.com'])[floor(random() * 3 + 1)]
FROM generate_series(1, 1000000);

-- Cr√©er les trois index
CREATE INDEX idx_text_btree ON test_text (email);
CREATE INDEX idx_text_gist ON test_text USING GIST (email);
CREATE INDEX idx_text_spgist ON test_text USING SPGIST (email);

ANALYZE test_text;

-- Benchmark : recherche de pr√©fixe
\timing on

-- SP-GiST (optimal)
EXPLAIN ANALYZE SELECT COUNT(*) FROM test_text WHERE email LIKE 'user12%';
-- ~3 ms

-- B-Tree (bon aussi)
EXPLAIN ANALYZE SELECT COUNT(*) FROM test_text WHERE email LIKE 'user12%';
-- ~4 ms

-- GiST (moins bon)
EXPLAIN ANALYZE SELECT COUNT(*) FROM test_text WHERE email LIKE 'user12%';
-- ~20 ms
```

#### Pour adresses r√©seau (INET)

```sql
-- SP-GiST : Excellent
-- Recherche de containment hi√©rarchique optimale

-- GiST : Bon
-- Mais structure plus lourde

-- B-Tree : Inadapt√©
-- Ne supporte pas les op√©rateurs r√©seau
```

### Taille comparative

```sql
SELECT
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS taille,
    idx_scan AS utilisations
FROM pg_stat_user_indexes
WHERE tablename = 'test_text'
ORDER BY pg_relation_size(indexrelid) DESC;

-- R√©sultats typiques (1M lignes) :
-- idx_text_btree  : 21 MB  (plus compact)
-- idx_text_spgist : 24 MB  (l√©g√®rement plus gros)
-- idx_text_gist   : 35 MB  (plus volumineux)
```

---

## 9. Cas d'Usage Concrets

### Cas 1 : Syst√®me d'autocompl√©tion

```sql
-- Table de recherche avec suggestions
CREATE TABLE search_suggestions (
    id SERIAL PRIMARY KEY,
    term TEXT NOT NULL,
    popularity INTEGER DEFAULT 0,
    category TEXT
);

-- Index SP-GiST pour pr√©fixes
CREATE INDEX idx_suggestions_term_spgist ON search_suggestions USING SPGIST (term);

-- Ins√©rer des suggestions
INSERT INTO search_suggestions (term, popularity, category) VALUES
    ('postgresql tutorial', 1000, 'database'),
    ('postgresql index', 800, 'database'),
    ('postgresql performance', 600, 'database'),
    ('postgres vs mysql', 400, 'comparison'),
    ('python tutorial', 1200, 'programming'),
    ('python flask', 900, 'programming');

-- Fonction d'autocompl√©tion
CREATE OR REPLACE FUNCTION suggest_search(prefix TEXT, limit_results INTEGER DEFAULT 5)
RETURNS TABLE(term TEXT, popularity INTEGER) AS $$
BEGIN
    RETURN QUERY
    SELECT s.term, s.popularity
    FROM search_suggestions s
    WHERE s.term LIKE prefix || '%'
    ORDER BY s.popularity DESC
    LIMIT limit_results;
END;
$$ LANGUAGE plpgsql STABLE;

-- Utilisation
SELECT * FROM suggest_search('post');

-- R√©sultat :
-- postgresql tutorial    | 1000
-- postgresql index       | 800
-- postgresql performance | 600
-- postgres vs mysql      | 400
```

### Cas 2 : Routage IP dynamique

```sql
-- Table de routage dynamique
CREATE TABLE dynamic_routing (
    id SERIAL PRIMARY KEY,
    destination_network CIDR NOT NULL,
    next_hop INET NOT NULL,
    interface TEXT,
    metric INTEGER,
    last_updated TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_routing_dest_spgist ON dynamic_routing USING SPGIST (destination_network);

-- Fonction de routage (longest prefix match)
CREATE OR REPLACE FUNCTION find_route(dest_ip INET)
RETURNS TABLE(
    network CIDR,
    next_hop INET,
    interface TEXT,
    metric INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        dr.destination_network,
        dr.next_hop,
        dr.interface,
        dr.metric
    FROM dynamic_routing dr
    WHERE dr.destination_network >>= dest_ip
    ORDER BY masklen(dr.destination_network) DESC
    LIMIT 1;
END;
$$ LANGUAGE plpgsql STABLE;

-- Test
SELECT * FROM find_route('192.168.1.50');
```

### Cas 3 : Gestion de calendrier avec exclusions

```sql
-- Table de disponibilit√©s
CREATE TABLE disponibilites (
    id SERIAL PRIMARY KEY,
    employe_id INTEGER NOT NULL,
    periode tstzrange NOT NULL,
    type TEXT CHECK (type IN ('disponible', 'occupe', 'conges')),
    EXCLUDE USING GIST (employe_id WITH =, periode WITH &&)
);

-- Index SP-GiST pour recherches temporelles
CREATE INDEX idx_dispo_periode_spgist ON disponibilites USING SPGIST (periode);

-- Trouver les employ√©s disponibles dans une plage
CREATE OR REPLACE FUNCTION employes_disponibles(
    debut TIMESTAMPTZ,
    fin TIMESTAMPTZ
)
RETURNS TABLE(employe_id INTEGER) AS $$
BEGIN
    RETURN QUERY
    SELECT DISTINCT d.employe_id
    FROM disponibilites d
    WHERE d.type = 'disponible'
      AND d.periode @> tstzrange(debut, fin)  -- Contient toute la p√©riode
    EXCEPT
    SELECT d.employe_id
    FROM disponibilites d
    WHERE d.type IN ('occupe', 'conges')
      AND d.periode && tstzrange(debut, fin);  -- Chevauche
END;
$$ LANGUAGE plpgsql STABLE;
```

### Cas 4 : Syst√®me de cache hi√©rarchique

```sql
-- Cache avec cl√©s hi√©rarchiques
CREATE TABLE hierarchical_cache (
    id SERIAL PRIMARY KEY,
    cache_key TEXT NOT NULL,
    cache_value JSONB,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index SP-GiST pour recherche par pr√©fixe
CREATE INDEX idx_hcache_key_spgist ON hierarchical_cache USING SPGIST (cache_key);

-- Cl√©s de type "app:module:feature:id"
INSERT INTO hierarchical_cache (cache_key, cache_value, expires_at) VALUES
    ('app:users:profile:123', '{"name":"Alice"}', NOW() + INTERVAL '1 hour'),
    ('app:users:profile:456', '{"name":"Bob"}', NOW() + INTERVAL '1 hour'),
    ('app:users:settings:123', '{"theme":"dark"}', NOW() + INTERVAL '1 day'),
    ('app:posts:recent', '[1,2,3]', NOW() + INTERVAL '5 minutes');

-- Invalider tout le cache d'un module
DELETE FROM hierarchical_cache
WHERE cache_key LIKE 'app:users:%'
  AND expires_at > NOW();

-- Recherche efficace avec SP-GiST
SELECT cache_value
FROM hierarchical_cache
WHERE cache_key LIKE 'app:users:profile:%'
  AND expires_at > NOW();
```

---

## 10. Pi√®ges Courants et Solutions

### Pi√®ge 1 : Utiliser SP-GiST pour recherche full-text

```sql
-- ‚ùå PROBL√àME : SP-GiST pour recherche dans le texte
CREATE INDEX idx_content_spgist ON articles USING SPGIST (content);

-- Requ√™tes non optimis√©es :
SELECT * FROM articles WHERE content LIKE '%postgresql%';  -- Scan s√©quentiel
SELECT * FROM articles WHERE content ~* 'performance';     -- Scan s√©quentiel

-- ‚úÖ SOLUTION : GIN pour full-text search
CREATE INDEX idx_content_gin ON articles USING GIN (to_tsvector('french', content));

SELECT * FROM articles
WHERE to_tsvector('french', content) @@ to_tsquery('french', 'postgresql');
```

### Pi√®ge 2 : SP-GiST sur donn√©es sans structure

```sql
-- ‚ùå PROBL√àME : SP-GiST sur UUID al√©atoires
CREATE TABLE sessions (
    session_id UUID PRIMARY KEY DEFAULT gen_random_uuid()
);

CREATE INDEX idx_session_spgist ON sessions USING SPGIST (session_id);

-- Pas de b√©n√©fice : UUIDs sont al√©atoires, pas de structure hi√©rarchique

-- ‚úÖ SOLUTION : B-Tree ou Hash pour UUID
CREATE INDEX idx_session_btree ON sessions (session_id);
```

### Pi√®ge 3 : Oublier la limitation de pr√©fixes

```sql
-- ‚ùå PROBL√àME : Recherche sans pr√©fixe
SELECT * FROM users WHERE email LIKE '%@gmail.com';  -- SP-GiST inutile

-- ‚úÖ SOLUTION : R√©organiser la requ√™te ou utiliser GIN
-- Option 1 : Si souvent recherche par domaine, stocker s√©par√©ment
ALTER TABLE users ADD COLUMN email_domain TEXT;
UPDATE users SET email_domain = split_part(email, '@', 2);
CREATE INDEX idx_domain_btree ON users (email_domain);

-- Option 2 : GIN avec trigrams
CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE INDEX idx_email_trgm ON users USING GIN (email gin_trgm_ops);
SELECT * FROM users WHERE email LIKE '%@gmail.com';  -- Utilise GIN
```

### Pi√®ge 4 : SP-GiST pour donn√©es g√©om√©triques complexes

```sql
-- ‚ùå PROBL√àME : SP-GiST pour polygones complexes
CREATE TABLE zones (
    id SERIAL PRIMARY KEY,
    frontiere geometry(Polygon, 4326)
);

CREATE INDEX idx_zones_spgist ON zones USING SPGIST (frontiere);

-- SP-GiST quadtree n'est pas optimal pour polygones

-- ‚úÖ SOLUTION : GiST pour g√©om√©tries complexes
CREATE INDEX idx_zones_gist ON zones USING GIST (frontiere);
```

### Pi√®ge 5 : Ne pas analyser apr√®s cr√©ation

```sql
-- ‚ùå PROBL√àME : Oublier ANALYZE
CREATE INDEX idx_email_spgist ON users USING SPGIST (email);

-- Statistiques non √† jour ‚Üí planificateur peut ne pas l'utiliser

-- ‚úÖ SOLUTION : Toujours ANALYZE
CREATE INDEX idx_email_spgist ON users USING SPGIST (email);
ANALYZE users;
```

---

## 11. Maintenance et Monitoring

### V√©rifier l'utilisation d'un index SP-GiST

```sql
-- Statistiques d'utilisation
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan AS utilisations,
    idx_tup_read AS lignes_lues,
    idx_tup_fetch AS lignes_retournees,
    pg_size_pretty(pg_relation_size(indexrelid)) AS taille
FROM pg_stat_user_indexes
WHERE indexname LIKE '%spgist%';
```

### V√©rifier qu'une requ√™te utilise SP-GiST

```sql
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM users WHERE email LIKE 'admin%';

-- Chercher :
-- "Index Scan using idx_users_email_spgist"
-- ou
-- "Bitmap Index Scan on idx_users_email_spgist"
```

### Maintenance des index SP-GiST

```sql
-- Reconstruire l'index
REINDEX INDEX idx_users_email_spgist;

-- Avec PostgreSQL 12+ : sans verrouillage
REINDEX INDEX CONCURRENTLY idx_users_email_spgist;

-- Analyser les statistiques
ANALYZE users;

-- Vacuum pour nettoyage
VACUUM users;
```

### Surveiller la sant√© de l'index

```sql
-- Extension pgstattuple pour d√©tails
CREATE EXTENSION IF NOT EXISTS pgstattuple;

SELECT * FROM pgstatindex('idx_users_email_spgist');

-- Regarder :
-- - avg_leaf_density : densit√© des feuilles
-- - leaf_fragmentation : fragmentation
```

---

## 12. Checklist et Bonnes Pratiques

### ‚úÖ Quand utiliser SP-GiST

- [ ] Recherches de **pr√©fixes** (LIKE 'prefix%')
- [ ] Adresses **r√©seau** (INET/CIDR)
- [ ] **Points** dans espace 2D (uniform√©ment distribu√©s)
- [ ] **Ranges** avec hi√©rarchie naturelle
- [ ] Donn√©es avec **structure partitionn√©e**

### ‚úÖ Configuration et cr√©ation

- [ ] Choisir la **classe d'op√©rateur** appropri√©e
- [ ] Ex√©cuter **ANALYZE** apr√®s cr√©ation
- [ ] Documenter le **cas d'usage** de l'index
- [ ] Tester avec **EXPLAIN ANALYZE**

### ‚úÖ Maintenance

- [ ] Surveiller l'utilisation (`pg_stat_user_indexes`)
- [ ] **REINDEX** si fragmentation
- [ ] **VACUUM** r√©gulier
- [ ] V√©rifier les **statistiques** √† jour

### ‚úÖ Performance

- [ ] Comparer avec **B-Tree** et **GiST**
- [ ] Mesurer les **gains r√©els**
- [ ] Optimiser les **requ√™tes** (pr√©fixes corrects)
- [ ] √âviter les **anti-patterns**

---

## 13. SP-GiST vs Autres Index : Tableau R√©capitulatif

| Crit√®re | SP-GiST | B-Tree | GiST | GIN |
|---------|---------|--------|------|-----|
| **Structure** | Non-√©quilibr√© | √âquilibr√© | √âquilibr√© | Inverted |
| **Pr√©fixes (LIKE 'x%')** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê |
| **INET/CIDR** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚ùå |
| **Points 2D** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚ùå | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚ùå |
| **G√©om√©trie complexe** | ‚≠ê‚≠ê | ‚ùå | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚ùå |
| **Full-text** | ‚ùå | ‚ùå | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **Ranges** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚ùå |
| **Taille** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê |
| **Insertion** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê |

---

## 14. Ressources et Documentation

### Documentation officielle PostgreSQL 18

- [SP-GiST Indexes](https://www.postgresql.org/docs/18/spgist.html)
- [SP-GiST Built-in Operator Classes](https://www.postgresql.org/docs/18/spgist-builtin-opclasses.html)
- [Index Types Comparison](https://www.postgresql.org/docs/18/indexes-types.html)

### Articles et √©tudes de cas

- **"Understanding SP-GiST"** - PostgreSQL Wiki
- **"Space-Partitioned GiST in Practice"** - Blog 2ndQuadrant
- **"Network Indexing with SP-GiST"** - Percona Blog

### Lectures recommand√©es

- **"PostgreSQL: Up and Running"** - Regina Obe & Leo Hsu
- **"Mastering PostgreSQL"** - Hans-J√ºrgen Sch√∂nig : Chapitre sur index avanc√©s
- **PostgreSQL Documentation** : Index chapter

### Extensions compl√©mentaires

- **pg_trgm** : Trigrams pour recherches floues
- **PostGIS** : G√©om√©trie avanc√©e (k-d tree support)
- **pgstattuple** : Analyse de sant√© d'index

---

## Conclusion

Les index **SP-GiST** sont un outil sp√©cialis√© et puissant pour des structures de donn√©es **partitionn√©es dans l'espace** et **naturellement non-√©quilibr√©es**. Bien que moins universels que B-Tree, ils excellent dans des niches sp√©cifiques.

### Points cl√©s √† retenir

1. **SP-GiST = Structures non-√©quilibr√©es** : Radix trees, quadtrees, k-d trees
2. **Trois domaines principaux** : Pr√©fixes texte, r√©seaux IP, points 2D
3. **Partitionnement strict** : Pas de chevauchement (contrairement √† GiST)
4. **Performance pr√©visible** : Pas de r√©√©quilibrage co√ªteux
5. **Sp√©cialis√© mais efficace** : Excellent pour cas d'usage cibl√©s

### Cas d'usage id√©aux

- üîç **Autocompl√©tion** : Recherche de pr√©fixes (emails, noms, termes)
- üåê **Routage r√©seau** : CIDR matching, g√©olocalisation IP
- üìç **Donn√©es spatiales** : Points uniform√©ment distribu√©s (quadtree)
- üìÖ **Ranges temporels** : R√©servations, disponibilit√©s
- üîë **Cl√©s hi√©rarchiques** : Cache structur√©, chemins

### Quand utiliser SP-GiST ?

```
Avez-vous des donn√©es avec une structure hi√©rarchique naturelle ?
‚îú‚îÄ NON ‚Üí B-Tree, GiST ou GIN selon le cas
‚îî‚îÄ OUI ‚Üí SP-GiST peut √™tre optimal

Type de hi√©rarchie :
‚îú‚îÄ Pr√©fixes de texte ‚Üí SP-GiST excellent
‚îú‚îÄ R√©seaux IP/CIDR ‚Üí SP-GiST excellent
‚îú‚îÄ Points 2D uniformes ‚Üí SP-GiST ou GiST
‚îú‚îÄ G√©om√©tries complexes ‚Üí GiST pr√©f√©rable
‚îî‚îÄ Ranges hi√©rarchiques ‚Üí SP-GiST bon

‚Üí Toujours comparer avec B-Tree et GiST via EXPLAIN ANALYZE
```

Avec SP-GiST, PostgreSQL offre une solution √©l√©gante pour des structures de donn√©es qui ne s'accommodent pas bien des arbres √©quilibr√©s traditionnels. C'est un outil de niche, mais redoutablement efficace quand le cas d'usage correspond ! üå≥

---


‚è≠Ô∏è [Strat√©gies d'indexation avanc√©es](/13-indexation-et-optimisation/05-strategies-indexation-avancees.md)
