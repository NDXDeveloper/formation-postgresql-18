üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.9.1. Auto-√©limination des Self-Joins (PostgreSQL 18)

## Introduction

PostgreSQL 18 introduit une optimisation intelligente du planificateur de requ√™tes : **l'auto-√©limination des self-joins**. Cette fonctionnalit√© permet au moteur de base de donn√©es de d√©tecter et d'√©liminer automatiquement certaines jointures redondantes d'une table avec elle-m√™me, am√©liorant ainsi significativement les performances sans modification du code SQL.

Pour comprendre cette nouveaut√©, commen√ßons par les bases.

---

## Qu'est-ce qu'un Self-Join ?

Un **self-join** (auto-jointure en fran√ßais) est une op√©ration o√π une table est jointe **avec elle-m√™me**. Cela peut sembler √©trange au premier abord, mais c'est une technique tr√®s utile dans certains sc√©narios.

### Exemple Simple

Imaginons une table `employes` qui contient des employ√©s et leurs managers :

```sql
CREATE TABLE employes (
    id INTEGER PRIMARY KEY,
    nom VARCHAR(100),
    manager_id INTEGER REFERENCES employes(id)
);
```

Pour afficher chaque employ√© avec le nom de son manager, on doit joindre la table avec elle-m√™me :

```sql
SELECT
    e.nom AS employe,
    m.nom AS manager
FROM employes e
LEFT JOIN employes m ON e.manager_id = m.id;
```

Ici, `employes` appara√Æt deux fois dans la requ√™te :
- Une fois avec l'alias `e` (pour l'employ√©)
- Une fois avec l'alias `m` (pour le manager)

C'est un self-join l√©gitime et n√©cessaire.

---

## Le Probl√®me : Self-Joins Redondants

Dans certaines situations, le SQL g√©n√©r√© par des ORM (Object-Relational Mapping) ou des outils de reporting peut cr√©er des **self-joins inutiles**. Ces jointures redondantes n'apportent aucune information suppl√©mentaire mais consomment des ressources.

### Exemple de Self-Join Redondant

```sql
SELECT e1.nom, e1.salaire
FROM employes e1
INNER JOIN employes e2 ON e1.id = e2.id
WHERE e1.departement = 'IT';
```

Dans cette requ√™te, la jointure entre `e1` et `e2` est **totalement inutile** :
- On joint `employes` avec lui-m√™me sur `id = id`
- La cl√© primaire garantit une correspondance 1:1
- Aucune colonne de `e2` n'est utilis√©e
- Cette jointure n'ajoute aucune valeur

Cette requ√™te devrait simplement √™tre :

```sql
SELECT nom, salaire
FROM employes
WHERE departement = 'IT';
```

---

## Pourquoi Cela Arrive-t-il ?

Les self-joins redondants apparaissent fr√©quemment dans plusieurs contextes :

### 1. G√©n√©ration Automatique de Requ√™tes par des ORM

Les frameworks ORM (comme Hibernate, Entity Framework, SQLAlchemy) g√©n√®rent parfois du SQL non optimal lorsqu'ils g√®rent des relations complexes :

```python
# Code Python avec SQLAlchemy (exemple simplifi√©)
query = session.query(Employee.name, Employee.salary)\
    .join(Employee, Employee.id == Employee.id)\
    .filter(Employee.department == 'IT')
```

Ce code peut g√©n√©rer un self-join inutile.

### 2. Outils de Business Intelligence

Les outils BI construisant des requ√™tes dynamiquement peuvent cr√©er des jointures superflues lors de la composition de multiples filtres ou vues.

### 3. Vues Imbriqu√©es

Des vues SQL construites les unes sur les autres peuvent accumuler des self-joins redondants :

```sql
CREATE VIEW vue_employes_base AS
SELECT * FROM employes e1
INNER JOIN employes e2 ON e1.id = e2.id;

-- Puis une autre vue utilisant la premi√®re...
CREATE VIEW vue_employes_it AS
SELECT * FROM vue_employes_base
WHERE departement = 'IT';
```

---

## La Solution PostgreSQL 18 : Auto-√©limination

Avant PostgreSQL 18, ces self-joins redondants √©taient **ex√©cut√©s** tels quels, m√™me s'ils √©taient inutiles. Le d√©veloppeur devait identifier et corriger manuellement ces probl√®mes.

### Comment Fonctionne l'Optimisation ?

Le planificateur de requ√™tes de PostgreSQL 18 analyse d√©sormais la structure des requ√™tes et d√©tecte automatiquement les self-joins qui respectent certains crit√®res :

**Crit√®res de D√©tection :**

1. **Jointure sur cl√© primaire ou unique** : La jointure doit se faire sur une colonne garantissant l'unicit√© (cl√© primaire, contrainte UNIQUE)

2. **Relation 1:1 garantie** : La contrainte d'unicit√© assure qu'une ligne de la premi√®re occurrence correspond √† exactement une ligne de la seconde occurrence

3. **Pas d'utilisation des colonnes de la seconde table** : Aucune colonne de la table "jointe" (la deuxi√®me occurrence) n'est utilis√©e dans le SELECT, WHERE, ou autres clauses

4. **Type de jointure compatible** : INNER JOIN ou LEFT JOIN avec des conditions sp√©cifiques

### Que Fait PostgreSQL 18 ?

Lorsque ces conditions sont remplies, PostgreSQL 18 **√©limine compl√®tement le self-join** du plan d'ex√©cution, transformant efficacement la requ√™te en une simple lecture de table.

---

## Exemples Concrets

### Exemple 1 : Self-Join Simple √âlimin√©

**Requ√™te Originale :**
```sql
SELECT e1.nom, e1.email
FROM employes e1
INNER JOIN employes e2 ON e1.id = e2.id
WHERE e1.salaire > 50000;
```

**Ce Que PostgreSQL 18 Ex√©cute R√©ellement :**
```sql
-- Le planificateur transforme automatiquement en :
SELECT nom, email
FROM employes
WHERE salaire > 50000;
```

Le self-join a √©t√© √©limin√© car :
- ‚úÖ Jointure sur `id` (cl√© primaire)
- ‚úÖ Relation 1:1 garantie
- ‚úÖ Aucune colonne de `e2` utilis√©e
- ‚úÖ INNER JOIN

### Exemple 2 : Avec Contrainte UNIQUE

```sql
CREATE TABLE produits (
    code_produit VARCHAR(20) UNIQUE,
    nom VARCHAR(100),
    prix NUMERIC
);

SELECT p1.nom, p1.prix
FROM produits p1
INNER JOIN produits p2 ON p1.code_produit = p2.code_produit
WHERE p1.prix > 100;
```

M√™me avec une contrainte UNIQUE (et non PRIMARY KEY), PostgreSQL 18 peut √©liminer le self-join.

### Exemple 3 : Self-Join NON √âlimin√© (Utilisation de la Seconde Table)

```sql
SELECT e1.nom, e2.salaire
FROM employes e1
INNER JOIN employes e2 ON e1.id = e2.id
WHERE e1.departement = 'IT';
```

‚ùå **Ce self-join NE SERA PAS √©limin√©** car on utilise `e2.salaire` dans le SELECT. Bien que dans cet exemple `e1.salaire` et `e2.salaire` soient identiques, le planificateur ne peut pas faire cette hypoth√®se sans analyse s√©mantique approfondie.

### Exemple 4 : Self-Join NON √âlimin√© (Pas de Contrainte Unique)

```sql
SELECT c1.nom, c1.email
FROM clients c1
INNER JOIN clients c2 ON c1.email = c2.email
WHERE c1.ville = 'Paris';
```

‚ùå **Ce self-join NE SERA PAS √©limin√©** si `email` n'a pas de contrainte UNIQUE. Plusieurs clients pourraient avoir le m√™me email, cr√©ant une relation 1:N.

---

## B√©n√©fices de Cette Optimisation

### 1. **Performances Am√©lior√©es Automatiquement**

Sans modification du code applicatif, les requ√™tes s'ex√©cutent plus rapidement :
- Moins d'op√©rations de lecture
- Moins de consommation m√©moire
- Moins de cycles CPU

### 2. **R√©duction de la Dette Technique**

Vous n'avez plus besoin de refactoriser imm√©diatement le code g√©n√©r√© par les ORM qui produit des self-joins inutiles. PostgreSQL 18 compense automatiquement.

### 3. **Compatibilit√© Descendante**

Cette optimisation est **totalement transparente** :
- Aucune modification de syntaxe SQL requise
- Les anciennes requ√™tes fonctionnent exactement comme avant
- Le comportement est activ√© par d√©faut

### 4. **Gain Particuli√®rement Important sur Grandes Tables**

Sur des tables de plusieurs millions de lignes, √©liminer un self-join peut r√©duire le temps d'ex√©cution de **50% ou plus**, car on √©vite un scan complet suppl√©mentaire.

---

## V√©rifier l'Optimisation avec EXPLAIN

Vous pouvez utiliser la commande `EXPLAIN` pour v√©rifier si PostgreSQL 18 a √©limin√© un self-join :

### Avant PostgreSQL 18 (ou sur une requ√™te non optimisable)

```sql
EXPLAIN
SELECT e1.nom, e1.email
FROM employes e1
INNER JOIN employes e2 ON e1.id = e2.id
WHERE e1.salaire > 50000;
```

**R√©sultat (PostgreSQL 17 et ant√©rieurs) :**
```
Hash Join
  Hash Cond: (e1.id = e2.id)
  -> Seq Scan on employes e1
       Filter: (salaire > 50000)
  -> Hash
       -> Seq Scan on employes e2
```

On voit bien les **deux scans** de la table `employes`.

### Avec PostgreSQL 18 (self-join √©limin√©)

```sql
EXPLAIN
SELECT e1.nom, e1.email
FROM employes e1
INNER JOIN employes e2 ON e1.id = e2.id
WHERE e1.salaire > 50000;
```

**R√©sultat (PostgreSQL 18) :**
```
Seq Scan on employes e1
  Filter: (salaire > 50000)
```

Le self-join a **disparu** ! Un seul scan de table.

---

## Cas Limites et Consid√©rations

### Quand l'Optimisation NE S'Applique PAS

1. **Colonnes de la seconde table utilis√©es**
   ```sql
   SELECT e1.nom, e2.departement
   FROM employes e1
   INNER JOIN employes e2 ON e1.id = e2.id;
   ```

2. **Pas de contrainte d'unicit√© sur la colonne de jointure**
   ```sql
   SELECT c1.nom
   FROM commandes c1
   INNER JOIN commandes c2 ON c1.client_id = c2.client_id;
   ```

3. **LEFT JOIN avec conditions complexes**
   ```sql
   SELECT e1.nom
   FROM employes e1
   LEFT JOIN employes e2 ON e1.id = e2.id AND e2.actif = true;
   ```

### Impact sur les Statistiques

L'√©limination du self-join est une **transformation du plan d'ex√©cution**, pas une r√©√©criture de la requ√™te. Les statistiques collect√©es (`pg_stat_statements`) montreront toujours la requ√™te originale avec le self-join.

---

## Bonnes Pratiques

### 1. Laissez le Planificateur Faire Son Travail

Ne vous pr√©cipitez pas pour r√©√©crire toutes vos requ√™tes. PostgreSQL 18 g√®re automatiquement de nombreux cas.

### 2. Utilisez EXPLAIN pour V√©rifier

En cas de doute sur une requ√™te critique, utilisez `EXPLAIN ANALYZE` pour confirmer que l'optimisation est appliqu√©e :

```sql
EXPLAIN ANALYZE
SELECT e1.nom
FROM employes e1
INNER JOIN employes e2 ON e1.id = e2.id
WHERE e1.actif = true;
```

### 3. D√©clarez Vos Contraintes !

Pour que cette optimisation fonctionne, il est **crucial** d'avoir des contraintes PRIMARY KEY ou UNIQUE correctement d√©finies :

```sql
-- ‚úÖ BON : Permet l'optimisation
ALTER TABLE employes ADD PRIMARY KEY (id);

-- ‚úÖ BON : Permet aussi l'optimisation
ALTER TABLE produits ADD CONSTRAINT unique_code UNIQUE (code_produit);
```

### 4. Restez Vigilant avec les ORM

M√™me si PostgreSQL 18 compense, il reste pr√©f√©rable de configurer correctement vos ORM pour √©viter de g√©n√©rer des self-joins inutiles en premier lieu.

---

## Conclusion

L'**auto-√©limination des self-joins** dans PostgreSQL 18 est une am√©lioration intelligente qui :

- ‚úÖ Am√©liore automatiquement les performances de requ√™tes sous-optimales
- ‚úÖ R√©duit la charge sur le serveur de base de donn√©es
- ‚úÖ Ne n√©cessite aucune modification de code
- ‚úÖ Est totalement transparente et r√©trocompatible
- ‚úÖ Fonctionne particuli√®rement bien avec du code g√©n√©r√© automatiquement

Cette fonctionnalit√© fait partie d'une s√©rie d'optimisations du planificateur introduites dans PostgreSQL 18, t√©moignant de la maturit√© croissante du moteur et de son intelligence dans la r√©√©criture et l'optimisation des requ√™tes.

**Message cl√© pour les d√©butants :** Vous n'avez rien √† faire de sp√©cial pour b√©n√©ficier de cette optimisation ! Assurez-vous simplement d'avoir des contraintes PRIMARY KEY et UNIQUE correctement d√©finies sur vos tables, et PostgreSQL 18 s'occupera du reste.

---

## Pour Aller Plus Loin

- Documentation officielle PostgreSQL 18 sur les optimisations du planificateur
- Section 13.9.2 : R√©organisation automatique des colonnes DISTINCT
- Section 13.9.3 : Optimisation IN (VALUES ...) vers ANY
- Section 13.6 : Le planificateur de requ√™tes et les statistiques

---


‚è≠Ô∏è [R√©organisation automatique des colonnes DISTINCT](/13-indexation-et-optimisation/09.2-reorganisation-colonnes-distinct.md)
