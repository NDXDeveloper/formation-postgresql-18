ðŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 21.1.3 RÃ©sumÃ© AvancÃ© : MVCC, RÃ©plication, Optimisation et Production

## Introduction

Bienvenue dans ce guide de niveau avancÃ© pour PostgreSQL. AprÃ¨s avoir maÃ®trisÃ© les fondamentaux (SQL, DDL, DML, contraintes) et les concepts intermÃ©diaires (jointures, agrÃ©gation, indexation), vous Ãªtes prÃªt Ã  explorer les mÃ©canismes internes et les pratiques de production qui font de PostgreSQL un systÃ¨me de gestion de bases de donnÃ©es de classe entreprise.

Ce chapitre couvre quatre domaines essentiels :

1. **MVCC** : Le modÃ¨le de concurrence qui permet Ã  PostgreSQL de gÃ©rer des milliers d'utilisateurs simultanÃ©s
2. **RÃ©plication** : Les stratÃ©gies pour la haute disponibilitÃ© et la rÃ©partition de charge
3. **Optimisation** : Les techniques avancÃ©es pour maximiser les performances
4. **Production** : Les bonnes pratiques pour dÃ©ployer, surveiller et maintenir PostgreSQL en environnement professionnel

---

## Partie 1 : MVCC (Multiversion Concurrency Control)

Le MVCC est le cÅ“ur de PostgreSQL. C'est le mÃ©canisme qui permet Ã  plusieurs transactions de travailler simultanÃ©ment sur les mÃªmes donnÃ©es sans se bloquer mutuellement.

### 1.1 Qu'est-ce que le MVCC ?

**MVCC** (Multiversion Concurrency Control) est une technique de gestion de la concurrence qui maintient **plusieurs versions** de chaque ligne de donnÃ©es. Au lieu de verrouiller les lignes pendant la lecture, PostgreSQL permet Ã  chaque transaction de voir une **photo cohÃ©rente** (snapshot) de la base de donnÃ©es Ã  un instant donnÃ©.

#### Le Principe Fondamental

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         MVCC : Le Concept                              â”‚
â”‚                                                                        â”‚
â”‚   Transaction A (lecture)         Transaction B (Ã©criture)             â”‚
â”‚         â”‚                               â”‚                              â”‚
â”‚         â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚                              â”‚
â”‚         â”‚  â”‚ Version 1    â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ CrÃ©e Version 2               â”‚
â”‚         â”‚  â”‚ (ancienne)   â”‚             â”‚                              â”‚
â”‚         â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚                              â”‚
â”‚         â”‚                               â–¼                              â”‚
â”‚         â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚         â”‚                        â”‚ Version 2    â”‚                      â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ (nouvelle)   â”‚                      â”‚
â”‚           Voit Version 1         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚           (snapshot cohÃ©rent)                                          â”‚
â”‚                                                                        â”‚
â”‚   âžœ Les lecteurs ne bloquent pas les Ã©crivains                         â”‚
â”‚   âžœ Les Ã©crivains ne bloquent pas les lecteurs                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Avantages du MVCC** :
- Les lectures ne bloquent jamais les Ã©critures
- Les Ã©critures ne bloquent jamais les lectures
- Chaque transaction voit un Ã©tat cohÃ©rent de la base
- Excellente performance en environnement concurrent

### 1.2 Les Identifiants de Transaction (XID)

Chaque transaction dans PostgreSQL reÃ§oit un identifiant unique appelÃ© **XID** (Transaction ID).

```sql
-- Voir l'identifiant de la transaction courante
SELECT txid_current();
```

PostgreSQL utilise ces XIDs pour dÃ©terminer quelles versions de lignes sont visibles pour chaque transaction.

#### Structure Interne d'une Ligne

Chaque ligne (tuple) dans PostgreSQL contient des colonnes systÃ¨me invisibles :

| Colonne | Description |
|---------|-------------|
| `xmin` | XID de la transaction qui a crÃ©Ã© cette version |
| `xmax` | XID de la transaction qui a supprimÃ©/modifiÃ© cette version (0 si active) |
| `ctid` | Identifiant physique de la ligne (page, offset) |

```sql
-- Voir les colonnes systÃ¨me d'une ligne
SELECT xmin, xmax, ctid, * FROM clients LIMIT 5;
```

### 1.3 Cycle de Vie d'une Ligne

#### Insertion

Quand vous insÃ©rez une ligne :
- `xmin` = XID de votre transaction
- `xmax` = 0 (non supprimÃ©e)

```sql
BEGIN;
INSERT INTO clients (nom) VALUES ('Alice');
-- xmin = 12345 (XID courant), xmax = 0
COMMIT;
```

#### Mise Ã  Jour

Quand vous modifiez une ligne, PostgreSQL ne modifie pas la ligne existante. Il :
1. Marque l'ancienne version comme "supprimÃ©e" (`xmax` = XID courant)
2. CrÃ©e une **nouvelle version** avec les nouvelles valeurs

```sql
BEGIN;
UPDATE clients SET nom = 'Alice Martin' WHERE id = 1;
-- Ancienne ligne : xmax = 12346 (marquÃ©e comme supprimÃ©e)
-- Nouvelle ligne : xmin = 12346, xmax = 0
COMMIT;
```

C'est pourquoi les UPDATEs frÃ©quents crÃ©ent des "lignes mortes" (dead tuples).

#### Suppression

Quand vous supprimez une ligne :
- PostgreSQL marque simplement `xmax` avec le XID courant
- La ligne reste physiquement prÃ©sente jusqu'au VACUUM

```sql
BEGIN;
DELETE FROM clients WHERE id = 1;
-- La ligne est marquÃ©e xmax = 12347, mais existe encore physiquement
COMMIT;
```

### 1.4 VisibilitÃ© des Lignes

Une ligne est **visible** pour une transaction si :
1. `xmin` est une transaction **validÃ©e** (committed) avant le dÃ©but de notre snapshot
2. `xmax` est soit 0, soit une transaction **non validÃ©e** ou validÃ©e **aprÃ¨s** notre snapshot

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    RÃ¨gles de VisibilitÃ©                                 â”‚
â”‚                                                                         â”‚
â”‚   Transaction courante : XID = 100                                      â”‚
â”‚                                                                         â”‚
â”‚   Ligne A : xmin=50 (committed), xmax=0        â†’ VISIBLE âœ“              â”‚
â”‚   Ligne B : xmin=50 (committed), xmax=80       â†’ NON VISIBLE âœ—          â”‚
â”‚   Ligne C : xmin=110 (en cours), xmax=0        â†’ NON VISIBLE âœ—          â”‚
â”‚   Ligne D : xmin=50 (committed), xmax=110      â†’ VISIBLE âœ“              â”‚
â”‚             (xmax en cours = suppression non validÃ©e)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.5 Transactions et Niveaux d'Isolation

Les niveaux d'isolation dÃ©finissent quelles donnÃ©es une transaction peut voir.

#### Les Quatre Niveaux ANSI SQL

| Niveau | Dirty Read | Non-Repeatable Read | Phantom Read |
|--------|------------|---------------------|--------------|
| Read Uncommitted | Possible | Possible | Possible |
| Read Committed | Impossible | Possible | Possible |
| Repeatable Read | Impossible | Impossible | Possible* |
| Serializable | Impossible | Impossible | Impossible |

> **Note PostgreSQL** : PostgreSQL n'implÃ©mente pas rÃ©ellement "Read Uncommitted" - il se comporte comme "Read Committed". De plus, "Repeatable Read" dans PostgreSQL prÃ©vient Ã©galement les Phantom Reads.

#### Read Committed (DÃ©faut)

Chaque instruction voit un nouveau snapshot de la base. C'est le niveau par dÃ©faut.

```sql
-- Session 1
BEGIN;
SELECT * FROM comptes WHERE id = 1;  -- solde = 100

-- Session 2 (pendant ce temps)
UPDATE comptes SET solde = 200 WHERE id = 1;
COMMIT;

-- Session 1 (continue)
SELECT * FROM comptes WHERE id = 1;  -- solde = 200 (voit le changement!)
COMMIT;
```

#### Repeatable Read

Le snapshot est pris au dÃ©but de la **premiÃ¨re instruction** et reste fixe.

```sql
-- Session 1
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM comptes WHERE id = 1;  -- solde = 100

-- Session 2 (pendant ce temps)
UPDATE comptes SET solde = 200 WHERE id = 1;
COMMIT;

-- Session 1 (continue)
SELECT * FROM comptes WHERE id = 1;  -- solde = 100 (mÃªme rÃ©sultat!)
COMMIT;
```

#### Serializable

Le niveau le plus strict. Garantit que les transactions s'exÃ©cutent comme si elles Ã©taient sÃ©quentielles.

```sql
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
-- PostgreSQL vÃ©rifie les conflits et peut annuler la transaction
-- avec l'erreur "could not serialize access"
```

### 1.6 Anomalies Transactionnelles

#### Dirty Read (Lecture Sale)

Lire des donnÃ©es non validÃ©es d'une autre transaction. **Impossible dans PostgreSQL**.

#### Non-Repeatable Read (Lecture Non RÃ©pÃ©table)

La mÃªme requÃªte retourne des rÃ©sultats diffÃ©rents au sein d'une mÃªme transaction.

```sql
-- En Read Committed, ce problÃ¨me peut survenir
BEGIN;
SELECT solde FROM comptes WHERE id = 1;  -- 100
-- Autre transaction modifie et commit
SELECT solde FROM comptes WHERE id = 1;  -- 200 (diffÃ©rent!)
COMMIT;
```

#### Phantom Read (Lecture FantÃ´me)

De nouvelles lignes apparaissent entre deux exÃ©cutions de la mÃªme requÃªte.

```sql
-- En Read Committed
BEGIN;
SELECT COUNT(*) FROM clients WHERE ville = 'Paris';  -- 10
-- Autre transaction insÃ¨re un nouveau client parisien
SELECT COUNT(*) FROM clients WHERE ville = 'Paris';  -- 11 (fantÃ´me!)
COMMIT;
```

### 1.7 Verrouillage (Locks)

Bien que MVCC rÃ©duise le besoin de verrous, PostgreSQL utilise encore des verrous pour certaines opÃ©rations.

#### Types de Verrous sur les Lignes

| Mode | SELECT | SELECT FOR UPDATE | UPDATE | DELETE |
|------|--------|-------------------|--------|--------|
| FOR KEY SHARE | âœ“ | âœ“ | âœ“* | âœ— |
| FOR SHARE | âœ“ | âœ“ | âœ— | âœ— |
| FOR NO KEY UPDATE | âœ“ | âœ— | âœ“* | âœ— |
| FOR UPDATE | âœ“ | âœ— | âœ— | âœ— |

```sql
-- Verrouiller des lignes pour mise Ã  jour
SELECT * FROM comptes WHERE id = 1 FOR UPDATE;

-- Verrouiller sans bloquer (retourne immÃ©diatement si verrouillÃ©)
SELECT * FROM comptes WHERE id = 1 FOR UPDATE NOWAIT;

-- Sauter les lignes verrouillÃ©es
SELECT * FROM comptes FOR UPDATE SKIP LOCKED;
```

#### Verrous de Table

| Mode | Conflit avec |
|------|--------------|
| ACCESS SHARE | ACCESS EXCLUSIVE |
| ROW SHARE | EXCLUSIVE, ACCESS EXCLUSIVE |
| ROW EXCLUSIVE | SHARE, SHARE ROW EXCLUSIVE, EXCLUSIVE, ACCESS EXCLUSIVE |
| SHARE | ROW EXCLUSIVE, SHARE ROW EXCLUSIVE, EXCLUSIVE, ACCESS EXCLUSIVE |
| ACCESS EXCLUSIVE | Tous |

```sql
-- Verrouiller explicitement une table
LOCK TABLE clients IN EXCLUSIVE MODE;

-- Voir les verrous actifs
SELECT * FROM pg_locks WHERE relation = 'clients'::regclass;
```

#### Deadlocks (Interblocages)

Un deadlock survient quand deux transactions s'attendent mutuellement.

```sql
-- Session 1
BEGIN;
UPDATE comptes SET solde = solde - 100 WHERE id = 1;
-- Attend Session 2...

-- Session 2
BEGIN;
UPDATE comptes SET solde = solde - 50 WHERE id = 2;
UPDATE comptes SET solde = solde + 50 WHERE id = 1;  -- BloquÃ© par Session 1

-- Session 1 (continue)
UPDATE comptes SET solde = solde + 100 WHERE id = 2;  -- DEADLOCK!
```

PostgreSQL dÃ©tecte automatiquement les deadlocks (via `deadlock_timeout`, dÃ©faut 1s) et annule une des transactions.

**PrÃ©vention** : Toujours accÃ©der aux ressources dans le **mÃªme ordre**.

### 1.8 Advisory Locks (Verrous Applicatifs)

Les advisory locks sont des verrous personnalisÃ©s gÃ©rÃ©s par votre application.

```sql
-- Obtenir un verrou (bloquant)
SELECT pg_advisory_lock(12345);

-- Tenter d'obtenir un verrou (non bloquant)
SELECT pg_try_advisory_lock(12345);  -- Retourne true/false

-- LibÃ©rer le verrou
SELECT pg_advisory_unlock(12345);

-- Verrous au niveau session vs transaction
SELECT pg_advisory_xact_lock(12345);  -- LibÃ©rÃ© automatiquement au COMMIT
```

**Cas d'usage** : Ã‰viter les traitements en double (jobs cron), mutex applicatifs.

### 1.9 VACUUM : Nettoyer les Versions ObsolÃ¨tes

Le MVCC crÃ©e des "dead tuples" (lignes mortes). **VACUUM** les nettoie.

#### Pourquoi VACUUM est Essentiel

1. **RÃ©cupÃ©rer l'espace** des lignes mortes
2. **Mettre Ã  jour les statistiques** pour le planificateur
3. **PrÃ©venir le Transaction ID Wraparound** (voir ci-dessous)

```sql
-- VACUUM simple (rÃ©cupÃ¨re l'espace pour rÃ©utilisation)
VACUUM clients;

-- VACUUM avec mise Ã  jour des statistiques
VACUUM ANALYZE clients;

-- VACUUM FULL (rÃ©Ã©crit toute la table, rÃ©cupÃ¨re l'espace disque)
-- ATTENTION : Verrouille la table en exclusif !
VACUUM FULL clients;

-- Voir les statistiques de VACUUM
SELECT
    relname,
    n_dead_tup,
    n_live_tup,
    last_vacuum,
    last_autovacuum
FROM pg_stat_user_tables;
```

#### Autovacuum

PostgreSQL exÃ©cute automatiquement VACUUM via le processus **autovacuum**.

```sql
-- ParamÃ¨tres principaux (postgresql.conf)
autovacuum = on                          -- Activer l'autovacuum
autovacuum_vacuum_threshold = 50         -- Lignes mortes minimum
autovacuum_vacuum_scale_factor = 0.2     -- 20% de la table
autovacuum_analyze_threshold = 50
autovacuum_analyze_scale_factor = 0.1
```

Une table est vacuum quand : `dead_tuples > threshold + scale_factor * n_live_tuples`

#### PostgreSQL 18 : AmÃ©liorations Autovacuum

PostgreSQL 18 introduit :
- `autovacuum_vacuum_max_threshold` : Limite haute pour dÃ©clencher le vacuum
- `autovacuum_worker_slots` : Allocation dynamique des workers

### 1.10 Transaction ID Wraparound

Les XIDs sont stockÃ©s sur 32 bits (â‰ˆ4 milliards de valeurs). Quand on approche de la limite, PostgreSQL doit "geler" les anciennes transactions.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Transaction ID Wraparound                             â”‚
â”‚                                                                         â”‚
â”‚   XIDs : 0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º 4 milliards   â”‚
â”‚              â”‚                                        â”‚                 â”‚
â”‚              â”‚  "PassÃ©"        â”‚  "PrÃ©sent"           â”‚  "Futur"        â”‚
â”‚              â”‚  (visible)      â”‚  (courant)           â”‚  (invisible)    â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                                         â”‚
â”‚   Sans VACUUM : les vieilles transactions deviennent "futures"          â”‚
â”‚   = Perte de donnÃ©es visibles !                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**VACUUM FREEZE** marque les lignes comme "toujours visibles" (frozen).

```sql
-- Voir l'Ã¢ge des transactions
SELECT
    datname,
    age(datfrozenxid) AS age_xid,
    2147483647 - age(datfrozenxid) AS transactions_restantes
FROM pg_database
ORDER BY age_xid DESC;

-- Forcer le freeze
VACUUM FREEZE clients;
```

> **Alerte Critique** : Si `age(datfrozenxid)` approche de 2 milliards, PostgreSQL se mettra en mode "single-user" pour forcer le VACUUM. C'est une urgence !

---

## Partie 2 : RÃ©plication

La rÃ©plication permet de maintenir des copies synchronisÃ©es de vos donnÃ©es sur plusieurs serveurs pour la haute disponibilitÃ© et la rÃ©partition de charge.

### 2.1 Concepts Fondamentaux

#### Terminologie

| Terme | Description |
|-------|-------------|
| **Primary** (Master) | Serveur principal qui accepte les Ã©critures |
| **Standby** (Replica) | Serveur secondaire en lecture seule |
| **WAL** | Write-Ahead Log, journal des modifications |
| **LSN** | Log Sequence Number, position dans le WAL |
| **Failover** | Promotion d'un standby en primary |
| **Switchover** | Basculement planifiÃ© vers un standby |

#### Le WAL (Write-Ahead Log)

Le WAL est le journal de toutes les modifications. Avant d'Ã©crire les donnÃ©es, PostgreSQL Ã©crit d'abord dans le WAL.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Architecture WAL                                â”‚
â”‚                                                                        â”‚
â”‚   Application                                                          â”‚
â”‚       â”‚                                                                â”‚
â”‚       â–¼                                                                â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    1. Ã‰crire WAL    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚   â”‚ Primary â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚   WAL   â”‚                          â”‚
â”‚   â”‚ Server  â”‚                     â”‚  Files  â”‚                          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    2. Ã‰crire Data   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                          â”‚
â”‚       â”‚         â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚                               â”‚
â”‚       â–¼                                â”‚  3. RÃ©pliquer                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â–¼                               â”‚
â”‚   â”‚  Data   â”‚                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚   â”‚  Files  â”‚                     â”‚ Standby â”‚                          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚ Server  â”‚                          â”‚
â”‚                                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 RÃ©plication Physique (Streaming Replication)

La rÃ©plication physique copie le WAL byte par byte. Le standby est une copie exacte du primary.

#### Configuration du Primary

```ini
# postgresql.conf sur le Primary
wal_level = replica              # Niveau de journalisation (minimal, replica, logical)
max_wal_senders = 10            # Nombre maximum de connexions de rÃ©plication
max_replication_slots = 10      # Slots de rÃ©plication
wal_keep_size = 1GB             # WAL Ã  conserver pour les standbys
```

```ini
# pg_hba.conf - Autoriser les connexions de rÃ©plication
host    replication    replicator    192.168.1.0/24    scram-sha-256
```

```sql
-- CrÃ©er un utilisateur de rÃ©plication
CREATE USER replicator WITH REPLICATION ENCRYPTED PASSWORD 'motdepasse';

-- CrÃ©er un slot de rÃ©plication (optionnel mais recommandÃ©)
SELECT pg_create_physical_replication_slot('standby1_slot');
```

#### Configuration du Standby

```bash
# CrÃ©er une copie de base du primary
pg_basebackup -h primary_host -D /var/lib/postgresql/data -U replicator -P -R
```

L'option `-R` crÃ©e automatiquement le fichier de configuration pour le standby.

```ini
# postgresql.auto.conf gÃ©nÃ©rÃ© (ou postgresql.conf)
primary_conninfo = 'host=primary_host port=5432 user=replicator password=motdepasse'
primary_slot_name = 'standby1_slot'
```

```bash
# CrÃ©er le fichier signal pour indiquer le mode standby
touch /var/lib/postgresql/data/standby.signal
```

#### VÃ©rifier la RÃ©plication

```sql
-- Sur le Primary : voir les standbys connectÃ©s
SELECT
    client_addr,
    state,
    sent_lsn,
    write_lsn,
    flush_lsn,
    replay_lsn,
    pg_wal_lsn_diff(sent_lsn, replay_lsn) AS lag_bytes
FROM pg_stat_replication;

-- Sur le Standby : voir l'Ã©tat de rÃ©ception
SELECT
    status,
    received_lsn,
    latest_end_lsn,
    pg_wal_lsn_diff(latest_end_lsn, received_lsn) AS lag_bytes
FROM pg_stat_wal_receiver;
```

### 2.3 RÃ©plication Synchrone vs Asynchrone

#### RÃ©plication Asynchrone (DÃ©faut)

Le primary n'attend pas la confirmation du standby. Risque de perte de donnÃ©es en cas de crash.

```
Primary                     Standby
   â”‚                           â”‚
   â”‚  COMMIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º   â”‚
   â”‚  (n'attend pas)           â”‚
   â–¼                           â–¼
 Client                    Peut avoir
 notifiÃ©                   du retard
```

#### RÃ©plication Synchrone

Le primary attend que le standby confirme avant de valider le COMMIT.

```ini
# postgresql.conf sur le Primary
synchronous_commit = on                           # Attendre la confirmation
synchronous_standby_names = 'standby1'            # Nom du standby synchrone
```

```sql
-- Sur le Standby, dÃ©finir un nom d'application
-- primary_conninfo = '... application_name=standby1'
```

**Niveaux de synchronisation** :

| ParamÃ¨tre | Garantie | Performance |
|-----------|----------|-------------|
| `off` | Aucune | TrÃ¨s rapide |
| `local` | Ã‰criture locale | Rapide |
| `remote_write` | Standby a reÃ§u | Moyenne |
| `on` (dÃ©faut) | Standby a Ã©crit sur disque | Lente |
| `remote_apply` | Standby a appliquÃ© | TrÃ¨s lente |

#### Quorum-Based Synchronous Replication

Avec plusieurs standbys, vous pouvez dÃ©finir un quorum :

```ini
# Au moins 2 parmi 3 standbys doivent confirmer
synchronous_standby_names = 'ANY 2 (standby1, standby2, standby3)'

# Les standbys dans l'ordre de prioritÃ©
synchronous_standby_names = 'FIRST 1 (standby1, standby2)'
```

### 2.4 RÃ©plication Logique

La rÃ©plication logique transmet les **changements logiques** (INSERT, UPDATE, DELETE) plutÃ´t que les blocs WAL. Plus flexible mais plus complexe.

#### Avantages de la RÃ©plication Logique

- RÃ©plication sÃ©lective (certaines tables uniquement)
- RÃ©plication entre versions PostgreSQL diffÃ©rentes
- PossibilitÃ© d'Ã©crire sur le subscriber (rÃ©plica)
- Transformation des donnÃ©es pendant la rÃ©plication

#### Configuration

**Sur le Publisher (source)** :

```ini
# postgresql.conf
wal_level = logical
max_replication_slots = 10
max_wal_senders = 10
```

```sql
-- CrÃ©er une publication
CREATE PUBLICATION ma_publication FOR TABLE clients, commandes;

-- Ou publier toutes les tables
CREATE PUBLICATION toutes_tables FOR ALL TABLES;
```

**Sur le Subscriber (destination)** :

```sql
-- CrÃ©er une souscription
CREATE SUBSCRIPTION ma_souscription
CONNECTION 'host=publisher_host dbname=mabase user=replicator password=xxx'
PUBLICATION ma_publication;
```

#### VÃ©rifier la RÃ©plication Logique

```sql
-- Sur le Publisher
SELECT * FROM pg_publication;
SELECT * FROM pg_publication_tables;
SELECT * FROM pg_stat_replication;

-- Sur le Subscriber
SELECT * FROM pg_subscription;
SELECT * FROM pg_stat_subscription;
```

### 2.5 Slots de RÃ©plication

Les slots garantissent que le primary conserve les WAL nÃ©cessaires aux standbys.

```sql
-- CrÃ©er un slot physique
SELECT pg_create_physical_replication_slot('standby1_slot');

-- CrÃ©er un slot logique
SELECT pg_create_logical_replication_slot('logical_slot', 'pgoutput');

-- Voir les slots
SELECT
    slot_name,
    slot_type,
    active,
    pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) AS lag_bytes
FROM pg_replication_slots;

-- Supprimer un slot (ATTENTION : libÃ¨re le WAL retenu !)
SELECT pg_drop_replication_slot('standby1_slot');
```

> **Attention** : Un slot inactif peut accumuler des WAL indÃ©finiment et remplir le disque !

### 2.6 Failover et Promotion

#### Promotion Manuelle

```bash
# Promouvoir un standby en primary
pg_ctl promote -D /var/lib/postgresql/data

# Ou via SQL (PostgreSQL 12+)
SELECT pg_promote();
```

#### Outils de Haute DisponibilitÃ©

**Patroni** : Solution complÃ¨te avec consensus distribuÃ© (etcd, Consul, ZooKeeper)

```yaml
# Exemple de configuration Patroni
scope: mon_cluster
name: node1

restapi:
  listen: 0.0.0.0:8008

etcd:
  hosts: etcd1:2379,etcd2:2379,etcd3:2379

postgresql:
  listen: 0.0.0.0:5432
  data_dir: /var/lib/postgresql/data

  parameters:
    max_connections: 100
    shared_buffers: 1GB
```

**Repmgr** : Outil plus simple pour la gestion de rÃ©plication

```bash
# Enregistrer le primary
repmgr primary register

# Cloner et enregistrer un standby
repmgr standby clone -h primary_host -U repmgr
repmgr standby register

# Failover automatique
repmgr standby switchover --siblings-follow
```

### 2.7 Architectures Haute DisponibilitÃ©

#### Architecture Simple (1 Primary + 1 Standby)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Primary    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   Standby    â”‚
â”‚  (R/W)       â”‚   WAL   â”‚  (R/O)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â–²
       â”‚
   Applications
```

#### Architecture avec Load Balancer

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  HAProxy /   â”‚
                    â”‚  PgBouncer   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â–¼               â–¼               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Primary    â”‚ â”‚  Standby 1   â”‚ â”‚  Standby 2   â”‚
    â”‚  (R/W)       â”‚ â”‚  (R/O)       â”‚ â”‚  (R/O)       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Configuration HAProxy pour sÃ©parer lectures et Ã©critures :

```haproxy
frontend pg_write
    bind *:5432
    default_backend pg_primary

frontend pg_read
    bind *:5433
    default_backend pg_standbys

backend pg_primary
    option httpchk GET /master
    server primary 192.168.1.10:5432 check port 8008

backend pg_standbys
    balance roundrobin
    option httpchk GET /replica
    server standby1 192.168.1.11:5432 check port 8008
    server standby2 192.168.1.12:5432 check port 8008
```

---

## Partie 3 : Optimisation AvancÃ©e

L'optimisation va au-delÃ  de la simple indexation. Elle englobe la configuration systÃ¨me, l'analyse des requÃªtes et le tuning fin.

### 3.1 Configuration MÃ©moire

#### Shared Buffers

Cache partagÃ© pour les pages de donnÃ©es. RÃ¨gle gÃ©nÃ©rale : 25% de la RAM.

```ini
# postgresql.conf
shared_buffers = 4GB    # 25% de 16GB de RAM
```

```sql
-- VÃ©rifier le cache hit ratio
SELECT
    sum(heap_blks_read) AS blocs_lus_disque,
    sum(heap_blks_hit) AS blocs_lus_cache,
    round(sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)) * 100, 2) AS cache_hit_ratio
FROM pg_statio_user_tables;
```

> **Objectif** : Cache hit ratio > 99%

#### Work Mem

MÃ©moire pour les opÃ©rations de tri et hash par opÃ©ration.

```ini
work_mem = 64MB    # Par opÃ©ration, pas par connexion !
```

> **Attention** : Une requÃªte complexe peut utiliser plusieurs fois `work_mem`. Avec 100 connexions Ã— 5 opÃ©rations Ã— 64MB = 32GB !

#### Maintenance Work Mem

MÃ©moire pour les opÃ©rations de maintenance (VACUUM, CREATE INDEX, etc.)

```ini
maintenance_work_mem = 1GB
```

#### Effective Cache Size

Estimation de la mÃ©moire totale disponible pour le cache (PostgreSQL + OS).

```ini
effective_cache_size = 12GB    # ~75% de la RAM
```

### 3.2 Configuration WAL et Checkpoints

```ini
# Taille maximale du WAL avant checkpoint
max_wal_size = 4GB

# Taille minimale du WAL
min_wal_size = 1GB

# Intervalle entre checkpoints
checkpoint_timeout = 15min

# Ã‰talement des Ã©critures de checkpoint
checkpoint_completion_target = 0.9

# Niveau de journalisation
wal_level = replica    # minimal, replica, logical
```

### 3.3 PostgreSQL 18 : I/O Asynchrone

PostgreSQL 18 introduit un sous-systÃ¨me d'I/O asynchrone pour des performances jusqu'Ã  3Ã— supÃ©rieures.

```ini
# postgresql.conf (PostgreSQL 18+)
io_method = 'worker'    # 'sync' (dÃ©faut) ou 'worker' (async)

# Nombre de workers I/O
io_max_concurrency = 16
```

### 3.4 pg_stat_statements : Analyser les RequÃªtes

L'extension essentielle pour identifier les requÃªtes problÃ©matiques.

```sql
-- Activer l'extension
CREATE EXTENSION pg_stat_statements;
```

```ini
# postgresql.conf
shared_preload_libraries = 'pg_stat_statements'
pg_stat_statements.track = all
```

```sql
-- Top 10 des requÃªtes les plus longues
SELECT
    substring(query, 1, 50) AS query,
    calls,
    round(total_exec_time::numeric, 2) AS total_ms,
    round(mean_exec_time::numeric, 2) AS mean_ms,
    rows
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 10;

-- Top 10 des requÃªtes les plus appelÃ©es
SELECT
    substring(query, 1, 50) AS query,
    calls,
    round(total_exec_time::numeric, 2) AS total_ms,
    round((total_exec_time / calls)::numeric, 2) AS avg_ms
FROM pg_stat_statements
ORDER BY calls DESC
LIMIT 10;

-- RÃ©initialiser les statistiques
SELECT pg_stat_statements_reset();
```

### 3.5 Analyse AvancÃ©e des Plans d'ExÃ©cution

#### EXPLAIN avec Options ComplÃ¨tes

```sql
EXPLAIN (
    ANALYZE,          -- ExÃ©cuter rÃ©ellement la requÃªte
    BUFFERS,          -- Statistiques de buffers (PG18: automatique avec ANALYZE)
    COSTS,            -- Afficher les coÃ»ts estimÃ©s
    TIMING,           -- Mesurer le temps par nÅ“ud
    VERBOSE,          -- DÃ©tails supplÃ©mentaires
    FORMAT JSON       -- Format de sortie (TEXT, XML, JSON, YAML)
)
SELECT * FROM clients c
JOIN commandes cmd ON c.id = cmd.client_id
WHERE c.ville = 'Paris';
```

#### Indicateurs ClÃ©s Ã  Surveiller

```
Seq Scan on clients  (cost=0.00..1.05 rows=1 width=236)
                      (actual time=0.015..0.016 rows=2 loops=1)
  Filter: (ville = 'Paris')
  Rows Removed by Filter: 998
  Buffers: shared hit=10 read=5      â† Lectures disque Ã  minimiser
Planning Time: 0.080 ms
Execution Time: 0.035 ms
```

| Indicateur | Signification |
|------------|---------------|
| `rows=1` vs `rows=2` | Estimation vs rÃ©alitÃ© (mauvaises stats ?) |
| `Rows Removed by Filter: 998` | Beaucoup de lignes lues inutilement |
| `shared hit` | Lectures depuis le cache (bon) |
| `shared read` | Lectures depuis le disque (Ã  minimiser) |
| `loops=1000` | Boucle exÃ©cutÃ©e 1000 fois (attention N+1) |

### 3.6 Identifier et RÃ©soudre les ProblÃ¨mes Courants

#### ProblÃ¨me : Estimation de Lignes Incorrecte

```sql
-- Le planificateur estime 1 ligne mais 10000 sont retournÃ©es
Seq Scan on clients  (cost=0.00..1.05 rows=1 width=236)
                     (actual time=0.015..50.016 rows=10000 loops=1)
```

**Solution** : Mettre Ã  jour les statistiques

```sql
ANALYZE clients;

-- Augmenter la prÃ©cision des statistiques pour une colonne
ALTER TABLE clients ALTER COLUMN ville SET STATISTICS 1000;
ANALYZE clients;
```

#### ProblÃ¨me : Seq Scan sur Grande Table

**Solution** : CrÃ©er un index appropriÃ©

```sql
-- VÃ©rifier que l'index est utilisÃ©
SET enable_seqscan = off;  -- Temporairement pour tester
EXPLAIN SELECT * FROM clients WHERE ville = 'Paris';
RESET enable_seqscan;
```

#### ProblÃ¨me : Index Non UtilisÃ©

Causes possibles :
- Le planificateur estime qu'un Seq Scan est plus rapide
- L'index ne correspond pas Ã  la requÃªte
- Statistiques obsolÃ¨tes

```sql
-- Forcer l'utilisation d'un index (pour diagnostic uniquement)
SET enable_seqscan = off;
SET enable_bitmapscan = off;
```

### 3.7 Optimisation des RequÃªtes N+1

Le pattern N+1 est un tueur de performances classique.

```sql
-- PROBLÃˆME : N+1 queries
-- Application fait :
-- 1. SELECT * FROM clients
-- 2. Pour chaque client : SELECT * FROM commandes WHERE client_id = ?

-- SOLUTION 1 : JOIN
SELECT c.*, cmd.*
FROM clients c
LEFT JOIN commandes cmd ON c.id = cmd.client_id;

-- SOLUTION 2 : Sous-requÃªte avec agrÃ©gation
SELECT
    c.*,
    (SELECT COUNT(*) FROM commandes cmd WHERE cmd.client_id = c.id) AS nb_commandes
FROM clients c;

-- SOLUTION 3 : LATERAL (plus flexible)
SELECT c.nom, recent.*
FROM clients c
LEFT JOIN LATERAL (
    SELECT date_commande, montant
    FROM commandes cmd
    WHERE cmd.client_id = c.id
    ORDER BY date_commande DESC
    LIMIT 3
) recent ON TRUE;
```

### 3.8 Partitionnement pour les Performances

Le partitionnement divise une grande table en morceaux plus petits.

```sql
-- CrÃ©er une table partitionnÃ©e par plage de dates
CREATE TABLE logs (
    id BIGSERIAL,
    created_at TIMESTAMP NOT NULL,
    message TEXT,
    level VARCHAR(10)
) PARTITION BY RANGE (created_at);

-- CrÃ©er les partitions
CREATE TABLE logs_2024 PARTITION OF logs
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE logs_2025 PARTITION OF logs
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');

-- Partition par dÃ©faut pour les donnÃ©es non couvertes
CREATE TABLE logs_default PARTITION OF logs DEFAULT;
```

**Avantages** :
- **Partition Pruning** : Le planificateur ne scanne que les partitions pertinentes
- **Maintenance** : VACUUM/ANALYZE plus rapides par partition
- **Archivage** : DÃ©tacher et supprimer les anciennes partitions

```sql
-- DÃ©tacher une partition pour archivage
ALTER TABLE logs DETACH PARTITION logs_2024;

-- Supprimer (rapide car pas de DELETE ligne par ligne)
DROP TABLE logs_2024;
```

### 3.9 Connection Pooling

PostgreSQL crÃ©e un processus par connexion, ce qui est coÃ»teux. Un pooler de connexions est essentiel en production.

#### PgBouncer

```ini
# pgbouncer.ini
[databases]
mydb = host=127.0.0.1 port=5432 dbname=mydb

[pgbouncer]
listen_addr = *
listen_port = 6432
auth_type = scram-sha-256
auth_file = /etc/pgbouncer/userlist.txt

# Mode de pooling
pool_mode = transaction    # session, transaction, statement

# Taille du pool
default_pool_size = 20
max_client_conn = 1000
```

**Modes de pooling** :

| Mode | Description | Quand utiliser |
|------|-------------|----------------|
| `session` | Une connexion par session client | Applications avec sessions longues |
| `transaction` | Connexion partagÃ©e entre transactions | La plupart des cas |
| `statement` | Connexion partagÃ©e entre requÃªtes | RequÃªtes simples uniquement |

> **Attention** : En mode `transaction`, les variables de session, les prepared statements et les curseurs ne persistent pas entre les transactions.

---

## Partie 4 : PostgreSQL en Production

### 4.1 Monitoring et ObservabilitÃ©

#### MÃ©triques Essentielles

```sql
-- 1. Connexions actives
SELECT
    state,
    COUNT(*)
FROM pg_stat_activity
GROUP BY state;

-- 2. RequÃªtes en cours d'exÃ©cution
SELECT
    pid,
    now() - pg_stat_activity.query_start AS duration,
    query,
    state
FROM pg_stat_activity
WHERE (now() - pg_stat_activity.query_start) > interval '5 minutes'
AND state != 'idle';

-- 3. Verrous en attente
SELECT
    blocked.pid AS blocked_pid,
    blocked.query AS blocked_query,
    blocking.pid AS blocking_pid,
    blocking.query AS blocking_query
FROM pg_stat_activity blocked
JOIN pg_locks blocked_locks ON blocked.pid = blocked_locks.pid
JOIN pg_locks blocking_locks ON blocked_locks.locktype = blocking_locks.locktype
    AND blocked_locks.relation = blocking_locks.relation
    AND blocked_locks.pid != blocking_locks.pid
JOIN pg_stat_activity blocking ON blocking_locks.pid = blocking.pid
WHERE NOT blocked_locks.granted;

-- 4. Taille des tables et index
SELECT
    relname AS table,
    pg_size_pretty(pg_total_relation_size(relid)) AS total,
    pg_size_pretty(pg_relation_size(relid)) AS table_size,
    pg_size_pretty(pg_indexes_size(relid)) AS indexes
FROM pg_stat_user_tables
ORDER BY pg_total_relation_size(relid) DESC;

-- 5. Bloat (fragmentation) estimÃ©
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_relation_size(schemaname || '.' || tablename)) AS size,
    n_dead_tup,
    n_live_tup,
    round(n_dead_tup * 100.0 / nullif(n_live_tup + n_dead_tup, 0), 2) AS dead_ratio
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY n_dead_tup DESC;
```

#### PostgreSQL 18 : Nouvelles Statistiques

```sql
-- Statistiques VACUUM et ANALYZE par table
SELECT
    relname,
    vacuum_count,
    autovacuum_count,
    analyze_count,
    autoanalyze_count,
    last_vacuum,
    last_autovacuum
FROM pg_stat_user_tables;

-- Statistiques I/O par backend
SELECT * FROM pg_stat_io;

-- Statistiques WAL par backend
SELECT * FROM pg_stat_wal;
```

#### Stack de Monitoring RecommandÃ©e

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Stack de Monitoring                               â”‚
â”‚                                                                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚  PostgreSQL   â”‚â”€â”€â”€â–ºâ”‚  postgres_    â”‚â”€â”€â”€â–ºâ”‚  Prometheus   â”‚          â”‚
â”‚   â”‚               â”‚    â”‚  exporter     â”‚    â”‚               â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                     â”‚                  â”‚
â”‚                                                     â–¼                  â”‚
â”‚                                             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚                                             â”‚    Grafana    â”‚          â”‚
â”‚                                             â”‚  (Dashboard)  â”‚          â”‚
â”‚                                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                        â”‚
â”‚   Alternatives : pgwatch2, Datadog, New Relic, CloudWatch              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 Sauvegardes et Restauration

#### Sauvegarde Logique (pg_dump)

```bash
# Sauvegarde d'une base (format personnalisÃ©, compressÃ©)
pg_dump -Fc -f backup.dump mydb

# Sauvegarde de toutes les bases
pg_dumpall -f all_databases.sql

# Options utiles
pg_dump -Fc \
    --verbose \
    --jobs=4 \           # ParallÃ©lisation
    --file=backup.dump \
    mydb

# Restauration
pg_restore -d mydb backup.dump

# Restauration avec parallÃ©lisation
pg_restore -j 4 -d mydb backup.dump
```

#### Sauvegarde Physique (pg_basebackup)

```bash
# Sauvegarde complÃ¨te
pg_basebackup \
    -h primary_host \
    -D /backup/base_backup \
    -U replicator \
    -P \                  # Progress
    -Ft \                 # Format tar
    -z \                  # Compression gzip
    -Xs                   # Stream WAL

# Avec checksum (PostgreSQL 18 : activÃ© par dÃ©faut)
pg_basebackup -D /backup/base_backup --checkpoint=fast
```

#### Point-In-Time Recovery (PITR)

Permet de restaurer la base Ã  n'importe quel moment dans le temps.

```ini
# postgresql.conf - Configuration de l'archivage
archive_mode = on
archive_command = 'cp %p /archive/%f'
```

```bash
# Restauration PITR
# 1. Restaurer la sauvegarde de base
pg_restore -d mydb base_backup.dump

# 2. CrÃ©er recovery.signal
touch /var/lib/postgresql/data/recovery.signal

# 3. Configurer le point de rÃ©cupÃ©ration
# postgresql.conf ou postgresql.auto.conf
restore_command = 'cp /archive/%f %p'
recovery_target_time = '2025-11-24 14:30:00'
recovery_target_action = 'promote'

# 4. DÃ©marrer PostgreSQL
pg_ctl start
```

#### StratÃ©gie de Sauvegarde 3-2-1

- **3** copies des donnÃ©es
- **2** types de supports diffÃ©rents
- **1** copie hors site

### 4.3 SÃ©curitÃ©

#### Authentification (pg_hba.conf)

```ini
# TYPE  DATABASE    USER        ADDRESS          METHOD

# Connexions locales
local   all         postgres                     peer
local   all         all                          scram-sha-256

# Connexions rÃ©seau
host    all         all         127.0.0.1/32     scram-sha-256
host    all         all         192.168.1.0/24   scram-sha-256

# Connexions SSL uniquement
hostssl all         all         0.0.0.0/0        scram-sha-256

# RÃ©plication
host    replication replicator  192.168.1.0/24   scram-sha-256
```

#### PostgreSQL 18 : Authentification OAuth 2.0

```ini
# pg_hba.conf
host    all         all         0.0.0.0/0        oauth
```

```ini
# postgresql.conf
oauth_providers = 'google'
oauth_google_issuer = 'https://accounts.google.com'
oauth_google_client_id = 'your-client-id'
oauth_google_client_secret = 'your-client-secret'
```

#### Bonnes Pratiques de SÃ©curitÃ©

```sql
-- 1. Ne jamais utiliser le superuser pour les applications
CREATE USER app_user WITH PASSWORD 'strong_password';
GRANT CONNECT ON DATABASE mydb TO app_user;
GRANT USAGE ON SCHEMA public TO app_user;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_user;

-- 2. Row-Level Security (RLS)
ALTER TABLE clients ENABLE ROW LEVEL SECURITY;

CREATE POLICY client_isolation ON clients
    FOR ALL
    USING (tenant_id = current_setting('app.tenant_id')::integer);

-- 3. Masquer les donnÃ©es sensibles avec des vues
CREATE VIEW clients_safe AS
SELECT
    id,
    nom,
    LEFT(email, 3) || '***@***' AS email_masked,
    ville
FROM clients;
```

#### SSL/TLS

```ini
# postgresql.conf
ssl = on
ssl_cert_file = '/etc/ssl/certs/server.crt'
ssl_key_file = '/etc/ssl/private/server.key'
ssl_ca_file = '/etc/ssl/certs/ca.crt'
ssl_min_protocol_version = 'TLSv1.3'    # PostgreSQL 18
```

### 4.4 Migrations de SchÃ©ma

#### Outils de Migration

- **Flyway** : Migrations versionnÃ©es en SQL ou Java
- **Liquibase** : Migrations en XML, YAML, JSON ou SQL
- **Alembic** : Pour Python/SQLAlchemy
- **golang-migrate** : Pour Go
- **dbmate** : Simple et multi-langages

#### Bonnes Pratiques

```sql
-- 1. Migrations idempotentes
CREATE TABLE IF NOT EXISTS new_table (...);
ALTER TABLE clients ADD COLUMN IF NOT EXISTS new_column VARCHAR(100);

-- 2. Migrations rÃ©versibles
-- up.sql
ALTER TABLE clients ADD COLUMN phone VARCHAR(20);

-- down.sql
ALTER TABLE clients DROP COLUMN phone;

-- 3. Ã‰viter les verrous longs
-- MAUVAIS : verrouille la table pendant l'ajout de l'index
CREATE INDEX idx_clients_email ON clients(email);

-- BON : ne verrouille pas les Ã©critures
CREATE INDEX CONCURRENTLY idx_clients_email ON clients(email);

-- 4. Ajouter des colonnes NOT NULL en plusieurs Ã©tapes
-- Ã‰tape 1 : Ajouter avec valeur par dÃ©faut
ALTER TABLE clients ADD COLUMN status VARCHAR(20) DEFAULT 'active';

-- Ã‰tape 2 : Mettre Ã  jour les valeurs existantes (par lots si nÃ©cessaire)
UPDATE clients SET status = 'active' WHERE status IS NULL;

-- Ã‰tape 3 : Ajouter la contrainte NOT NULL
ALTER TABLE clients ALTER COLUMN status SET NOT NULL;
```

### 4.5 Mise Ã  Niveau de Version

#### PostgreSQL 18 : AmÃ©liorations pg_upgrade

```bash
# VÃ©rification prÃ©alable
pg_upgrade \
    --old-datadir /var/lib/postgresql/17/data \
    --new-datadir /var/lib/postgresql/18/data \
    --old-bindir /usr/lib/postgresql/17/bin \
    --new-bindir /usr/lib/postgresql/18/bin \
    --check

# Mise Ã  niveau avec prÃ©servation des statistiques (PostgreSQL 18)
pg_upgrade \
    --old-datadir /var/lib/postgresql/17/data \
    --new-datadir /var/lib/postgresql/18/data \
    --old-bindir /usr/lib/postgresql/17/bin \
    --new-bindir /usr/lib/postgresql/18/bin \
    --copy-stats              # Nouveau PG18 : copie les statistiques

# Nouvelle option --swap pour upgrade in-place
pg_upgrade \
    ... \
    --swap                    # Ã‰change les rÃ©pertoires directement

# VÃ©rifications parallÃ¨les
pg_upgrade \
    ... \
    --jobs=4                  # ParallÃ©lisation des vÃ©rifications
```

#### StratÃ©gie Blue/Green

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Migration Blue/Green                              â”‚
â”‚                                                                        â”‚
â”‚   1. Configuration initiale                                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚   â”‚  PG 17 Blue  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Applications â”‚                            â”‚
â”‚   â”‚  (Primary)   â”‚         â”‚              â”‚                            â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚                                                                        â”‚
â”‚   2. Ajouter PG 18 en rÃ©plication logique                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚   â”‚  PG 17 Blue  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  PG 18 Green â”‚                            â”‚
â”‚   â”‚  (Primary)   â”‚  Logicalâ”‚  (Standby)   â”‚                            â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  Repli. â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚                                                                        â”‚
â”‚   3. Basculer les applications                                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  PG 17 Blue  â”‚         â”‚  PG 18 Green â”‚â—„â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Applications â”‚   â”‚
â”‚   â”‚  (Ã  arrÃªter) â”‚         â”‚  (Primary)   â”‚         â”‚              â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.6 Troubleshooting

#### Diagnostic des RequÃªtes Lentes

```sql
-- 1. Identifier les requÃªtes lentes en cours
SELECT
    pid,
    now() - query_start AS duration,
    state,
    query
FROM pg_stat_activity
WHERE state = 'active'
ORDER BY duration DESC;

-- 2. Annuler une requÃªte
SELECT pg_cancel_backend(pid);

-- 3. Terminer une connexion (plus agressif)
SELECT pg_terminate_backend(pid);

-- 4. Activer le logging des requÃªtes lentes
-- postgresql.conf
-- log_min_duration_statement = 1000  # Log requÃªtes > 1 seconde
```

#### Diagnostic des Verrous

```sql
-- Voir tous les verrous
SELECT
    l.pid,
    l.locktype,
    l.mode,
    l.granted,
    a.query
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
WHERE NOT l.granted;

-- Identifier les blocages
SELECT
    blocked.pid AS blocked_pid,
    blocked.query AS blocked_query,
    now() - blocked.query_start AS blocked_duration,
    blocking.pid AS blocking_pid,
    blocking.query AS blocking_query
FROM pg_stat_activity blocked
JOIN pg_locks blocked_locks ON blocked.pid = blocked_locks.pid
JOIN pg_locks blocking_locks ON
    blocked_locks.locktype = blocking_locks.locktype AND
    blocked_locks.relation = blocking_locks.relation AND
    blocked_locks.pid != blocking_locks.pid
JOIN pg_stat_activity blocking ON blocking_locks.pid = blocking.pid
WHERE NOT blocked_locks.granted;
```

#### Diagnostic de l'Espace Disque

```sql
-- Espace utilisÃ© par base
SELECT
    datname,
    pg_size_pretty(pg_database_size(datname)) AS size
FROM pg_database
ORDER BY pg_database_size(datname) DESC;

-- Espace utilisÃ© par table
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname || '.' || tablename)) AS total,
    pg_size_pretty(pg_relation_size(schemaname || '.' || tablename)) AS table,
    pg_size_pretty(pg_indexes_size(schemaname || '.' || tablename)) AS indexes
FROM pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY pg_total_relation_size(schemaname || '.' || tablename) DESC
LIMIT 20;

-- Tables avec beaucoup de bloat
SELECT
    schemaname || '.' || relname AS table_name,
    pg_size_pretty(pg_relation_size(relid)) AS table_size,
    n_dead_tup AS dead_tuples,
    n_live_tup AS live_tuples,
    CASE
        WHEN n_live_tup > 0
        THEN round(n_dead_tup * 100.0 / n_live_tup, 2)
        ELSE 0
    END AS dead_pct
FROM pg_stat_user_tables
WHERE n_dead_tup > 10000
ORDER BY n_dead_tup DESC;
```

#### RÃ©soudre un ProblÃ¨me de Transaction ID Wraparound

```sql
-- VÃ©rifier l'Ã¢ge des transactions
SELECT
    datname,
    age(datfrozenxid) AS xid_age,
    current_setting('autovacuum_freeze_max_age')::bigint AS freeze_max,
    current_setting('autovacuum_freeze_max_age')::bigint - age(datfrozenxid) AS remaining
FROM pg_database
ORDER BY xid_age DESC;

-- Si critique : forcer VACUUM FREEZE
VACUUM (FREEZE, VERBOSE) table_problematique;

-- Pour toute la base
vacuumdb --freeze --all
```

### 4.7 Checklist de Mise en Production

#### Configuration SystÃ¨me

```ini
# postgresql.conf - Configuration recommandÃ©e pour production

# MÃ©moire
shared_buffers = '4GB'              # 25% RAM
effective_cache_size = '12GB'       # 75% RAM
work_mem = '64MB'
maintenance_work_mem = '1GB'
huge_pages = try

# WAL
wal_level = replica
max_wal_senders = 10
wal_keep_size = '2GB'
max_wal_size = '4GB'

# Checkpoints
checkpoint_timeout = '15min'
checkpoint_completion_target = 0.9

# Connexions
max_connections = 200               # Utiliser un pooler !
superuser_reserved_connections = 3

# Logging
logging_collector = on
log_destination = 'stderr'
log_directory = 'log'
log_filename = 'postgresql-%Y-%m-%d.log'
log_min_duration_statement = 1000   # Log requÃªtes > 1s
log_checkpoints = on
log_connections = on
log_disconnections = on
log_lock_waits = on
log_temp_files = 0

# Autovacuum
autovacuum = on
autovacuum_max_workers = 4
autovacuum_vacuum_scale_factor = 0.1
autovacuum_analyze_scale_factor = 0.05

# SÃ©curitÃ© (PostgreSQL 18)
password_encryption = scram-sha-256
ssl = on
ssl_min_protocol_version = 'TLSv1.3'
```

#### Checklist Finale

- [ ] **Sauvegardes** : AutomatisÃ©es, testÃ©es, off-site
- [ ] **Monitoring** : Alertes sur espace disque, connexions, locks, replication lag
- [ ] **SÃ©curitÃ©** : SSL activÃ©, SCRAM-SHA-256, RLS si multi-tenant
- [ ] **Haute DisponibilitÃ©** : RÃ©plication configurÃ©e, failover testÃ©
- [ ] **Performance** : pg_stat_statements activÃ©, connexion pooling
- [ ] **Maintenance** : Autovacuum configurÃ©, ANALYZE rÃ©gulier
- [ ] **Logs** : Rotation configurÃ©e, requÃªtes lentes loggÃ©es
- [ ] **Documentation** : Runbooks pour les incidents courants

---

## RÃ©sumÃ©

Ce chapitre avancÃ© vous a prÃ©sentÃ© les concepts essentiels pour maÃ®triser PostgreSQL en production :

| Concept | Ce qu'il faut retenir |
|---------|----------------------|
| **MVCC** | SystÃ¨me de versions multiples, XID, VACUUM essentiel |
| **RÃ©plication** | Streaming (physique) vs Logique, synchrone vs asynchrone |
| **Optimisation** | Configuration mÃ©moire, pg_stat_statements, EXPLAIN |
| **Production** | Monitoring, sauvegardes, sÃ©curitÃ©, troubleshooting |

### Points ClÃ©s Ã  Retenir

- **MVCC** permet une concurrence Ã©levÃ©e mais nÃ©cessite VACUUM rÃ©gulier
- **RÃ©plication** : Choisissez entre haute disponibilitÃ© (synchrone) et performance (asynchrone)
- **Optimisation** : Mesurez avant d'optimiser, utilisez pg_stat_statements
- **Production** : Automatisez tout, testez vos sauvegardes et failovers

### Pour Aller Plus Loin

- Documentation officielle PostgreSQL : https://www.postgresql.org/docs/
- Wiki PostgreSQL : https://wiki.postgresql.org/
- ConfÃ©rences : PGConf, FOSDEM PostgreSQL DevRoom
- Livres : "PostgreSQL: Up and Running", "The Art of PostgreSQL"
- Extensions : pg_stat_statements, pg_repack, pgvector, TimescaleDB

---


â­ï¸ [L'avenir de PostgreSQL : Tendances et Ã©volutions](/21-conclusion-et-perspectives/02-avenir-de-postgresql.md)
