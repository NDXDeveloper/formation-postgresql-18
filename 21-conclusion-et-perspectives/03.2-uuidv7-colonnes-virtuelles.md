üîù Retour au [Sommaire](/SOMMAIRE.md)

# 21.3.2. UUIDv7 et Colonnes Virtuelles

## Introduction

PostgreSQL 18 introduit deux fonctionnalit√©s tr√®s attendues par les d√©veloppeurs :

1. **UUIDv7** : Une nouvelle g√©n√©ration d'identifiants uniques universels, ordonn√©s par le temps
2. **Colonnes virtuelles** : Des colonnes calcul√©es √† la vol√©e, sans stockage sur disque

Ces deux fonctionnalit√©s simplifient consid√©rablement le travail des d√©veloppeurs tout en am√©liorant les performances. Cette section vous explique ces concepts de mani√®re accessible, m√™me si vous d√©butez avec PostgreSQL.

---

# Partie 1 : UUIDv7 ‚Äî Des Identifiants Uniques et Performants

## Qu'est-ce qu'un UUID ?

### D√©finition Simple

Un **UUID** (Universally Unique Identifier, ou Identifiant Unique Universel) est une cha√Æne de caract√®res con√ßue pour √™tre **unique dans le monde entier**, sans coordination centrale.

Un UUID ressemble √† ceci :

```
550e8400-e29b-41d4-a716-446655440000
```

Il s'agit d'une valeur de 128 bits (32 caract√®res hexad√©cimaux + 4 tirets).

### Pourquoi Utiliser des UUID ?

Traditionnellement, les bases de donn√©es utilisent des identifiants **auto-incr√©ment√©s** (1, 2, 3, 4...) comme cl√©s primaires. Cette approche fonctionne bien sur un seul serveur, mais pose des probl√®mes dans certaines situations :

| Situation | Probl√®me avec les ID s√©quentiels |
|-----------|----------------------------------|
| Bases de donn√©es distribu√©es | Deux serveurs peuvent g√©n√©rer le m√™me ID |
| Applications mobiles/hors ligne | Impossible de g√©n√©rer un ID sans connexion au serveur |
| S√©curit√© | Les ID s√©quentiels r√©v√®lent des informations (nombre de clients, etc.) |
| Fusion de donn√©es | Conflits lors de la fusion de bases de donn√©es |

Les UUID r√©solvent ces probl√®mes : ils peuvent √™tre g√©n√©r√©s **n'importe o√π**, **n'importe quand**, avec une probabilit√© de collision quasi nulle.

---

## Le Probl√®me des UUID Traditionnels (UUIDv4)

### Comment Fonctionne UUIDv4

Avant PostgreSQL 18, la fonction `gen_random_uuid()` g√©n√©rait des UUID de version 4 (UUIDv4). Ces UUID sont **totalement al√©atoires** :

```sql
-- G√©n√©ration de 3 UUIDv4
SELECT gen_random_uuid();
-- R√©sultat : 7c9e6679-7425-40de-944b-e07fc1f90ae7

SELECT gen_random_uuid();
-- R√©sultat : a1b2c3d4-e5f6-4a7b-8c9d-0e1f2a3b4c5d

SELECT gen_random_uuid();
-- R√©sultat : f47ac10b-58cc-4372-a567-0e02b2c3d479
```

### Le Probl√®me de Performance

Les UUIDv4 posent un **probl√®me majeur de performance** avec les index B-tree (le type d'index le plus courant) :

**Imaginez une biblioth√®que o√π les nouveaux livres arrivent avec des num√©ros al√©atoires :**

- Le livre n¬∞847 doit aller entre 846 et 848
- Le livre n¬∞123 doit aller entre 122 et 124
- Le livre n¬∞999 doit aller entre 998 et 1000

Le biblioth√©caire passe son temps √† **r√©organiser les √©tag√®res** plut√¥t qu'√† simplement ajouter les livres √† la fin !

C'est exactement ce qui se passe avec les index B-tree et les UUIDv4 :

1. **Fragmentation de l'index** : Les nouvelles valeurs sont ins√©r√©es √† des positions al√©atoires
2. **Divisions de pages** (page splits) : L'index doit constamment se r√©organiser
3. **Mauvaise utilisation du cache** : Les pages d'index en m√©moire ne sont pas optimales
4. **Performances en √©criture d√©grad√©es** : Chaque insertion co√ªte plus cher

---

## La Solution : UUIDv7

### Le Meilleur des Deux Mondes

UUIDv7 est d√©fini dans la norme **RFC 9562**. Il combine :

- ‚úÖ L'**unicit√© globale** des UUID (pas de coordination n√©cessaire)
- ‚úÖ L'**ordre chronologique** des identifiants s√©quentiels (bon pour les index)

### Comment Fonctionne UUIDv7

Un UUIDv7 est compos√© de deux parties principales :

```
0199e46c-4b68-765f-ad72-d388d2e2ef22
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
   Timestamp     v7      Al√©atoire
  (48 bits)          (74 bits)
```

| Composant | Description |
|-----------|-------------|
| **Timestamp** | Horodatage Unix en millisecondes (48 bits) |
| **Version** | Toujours `7` pour UUIDv7 |
| **Fraction sub-milliseconde** | Pr√©cision suppl√©mentaire (12 bits dans PostgreSQL) |
| **Partie al√©atoire** | Garantit l'unicit√© m√™me dans la m√™me milliseconde |

### Pourquoi C'est Mieux pour les Index

Avec UUIDv7, les nouveaux UUID sont **naturellement ordonn√©s par le temps** :

```
UUID g√©n√©r√© √† 10:00:00 ‚Üí 0199e46c-0001-7xxx-xxxx-xxxxxxxxxxxx
UUID g√©n√©r√© √† 10:00:01 ‚Üí 0199e46c-0002-7xxx-xxxx-xxxxxxxxxxxx
UUID g√©n√©r√© √† 10:00:02 ‚Üí 0199e46c-0003-7xxx-xxxx-xxxxxxxxxxxx
```

Les nouvelles valeurs sont toujours ins√©r√©es **√† la fin** de l'index, comme avec des identifiants auto-incr√©ment√©s !

---

## Utiliser UUIDv7 dans PostgreSQL 18

### La Fonction `uuidv7()`

PostgreSQL 18 introduit la fonction native `uuidv7()` :

```sql
-- G√©n√©rer un UUIDv7 avec l'horodatage actuel
SELECT uuidv7();
-- R√©sultat : 0196ea4a-6f32-7fd0-a9d9-9c815a0750cd
```

### Cr√©er une Table avec UUIDv7

Voici comment utiliser UUIDv7 comme cl√© primaire :

```sql
CREATE TABLE clients (
    id UUID PRIMARY KEY DEFAULT uuidv7(),
    nom VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE,
    date_inscription TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Les insertions g√©n√®rent automatiquement l'UUID
INSERT INTO clients (nom, email) VALUES ('Alice Dupont', 'alice@example.com');
INSERT INTO clients (nom, email) VALUES ('Bob Martin', 'bob@example.com');

-- V√©rification
SELECT id, nom FROM clients;
-- R√©sultat :
-- id                                   | nom
-- -------------------------------------+-------------
-- 0196ea4a-6f32-7fd0-a9d9-9c815a0750cd | Alice Dupont
-- 0196ea4a-6f33-7a12-b456-789abcdef012 | Bob Martin
```

Remarquez comment les UUID commencent par des pr√©fixes similaires (`0196ea4a-6f3...`) car ils ont √©t√© g√©n√©r√©s presque au m√™me moment.

### G√©n√©rer des UUID pour des Dates Sp√©cifiques

La fonction `uuidv7()` accepte un param√®tre optionnel de type `INTERVAL` pour d√©caler l'horodatage :

```sql
-- UUID pour maintenant
SELECT uuidv7() AS maintenant;

-- UUID pour hier
SELECT uuidv7('-1 day'::INTERVAL) AS hier;

-- UUID pour dans une semaine
SELECT uuidv7('7 days'::INTERVAL) AS semaine_prochaine;

-- UUID pour il y a 6 mois
SELECT uuidv7('-6 months'::INTERVAL) AS il_y_a_6_mois;
```

Cette fonctionnalit√© est utile pour :

- **Backfilling** : Cr√©er des donn√©es historiques avec des UUID coh√©rents
- **Tests** : Simuler des donn√©es cr√©√©es √† diff√©rents moments
- **Masquage** : D√©caler l'horodatage pour ne pas r√©v√©ler la date exacte de cr√©ation

### Extraire l'Horodatage d'un UUID

PostgreSQL 18 permet d'extraire l'horodatage contenu dans un UUIDv7 :

```sql
-- G√©n√©rer un UUID et extraire son timestamp
SELECT
    uuidv7() AS uuid,
    uuid_extract_timestamp(uuidv7()) AS timestamp_extraction;

-- R√©sultat :
-- uuid                                 | timestamp_extraction
-- -------------------------------------+------------------------
-- 0196ea4a-6f32-7fd0-a9d9-9c815a0750cd | 2025-05-19 20:50:40+00
```

### Identifier la Version d'un UUID

Vous pouvez v√©rifier la version de n'importe quel UUID :

```sql
-- V√©rifier la version d'un UUIDv7
SELECT uuid_extract_version(uuidv7());
-- R√©sultat : 7

-- V√©rifier la version d'un UUIDv4
SELECT uuid_extract_version(gen_random_uuid());
-- R√©sultat : 4
```

### Alias `uuidv4()` pour la Coh√©rence

Pour une meilleure coh√©rence de nommage, PostgreSQL 18 ajoute `uuidv4()` comme alias de `gen_random_uuid()` :

```sql
-- Ces deux fonctions sont √©quivalentes
SELECT gen_random_uuid();
SELECT uuidv4();
```

---

## Quand Utiliser UUIDv7 vs Autres Approches

### Tableau Comparatif

| Crit√®re | SERIAL/IDENTITY | UUIDv4 | UUIDv7 |
|---------|-----------------|--------|--------|
| **Unicit√© globale** | ‚ùå Non | ‚úÖ Oui | ‚úÖ Oui |
| **Performance index B-tree** | ‚úÖ Excellente | ‚ùå M√©diocre | ‚úÖ Excellente |
| **G√©n√©ration c√¥t√© client** | ‚ùå Non | ‚úÖ Oui | ‚úÖ Oui |
| **Tri chronologique naturel** | ‚úÖ Oui | ‚ùå Non | ‚úÖ Oui |
| **S√©curit√© (non pr√©dictible)** | ‚ùå Pr√©dictible | ‚úÖ Non pr√©dictible | ‚ö†Ô∏è Partiellement |
| **R√©v√®le la date de cr√©ation** | ‚ùå Non | ‚ùå Non | ‚ö†Ô∏è Oui |

### Recommandations

**Utilisez UUIDv7 quand :**
- Vous avez une application distribu√©e ou multi-serveurs
- Vous devez g√©n√©rer des identifiants c√¥t√© client
- Vous voulez combiner unicit√© globale et bonnes performances
- Le tri chronologique des enregistrements est utile

**Consid√©rations de s√©curit√© :**
- UUIDv7 contient un horodatage : ne l'exposez pas si la date de cr√©ation est sensible
- Utilisez le param√®tre d'intervalle pour masquer la vraie date si n√©cessaire

---

# Partie 2 : Colonnes Virtuelles ‚Äî Calculs √† la Demande

## Qu'est-ce qu'une Colonne G√©n√©r√©e ?

### Le Concept

Une **colonne g√©n√©r√©e** est une colonne dont la valeur est **automatiquement calcul√©e** √† partir d'autres colonnes. Vous ne pouvez pas y √©crire directement : PostgreSQL la calcule pour vous.

C'est comme une formule dans Excel : quand vous modifiez une cellule source, la cellule avec la formule se met √† jour automatiquement.

### Exemple Simple

```sql
-- Table avec une colonne g√©n√©r√©e pour le nom complet
CREATE TABLE personnes (
    prenom VARCHAR(50),
    nom VARCHAR(50),
    nom_complet VARCHAR(100) GENERATED ALWAYS AS (prenom || ' ' || nom)
);

INSERT INTO personnes (prenom, nom) VALUES ('Marie', 'Curie');

SELECT * FROM personnes;
-- R√©sultat :
-- prenom | nom   | nom_complet
-- -------+-------+------------
-- Marie  | Curie | Marie Curie
```

La colonne `nom_complet` est calcul√©e automatiquement !

---

## Stored vs Virtual : Les Deux Types

### Colonnes Stock√©es (STORED)

Disponibles depuis PostgreSQL 12, les colonnes **STORED** :

- Sont calcul√©es lors de l'**INSERT** ou de l'**UPDATE**
- Sont **stock√©es physiquement** sur le disque
- Occupent de l'**espace disque**
- Peuvent √™tre **index√©es**

```sql
CREATE TABLE produits (
    prix_ht NUMERIC(10,2),
    tva NUMERIC(10,2) GENERATED ALWAYS AS (prix_ht * 0.20) STORED
);
```

### Colonnes Virtuelles (VIRTUAL) ‚Äî Nouveaut√© PostgreSQL 18

Les colonnes **VIRTUAL** sont la grande nouveaut√© de PostgreSQL 18 :

- Sont calcul√©es lors de la **lecture** (SELECT)
- Ne sont **jamais stock√©es** sur le disque
- N'occupent **aucun espace disque**
- Ne peuvent **pas √™tre index√©es** (pour l'instant)

```sql
CREATE TABLE produits (
    prix_ht NUMERIC(10,2),
    tva NUMERIC(10,2) GENERATED ALWAYS AS (prix_ht * 0.20) VIRTUAL
);
```

### Le Changement Important dans PostgreSQL 18

√Ä partir de PostgreSQL 18, **VIRTUAL est le mode par d√©faut**. Si vous ne pr√©cisez rien, la colonne sera virtuelle :

```sql
-- Ces deux d√©clarations sont √©quivalentes dans PostgreSQL 18
tva NUMERIC(10,2) GENERATED ALWAYS AS (prix_ht * 0.20)
tva NUMERIC(10,2) GENERATED ALWAYS AS (prix_ht * 0.20) VIRTUAL
```

---

## Analogie : Vues vs Vues Mat√©rialis√©es

Pour mieux comprendre la diff√©rence entre STORED et VIRTUAL :

| Type de Colonne | Analogie | Comportement |
|-----------------|----------|--------------|
| **STORED** | Vue mat√©rialis√©e | Donn√©es pr√©-calcul√©es et stock√©es |
| **VIRTUAL** | Vue simple | Calcul √† chaque lecture |

Une colonne STORED est comme une **photo** : prise une fois, elle ne change plus (sauf mise √† jour).

Une colonne VIRTUAL est comme un **miroir** : elle refl√®te toujours l'√©tat actuel.

---

## Exemples Pratiques

### Exemple 1 : Calculs Financiers

```sql
CREATE TABLE factures (
    id UUID PRIMARY KEY DEFAULT uuidv7(),
    montant_ht NUMERIC(10,2) NOT NULL,
    taux_tva NUMERIC(4,2) DEFAULT 0.20,
    -- Colonnes virtuelles : calcul√©es √† la lecture
    montant_tva NUMERIC(10,2) GENERATED ALWAYS AS (montant_ht * taux_tva),
    montant_ttc NUMERIC(10,2) GENERATED ALWAYS AS (montant_ht * (1 + taux_tva))
);

INSERT INTO factures (montant_ht) VALUES (1000.00);
INSERT INTO factures (montant_ht, taux_tva) VALUES (500.00, 0.055);

SELECT * FROM factures;
-- R√©sultat :
-- id          | montant_ht | taux_tva | montant_tva | montant_ttc
-- ------------+------------+----------+-------------+------------
-- 0196ea...   | 1000.00    | 0.20     | 200.00      | 1200.00
-- 0196eb...   | 500.00     | 0.055    | 27.50       | 527.50
```

### Exemple 2 : Formatage de Donn√©es

```sql
CREATE TABLE employes (
    id SERIAL PRIMARY KEY,
    prenom VARCHAR(50) NOT NULL,
    nom VARCHAR(50) NOT NULL,
    -- Colonnes virtuelles pour diff√©rents formats
    nom_complet VARCHAR(100) GENERATED ALWAYS AS (prenom || ' ' || nom),
    nom_formel VARCHAR(100) GENERATED ALWAYS AS (upper(nom) || ' ' || prenom),
    initiales VARCHAR(5) GENERATED ALWAYS AS (left(prenom, 1) || left(nom, 1))
);

INSERT INTO employes (prenom, nom) VALUES ('Jean', 'Dupont');

SELECT nom_complet, nom_formel, initiales FROM employes;
-- R√©sultat :
-- nom_complet  | nom_formel     | initiales
-- -------------+----------------+----------
-- Jean Dupont  | DUPONT Jean    | JD
```

### Exemple 3 : Extraction de Donn√©es JSON

Les colonnes virtuelles sont particuli√®rement utiles pour "aplatir" des donn√©es JSON :

```sql
CREATE TABLE evenements (
    id UUID PRIMARY KEY DEFAULT uuidv7(),
    donnees JSONB NOT NULL,
    -- Colonnes virtuelles pour acc√©der facilement aux donn√©es JSON
    type_evenement TEXT GENERATED ALWAYS AS (donnees->>'type'),
    utilisateur_id TEXT GENERATED ALWAYS AS (donnees->'user'->>'id'),
    timestamp_evt TIMESTAMP GENERATED ALWAYS AS (
        (donnees->>'timestamp')::TIMESTAMP
    )
);

INSERT INTO evenements (donnees) VALUES (
    '{"type": "achat", "user": {"id": "U123", "name": "Alice"}, "timestamp": "2025-01-15 14:30:00"}'
);

SELECT type_evenement, utilisateur_id, timestamp_evt FROM evenements;
-- R√©sultat :
-- type_evenement | utilisateur_id | timestamp_evt
-- ---------------+----------------+---------------------
-- achat          | U123           | 2025-01-15 14:30:00
```

---

## Avantages des Colonnes Virtuelles

### 1. √âconomie d'Espace Disque

Les colonnes virtuelles n'occupent aucun espace :

```sql
-- Cr√©ation d'une table de test
CREATE TABLE test_stockage (
    id SERIAL PRIMARY KEY,
    valeur INT
);

-- Insertion de donn√©es
INSERT INTO test_stockage (valeur)
SELECT generate_series(1, 10000);

-- Taille avant ajout de colonne virtuelle
SELECT pg_total_relation_size('test_stockage');
-- R√©sultat : 450560 bytes

-- Ajout d'une colonne virtuelle
ALTER TABLE test_stockage
ADD COLUMN valeur_double INT GENERATED ALWAYS AS (valeur * 2) VIRTUAL;

-- Taille apr√®s : identique !
SELECT pg_total_relation_size('test_stockage');
-- R√©sultat : 450560 bytes
```

### 2. Ajout Instantan√©

Ajouter une colonne virtuelle √† une table existante est **instantan√©**, quelle que soit la taille de la table :

- Pas de r√©√©criture de la table
- Pas de verrou long
- Modification des m√©tadonn√©es uniquement

```sql
-- Cette op√©ration est instantan√©e, m√™me sur une table de millions de lignes
ALTER TABLE grande_table
ADD COLUMN calcul_complexe NUMERIC GENERATED ALWAYS AS (col1 * col2 + col3) VIRTUAL;
```

Avec une colonne STORED, PostgreSQL devrait r√©√©crire **toute la table** pour calculer et stocker les valeurs.

### 3. Toujours √† Jour

Les colonnes virtuelles refl√®tent **toujours** l'√©tat actuel des donn√©es sources :

```sql
UPDATE factures SET montant_ht = 1500.00 WHERE id = '...';

-- montant_tva et montant_ttc sont automatiquement recalcul√©s
-- lors de la prochaine lecture
```

### 4. Logique Centralis√©e

La formule de calcul est d√©finie **une seule fois** dans le sch√©ma :

- Pas besoin de r√©p√©ter la formule dans chaque requ√™te
- Pas de risque d'incoh√©rence entre diff√©rentes applications
- Documentation implicite du mod√®le de donn√©es

---

## Limitations des Colonnes Virtuelles

### Ce Qui N'est Pas Possible (Actuellement)

| Limitation | Explication |
|------------|-------------|
| **Pas d'index** | Impossible de cr√©er un index sur une colonne virtuelle |
| **Pas de contrainte UNIQUE** | D√©coule de l'impossibilit√© d'indexer |
| **Pas de r√©plication logique** | Les colonnes virtuelles ne sont pas r√©pliqu√©es |
| **Fonctions immutables uniquement** | Pas de `random()`, `now()`, etc. |
| **Pas de types personnalis√©s** | Uniquement les types int√©gr√©s de PostgreSQL |
| **Pas de sous-requ√™tes** | L'expression ne peut pas contenir de SELECT |

### Quand Utiliser STORED Plut√¥t que VIRTUAL

Pr√©f√©rez une colonne **STORED** quand :

1. **Vous devez indexer la colonne** (recherches fr√©quentes sur cette valeur)
2. **Le calcul est co√ªteux** et la colonne est lue souvent
3. **Vous avez besoin de r√©plication logique**
4. **Vous voulez des contraintes d'unicit√©**

```sql
-- Exemple : colonne STORED avec index pour recherche rapide
CREATE TABLE utilisateurs (
    id UUID PRIMARY KEY DEFAULT uuidv7(),
    prenom VARCHAR(50),
    nom VARCHAR(50),
    -- STORED car on veut un index pour les recherches
    nom_complet_recherche VARCHAR(100)
        GENERATED ALWAYS AS (lower(prenom || ' ' || nom)) STORED
);

CREATE INDEX idx_nom_recherche ON utilisateurs(nom_complet_recherche);
```

---

## Comparaison STORED vs VIRTUAL

| Aspect | STORED | VIRTUAL |
|--------|--------|---------|
| **Stockage disque** | Oui | Non |
| **Moment du calcul** | INSERT/UPDATE | SELECT |
| **Performance en lecture** | Rapide (d√©j√† calcul√©) | Calcul √† chaque lecture |
| **Performance en √©criture** | Plus lent (calcul) | Rapide |
| **Ajout √† une table existante** | Lent (r√©√©criture) | Instantan√© |
| **Indexation** | Possible | Impossible |
| **R√©plication logique** | Oui (PG 18+) | Non |
| **Espace disque** | Consomm√© | Aucun |

---

## Bonnes Pratiques

### Nommage

Utilisez des conventions claires pour distinguer les colonnes g√©n√©r√©es :

```sql
-- Convention sugg√©r√©e : pr√©fixe ou suffixe explicite
nom_complet_calc  -- suffixe _calc
v_total           -- pr√©fixe v_ pour virtual
s_hash            -- pr√©fixe s_ pour stored
```

### Documentation

Commentez vos colonnes g√©n√©r√©es :

```sql
CREATE TABLE commandes (
    prix_unitaire NUMERIC(10,2),
    quantite INT,
    total NUMERIC(10,2) GENERATED ALWAYS AS (prix_unitaire * quantite)
);

COMMENT ON COLUMN commandes.total IS
    'Colonne virtuelle : prix_unitaire √ó quantite. Calcul√©e √† la lecture.';
```

### Migration Progressive

Si vous passez de colonnes classiques √† des colonnes g√©n√©r√©es :

1. Cr√©ez d'abord la colonne g√©n√©r√©e avec un nom temporaire
2. V√©rifiez que les valeurs correspondent
3. Supprimez l'ancienne colonne
4. Renommez la nouvelle colonne

---

## R√©sum√©

### UUIDv7

| Point Cl√© | Description |
|-----------|-------------|
| **Fonction** | `uuidv7()` g√©n√®re des UUID ordonn√©s par le temps |
| **Avantage principal** | Performance des index B-tree comparable aux ID s√©quentiels |
| **Param√®tre optionnel** | `uuidv7(INTERVAL)` pour d√©caler l'horodatage |
| **Extraction** | `uuid_extract_timestamp()` pour r√©cup√©rer la date |
| **Alias** | `uuidv4()` est maintenant disponible pour les UUIDv4 |

### Colonnes Virtuelles

| Point Cl√© | Description |
|-----------|-------------|
| **Syntaxe** | `GENERATED ALWAYS AS (expression) VIRTUAL` |
| **D√©faut PG 18** | VIRTUAL est maintenant le mode par d√©faut |
| **Avantage principal** | Aucun stockage disque, ajout instantan√© |
| **Limitation principale** | Impossible d'indexer |
| **Cas d'usage id√©al** | Calculs simples, extraction JSON, formatage |

### Recommandations G√©n√©rales

1. **Pour les nouvelles tables** : Utilisez `uuidv7()` comme cl√© primaire par d√©faut
2. **Pour les calculs simples** : Pr√©f√©rez VIRTUAL (√©conomie d'espace)
3. **Pour les recherches fr√©quentes** : Utilisez STORED avec un index
4. **Testez les performances** : Chaque cas d'usage est diff√©rent

---


‚è≠Ô∏è [OAuth et s√©curit√© moderne](/21-conclusion-et-perspectives/03.3-oauth-securite-moderne.md)
