üîù Retour au [Sommaire](/SOMMAIRE.md)

# 21.5. Roadmap de Mont√©e en Comp√©tence

## 21.5.1. Parcours D√©veloppeur PostgreSQL

Ce parcours est con√ßu pour guider les d√©veloppeurs dans leur apprentissage de PostgreSQL, depuis les bases jusqu'√† un niveau avanc√©. Il est structur√© en trois phases progressives, chacune correspondant √† une p√©riode de 6 √† 12 mois.

> **Note importante** : Les dur√©es indiqu√©es sont des estimations bas√©es sur un apprentissage r√©gulier (quelques heures par semaine). Votre progression peut varier selon votre exp√©rience pr√©alable, votre disponibilit√© et l'intensit√© de votre pratique.

---

## Phase 1 : Fondations (0-6 mois)

### Objectif de cette phase

Acqu√©rir une ma√Ætrise solide des fondamentaux de PostgreSQL et du langage SQL. √Ä la fin de cette phase, vous serez capable d'√©crire des requ√™tes efficaces, de concevoir des sch√©mas de base de donn√©es simples et de comprendre le fonctionnement g√©n√©ral de PostgreSQL.

### Comp√©tences √† d√©velopper

#### Mois 1-2 : D√©couverte et Premiers Pas

**Concepts fondamentaux √† ma√Ætriser :**

- Comprendre ce qu'est une base de donn√©es relationnelle et pourquoi PostgreSQL se distingue
- Installer PostgreSQL sur votre environnement de d√©veloppement (Linux, macOS ou Windows)
- Se familiariser avec l'outil en ligne de commande `psql` et ses commandes de base (`\l`, `\c`, `\dt`, `\d`)
- Comprendre la hi√©rarchie des objets : Instance ‚Üí Base de donn√©es ‚Üí Sch√©ma ‚Üí Table

**SQL de base :**

- Ma√Ætriser la commande `SELECT` avec ses clauses essentielles : `WHERE`, `ORDER BY`, `LIMIT`
- Comprendre les op√©rateurs de comparaison et la logique bool√©enne (`AND`, `OR`, `NOT`)
- Apprendre √† filtrer les donn√©es avec `LIKE`, `IN`, `BETWEEN`
- D√©couvrir les fonctions de base : `UPPER()`, `LOWER()`, `LENGTH()`, `CONCAT()`

**Cr√©ation de structures :**

- Cr√©er des tables avec `CREATE TABLE`
- Comprendre les types de donn√©es essentiels :
  - Num√©riques : `INTEGER`, `BIGINT`, `NUMERIC`, `DECIMAL`
  - Texte : `VARCHAR(n)`, `TEXT`, `CHAR(n)`
  - Temporels : `DATE`, `TIME`, `TIMESTAMP`, `TIMESTAMPTZ`
  - Bool√©en : `BOOLEAN`
- D√©finir des contraintes simples : `NOT NULL`, `DEFAULT`

#### Mois 3-4 : Manipulation des Donn√©es et Relations

**Op√©rations DML (Data Manipulation Language) :**

- Ins√©rer des donn√©es avec `INSERT` (insertion simple et multiple)
- Mettre √† jour des enregistrements avec `UPDATE`
- Supprimer des donn√©es avec `DELETE`
- Comprendre la diff√©rence entre `DELETE` et `TRUNCATE`
- D√©couvrir la clause `RETURNING` propre √† PostgreSQL

**Contraintes d'int√©grit√© :**

- Cl√©s primaires (`PRIMARY KEY`) : unicit√© et identification
- Cl√©s √©trang√®res (`FOREIGN KEY`) : relations entre tables
- Contraintes d'unicit√© (`UNIQUE`)
- Contraintes de v√©rification (`CHECK`)
- Comprendre l'int√©grit√© r√©f√©rentielle et les actions en cascade (`ON DELETE CASCADE`, `ON UPDATE CASCADE`)

**Introduction aux jointures :**

- Comprendre le concept de jointure et son utilit√©
- Ma√Ætriser `INNER JOIN` : la jointure la plus courante
- D√©couvrir `LEFT JOIN` et `RIGHT JOIN` : inclure les enregistrements sans correspondance
- Apprendre √† joindre plusieurs tables dans une m√™me requ√™te

#### Mois 5-6 : Agr√©gation et Requ√™tes Interm√©diaires

**Fonctions d'agr√©gation :**

- `COUNT()` : compter les enregistrements
- `SUM()` : calculer des totaux
- `AVG()` : calculer des moyennes
- `MIN()` et `MAX()` : trouver les valeurs extr√™mes
- Comprendre la diff√©rence entre `COUNT(*)` et `COUNT(colonne)`

**Groupement de donn√©es :**

- Utiliser `GROUP BY` pour regrouper les r√©sultats
- Filtrer les groupes avec `HAVING` (diff√©rence avec `WHERE`)
- Combiner agr√©gation et jointures

**Gestion des valeurs NULL :**

- Comprendre la logique ternaire (vrai, faux, inconnu)
- Utiliser `IS NULL` et `IS NOT NULL`
- Ma√Ætriser `COALESCE()` pour g√©rer les valeurs par d√©faut
- D√©couvrir `NULLIF()` pour √©viter les divisions par z√©ro

**Sous-requ√™tes simples :**

- Sous-requ√™tes dans la clause `WHERE`
- Sous-requ√™tes scalaires (retournant une seule valeur)
- Utiliser `IN` avec une sous-requ√™te
- Comprendre `EXISTS` et son fonctionnement

### Indicateurs de progression (Phase 1)

√Ä la fin de cette phase, vous devriez √™tre capable de :

- Concevoir un sch√©ma de base de donn√©es simple avec plusieurs tables reli√©es
- √âcrire des requ√™tes `SELECT` impliquant plusieurs jointures
- Utiliser les fonctions d'agr√©gation avec `GROUP BY` et `HAVING`
- Ins√©rer, modifier et supprimer des donn√©es en respectant l'int√©grit√© r√©f√©rentielle
- Naviguer confortablement dans `psql` et comprendre les messages d'erreur courants

### Ressources recommand√©es (Phase 1)

- Documentation officielle PostgreSQL : Tutorial (chapitres 1 √† 6)
- Le SQL de base dans la documentation PostgreSQL
- Un outil graphique comme pgAdmin ou DBeaver pour visualiser vos donn√©es

---

## Phase 2 : Approfondissement (6-12 mois)

### Objectif de cette phase

D√©velopper une compr√©hension approfondie de PostgreSQL, ma√Ætriser les techniques SQL avanc√©es et comprendre les m√©canismes internes qui influencent les performances. Vous serez capable d'optimiser vos requ√™tes et de concevoir des sch√©mas adapt√©s √† des cas d'usage complexes.

### Comp√©tences √† d√©velopper

#### Mois 7-8 : SQL Avanc√©

**Jointures avanc√©es :**

- `FULL OUTER JOIN` : combiner toutes les donn√©es de deux tables
- `CROSS JOIN` : produit cart√©sien (et ses cas d'usage l√©gitimes)
- Self-join : joindre une table √† elle-m√™me (hi√©rarchies, comparaisons)
- `LATERAL JOIN` : sous-requ√™tes corr√©l√©es dans la clause `FROM`

**Common Table Expressions (CTE) :**

- Syntaxe `WITH` pour am√©liorer la lisibilit√© des requ√™tes complexes
- Comprendre quand utiliser `MATERIALIZED` vs non mat√©rialis√©
- CTE r√©cursives pour parcourir des structures hi√©rarchiques (arbres, graphes)
- Cas d'usage : organigrammes, cat√©gories imbriqu√©es, chemins dans un graphe

**Op√©rations ensemblistes :**

- `UNION` et `UNION ALL` : combiner des r√©sultats
- `INTERSECT` : trouver les √©l√©ments communs
- `EXCEPT` : trouver les diff√©rences entre deux ensembles

**Expressions conditionnelles :**

- `CASE WHEN ... THEN ... ELSE ... END` : logique conditionnelle dans les requ√™tes
- `CASE` simple vs `CASE` recherch√©
- Utilisation dans `SELECT`, `WHERE`, `ORDER BY` et `GROUP BY`

#### Mois 9-10 : Fonctions de Fen√™trage et Types Avanc√©s

**Window Functions (fonctions de fen√™trage) :**

Les fonctions de fen√™trage sont l'une des fonctionnalit√©s les plus puissantes de SQL moderne. Elles permettent d'effectuer des calculs sur un ensemble de lignes tout en conservant le d√©tail de chaque ligne.

- Comprendre la clause `OVER()` et son fonctionnement
- `PARTITION BY` : d√©finir des groupes pour le calcul
- `ORDER BY` dans la fen√™tre : d√©finir l'ordre des calculs

**Fonctions de rang :**

- `ROW_NUMBER()` : num√©rotation s√©quentielle
- `RANK()` : rang avec gaps en cas d'√©galit√©
- `DENSE_RANK()` : rang sans gaps
- `NTILE(n)` : r√©partition en n groupes √©gaux

**Fonctions de valeur :**

- `LAG()` et `LEAD()` : acc√©der aux lignes pr√©c√©dentes/suivantes
- `FIRST_VALUE()` et `LAST_VALUE()` : premi√®re et derni√®re valeur d'une fen√™tre
- `NTH_VALUE()` : acc√©der √† la n-i√®me valeur

**Frames de fen√™tre :**

- Comprendre `ROWS BETWEEN ... AND ...`
- Diff√©rence entre `ROWS`, `RANGE` et `GROUPS`
- Calculs de moyennes mobiles et totaux cumul√©s

**Types de donn√©es PostgreSQL sp√©cifiques :**

- `JSON` et `JSONB` : stocker et interroger des donn√©es semi-structur√©es
  - Diff√©rences entre JSON et JSONB (stockage, indexation, performance)
  - Op√©rateurs d'acc√®s : `->`, `->>`, `#>`, `#>>`
  - Fonctions : `jsonb_extract_path()`, `jsonb_array_elements()`, `jsonb_each()`
- `ARRAY` : listes de valeurs typ√©es
  - D√©claration et manipulation
  - Op√©rateurs : `@>`, `<@`, `&&`, `||`
  - Fonctions : `array_agg()`, `unnest()`, `array_length()`
- `UUID` : identifiants universels uniques
  - Avantages par rapport aux s√©quences (distribution, s√©curit√©)
  - G√©n√©ration avec `gen_random_uuid()`
  - Nouveaut√© PostgreSQL 18 : support natif de UUIDv7 (triable chronologiquement)

#### Mois 11-12 : Indexation et Performances

**Comprendre les index :**

- Pourquoi les index acc√©l√®rent les requ√™tes (analogie avec l'index d'un livre)
- Le co√ªt des index : espace disque et maintenance lors des √©critures
- Quand cr√©er un index et quand s'en abstenir

**Types d'index PostgreSQL :**

- **B-Tree** : l'index par d√©faut, adapt√© aux comparaisons (`=`, `<`, `>`, `BETWEEN`)
- **Hash** : optimis√© pour les √©galit√©s strictes uniquement
- **GIN** (Generalized Inverted Index) : id√©al pour JSONB, arrays, full-text search
- **GiST** (Generalized Search Tree) : g√©om√©trie, donn√©es spatiales, recherche de similarit√©
- **BRIN** (Block Range Index) : donn√©es naturellement ordonn√©es, tr√®s grandes tables

**Strat√©gies d'indexation avanc√©es :**

- Index partiels : indexer seulement un sous-ensemble de donn√©es (`WHERE condition`)
- Index sur expressions : indexer le r√©sultat d'une fonction (`CREATE INDEX ON table((lower(colonne)))`)
- Index multi-colonnes : ordre des colonnes et impact sur les performances
- Index couvrants (`INCLUDE`) : √©viter les acc√®s √† la table principale

**Lecture des plans d'ex√©cution :**

- Utiliser `EXPLAIN` pour comprendre comment PostgreSQL ex√©cute une requ√™te
- `EXPLAIN ANALYZE` : mesurer les temps r√©els d'ex√©cution
- Interpr√©ter les n≈ìuds du plan : Seq Scan, Index Scan, Bitmap Scan, Nested Loop, Hash Join, Merge Join
- Identifier les op√©rations co√ªteuses et les optimiser
- Nouveaut√© PostgreSQL 18 : affichage automatique des buffers dans `EXPLAIN ANALYZE`

**Introduction aux statistiques :**

- R√¥le de `ANALYZE` dans la collecte de statistiques
- Comment le planificateur utilise les statistiques pour choisir un plan
- Vue `pg_stats` : examiner les statistiques d'une colonne

### Indicateurs de progression (Phase 2)

√Ä la fin de cette phase, vous devriez √™tre capable de :

- √âcrire des requ√™tes complexes utilisant CTE, window functions et sous-requ√™tes corr√©l√©es
- Mod√©liser des donn√©es JSON/JSONB et les interroger efficacement
- Cr√©er des index adapt√©s √† vos requ√™tes et comprendre leur impact
- Lire et interpr√©ter un plan d'ex√©cution `EXPLAIN ANALYZE`
- Identifier et r√©soudre les probl√®mes de performance courants

### Ressources recommand√©es (Phase 2)

- Documentation PostgreSQL : chapitres sur les Window Functions et les Index
- "The Art of PostgreSQL" de Dimitri Fontaine
- Blog "Use The Index, Luke" (use-the-index-luke.com) pour l'indexation
- Extension `pg_stat_statements` pour analyser les requ√™tes fr√©quentes

---

## Phase 3 : Ma√Ætrise et Expertise (12-24 mois)

### Objectif de cette phase

Atteindre un niveau d'expertise permettant de concevoir des architectures robustes, d'optimiser finement les performances et d'int√©grer PostgreSQL dans des environnements de production complexes. Vous serez capable de prendre des d√©cisions architecturales √©clair√©es et de r√©soudre des probl√®mes avanc√©s.

### Comp√©tences √† d√©velopper

#### Mois 13-16 : Transactions, Concurrence et MVCC

**Comprendre les transactions :**

- Le cycle de vie d'une transaction : `BEGIN`, `COMMIT`, `ROLLBACK`
- Points de sauvegarde (`SAVEPOINT`) pour des rollbacks partiels
- Transactions implicites vs explicites
- Propri√©t√©s ACID : Atomicit√©, Coh√©rence, Isolation, Durabilit√©

**MVCC (Multiversion Concurrency Control) :**

MVCC est le m√©canisme fondamental qui permet √† PostgreSQL de g√©rer la concurrence sans bloquer les lectures.

- Principe : chaque transaction voit un "snapshot" coh√©rent des donn√©es
- Versions de lignes : `xmin`, `xmax` et visibilit√© des tuples
- Pourquoi les `UPDATE` cr√©ent de nouvelles versions (et l'importance de `VACUUM`)
- Impact sur le stockage et la notion de "bloat"

**Niveaux d'isolation :**

- `READ COMMITTED` (d√©faut PostgreSQL) : chaque requ√™te voit les donn√©es commit√©es au moment de son ex√©cution
- `REPEATABLE READ` : la transaction voit un snapshot fixe pris au d√©but
- `SERIALIZABLE` : garantit que les transactions s'ex√©cutent comme si elles √©taient s√©quentielles
- Anomalies transactionnelles : dirty read, non-repeatable read, phantom read, serialization anomaly

**Gestion des verrous :**

- Verrous de ligne vs verrous de table
- Modes de verrouillage : `ACCESS SHARE`, `ROW EXCLUSIVE`, `EXCLUSIVE`, etc.
- D√©tecter les verrous avec `pg_locks` et `pg_blocking_pids()`
- Deadlocks : comprendre, d√©tecter et √©viter
- Advisory locks : verrouillage applicatif personnalis√©

#### Mois 17-18 : Mod√©lisation Avanc√©e et Programmation Serveur

**Partitionnement de tables :**

Le partitionnement permet de diviser une grande table en morceaux plus petits et plus g√©rables.

- Partitionnement d√©claratif (introduit en PostgreSQL 10)
- Strat√©gies de partitionnement :
  - `RANGE` : par plages de valeurs (dates, identifiants)
  - `LIST` : par valeurs discr√®tes (r√©gions, statuts)
  - `HASH` : distribution uniforme
- Partition pruning : comment PostgreSQL ignore les partitions non pertinentes
- Gestion des partitions : cr√©ation, attachement, d√©tachement
- Cas d'usage : donn√©es historiques, multi-tenant, archivage

**Vues et vues mat√©rialis√©es :**

- Vues simples : encapsulation de requ√™tes complexes
- Vues updatable : conditions et limitations
- Vues mat√©rialis√©es : stockage physique des r√©sultats
- Rafra√Æchissement : `REFRESH MATERIALIZED VIEW` (avec ou sans `CONCURRENTLY`)
- Indexation des vues mat√©rialis√©es

**Colonnes g√©n√©r√©es :**

- Colonnes calcul√©es stock√©es (`STORED`)
- Nouveaut√© PostgreSQL 18 : colonnes g√©n√©r√©es virtuelles (`VIRTUAL`) ‚Äî calcul√©es √† la lecture

**Programmation PL/pgSQL :**

- Diff√©rence entre fonctions SQL et fonctions PL/pgSQL
- Structure d'une fonction : `DECLARE`, `BEGIN`, `END`
- Variables, boucles (`FOR`, `WHILE`, `LOOP`), conditions (`IF`, `CASE`)
- Retourner des r√©sultats : `RETURN`, `RETURN NEXT`, `RETURN QUERY`
- Cat√©gories de volatilit√© : `VOLATILE`, `STABLE`, `IMMUTABLE` ‚Äî impact sur l'optimisation
- Gestion des exceptions : `BEGIN ... EXCEPTION WHEN ... THEN ... END`

**Proc√©dures stock√©es :**

- Diff√©rence entre fonction et proc√©dure (depuis PostgreSQL 11)
- Gestion transactionnelle dans les proc√©dures (`COMMIT`, `ROLLBACK`)
- Appel avec `CALL`

**Triggers :**

- Triggers `BEFORE` et `AFTER` : quand les utiliser
- Triggers `FOR EACH ROW` vs `FOR EACH STATEMENT`
- Variables sp√©ciales : `NEW`, `OLD`, `TG_OP`, `TG_TABLE_NAME`
- Cas d'usage : audit, validation complexe, synchronisation de donn√©es
- Triggers `INSTEAD OF` sur les vues

#### Mois 19-21 : Int√©gration Applicative et Patterns Avanc√©s

**Connexion et drivers :**

- Comprendre le protocole de communication PostgreSQL
- Drivers par langage :
  - Python : `psycopg3` (moderne, asynchrone) vs `psycopg2` (legacy)
  - Node.js : `pg` (node-postgres), int√©gration avec Prisma
  - Java : JDBC, pools de connexions (HikariCP)
  - Go : `pgx` (recommand√©), `database/sql`
- Prepared statements : s√©curit√© (injection SQL) et performance

**Gestion des connexions :**

- Pourquoi limiter les connexions (`max_connections`)
- Connection pooling avec PgBouncer :
  - Mode `session` : une connexion par session client
  - Mode `transaction` : partage de connexions entre transactions
  - Mode `statement` : partage maximal (limitations)
- Dimensionnement : formule de base et ajustements
- D√©tection des fuites de connexions

**Patterns anti-corruption :**

- Probl√®me N+1 : d√©tection et solutions (jointures, `LATERAL`, batch loading)
- ORM vs SQL brut : avantages, inconv√©nients, quand utiliser quoi
- Lazy loading vs eager loading : compromis √† comprendre
- Bulk operations : `COPY` vs `INSERT` multiple, impact sur les performances

**UPSERT et MERGE :**

- `INSERT ... ON CONFLICT DO NOTHING` : ignorer les doublons
- `INSERT ... ON CONFLICT DO UPDATE` : mettre √† jour si existe
- `MERGE` (PostgreSQL 15+) : consolidation de donn√©es en une seule instruction
- Nouveaut√© PostgreSQL 18 : acc√®s √† `OLD` et `NEW` dans `RETURNING`

#### Mois 22-24 : Production, Maintenance et √âcosyst√®me

**Maintenance et sant√© de la base :**

- `VACUUM` : comprendre son r√¥le crucial
  - R√©cup√©ration de l'espace des tuples morts
  - Mise √† jour de la visibility map
  - Pr√©vention du "transaction ID wraparound"
- `VACUUM FULL` vs `VACUUM` standard : diff√©rences et quand l'utiliser
- `ANALYZE` : mise √† jour des statistiques du planificateur
- Autovacuum : configuration et supervision
- Nouveaut√© PostgreSQL 18 : nouveaux param√®tres autovacuum (`autovacuum_vacuum_max_threshold`)

**Monitoring et observabilit√© :**

- Extension `pg_stat_statements` : indispensable pour identifier les requ√™tes probl√©matiques
- Vues syst√®me essentielles :
  - `pg_stat_activity` : connexions et requ√™tes en cours
  - `pg_stat_user_tables` : statistiques par table (lectures, √©critures, tuples morts)
  - `pg_stat_user_indexes` : utilisation des index
  - `pg_locks` : verrous actifs
- M√©triques vitales √† surveiller :
  - Cache hit ratio (objectif > 99%)
  - Table bloat (espace perdu)
  - Connexions actives vs disponibles
  - Temps de checkpoint et g√©n√©ration WAL

**Sauvegardes et restauration :**

- Sauvegardes logiques : `pg_dump` et `pg_dumpall`
  - Formats : plain SQL, custom, directory
  - Options utiles : `--schema-only`, `--data-only`, `--table`
- Sauvegardes physiques : `pg_basebackup`
- Point-In-Time Recovery (PITR) : restauration √† un instant pr√©cis
- Strat√©gie 3-2-1 : 3 copies, 2 supports diff√©rents, 1 hors site

**Extensions PostgreSQL :**

- `pg_stat_statements` : analyse des requ√™tes
- `pgcrypto` : fonctions de chiffrement
- `uuid-ossp` ou `pgcrypto` : g√©n√©ration d'UUID
- `pg_trgm` : recherche de similarit√© textuelle
- `PostGIS` : donn√©es g√©ospatiales
- `pgvector` : recherche vectorielle pour l'IA et le machine learning

**Introduction √† la r√©plication :**

- Concepts : primary, standby, WAL shipping
- R√©plication physique (streaming replication) : copie identique
- R√©plication logique : s√©lection des tables, cas d'usage migrations
- Notions de haute disponibilit√© : failover, promotion

### Indicateurs de progression (Phase 3)

√Ä la fin de cette phase, vous devriez √™tre capable de :

- Concevoir des sch√©mas complexes avec partitionnement et contraintes avanc√©es
- √âcrire des fonctions et triggers PL/pgSQL pour la logique m√©tier
- Configurer et superviser une base PostgreSQL en production
- Diagnostiquer et r√©soudre des probl√®mes de concurrence (deadlocks, contention)
- Mettre en place des strat√©gies de sauvegarde et restauration fiables
- Int√©grer PostgreSQL dans une architecture applicative moderne
- Prendre des d√©cisions √©clair√©es sur l'indexation, le partitionnement et le tuning

### Ressources recommand√©es (Phase 3)

- Documentation PostgreSQL : chapitres sur l'administration et la r√©plication
- "PostgreSQL: Up and Running" de Regina Obe et Leo Hsu
- Blogs techniques : 2ndQuadrant, Percona, Crunchy Data, Cybertec
- Conf√©rences : PGConf, FOSDEM PostgreSQL devroom
- Communaut√©s : pgsql-general mailing list, Reddit r/PostgreSQL, Discord PostgreSQL

---

## Conseils G√©n√©raux pour Votre Progression

### Adopter une approche progressive

Ne cherchez pas √† tout apprendre en m√™me temps. Chaque concept s'appuie sur les pr√©c√©dents. Assurez-vous de bien ma√Ætriser les fondamentaux avant de passer aux sujets avanc√©s.

### Pratiquer r√©guli√®rement

La th√©orie seule ne suffit pas. Cr√©ez des projets personnels, reproduisez des sc√©narios r√©els, exp√©rimentez avec diff√©rentes approches. C'est en pratiquant que vous d√©velopperez une v√©ritable intuition.

### Lire les messages d'erreur

PostgreSQL fournit des messages d'erreur d√©taill√©s et souvent des suggestions de correction. Prenez le temps de les lire et de les comprendre plut√¥t que de chercher imm√©diatement une solution sur internet.

### Explorer la documentation officielle

La documentation PostgreSQL est exceptionnellement compl√®te et bien √©crite. Elle reste la r√©f√©rence ultime pour comprendre le fonctionnement de chaque fonctionnalit√©.

### Rejoindre la communaut√©

La communaut√© PostgreSQL est accueillante et active. N'h√©sitez pas √† poser des questions, √† participer aux discussions et √† partager vos d√©couvertes.

### Rester √† jour

PostgreSQL √©volue constamment avec une nouvelle version majeure chaque ann√©e. Suivez les release notes et testez les nouvelles fonctionnalit√©s pour rester √† la pointe.

---

## R√©capitulatif des Phases

| Phase | P√©riode | Focus Principal | Comp√©tences Cl√©s |
|-------|---------|-----------------|------------------|
| **1. Fondations** | 0-6 mois | SQL de base, DDL, DML | SELECT, JOIN, GROUP BY, contraintes |
| **2. Approfondissement** | 6-12 mois | SQL avanc√©, types, performance | CTE, Window Functions, JSONB, indexation, EXPLAIN |
| **3. Ma√Ætrise** | 12-24 mois | Production, architecture | MVCC, partitionnement, PL/pgSQL, monitoring, maintenance |

---


‚è≠Ô∏è [Parcours DevOps/SRE](/21-conclusion-et-perspectives/05.2-parcours-devops-sre.md)
