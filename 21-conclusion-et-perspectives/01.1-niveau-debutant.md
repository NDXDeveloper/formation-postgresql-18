üîù Retour au [Sommaire](/SOMMAIRE.md)

# 21.1.1 R√©sum√© pour D√©butants : SQL, DDL, DML et Contraintes

## Introduction

Bienvenue dans ce guide de synth√®se destin√© aux d√©butants en PostgreSQL. Ce chapitre r√©capitule les concepts fondamentaux que tout d√©veloppeur ou administrateur de bases de donn√©es doit ma√Ætriser avant de progresser vers des sujets plus avanc√©s.

Nous allons couvrir quatre piliers essentiels :

1. **SQL** : Le langage universel des bases de donn√©es relationnelles
2. **DDL** : La d√©finition des structures de donn√©es
3. **DML** : La manipulation des donn√©es
4. **Contraintes** : Les r√®gles garantissant l'int√©grit√© des donn√©es

---

## 1. SQL : Le Langage Universel des Bases de Donn√©es

### 1.1 Qu'est-ce que SQL ?

**SQL** (Structured Query Language, ou Langage de Requ√™te Structur√©) est le langage standard utilis√© pour communiquer avec les bases de donn√©es relationnelles. Cr√©√© dans les ann√©es 1970, il est aujourd'hui utilis√© par pratiquement tous les syst√®mes de gestion de bases de donn√©es relationnelles (SGBDR), dont PostgreSQL.

SQL vous permet de :

- Cr√©er et modifier la structure de vos bases de donn√©es
- Ins√©rer, modifier et supprimer des donn√©es
- Interroger vos donn√©es pour obtenir des informations pr√©cises
- Contr√¥ler les acc√®s et les permissions

### 1.2 Les Cat√©gories de Commandes SQL

SQL se divise en plusieurs sous-langages, chacun ayant un r√¥le sp√©cifique :

| Cat√©gorie | Nom Complet | R√¥le | Exemples de Commandes |
|-----------|-------------|------|----------------------|
| **DDL** | Data Definition Language | D√©finir la structure | `CREATE`, `ALTER`, `DROP` |
| **DML** | Data Manipulation Language | Manipuler les donn√©es | `INSERT`, `UPDATE`, `DELETE` |
| **DQL** | Data Query Language | Interroger les donn√©es | `SELECT` |
| **DCL** | Data Control Language | G√©rer les permissions | `GRANT`, `REVOKE` |
| **TCL** | Transaction Control Language | Contr√¥ler les transactions | `BEGIN`, `COMMIT`, `ROLLBACK` |

> **Note** : Certains consid√®rent DQL comme faisant partie de DML. Dans ce guide, nous nous concentrons sur DDL et DML, en incluant `SELECT` dans notre discussion sur DML pour des raisons pratiques.

### 1.3 Syntaxe de Base SQL

SQL utilise une syntaxe d√©clarative : vous d√©crivez **ce que vous voulez obtenir**, et non **comment l'obtenir**. Voici quelques r√®gles fondamentales :

- Les commandes SQL ne sont **pas sensibles √† la casse** (majuscules/minuscules)
- Par convention, les mots-cl√©s SQL s'√©crivent en MAJUSCULES
- Chaque instruction se termine par un **point-virgule** (`;`)
- Les cha√Ænes de caract√®res sont entour√©es de **guillemets simples** (`'texte'`)
- Les commentaires utilisent `--` (une ligne) ou `/* ... */` (plusieurs lignes)

```sql
-- Ceci est un commentaire sur une ligne

/* Ceci est un commentaire
   sur plusieurs lignes */

SELECT nom, prenom   -- Les mots-cl√©s en majuscules
FROM utilisateurs    -- Les noms de tables/colonnes en minuscules
WHERE age >= 18;     -- Point-virgule pour terminer
```

---

## 2. DDL : Data Definition Language (Langage de D√©finition des Donn√©es)

Le DDL permet de cr√©er, modifier et supprimer les **structures** qui contiennent vos donn√©es : bases de donn√©es, sch√©mas, tables, index, etc.

### 2.1 Hi√©rarchie des Objets PostgreSQL

Avant de cr√©er des objets, comprenons comment PostgreSQL organise les donn√©es :

```
Instance PostgreSQL (Serveur)
    ‚îî‚îÄ‚îÄ Database (Base de donn√©es)
            ‚îî‚îÄ‚îÄ Schema (Sch√©ma / Espace de noms)
                    ‚îî‚îÄ‚îÄ Table (Table)
                            ‚îî‚îÄ‚îÄ Column (Colonne)
```

- **Instance** : Le serveur PostgreSQL lui-m√™me
- **Database** : Une base de donn√©es isol√©e (vous pouvez en avoir plusieurs)
- **Schema** : Un espace de noms pour organiser les objets (par d√©faut : `public`)
- **Table** : La structure qui contient les donn√©es en lignes et colonnes

### 2.2 CREATE : Cr√©er des Objets

#### Cr√©er une Base de Donn√©es

```sql
CREATE DATABASE ma_boutique;
```

#### Cr√©er un Sch√©ma

```sql
CREATE SCHEMA ventes;
```

#### Cr√©er une Table

La cr√©ation de table est l'op√©ration DDL la plus courante. Voici la syntaxe de base :

```sql
CREATE TABLE nom_de_table (
    nom_colonne1 type_donnees contraintes,
    nom_colonne2 type_donnees contraintes,
    ...
);
```

**Exemple concret** : Cr√©ons une table pour stocker des clients.

```sql
CREATE TABLE clients (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100) NOT NULL,
    prenom VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE,
    date_naissance DATE,
    date_inscription TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

D√©cortiquons cet exemple :

| Colonne | Type | Explication |
|---------|------|-------------|
| `id` | `SERIAL` | Entier auto-incr√©ment√© (1, 2, 3...) |
| `nom` | `VARCHAR(100)` | Texte variable jusqu'√† 100 caract√®res |
| `prenom` | `VARCHAR(100)` | Texte variable jusqu'√† 100 caract√®res |
| `email` | `VARCHAR(255)` | Texte variable jusqu'√† 255 caract√®res |
| `date_naissance` | `DATE` | Date (ann√©e-mois-jour) |
| `date_inscription` | `TIMESTAMP` | Date et heure |

### 2.3 Les Types de Donn√©es Fondamentaux

PostgreSQL offre de nombreux types de donn√©es. Voici les plus courants pour d√©buter :

#### Types Num√©riques

| Type | Description | Plage de Valeurs |
|------|-------------|------------------|
| `SMALLINT` | Petit entier | -32 768 √† 32 767 |
| `INTEGER` ou `INT` | Entier standard | -2 147 483 648 √† 2 147 483 647 |
| `BIGINT` | Grand entier | Tr√®s grande plage |
| `SERIAL` | Entier auto-incr√©ment√© | Comme INTEGER mais automatique |
| `NUMERIC(p,s)` | Nombre d√©cimal pr√©cis | `p` chiffres, `s` d√©cimales |
| `REAL` | Nombre √† virgule flottante | Pr√©cision simple |
| `DOUBLE PRECISION` | Nombre √† virgule flottante | Pr√©cision double |

```sql
-- Exemples d'utilisation
CREATE TABLE produits (
    id SERIAL,
    quantite INTEGER,
    prix NUMERIC(10, 2),    -- 10 chiffres dont 2 d√©cimales (ex: 12345678.99)
    poids REAL
);
```

#### Types Texte

| Type | Description | Utilisation |
|------|-------------|-------------|
| `CHAR(n)` | Cha√Æne fixe de n caract√®res | Codes fixes (ex: code postal) |
| `VARCHAR(n)` | Cha√Æne variable jusqu'√† n caract√®res | Texte de longueur variable |
| `TEXT` | Cha√Æne de longueur illimit√©e | Descriptions, contenus longs |

```sql
-- Exemples d'utilisation
CREATE TABLE articles (
    code_postal CHAR(5),        -- Toujours 5 caract√®res
    titre VARCHAR(200),          -- Jusqu'√† 200 caract√®res
    contenu TEXT                 -- Sans limite
);
```

> **Conseil PostgreSQL** : En pratique, `VARCHAR` sans limite de taille et `TEXT` sont √©quivalents en termes de performance dans PostgreSQL. Utilisez `VARCHAR(n)` si vous voulez imposer une limite m√©tier.

#### Types Temporels

| Type | Description | Exemple |
|------|-------------|---------|
| `DATE` | Date seule | `'2025-11-24'` |
| `TIME` | Heure seule | `'14:30:00'` |
| `TIMESTAMP` | Date et heure | `'2025-11-24 14:30:00'` |
| `TIMESTAMPTZ` | Date, heure et fuseau horaire | `'2025-11-24 14:30:00+01'` |
| `INTERVAL` | Dur√©e | `'2 hours 30 minutes'` |

```sql
-- Exemples d'utilisation
CREATE TABLE evenements (
    date_evenement DATE,
    heure_debut TIME,
    cree_le TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    cree_le_tz TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
```

> **Bonne pratique** : Privil√©giez `TIMESTAMPTZ` pour stocker des dates avec heures. PostgreSQL convertira automatiquement selon le fuseau horaire de la session.

#### Types Bool√©en et Sp√©ciaux

| Type | Description | Valeurs Possibles |
|------|-------------|-------------------|
| `BOOLEAN` | Vrai ou faux | `TRUE`, `FALSE`, `NULL` |
| `UUID` | Identifiant unique universel | `'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'` |
| `JSON` / `JSONB` | Donn√©es JSON | `'{"nom": "Dupont"}'` |

```sql
-- Exemples d'utilisation
CREATE TABLE utilisateurs (
    id UUID DEFAULT gen_random_uuid(),
    actif BOOLEAN DEFAULT TRUE,
    preferences JSONB
);
```

### 2.4 ALTER : Modifier des Objets Existants

La commande `ALTER` permet de modifier la structure d'objets existants sans les supprimer.

#### Ajouter une Colonne

```sql
ALTER TABLE clients
ADD COLUMN telephone VARCHAR(20);
```

#### Supprimer une Colonne

```sql
ALTER TABLE clients
DROP COLUMN telephone;
```

#### Modifier le Type d'une Colonne

```sql
ALTER TABLE clients
ALTER COLUMN nom TYPE VARCHAR(150);
```

#### Renommer une Colonne

```sql
ALTER TABLE clients
RENAME COLUMN nom TO nom_famille;
```

#### Renommer une Table

```sql
ALTER TABLE clients
RENAME TO customers;
```

#### Ajouter une Contrainte

```sql
ALTER TABLE clients
ADD CONSTRAINT email_unique UNIQUE (email);
```

#### Supprimer une Contrainte

```sql
ALTER TABLE clients
DROP CONSTRAINT email_unique;
```

### 2.5 DROP : Supprimer des Objets

La commande `DROP` supprime d√©finitivement un objet et toutes ses donn√©es.

```sql
-- Supprimer une table
DROP TABLE clients;

-- Supprimer une table seulement si elle existe (√©vite les erreurs)
DROP TABLE IF EXISTS clients;

-- Supprimer une table et tous les objets qui en d√©pendent
DROP TABLE clients CASCADE;
```

> **Attention** : `DROP` est irr√©versible ! Utilisez toujours `IF EXISTS` pour √©viter les erreurs dans vos scripts, et `CASCADE` avec pr√©caution.

### 2.6 TRUNCATE : Vider une Table

`TRUNCATE` supprime toutes les lignes d'une table mais conserve sa structure.

```sql
TRUNCATE TABLE clients;

-- R√©initialiser √©galement les s√©quences (compteurs auto-incr√©ment√©s)
TRUNCATE TABLE clients RESTART IDENTITY;
```

> **Diff√©rence avec DELETE** : `TRUNCATE` est beaucoup plus rapide car il ne parcourt pas chaque ligne. Cependant, il ne d√©clenche pas les triggers `ON DELETE` et ne peut pas √™tre filtr√© avec `WHERE`.

---

## 3. DML : Data Manipulation Language (Langage de Manipulation des Donn√©es)

Le DML permet d'interagir avec les **donn√©es** contenues dans vos tables : insertion, modification, suppression et consultation.

### 3.1 INSERT : Ins√©rer des Donn√©es

#### Insertion Simple

```sql
INSERT INTO clients (nom, prenom, email)
VALUES ('Dupont', 'Marie', 'marie.dupont@email.com');
```

#### Insertion avec Toutes les Colonnes

Si vous ins√©rez une valeur pour chaque colonne (dans l'ordre de cr√©ation), vous pouvez omettre la liste des colonnes :

```sql
-- Attention : l'ordre doit correspondre exactement √† la structure de la table
INSERT INTO clients
VALUES (1, 'Dupont', 'Marie', 'marie.dupont@email.com', '1990-05-15', NOW());
```

> **Bonne pratique** : Sp√©cifiez toujours explicitement les colonnes. Cela rend le code plus lisible et r√©sistant aux modifications de sch√©ma.

#### Insertion Multiple

Ins√©rez plusieurs lignes en une seule commande :

```sql
INSERT INTO clients (nom, prenom, email)
VALUES
    ('Martin', 'Pierre', 'pierre.martin@email.com'),
    ('Bernard', 'Sophie', 'sophie.bernard@email.com'),
    ('Petit', 'Lucas', 'lucas.petit@email.com');
```

#### Insertion avec Valeurs par D√©faut

```sql
-- Utilise les valeurs DEFAULT d√©finies dans la table
INSERT INTO clients (nom, prenom)
VALUES ('Durand', 'Alice');
-- date_inscription prendra la valeur CURRENT_TIMESTAMP automatiquement
```

#### La Clause RETURNING

PostgreSQL offre une fonctionnalit√© puissante : r√©cup√©rer les valeurs g√©n√©r√©es lors de l'insertion.

```sql
INSERT INTO clients (nom, prenom, email)
VALUES ('Moreau', 'Julie', 'julie.moreau@email.com')
RETURNING id, date_inscription;
```

Cette requ√™te ins√®re la ligne ET retourne l'`id` auto-g√©n√©r√© ainsi que la date d'inscription.

### 3.2 SELECT : Interroger les Donn√©es

`SELECT` est la commande la plus utilis√©e en SQL. Elle permet de lire et filtrer les donn√©es.

#### S√©lection Basique

```sql
-- S√©lectionner toutes les colonnes
SELECT * FROM clients;

-- S√©lectionner des colonnes sp√©cifiques
SELECT nom, prenom, email FROM clients;
```

#### Alias de Colonnes

```sql
SELECT
    nom AS nom_famille,
    prenom AS prenom_usuel,
    email AS adresse_email
FROM clients;
```

#### Filtrage avec WHERE

```sql
-- √âgalit√©
SELECT * FROM clients WHERE nom = 'Dupont';

-- Comparaisons
SELECT * FROM clients WHERE date_naissance > '1990-01-01';

-- Op√©rateurs logiques
SELECT * FROM clients
WHERE nom = 'Dupont' AND prenom = 'Marie';

SELECT * FROM clients
WHERE nom = 'Dupont' OR nom = 'Martin';

-- N√©gation
SELECT * FROM clients WHERE nom != 'Dupont';
SELECT * FROM clients WHERE NOT nom = 'Dupont';
```

#### Op√©rateurs de Comparaison Courants

| Op√©rateur | Signification |
|-----------|---------------|
| `=` | √âgal √† |
| `!=` ou `<>` | Diff√©rent de |
| `<` | Inf√©rieur √† |
| `>` | Sup√©rieur √† |
| `<=` | Inf√©rieur ou √©gal √† |
| `>=` | Sup√©rieur ou √©gal √† |
| `BETWEEN ... AND ...` | Dans une plage |
| `IN (...)` | Dans une liste |
| `LIKE` | Correspondance de motif |
| `IS NULL` | Est nul |
| `IS NOT NULL` | N'est pas nul |

#### Exemples d'Op√©rateurs

```sql
-- BETWEEN : dans une plage (inclusif)
SELECT * FROM clients
WHERE date_naissance BETWEEN '1980-01-01' AND '1990-12-31';

-- IN : dans une liste de valeurs
SELECT * FROM clients
WHERE nom IN ('Dupont', 'Martin', 'Bernard');

-- LIKE : recherche par motif
SELECT * FROM clients WHERE nom LIKE 'D%';      -- Commence par D
SELECT * FROM clients WHERE nom LIKE '%ont';    -- Finit par "ont"
SELECT * FROM clients WHERE nom LIKE '%up%';    -- Contient "up"
SELECT * FROM clients WHERE nom LIKE 'D_pont';  -- D + 1 caract√®re + pont

-- ILIKE : comme LIKE mais insensible √† la casse (sp√©cifique PostgreSQL)
SELECT * FROM clients WHERE nom ILIKE 'd%';     -- d ou D

-- IS NULL / IS NOT NULL
SELECT * FROM clients WHERE email IS NULL;
SELECT * FROM clients WHERE email IS NOT NULL;
```

> **Important** : Pour tester si une valeur est `NULL`, utilisez toujours `IS NULL` ou `IS NOT NULL`. L'op√©rateur `=` ne fonctionne pas avec `NULL`.

#### Tri avec ORDER BY

```sql
-- Tri ascendant (par d√©faut)
SELECT * FROM clients ORDER BY nom;
SELECT * FROM clients ORDER BY nom ASC;

-- Tri descendant
SELECT * FROM clients ORDER BY date_inscription DESC;

-- Tri multiple
SELECT * FROM clients ORDER BY nom ASC, prenom ASC;

-- Gestion des NULL dans le tri
SELECT * FROM clients ORDER BY email NULLS LAST;   -- NULL √† la fin
SELECT * FROM clients ORDER BY email NULLS FIRST;  -- NULL au d√©but
```

#### Limitation des R√©sultats

```sql
-- Limiter le nombre de r√©sultats
SELECT * FROM clients LIMIT 10;

-- Pagination : sauter les N premi√®res lignes
SELECT * FROM clients LIMIT 10 OFFSET 20;  -- Lignes 21 √† 30
```

> **Attention** : La pagination avec `OFFSET` devient lente sur de grandes tables. Pour de meilleures performances, utilisez une pagination par curseur (bas√©e sur une valeur de colonne).

#### √âliminer les Doublons

```sql
-- Valeurs uniques d'une colonne
SELECT DISTINCT nom FROM clients;

-- Combinaisons uniques de colonnes
SELECT DISTINCT nom, prenom FROM clients;
```

### 3.3 UPDATE : Modifier des Donn√©es

`UPDATE` modifie les valeurs de colonnes pour les lignes correspondant √† une condition.

#### Mise √† Jour Simple

```sql
UPDATE clients
SET email = 'nouveau.email@example.com'
WHERE id = 1;
```

#### Mise √† Jour de Plusieurs Colonnes

```sql
UPDATE clients
SET
    email = 'marie.dupont.nouveau@email.com',
    nom = 'Dupont-Martin'
WHERE id = 1;
```

#### Mise √† Jour avec Calcul

```sql
-- Supposons une table produits avec un prix
UPDATE produits
SET prix = prix * 1.10  -- Augmentation de 10%
WHERE categorie = '√©lectronique';
```

#### UPDATE avec RETURNING

```sql
UPDATE clients
SET email = 'nouveau@email.com'
WHERE id = 1
RETURNING id, nom, email;  -- Retourne les valeurs apr√®s modification
```

> **Attention** : Un `UPDATE` sans clause `WHERE` modifie **toutes** les lignes de la table ! V√©rifiez toujours votre condition avant d'ex√©cuter.

```sql
-- DANGER : modifie TOUS les clients !
UPDATE clients SET actif = FALSE;
```

### 3.4 DELETE : Supprimer des Donn√©es

`DELETE` supprime les lignes correspondant √† une condition.

#### Suppression avec Condition

```sql
DELETE FROM clients
WHERE id = 1;
```

#### Suppression avec Plusieurs Conditions

```sql
DELETE FROM clients
WHERE date_inscription < '2020-01-01'
AND actif = FALSE;
```

#### DELETE avec RETURNING

```sql
DELETE FROM clients
WHERE id = 1
RETURNING *;  -- Retourne la ligne supprim√©e
```

> **Attention** : Comme pour `UPDATE`, un `DELETE` sans `WHERE` supprime **toutes** les lignes !

```sql
-- DANGER : supprime TOUS les clients !
DELETE FROM clients;
```

### 3.5 UPSERT : INSERT ... ON CONFLICT

L'op√©ration "UPSERT" (UPDATE + INSERT) permet d'ins√©rer une ligne, ou de la mettre √† jour si elle existe d√©j√†.

#### Ignorer les Conflits

```sql
INSERT INTO clients (id, nom, prenom, email)
VALUES (1, 'Dupont', 'Marie', 'marie@email.com')
ON CONFLICT (id) DO NOTHING;  -- Si l'id existe, ne rien faire
```

#### Mettre √† Jour en Cas de Conflit

```sql
INSERT INTO clients (id, nom, prenom, email)
VALUES (1, 'Dupont', 'Marie', 'marie.nouveau@email.com')
ON CONFLICT (id)
DO UPDATE SET
    email = EXCLUDED.email,  -- EXCLUDED r√©f√©rence les nouvelles valeurs
    nom = EXCLUDED.nom;
```

`EXCLUDED` est un mot-cl√© sp√©cial qui fait r√©f√©rence aux valeurs que vous tentiez d'ins√©rer.

---

## 4. Contraintes d'Int√©grit√©

Les contraintes sont des r√®gles appliqu√©es aux colonnes ou aux tables pour garantir la **validit√©** et la **coh√©rence** des donn√©es. Elles constituent un filet de s√©curit√© essentiel.

### 4.1 Pourquoi les Contraintes ?

Les contraintes permettent de :

- **Garantir la qualit√©** des donn√©es √† la source
- **√âviter les erreurs** applicatives en amont
- **Documenter** les r√®gles m√©tier dans le sch√©ma
- **Optimiser** les performances (les cl√©s primaires cr√©ent automatiquement des index)

### 4.2 PRIMARY KEY : Cl√© Primaire

La cl√© primaire identifie de mani√®re **unique** chaque ligne d'une table. Elle ne peut pas √™tre `NULL` et chaque valeur doit √™tre unique.

```sql
-- M√©thode 1 : Contrainte au niveau de la colonne
CREATE TABLE clients (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100)
);

-- M√©thode 2 : Contrainte au niveau de la table
CREATE TABLE clients (
    id SERIAL,
    nom VARCHAR(100),
    PRIMARY KEY (id)
);

-- Cl√© primaire composite (plusieurs colonnes)
CREATE TABLE commande_produits (
    commande_id INTEGER,
    produit_id INTEGER,
    quantite INTEGER,
    PRIMARY KEY (commande_id, produit_id)
);
```

> **Bonne pratique** : Chaque table devrait avoir une cl√© primaire. Pr√©f√©rez un identifiant technique (`id SERIAL` ou `UUID`) plut√¥t qu'une donn√©e m√©tier qui pourrait changer.

### 4.3 FOREIGN KEY : Cl√© √âtrang√®re

La cl√© √©trang√®re cr√©e une **relation** entre deux tables. Elle garantit que la valeur r√©f√©rence une ligne existante dans une autre table.

```sql
-- Table parente
CREATE TABLE categories (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100) NOT NULL
);

-- Table enfant avec cl√© √©trang√®re
CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100) NOT NULL,
    categorie_id INTEGER REFERENCES categories(id)
);
```

#### Syntaxe Compl√®te

```sql
CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100) NOT NULL,
    categorie_id INTEGER,
    FOREIGN KEY (categorie_id) REFERENCES categories(id)
        ON DELETE CASCADE      -- Que faire si la cat√©gorie est supprim√©e ?
        ON UPDATE CASCADE      -- Que faire si l'id de la cat√©gorie change ?
);
```

#### Actions R√©f√©rentielles

| Action | Comportement |
|--------|--------------|
| `CASCADE` | Propager l'action aux lignes enfants |
| `RESTRICT` | Emp√™cher l'action si des enfants existent (par d√©faut) |
| `SET NULL` | Mettre la cl√© √©trang√®re √† NULL |
| `SET DEFAULT` | Mettre la cl√© √©trang√®re √† sa valeur par d√©faut |
| `NO ACTION` | Similaire √† RESTRICT (v√©rification diff√©r√©e possible) |

**Exemple concret** :

```sql
-- Si on supprime une cat√©gorie, tous ses produits sont aussi supprim√©s
ON DELETE CASCADE

-- Si on supprime une cat√©gorie, l'op√©ration est bloqu√©e s'il y a des produits
ON DELETE RESTRICT

-- Si on supprime une cat√©gorie, les produits ont categorie_id = NULL
ON DELETE SET NULL
```

### 4.4 UNIQUE : Valeur Unique

La contrainte `UNIQUE` garantit que toutes les valeurs d'une colonne (ou combinaison de colonnes) sont distinctes.

```sql
-- Contrainte sur une colonne
CREATE TABLE clients (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE
);

-- Contrainte sur plusieurs colonnes
CREATE TABLE employes (
    id SERIAL PRIMARY KEY,
    prenom VARCHAR(100),
    nom VARCHAR(100),
    UNIQUE (prenom, nom)  -- La combinaison pr√©nom + nom doit √™tre unique
);
```

> **Note** : Contrairement √† `PRIMARY KEY`, une contrainte `UNIQUE` autorise les valeurs `NULL`. Plusieurs lignes peuvent avoir `NULL` dans une colonne `UNIQUE`.

### 4.5 NOT NULL : Valeur Obligatoire

`NOT NULL` interdit les valeurs nulles dans une colonne.

```sql
CREATE TABLE clients (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100) NOT NULL,      -- Obligatoire
    prenom VARCHAR(100) NOT NULL,   -- Obligatoire
    email VARCHAR(255)              -- Facultatif (NULL autoris√©)
);
```

> **Conseil** : R√©fl√©chissez bien √† quelles colonnes doivent √™tre obligatoires. Une fois la table remplie, ajouter `NOT NULL` peut √™tre complexe si des valeurs nulles existent.

### 4.6 CHECK : Validation Personnalis√©e

`CHECK` permet de d√©finir une condition que chaque valeur doit respecter.

```sql
CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100) NOT NULL,
    prix NUMERIC(10, 2) CHECK (prix >= 0),           -- Prix positif ou nul
    stock INTEGER CHECK (stock >= 0),                 -- Stock positif ou nul
    date_creation DATE CHECK (date_creation <= CURRENT_DATE)  -- Pas dans le futur
);

-- Contrainte CHECK nomm√©e (facilite la maintenance)
CREATE TABLE employes (
    id SERIAL PRIMARY KEY,
    salaire NUMERIC(10, 2),
    CONSTRAINT salaire_positif CHECK (salaire > 0)
);

-- CHECK sur plusieurs colonnes
CREATE TABLE promotions (
    id SERIAL PRIMARY KEY,
    date_debut DATE,
    date_fin DATE,
    CONSTRAINT dates_valides CHECK (date_fin > date_debut)
);
```

### 4.7 DEFAULT : Valeur par D√©faut

`DEFAULT` d√©finit la valeur utilis√©e si aucune valeur n'est sp√©cifi√©e lors de l'insertion.

```sql
CREATE TABLE commandes (
    id SERIAL PRIMARY KEY,
    date_commande TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    statut VARCHAR(20) DEFAULT 'en_attente',
    montant NUMERIC(10, 2) DEFAULT 0.00,
    actif BOOLEAN DEFAULT TRUE
);
```

### 4.8 Nommer les Contraintes

Il est recommand√© de nommer explicitement vos contraintes pour faciliter la maintenance et les messages d'erreur.

```sql
CREATE TABLE produits (
    id SERIAL,
    nom VARCHAR(100),
    prix NUMERIC(10, 2),
    categorie_id INTEGER,

    -- Contraintes nomm√©es
    CONSTRAINT pk_produits PRIMARY KEY (id),
    CONSTRAINT uq_produits_nom UNIQUE (nom),
    CONSTRAINT chk_produits_prix CHECK (prix >= 0),
    CONSTRAINT fk_produits_categorie FOREIGN KEY (categorie_id)
        REFERENCES categories(id) ON DELETE SET NULL
);
```

**Convention de nommage sugg√©r√©e** :

- `pk_` : Primary Key
- `fk_` : Foreign Key
- `uq_` : Unique
- `chk_` : Check
- Suivi du nom de la table et des colonnes concern√©es

### 4.9 Ajouter et Supprimer des Contraintes

#### Ajouter une Contrainte √† une Table Existante

```sql
-- Ajouter NOT NULL
ALTER TABLE clients
ALTER COLUMN nom SET NOT NULL;

-- Ajouter une contrainte UNIQUE
ALTER TABLE clients
ADD CONSTRAINT uq_clients_email UNIQUE (email);

-- Ajouter une contrainte CHECK
ALTER TABLE produits
ADD CONSTRAINT chk_produits_prix CHECK (prix >= 0);

-- Ajouter une cl√© √©trang√®re
ALTER TABLE produits
ADD CONSTRAINT fk_produits_categorie
    FOREIGN KEY (categorie_id) REFERENCES categories(id);
```

#### Supprimer une Contrainte

```sql
-- Supprimer une contrainte nomm√©e
ALTER TABLE clients
DROP CONSTRAINT uq_clients_email;

-- Supprimer NOT NULL
ALTER TABLE clients
ALTER COLUMN nom DROP NOT NULL;
```

### 4.10 Tableau R√©capitulatif des Contraintes

| Contrainte | R√¥le | Permet NULL ? | Cr√©e un Index ? |
|------------|------|---------------|-----------------|
| `PRIMARY KEY` | Identifiant unique de la ligne | Non | Oui (automatique) |
| `FOREIGN KEY` | R√©f√©rence vers une autre table | Oui | Non (√† cr√©er manuellement) |
| `UNIQUE` | Valeurs distinctes | Oui | Oui (automatique) |
| `NOT NULL` | Valeur obligatoire | Non | Non |
| `CHECK` | Validation personnalis√©e | Oui | Non |
| `DEFAULT` | Valeur par d√©faut | Oui | Non |

> **Conseil Performance** : Cr√©ez toujours un index sur les colonnes de cl√© √©trang√®re qui seront utilis√©es dans des jointures. PostgreSQL ne le fait pas automatiquement.

```sql
-- Apr√®s avoir cr√©√© une cl√© √©trang√®re
CREATE INDEX idx_produits_categorie_id ON produits(categorie_id);
```

---

## 5. Bonnes Pratiques

### 5.1 Conventions de Nommage

- Utilisez des noms en **minuscules** avec des **underscores** (`_`) comme s√©parateurs
- Nommez les tables au **pluriel** (`clients`, `produits`, `commandes`)
- Nommez les colonnes au **singulier** (`nom`, `prix`, `date_creation`)
- Soyez **coh√©rent** dans tout votre sch√©ma

```sql
-- Bon
CREATE TABLE commandes (
    id SERIAL PRIMARY KEY,
    client_id INTEGER REFERENCES clients(id),
    date_commande TIMESTAMP,
    montant_total NUMERIC(10, 2)
);

-- √Ä √©viter
CREATE TABLE Commande (
    ID SERIAL PRIMARY KEY,
    ClientID INTEGER,
    dateCommande TIMESTAMP,
    MontantTotal NUMERIC(10, 2)
);
```

### 5.2 Toujours Utiliser des Transactions

Pour les op√©rations critiques, encadrez vos commandes dans une transaction :

```sql
BEGIN;

UPDATE comptes SET solde = solde - 100 WHERE id = 1;
UPDATE comptes SET solde = solde + 100 WHERE id = 2;

-- Si tout est OK
COMMIT;

-- Ou en cas de probl√®me
-- ROLLBACK;
```

### 5.3 Tester Avant d'Ex√©cuter

Avant un `UPDATE` ou `DELETE`, v√©rifiez les lignes concern√©es avec un `SELECT` :

```sql
-- D'abord, v√©rifier ce qui sera affect√©
SELECT * FROM clients
WHERE date_inscription < '2020-01-01' AND actif = FALSE;

-- Puis, si c'est correct, ex√©cuter
DELETE FROM clients
WHERE date_inscription < '2020-01-01' AND actif = FALSE;
```

### 5.4 Commenter Votre Sch√©ma

PostgreSQL permet d'ajouter des commentaires aux objets :

```sql
COMMENT ON TABLE clients IS 'Table des clients de la boutique en ligne';
COMMENT ON COLUMN clients.email IS 'Adresse email unique, utilis√©e pour la connexion';
```

---

## R√©sum√©

Ce chapitre vous a pr√©sent√© les fondamentaux de PostgreSQL :

| Concept | Ce qu'il faut retenir |
|---------|----------------------|
| **SQL** | Langage d√©claratif standard pour les bases de donn√©es relationnelles |
| **DDL** | `CREATE`, `ALTER`, `DROP` pour d√©finir la structure |
| **DML** | `INSERT`, `SELECT`, `UPDATE`, `DELETE` pour manipuler les donn√©es |
| **Contraintes** | R√®gles garantissant l'int√©grit√© : PK, FK, UNIQUE, NOT NULL, CHECK, DEFAULT |

### Prochaines √âtapes

Une fois ces bases ma√Ætris√©es, vous pourrez explorer :

- Les **jointures** pour croiser les donn√©es de plusieurs tables
- Les **fonctions d'agr√©gation** (`COUNT`, `SUM`, `AVG`) pour analyser vos donn√©es
- Les **index** pour optimiser les performances de vos requ√™tes
- Les **transactions** et le mod√®le MVCC de PostgreSQL

---


‚è≠Ô∏è [Interm√©diaire : Jointures, Agr√©gation, Indexation](/21-conclusion-et-perspectives/01.2-niveau-intermediaire.md)
