üîù Retour au [Sommaire](/SOMMAIRE.md)

# 21.3.1. I/O Asynchrone : Jusqu'√† 3√ó Plus Rapide

## Introduction

L'une des am√©liorations les plus significatives de PostgreSQL 18 est l'introduction d'un **sous-syst√®me d'entr√©es/sorties asynchrones** (Asynchronous I/O ou AIO). Cette √©volution architecturale majeure permet d'am√©liorer consid√©rablement les performances de lecture, avec des gains pouvant atteindre **2 √† 3 fois** les performances des versions pr√©c√©dentes dans certains sc√©narios.

Cette section vous explique, de mani√®re accessible, ce qu'est l'I/O asynchrone, pourquoi c'est important, et comment PostgreSQL 18 l'impl√©mente.

---

## Comprendre le Probl√®me : L'I/O Synchrone Traditionnel

### Une Analogie Simple

Imaginez que vous √™tes dans une biblioth√®que et que vous devez consulter 100 livres rang√©s dans diff√©rentes √©tag√®res. Avec l'approche **synchrone** (celle utilis√©e par PostgreSQL avant la version 18), vous proc√©deriez ainsi :

1. Vous demandez le livre n¬∞1 au biblioth√©caire
2. Vous **attendez** qu'il aille le chercher
3. Vous recevez le livre et le lisez
4. Vous demandez le livre n¬∞2
5. Vous **attendez** √† nouveau...
6. Et ainsi de suite, un par un

Le probl√®me ? Vous passez beaucoup de temps √† **attendre** plut√¥t qu'√† lire.

### Le Mod√®le Synchrone dans PostgreSQL

Dans les versions pr√©c√©dentes de PostgreSQL, le fonctionnement √©tait similaire :

1. PostgreSQL demande √† lire un bloc de donn√©es (8 Ko) sur le disque
2. Le processus **se bloque** et attend que le disque r√©ponde
3. Une fois les donn√©es re√ßues, PostgreSQL les traite
4. PostgreSQL demande le bloc suivant
5. Nouveau blocage en attendant la r√©ponse...

Ce mod√®le est appel√© **I/O synchrone bloquant**. Le processeur reste inactif pendant que le disque travaille, ce qui repr√©sente un gaspillage de ressources significatif.

---

## La Solution : L'I/O Asynchrone

### Le Nouveau Paradigme

Avec l'I/O asynchrone, PostgreSQL peut maintenant :

1. **Soumettre plusieurs requ√™tes de lecture simultan√©ment**
2. **Continuer √† travailler** pendant que les donn√©es arrivent
3. **Traiter les donn√©es au fur et √† mesure** qu'elles deviennent disponibles

### Reprenons Notre Analogie

Avec l'approche **asynchrone**, vous proc√©dez diff√©remment dans la biblioth√®que :

1. Vous donnez au biblioth√©caire une liste de 10 livres √† r√©cup√©rer
2. Pendant qu'il va les chercher, vous commencez √† lire le livre que vous avez d√©j√†
3. Le biblioth√©caire vous apporte les livres au fur et √† mesure
4. Vous continuez √† lire sans interruption

R√©sultat : vous passez votre temps √† **lire** plut√¥t qu'√† **attendre**.

### Les B√©n√©fices Concrets

L'I/O asynchrone permet √† PostgreSQL de :

- **Anticiper** les besoins en donn√©es gr√¢ce aux plans d'ex√©cution des requ√™tes
- **Parall√©liser** les op√©rations de lecture avec le traitement des donn√©es
- **Optimiser** l'utilisation du mat√©riel (CPU, disques, m√©moire)

---

## Les Trois M√©thodes d'I/O dans PostgreSQL 18

PostgreSQL 18 introduit un nouveau param√®tre de configuration appel√© `io_method` qui permet de choisir parmi trois m√©thodes d'I/O.

### 1. La M√©thode `sync` (Synchrone)

```
io_method = 'sync'
```

Cette m√©thode reproduit le comportement des versions pr√©c√©dentes de PostgreSQL :

- Les lectures sont **synchrones et bloquantes**
- Utilise `posix_fadvise()` pour le read-ahead du noyau Linux
- **Cas d'usage** : D√©bogage, comparaison de performances, ou si vous rencontrez des probl√®mes avec les m√©thodes asynchrones

### 2. La M√©thode `worker` (Par D√©faut)

```
io_method = 'worker'
```

C'est la **m√©thode par d√©faut** dans PostgreSQL 18 :

- Des **processus worker d√©di√©s** g√®rent les op√©rations d'I/O en arri√®re-plan
- Le processus principal soumet les requ√™tes de lecture et continue son travail
- Les workers r√©cup√®rent les donn√©es ind√©pendamment de l'ex√©cution des requ√™tes
- **Compatible** avec tous les syst√®mes d'exploitation support√©s par PostgreSQL

Le nombre de workers est contr√¥l√© par le param√®tre `io_workers` (par d√©faut : 3).

### 3. La M√©thode `io_uring` (Linux Uniquement)

```
io_method = 'io_uring'
```

C'est la m√©thode la **plus performante**, mais avec des pr√©requis :

- Utilise l'interface moderne `io_uring` du noyau Linux
- Les requ√™tes sont soumises **directement au noyau** via un buffer circulaire partag√©
- **Pr√©requis** :
  - Linux avec noyau 5.1 ou sup√©rieur
  - PostgreSQL compil√© avec l'option `--with-liburing`
  - La fonctionnalit√© io_uring doit √™tre activ√©e dans le syst√®me

Cette m√©thode √©limine le besoin de processus workers interm√©diaires et offre les meilleures performances, particuli√®rement sur les syst√®mes de stockage √† haute latence (comme dans le cloud).

---

## Param√®tres de Configuration

### Les Param√®tres Principaux

| Param√®tre | Description | Valeur par d√©faut |
|-----------|-------------|-------------------|
| `io_method` | M√©thode d'I/O √† utiliser (`sync`, `worker`, `io_uring`) | `worker` |
| `io_workers` | Nombre de processus workers pour l'I/O asynchrone | 3 |
| `effective_io_concurrency` | Nombre de requ√™tes d'I/O concurrentes pour les op√©rations normales | 16 |
| `maintenance_io_concurrency` | Nombre de requ√™tes d'I/O concurrentes pour les op√©rations de maintenance (VACUUM, etc.) | 16 |
| `io_combine_limit` | Taille maximale des I/O combin√©es | Variable selon le syst√®me |

### Points Importants

- Le param√®tre `io_method` n√©cessite un **red√©marrage du serveur** pour √™tre pris en compte
- Les autres param√®tres peuvent g√©n√©ralement √™tre modifi√©s dynamiquement
- Sur les syst√®mes cloud ou avec des disques SSD/NVMe, des valeurs plus √©lev√©es pour `effective_io_concurrency` peuvent am√©liorer les performances

---

## Quelles Op√©rations B√©n√©ficient de l'I/O Asynchrone ?

Dans PostgreSQL 18, l'I/O asynchrone est impl√©ment√© pour les **op√©rations de lecture** suivantes :

### Op√©rations Support√©es

1. **Parcours s√©quentiels** (Sequential Scans) : Lecture compl√®te d'une table
2. **Parcours par bitmap** (Bitmap Heap Scans) : Lecture de blocs identifi√©s par un index bitmap
3. **Op√©rations de maintenance** : VACUUM, ANALYZE, et autres op√©rations de maintenance
4. **Op√©rations de sauvegarde** : pg_basebackup et similaires

### Limitations Actuelles

Il est important de noter que dans PostgreSQL 18 :

- **Seules les lectures** sont asynchrones
- **Les √©critures restent synchrones**, y compris les √©critures WAL (Write-Ahead Log)
- D'autres types d'acc√®s (comme certains types d'index) pourraient b√©n√©ficier de l'AIO dans les versions futures

---

## Gains de Performance : Les Chiffres

### Benchmarks Officiels

Les tests de performance r√©alis√©s par la communaut√© PostgreSQL et diff√©rents √©diteurs montrent des am√©liorations significatives :

| Sc√©nario | Am√©lioration Typique |
|----------|---------------------|
| Parcours s√©quentiels sur tables volumineuses | 2√ó √† 3√ó plus rapide |
| Workloads intensifs en lecture (lecture depuis le disque) | Jusqu'√† 3√ó plus rapide |
| Environnements cloud (stockage √† haute latence) | Gains les plus importants |

### Conditions pour Maximiser les Gains

Les gains de performance sont maximis√©s lorsque :

1. **Les donn√©es ne tiennent pas en m√©moire** : Si tout est en cache (shared_buffers), l'I/O asynchrone n'apporte pas d'avantage
2. **Le stockage a une latence significative** : Les environnements cloud b√©n√©ficient particuli√®rement de cette am√©lioration
3. **Les requ√™tes effectuent beaucoup de lectures** : Requ√™tes analytiques, rapports, exports de donn√©es
4. **Le CPU n'est pas satur√©** : Le CPU doit pouvoir traiter les donn√©es pendant que d'autres arrivent

### Quand les Gains Sont Moindres

L'I/O asynchrone apporte peu ou pas d'am√©lioration quand :

- Les donn√©es sont d√©j√† en cache m√©moire
- Les requ√™tes sont limit√©es par le CPU (calculs intensifs)
- Le stockage est d√©j√† satur√© (limite physique atteinte)
- Les requ√™tes utilisent principalement des index (peu de lectures s√©quentielles)

---

## Observabilit√© et Monitoring

PostgreSQL 18 fournit de nouveaux outils pour surveiller l'I/O asynchrone.

### La Vue Syst√®me `pg_aios`

Cette nouvelle vue permet de voir les op√©rations d'I/O asynchrone en cours :

```sql
SELECT * FROM pg_aios;
```

Elle affiche les handles de fichiers utilis√©s pour l'I/O asynchrone et l'√©tat des requ√™tes en cours.

### La Fonction `pg_get_aios()`

Cette fonction retourne des informations d√©taill√©es sur les I/O planifi√©es :

```sql
SELECT * FROM pg_get_aios();
```

Pour chaque requ√™te d'I/O planifi√©e, vous obtenez une entr√©e permettant de comprendre ce qui se passe en coulisses.

### Nouveaux √âv√©nements d'Attente

Avec la m√©thode `worker`, de nouveaux √©v√©nements d'attente apparaissent dans `pg_stat_activity` :

- `IO/AioIoCompletion` : Le backend attend la fin d'une op√©ration d'I/O asynchrone
- `IO/DataFileRead` : Un worker I/O effectue une lecture de fichier de donn√©es

Ces √©v√©nements permettent de diagnostiquer o√π le temps est pass√© lors de l'ex√©cution des requ√™tes.

---

## Comparaison des M√©thodes d'I/O

| Caract√©ristique | `sync` | `worker` | `io_uring` |
|-----------------|--------|----------|------------|
| **Mod√®le** | Synchrone bloquant | Asynchrone via workers | Asynchrone natif |
| **Compatibilit√©** | Tous OS | Tous OS | Linux 5.1+ uniquement |
| **Performance** | Baseline | Bonne | Excellente |
| **Overhead syst√®me** | Minimal | Mod√©r√© (processus workers) | Minimal |
| **Complexit√©** | Simple | Moyenne | Plus complexe √† configurer |
| **Cas d'usage id√©al** | D√©bogage, anciens syst√®mes | Production g√©n√©rale | Production Linux haute performance |

---

## Impact sur les Environnements Cloud

L'I/O asynchrone est particuli√®rement b√©n√©fique dans les environnements cloud pour plusieurs raisons :

### Latence du Stockage

Dans le cloud, le stockage (EBS sur AWS, Persistent Disk sur GCP, etc.) pr√©sente souvent une latence plus √©lev√©e que le stockage local. L'I/O asynchrone permet de :

- **Masquer cette latence** en soumettant plusieurs requ√™tes en parall√®le
- **Maintenir le d√©bit** m√™me avec une latence individuelle √©lev√©e
- **Optimiser les co√ªts** en utilisant mieux les IOPS provisionn√©es

### Stockage R√©seau

Les bases de donn√©es dans le cloud utilisent g√©n√©ralement du stockage r√©seau. L'I/O asynchrone est con√ßu pour tirer parti de la capacit√© de ces syst√®mes √† traiter de nombreuses requ√™tes en parall√®le.

---

## R√©sum√©

L'introduction de l'I/O asynchrone dans PostgreSQL 18 repr√©sente une **√©volution architecturale majeure** qui :

1. **Am√©liore significativement les performances** : Jusqu'√† 3√ó plus rapide pour les op√©rations de lecture intensives

2. **S'adapte aux infrastructures modernes** : Particuli√®rement efficace dans les environnements cloud et sur les syst√®mes de stockage modernes

3. **Reste compatible** : La m√©thode `sync` permet de revenir au comportement traditionnel si n√©cessaire

4. **Offre de la flexibilit√©** : Trois m√©thodes au choix selon votre environnement et vos besoins

5. **Am√©liore l'observabilit√©** : Nouveaux outils de monitoring pour comprendre le comportement I/O

### Points Cl√©s √† Retenir

- **Par d√©faut**, PostgreSQL 18 utilise la m√©thode `worker` (asynchrone)
- **Les lectures** sont asynchrones, **les √©critures** restent synchrones
- Les gains sont maximaux pour les **workloads intensifs en lecture** o√π les donn√©es ne tiennent pas en cache
- Sur **Linux moderne**, la m√©thode `io_uring` offre les meilleures performances
- Cette am√©lioration est **transparente** : vos applications existantes en b√©n√©ficient automatiquement

---

## Pour Aller Plus Loin

Cette fonctionnalit√© s'inscrit dans une tendance plus large d'am√©lioration des performances I/O dans PostgreSQL. Les versions futures pourraient √©tendre l'I/O asynchrone aux op√©rations d'√©criture et √† d'autres types d'acc√®s aux donn√©es.

Pour approfondir ce sujet, consultez :

- La documentation officielle PostgreSQL 18 sur les param√®tres `io_method` et associ√©s
- Les notes de version de PostgreSQL 18 (section sur l'I/O subsystem)
- Les articles de blog des contributeurs principaux (Andres Freund, Thomas Munro, et autres)

---


‚è≠Ô∏è [UUIDv7 et colonnes virtuelles](/21-conclusion-et-perspectives/03.2-uuidv7-colonnes-virtuelles.md)
