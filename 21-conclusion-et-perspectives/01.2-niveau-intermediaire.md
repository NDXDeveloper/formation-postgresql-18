üîù Retour au [Sommaire](/SOMMAIRE.md)

# 21.1.2 R√©sum√© Interm√©diaire : Jointures, Agr√©gation et Indexation

## Introduction

Bienvenue dans ce guide de niveau interm√©diaire pour PostgreSQL. Maintenant que vous ma√Ætrisez les bases du SQL (DDL, DML et contraintes), il est temps d'explorer des concepts plus puissants qui vous permettront de :

- **Croiser les donn√©es** de plusieurs tables gr√¢ce aux jointures
- **Analyser et r√©sumer** vos donn√©es avec les fonctions d'agr√©gation
- **Optimiser les performances** de vos requ√™tes gr√¢ce aux index

Ces trois piliers sont essentiels pour passer du statut de d√©butant √† celui de d√©veloppeur SQL comp√©tent.

---

## Partie 1 : Les Jointures

Les jointures permettent de combiner les donn√©es de plusieurs tables en une seule requ√™te. C'est l'une des fonctionnalit√©s les plus puissantes du mod√®le relationnel.

### 1.1 Pourquoi les Jointures ?

Dans une base de donn√©es bien con√ßue, les informations sont r√©parties dans plusieurs tables pour √©viter la redondance (normalisation). Par exemple :

- Une table `clients` contient les informations des clients
- Une table `commandes` contient les commandes pass√©es
- Une table `produits` contient le catalogue de produits

Pour afficher "toutes les commandes avec le nom du client et les produits achet√©s", vous devez **joindre** ces tables.

### 1.2 Sch√©ma de Donn√©es pour les Exemples

Pour illustrer les jointures, utilisons ce sch√©ma :

```sql
-- Table des clients
CREATE TABLE clients (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100) NOT NULL,
    email VARCHAR(255),
    ville VARCHAR(100)
);

-- Table des commandes
CREATE TABLE commandes (
    id SERIAL PRIMARY KEY,
    client_id INTEGER REFERENCES clients(id),
    date_commande DATE DEFAULT CURRENT_DATE,
    montant NUMERIC(10, 2)
);

-- Table des produits
CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100) NOT NULL,
    prix NUMERIC(10, 2),
    categorie_id INTEGER
);

-- Table des cat√©gories
CREATE TABLE categories (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100) NOT NULL
);

-- Donn√©es d'exemple
INSERT INTO clients (nom, email, ville) VALUES
    ('Alice Dupont', 'alice@email.com', 'Paris'),
    ('Bob Martin', 'bob@email.com', 'Lyon'),
    ('Claire Bernard', 'claire@email.com', 'Marseille'),
    ('David Petit', NULL, 'Paris');

INSERT INTO commandes (client_id, date_commande, montant) VALUES
    (1, '2025-01-15', 150.00),
    (1, '2025-02-20', 75.50),
    (2, '2025-01-22', 200.00),
    (NULL, '2025-03-01', 50.00);  -- Commande sans client (orpheline)

INSERT INTO categories (nom) VALUES
    ('√âlectronique'),
    ('V√™tements'),
    ('Alimentation');

INSERT INTO produits (nom, prix, categorie_id) VALUES
    ('Smartphone', 599.99, 1),
    ('T-shirt', 29.99, 2),
    ('Laptop', 1299.00, 1),
    ('Casque audio', 149.99, NULL);  -- Produit sans cat√©gorie
```

### 1.3 Le Produit Cart√©sien (CROSS JOIN)

Le produit cart√©sien combine **chaque ligne** d'une table avec **chaque ligne** d'une autre table. C'est la forme la plus basique de jointure.

```sql
-- Syntaxe implicite (√† √©viter)
SELECT * FROM clients, commandes;

-- Syntaxe explicite (recommand√©e)
SELECT * FROM clients CROSS JOIN commandes;
```

Si `clients` a 4 lignes et `commandes` a 4 lignes, le r√©sultat contient 4 √ó 4 = **16 lignes**.

> **Attention** : Le produit cart√©sien est rarement utile en pratique et peut √™tre tr√®s co√ªteux en performance. Il sert principalement de base th√©orique pour comprendre les autres jointures.

**Cas d'usage l√©gitime** : G√©n√©rer toutes les combinaisons possibles.

```sql
-- Toutes les combinaisons taille √ó couleur
SELECT tailles.nom, couleurs.nom
FROM tailles CROSS JOIN couleurs;
```

### 1.4 INNER JOIN : Jointure Interne

L'`INNER JOIN` retourne uniquement les lignes qui ont une **correspondance dans les deux tables**.

```sql
-- Syntaxe standard
SELECT
    clients.nom AS client,
    commandes.id AS commande_id,
    commandes.montant
FROM clients
INNER JOIN commandes ON clients.id = commandes.client_id;
```

**R√©sultat** :

| client | commande_id | montant |
|--------|-------------|---------|
| Alice Dupont | 1 | 150.00 |
| Alice Dupont | 2 | 75.50 |
| Bob Martin | 3 | 200.00 |

Notez que :
- Claire Bernard et David Petit n'apparaissent pas (pas de commandes)
- La commande avec `client_id = NULL` n'appara√Æt pas (pas de correspondance)

#### Syntaxe avec Alias

Les alias rendent les requ√™tes plus lisibles :

```sql
SELECT
    c.nom AS client,
    cmd.id AS commande_id,
    cmd.montant
FROM clients c
INNER JOIN commandes cmd ON c.id = cmd.client_id;
```

#### USING : Simplifier les Jointures

Quand les colonnes de jointure ont le **m√™me nom** dans les deux tables, utilisez `USING` :

```sql
-- Si la colonne s'appelait "client_id" dans les deux tables
SELECT c.nom, cmd.montant
FROM clients c
INNER JOIN commandes cmd USING (client_id);
```

#### NATURAL JOIN : Jointure Automatique

`NATURAL JOIN` joint automatiquement sur les colonnes de m√™me nom. √Ä √©viter car peu explicite et fragile.

```sql
-- D√©conseill√© : comportement implicite
SELECT * FROM clients NATURAL JOIN commandes;
```

### 1.5 LEFT JOIN (LEFT OUTER JOIN)

Le `LEFT JOIN` retourne **toutes les lignes de la table de gauche**, m√™me si elles n'ont pas de correspondance dans la table de droite. Les colonnes de la table de droite seront `NULL` pour les lignes sans correspondance.

```sql
SELECT
    c.nom AS client,
    cmd.id AS commande_id,
    cmd.montant
FROM clients c
LEFT JOIN commandes cmd ON c.id = cmd.client_id;
```

**R√©sultat** :

| client | commande_id | montant |
|--------|-------------|---------|
| Alice Dupont | 1 | 150.00 |
| Alice Dupont | 2 | 75.50 |
| Bob Martin | 3 | 200.00 |
| Claire Bernard | NULL | NULL |
| David Petit | NULL | NULL |

Claire et David apparaissent maintenant, avec `NULL` pour les colonnes de commandes.

#### Trouver les Lignes Sans Correspondance

Une utilisation courante du `LEFT JOIN` est de trouver les √©l√©ments "orphelins" :

```sql
-- Clients qui n'ont jamais command√©
SELECT c.nom, c.email
FROM clients c
LEFT JOIN commandes cmd ON c.id = cmd.client_id
WHERE cmd.id IS NULL;
```

**R√©sultat** :

| nom | email |
|-----|-------|
| Claire Bernard | claire@email.com |
| David Petit | NULL |

### 1.6 RIGHT JOIN (RIGHT OUTER JOIN)

Le `RIGHT JOIN` est l'inverse du `LEFT JOIN` : il retourne **toutes les lignes de la table de droite**.

```sql
SELECT
    c.nom AS client,
    cmd.id AS commande_id,
    cmd.montant
FROM clients c
RIGHT JOIN commandes cmd ON c.id = cmd.client_id;
```

**R√©sultat** :

| client | commande_id | montant |
|--------|-------------|---------|
| Alice Dupont | 1 | 150.00 |
| Alice Dupont | 2 | 75.50 |
| Bob Martin | 3 | 200.00 |
| NULL | 4 | 50.00 |

La commande sans client (id=4) appara√Æt avec `NULL` pour le nom du client.

> **En pratique** : Le `RIGHT JOIN` est peu utilis√©. On pr√©f√®re g√©n√©ralement inverser l'ordre des tables et utiliser un `LEFT JOIN` pour une meilleure lisibilit√©.

### 1.7 FULL OUTER JOIN

Le `FULL OUTER JOIN` retourne **toutes les lignes des deux tables**, avec `NULL` l√† o√π il n'y a pas de correspondance.

```sql
SELECT
    c.nom AS client,
    cmd.id AS commande_id,
    cmd.montant
FROM clients c
FULL OUTER JOIN commandes cmd ON c.id = cmd.client_id;
```

**R√©sultat** :

| client | commande_id | montant |
|--------|-------------|---------|
| Alice Dupont | 1 | 150.00 |
| Alice Dupont | 2 | 75.50 |
| Bob Martin | 3 | 200.00 |
| Claire Bernard | NULL | NULL |
| David Petit | NULL | NULL |
| NULL | 4 | 50.00 |

### 1.8 Sch√©ma Visuel des Jointures

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                                                     ‚îÇ
‚îÇ   Table A          Table B              R√©sultat                    ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                           ‚îÇ
‚îÇ   ‚îÇ     ‚îÇ         ‚îÇ     ‚îÇ                                           ‚îÇ
‚îÇ   ‚îÇ  A  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ  B  ‚îÇ                                           ‚îÇ
‚îÇ   ‚îÇ     ‚îÇ         ‚îÇ     ‚îÇ                                           ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                           ‚îÇ
‚îÇ                                                                     ‚îÇ
‚îÇ   INNER JOIN      : Seulement l'intersection (A ‚à© B)                ‚îÇ
‚îÇ   LEFT JOIN       : Tout A + intersection avec B                    ‚îÇ
‚îÇ   RIGHT JOIN      : Tout B + intersection avec A                    ‚îÇ
‚îÇ   FULL OUTER JOIN : Tout A + Tout B                                 ‚îÇ
‚îÇ   CROSS JOIN      : Produit cart√©sien (A √ó B)                       ‚îÇ
‚îÇ                                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 1.9 Jointures Multiples

Vous pouvez encha√Æner plusieurs jointures dans une m√™me requ√™te :

```sql
SELECT
    c.nom AS client,
    cmd.date_commande,
    p.nom AS produit,
    cat.nom AS categorie
FROM clients c
INNER JOIN commandes cmd ON c.id = cmd.client_id
INNER JOIN lignes_commande lc ON cmd.id = lc.commande_id
INNER JOIN produits p ON lc.produit_id = p.id
LEFT JOIN categories cat ON p.categorie_id = cat.id;
```

> **Conseil** : Commencez par la table principale, puis ajoutez les jointures dans un ordre logique. Utilisez des alias courts et coh√©rents.

### 1.10 Self-Join : Joindre une Table √† Elle-m√™me

Parfois, vous devez joindre une table √† elle-m√™me. C'est utile pour les structures hi√©rarchiques.

```sql
-- Table des employ√©s avec hi√©rarchie
CREATE TABLE employes (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    manager_id INTEGER REFERENCES employes(id)
);

INSERT INTO employes (nom, manager_id) VALUES
    ('Alice', NULL),      -- PDG, pas de manager
    ('Bob', 1),           -- Manager: Alice
    ('Claire', 1),        -- Manager: Alice
    ('David', 2);         -- Manager: Bob

-- Afficher chaque employ√© avec son manager
SELECT
    e.nom AS employe,
    m.nom AS manager
FROM employes e
LEFT JOIN employes m ON e.manager_id = m.id;
```

**R√©sultat** :

| employe | manager |
|---------|---------|
| Alice | NULL |
| Bob | Alice |
| Claire | Alice |
| David | Bob |

### 1.11 LATERAL JOIN : Jointures Corr√©l√©es

Le `LATERAL JOIN` permet √† la sous-requ√™te de droite de r√©f√©rencer des colonnes de la table de gauche. C'est tr√®s puissant pour les requ√™tes complexes.

```sql
-- Pour chaque client, obtenir ses 2 derni√®res commandes
SELECT
    c.nom,
    recent_cmd.date_commande,
    recent_cmd.montant
FROM clients c
LEFT JOIN LATERAL (
    SELECT date_commande, montant
    FROM commandes cmd
    WHERE cmd.client_id = c.id  -- R√©f√©rence √† la table de gauche
    ORDER BY date_commande DESC
    LIMIT 2
) recent_cmd ON TRUE;
```

Sans `LATERAL`, cette corr√©lation ne serait pas possible dans une sous-requ√™te de jointure.

### 1.12 Anti-Jointures et Semi-Jointures

Ces patterns permettent de filtrer bas√© sur l'existence (ou non) de lignes correspondantes.

#### Anti-Jointure : Lignes Sans Correspondance

```sql
-- M√©thode 1 : LEFT JOIN + IS NULL (recommand√©e)
SELECT c.*
FROM clients c
LEFT JOIN commandes cmd ON c.id = cmd.client_id
WHERE cmd.id IS NULL;

-- M√©thode 2 : NOT EXISTS
SELECT c.*
FROM clients c
WHERE NOT EXISTS (
    SELECT 1 FROM commandes cmd WHERE cmd.client_id = c.id
);

-- M√©thode 3 : NOT IN (attention aux NULL !)
SELECT c.*
FROM clients c
WHERE c.id NOT IN (
    SELECT client_id FROM commandes WHERE client_id IS NOT NULL
);
```

> **Attention avec NOT IN** : Si la sous-requ√™te contient des `NULL`, `NOT IN` peut retourner des r√©sultats inattendus. Pr√©f√©rez `NOT EXISTS` ou `LEFT JOIN`.

#### Semi-Jointure : V√©rifier l'Existence

```sql
-- Clients qui ont au moins une commande
SELECT c.*
FROM clients c
WHERE EXISTS (
    SELECT 1 FROM commandes cmd WHERE cmd.client_id = c.id
);
```

### 1.13 Bonnes Pratiques pour les Jointures

1. **Utilisez toujours des alias** pour am√©liorer la lisibilit√©
2. **Qualifiez les colonnes** avec leur alias de table (`c.nom` au lieu de `nom`)
3. **Pr√©f√©rez INNER JOIN** sauf si vous avez besoin des lignes sans correspondance
4. **Indexez les colonnes de jointure** (cl√©s √©trang√®res) pour de meilleures performances
5. **√âvitez les produits cart√©siens** accidentels (oubli de condition ON)

---

## Partie 2 : Agr√©gation et Groupement

L'agr√©gation permet de r√©sumer et analyser vos donn√©es en calculant des statistiques sur des groupes de lignes.

### 2.1 Fonctions d'Agr√©gation Standards

Les fonctions d'agr√©gation calculent une valeur unique √† partir d'un ensemble de lignes.

| Fonction | Description | Gestion des NULL |
|----------|-------------|------------------|
| `COUNT(*)` | Nombre total de lignes | Compte toutes les lignes |
| `COUNT(colonne)` | Nombre de valeurs non-NULL | Ignore les NULL |
| `COUNT(DISTINCT col)` | Nombre de valeurs uniques | Ignore les NULL |
| `SUM(colonne)` | Somme des valeurs | Ignore les NULL |
| `AVG(colonne)` | Moyenne des valeurs | Ignore les NULL |
| `MIN(colonne)` | Valeur minimale | Ignore les NULL |
| `MAX(colonne)` | Valeur maximale | Ignore les NULL |

#### Exemples Basiques

```sql
-- Nombre total de clients
SELECT COUNT(*) AS nombre_clients FROM clients;

-- Nombre de clients avec email
SELECT COUNT(email) AS clients_avec_email FROM clients;

-- Nombre de villes distinctes
SELECT COUNT(DISTINCT ville) AS nombre_villes FROM clients;

-- Statistiques sur les commandes
SELECT
    COUNT(*) AS nombre_commandes,
    SUM(montant) AS total_ventes,
    AVG(montant) AS panier_moyen,
    MIN(montant) AS plus_petite_commande,
    MAX(montant) AS plus_grande_commande
FROM commandes;
```

### 2.2 GROUP BY : Grouper les Donn√©es

`GROUP BY` divise les r√©sultats en groupes et applique les fonctions d'agr√©gation √† chaque groupe s√©par√©ment.

```sql
-- Nombre de commandes par client
SELECT
    client_id,
    COUNT(*) AS nombre_commandes,
    SUM(montant) AS total_depense
FROM commandes
GROUP BY client_id;
```

**R√©sultat** :

| client_id | nombre_commandes | total_depense |
|-----------|------------------|---------------|
| 1 | 2 | 225.50 |
| 2 | 1 | 200.00 |
| NULL | 1 | 50.00 |

#### R√®gle Fondamentale du GROUP BY

> **R√®gle** : Toute colonne dans le `SELECT` qui n'est pas dans une fonction d'agr√©gation **doit** appara√Ætre dans le `GROUP BY`.

```sql
-- CORRECT : nom est dans GROUP BY
SELECT
    c.nom,
    COUNT(cmd.id) AS nombre_commandes
FROM clients c
LEFT JOIN commandes cmd ON c.id = cmd.client_id
GROUP BY c.nom;

-- ERREUR : email n'est pas dans GROUP BY ni dans une fonction d'agr√©gation
SELECT
    c.nom,
    c.email,  -- ERREUR !
    COUNT(cmd.id)
FROM clients c
LEFT JOIN commandes cmd ON c.id = cmd.client_id
GROUP BY c.nom;

-- CORRECT : ajouter email au GROUP BY
SELECT
    c.nom,
    c.email,
    COUNT(cmd.id) AS nombre_commandes
FROM clients c
LEFT JOIN commandes cmd ON c.id = cmd.client_id
GROUP BY c.nom, c.email;
```

#### Groupement sur Plusieurs Colonnes

```sql
-- Ventes par ville et par mois
SELECT
    c.ville,
    EXTRACT(MONTH FROM cmd.date_commande) AS mois,
    COUNT(*) AS nombre_commandes,
    SUM(cmd.montant) AS total_ventes
FROM clients c
INNER JOIN commandes cmd ON c.id = cmd.client_id
GROUP BY c.ville, EXTRACT(MONTH FROM cmd.date_commande)
ORDER BY c.ville, mois;
```

### 2.3 HAVING : Filtrer les Groupes

`HAVING` filtre les r√©sultats **apr√®s** le groupement, contrairement √† `WHERE` qui filtre **avant**.

```sql
-- Clients avec plus d'une commande
SELECT
    client_id,
    COUNT(*) AS nombre_commandes,
    SUM(montant) AS total_depense
FROM commandes
GROUP BY client_id
HAVING COUNT(*) > 1;
```

#### Diff√©rence entre WHERE et HAVING

| Clause | Moment d'ex√©cution | Peut utiliser |
|--------|-------------------|---------------|
| `WHERE` | Avant le groupement | Colonnes brutes uniquement |
| `HAVING` | Apr√®s le groupement | Fonctions d'agr√©gation |

```sql
-- WHERE filtre les lignes AVANT le groupement
SELECT client_id, SUM(montant)
FROM commandes
WHERE montant > 50          -- Exclut les commandes ‚â§ 50‚Ç¨
GROUP BY client_id;

-- HAVING filtre les groupes APR√àS le groupement
SELECT client_id, SUM(montant)
FROM commandes
GROUP BY client_id
HAVING SUM(montant) > 100;  -- Garde seulement les clients avec total > 100‚Ç¨

-- Combinaison des deux
SELECT client_id, SUM(montant) AS total
FROM commandes
WHERE date_commande >= '2025-01-01'  -- Commandes de 2025 uniquement
GROUP BY client_id
HAVING SUM(montant) > 100;           -- Clients avec total > 100‚Ç¨
```

### 2.4 Ordre d'Ex√©cution Logique d'une Requ√™te SQL

Comprendre l'ordre d'ex√©cution aide √† √©crire des requ√™tes correctes :

```
1. FROM       - Identification des tables sources
2. JOIN       - Application des jointures
3. WHERE      - Filtrage des lignes
4. GROUP BY   - Groupement des lignes
5. HAVING     - Filtrage des groupes
6. SELECT     - S√©lection des colonnes et calculs
7. DISTINCT   - √âlimination des doublons
8. ORDER BY   - Tri des r√©sultats
9. LIMIT      - Limitation du nombre de r√©sultats
```

C'est pourquoi :
- `WHERE` ne peut pas utiliser les alias d√©finis dans `SELECT`
- `HAVING` peut utiliser les fonctions d'agr√©gation
- `ORDER BY` peut utiliser les alias du `SELECT`

### 2.5 Fonctions d'Agr√©gation Statistiques

PostgreSQL offre des fonctions statistiques avanc√©es :

```sql
SELECT
    -- √âcart-type (population vs √©chantillon)
    STDDEV_POP(montant) AS ecart_type_population,
    STDDEV_SAMP(montant) AS ecart_type_echantillon,
    STDDEV(montant) AS ecart_type,  -- Alias pour STDDEV_SAMP

    -- Variance
    VAR_POP(montant) AS variance_population,
    VAR_SAMP(montant) AS variance_echantillon,
    VARIANCE(montant) AS variance,  -- Alias pour VAR_SAMP

    -- Corr√©lation (entre deux colonnes)
    CORR(montant, quantite) AS correlation
FROM commandes;
```

### 2.6 Agr√©gations Ordonn√©es (WITHIN GROUP)

Certaines fonctions d'agr√©gation n√©cessitent un ordre sp√©cifique :

```sql
-- M√©diane (percentile 50)
SELECT
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY montant) AS mediane,
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY montant) AS premier_quartile,
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY montant) AS troisieme_quartile
FROM commandes;

-- Mode (valeur la plus fr√©quente)
SELECT MODE() WITHIN GROUP (ORDER BY ville) AS ville_la_plus_frequente
FROM clients;
```

### 2.7 Agr√©gation de Cha√Ænes : STRING_AGG

`STRING_AGG` concat√®ne les valeurs d'un groupe en une seule cha√Æne :

```sql
-- Liste des clients par ville
SELECT
    ville,
    STRING_AGG(nom, ', ' ORDER BY nom) AS liste_clients
FROM clients
GROUP BY ville;
```

**R√©sultat** :

| ville | liste_clients |
|-------|---------------|
| Lyon | Bob Martin |
| Marseille | Claire Bernard |
| Paris | Alice Dupont, David Petit |

### 2.8 Agr√©gation de Tableaux : ARRAY_AGG

```sql
-- Tableau des montants de commandes par client
SELECT
    client_id,
    ARRAY_AGG(montant ORDER BY date_commande) AS montants_commandes
FROM commandes
WHERE client_id IS NOT NULL
GROUP BY client_id;
```

**R√©sultat** :

| client_id | montants_commandes |
|-----------|-------------------|
| 1 | {150.00, 75.50} |
| 2 | {200.00} |

### 2.9 La Clause FILTER

`FILTER` permet d'appliquer une condition sp√©cifique √† une fonction d'agr√©gation :

```sql
SELECT
    COUNT(*) AS total_commandes,
    COUNT(*) FILTER (WHERE montant > 100) AS grosses_commandes,
    COUNT(*) FILTER (WHERE montant <= 100) AS petites_commandes,
    SUM(montant) FILTER (WHERE date_commande >= '2025-02-01') AS ventes_fevrier
FROM commandes;
```

C'est plus √©l√©gant que d'utiliser `CASE WHEN` :

```sql
-- √âquivalent avec CASE (moins lisible)
SELECT
    COUNT(*) AS total_commandes,
    COUNT(CASE WHEN montant > 100 THEN 1 END) AS grosses_commandes,
    SUM(CASE WHEN date_commande >= '2025-02-01' THEN montant ELSE 0 END) AS ventes_fevrier
FROM commandes;
```

### 2.10 Extensions de Groupement : ROLLUP, CUBE, GROUPING SETS

Ces extensions permettent de calculer des sous-totaux et totaux g√©n√©raux en une seule requ√™te.

#### ROLLUP : Sous-totaux Hi√©rarchiques

```sql
SELECT
    COALESCE(ville, 'TOTAL') AS ville,
    COALESCE(EXTRACT(MONTH FROM cmd.date_commande)::TEXT, 'Sous-total') AS mois,
    SUM(cmd.montant) AS total_ventes
FROM clients c
INNER JOIN commandes cmd ON c.id = cmd.client_id
GROUP BY ROLLUP (ville, EXTRACT(MONTH FROM cmd.date_commande))
ORDER BY ville NULLS LAST, mois NULLS LAST;
```

`ROLLUP(a, b)` g√©n√®re les groupements : `(a, b)`, `(a)`, `()`

#### CUBE : Toutes les Combinaisons

```sql
SELECT
    ville,
    EXTRACT(MONTH FROM cmd.date_commande) AS mois,
    SUM(cmd.montant) AS total_ventes
FROM clients c
INNER JOIN commandes cmd ON c.id = cmd.client_id
GROUP BY CUBE (ville, EXTRACT(MONTH FROM cmd.date_commande));
```

`CUBE(a, b)` g√©n√®re les groupements : `(a, b)`, `(a)`, `(b)`, `()`

#### GROUPING SETS : Groupements Personnalis√©s

```sql
SELECT
    ville,
    EXTRACT(YEAR FROM cmd.date_commande) AS annee,
    EXTRACT(MONTH FROM cmd.date_commande) AS mois,
    SUM(cmd.montant) AS total_ventes
FROM clients c
INNER JOIN commandes cmd ON c.id = cmd.client_id
GROUP BY GROUPING SETS (
    (ville, annee, mois),  -- D√©tail complet
    (ville, annee),         -- Par ville et ann√©e
    (annee, mois),          -- Par ann√©e et mois (toutes villes)
    ()                      -- Total g√©n√©ral
);
```

#### Identifier les Lignes de Sous-totaux : GROUPING()

```sql
SELECT
    CASE WHEN GROUPING(ville) = 1 THEN 'TOUTES' ELSE ville END AS ville,
    CASE WHEN GROUPING(mois) = 1 THEN 'TOUS' ELSE mois::TEXT END AS mois,
    SUM(montant) AS total
FROM ...
GROUP BY ROLLUP (ville, mois);
```

`GROUPING(colonne)` retourne 1 si la colonne est agr√©g√©e (ligne de sous-total), 0 sinon.

---

## Partie 3 : Indexation et Optimisation

Les index sont des structures de donn√©es qui acc√©l√®rent la recherche dans vos tables. Sans index appropri√©s, PostgreSQL doit parcourir chaque ligne (scan s√©quentiel), ce qui devient tr√®s lent sur de grandes tables.

### 3.1 Qu'est-ce qu'un Index ?

Un index est comparable √† l'index d'un livre : au lieu de lire toutes les pages pour trouver un sujet, vous consultez l'index qui vous indique directement la bonne page.

```
Sans index : Lecture de TOUTES les lignes (Seq Scan)
Avec index : Consultation de l'index ‚Üí Acc√®s direct aux lignes pertinentes
```

### 3.2 Types de Scans

PostgreSQL peut acc√©der aux donn√©es de diff√©rentes mani√®res :

| Type de Scan | Description | Quand utilis√© |
|--------------|-------------|---------------|
| **Seq Scan** | Lecture s√©quentielle de toute la table | Pas d'index ou grande partie de la table |
| **Index Scan** | Lecture de l'index puis de la table | Petite portion de la table |
| **Index Only Scan** | Lecture de l'index uniquement | Toutes les colonnes sont dans l'index |
| **Bitmap Scan** | Index ‚Üí Bitmap ‚Üí Table | Portion moyenne de la table |

### 3.3 Cr√©er un Index : Syntaxe de Base

```sql
-- Index simple
CREATE INDEX idx_clients_ville ON clients(ville);

-- Index avec nom automatique
CREATE INDEX ON clients(email);

-- Index unique (garantit l'unicit√© comme UNIQUE constraint)
CREATE UNIQUE INDEX idx_clients_email_unique ON clients(email);

-- Index sur plusieurs colonnes
CREATE INDEX idx_commandes_client_date ON commandes(client_id, date_commande);
```

### 3.4 L'Index B-Tree : Le D√©faut

Le B-Tree (Balanced Tree) est le type d'index par d√©faut. Il est efficace pour :

- Les comparaisons d'√©galit√© (`=`)
- Les comparaisons de plage (`<`, `>`, `<=`, `>=`, `BETWEEN`)
- Le tri (`ORDER BY`)
- Les recherches de pr√©fixe (`LIKE 'abc%'`)

```sql
-- Ces requ√™tes b√©n√©ficient d'un index B-Tree sur "ville"
SELECT * FROM clients WHERE ville = 'Paris';
SELECT * FROM clients WHERE ville > 'L' AND ville < 'P';
SELECT * FROM clients ORDER BY ville;
SELECT * FROM clients WHERE ville LIKE 'Par%';

-- Cette requ√™te NE b√©n√©ficie PAS de l'index B-Tree
SELECT * FROM clients WHERE ville LIKE '%aris';  -- Pr√©fixe inconnu
```

#### Index Multi-colonnes et Ordre

L'ordre des colonnes dans un index multi-colonnes est crucial :

```sql
CREATE INDEX idx_cmd_client_date ON commandes(client_id, date_commande);
```

Cet index est efficace pour :
- `WHERE client_id = 1`
- `WHERE client_id = 1 AND date_commande > '2025-01-01'`
- `ORDER BY client_id, date_commande`

Mais PAS pour :
- `WHERE date_commande > '2025-01-01'` (sans client_id)

> **R√®gle** : Un index multi-colonnes est utilisable pour les requ√™tes qui filtrent sur les **premi√®res** colonnes de l'index (pr√©fixe gauche).

### 3.5 PostgreSQL 18 : Skip Scan Optimization

PostgreSQL 18 introduit l'optimisation **Skip Scan** pour les index multi-colonnes :

```sql
-- Index sur (client_id, date_commande)
CREATE INDEX idx_cmd_client_date ON commandes(client_id, date_commande);

-- Avant PG 18 : Seq Scan (l'index n'est pas utilis√©)
-- Avec PG 18 : Skip Scan possible (parcourt l'index en "sautant" entre les valeurs de client_id)
SELECT * FROM commandes WHERE date_commande = '2025-01-15';
```

Cette optimisation am√©liore les performances quand la premi√®re colonne a peu de valeurs distinctes.

### 3.6 Index Sp√©cialis√©s

PostgreSQL offre plusieurs types d'index pour des cas d'usage sp√©cifiques :

#### Hash : √âgalit√© Stricte

```sql
CREATE INDEX idx_clients_email_hash ON clients USING hash(email);
```

Efficace uniquement pour les tests d'√©galit√© (`=`). Plus compact que B-Tree pour ce cas.

#### GIN : Donn√©es Composites (JSONB, Arrays, Full-Text)

```sql
-- Index GIN sur JSONB
CREATE INDEX idx_produits_specs ON produits USING gin(specifications);

-- Permet des requ√™tes comme :
SELECT * FROM produits WHERE specifications @> '{"couleur": "rouge"}';

-- Index GIN pour la recherche full-text
CREATE INDEX idx_articles_recherche ON articles USING gin(to_tsvector('french', contenu));
```

#### GiST : Donn√©es G√©om√©triques et Plages

```sql
-- Index GiST pour PostGIS
CREATE INDEX idx_lieux_geom ON lieux USING gist(geolocalisation);

-- Index GiST pour les plages de dates
CREATE INDEX idx_reservations_periode ON reservations USING gist(periode);
```

#### BRIN : Donn√©es S√©quentielles Massives

```sql
-- Tr√®s efficace pour les tables o√π les donn√©es arrivent dans l'ordre (logs, s√©ries temporelles)
CREATE INDEX idx_logs_date ON logs USING brin(date_creation);
```

BRIN est extr√™mement compact mais suppose une corr√©lation entre l'ordre physique et les valeurs.

### 3.7 Strat√©gies d'Indexation Avanc√©es

#### Index Partiel : Indexer un Sous-ensemble

```sql
-- Index seulement sur les commandes r√©centes
CREATE INDEX idx_commandes_recentes
ON commandes(client_id, date_commande)
WHERE date_commande >= '2024-01-01';

-- Index seulement sur les clients actifs
CREATE INDEX idx_clients_actifs
ON clients(email)
WHERE actif = TRUE;
```

Les index partiels sont plus petits et plus rapides √† maintenir.

#### Index sur Expression

```sql
-- Index sur une expression (fonction)
CREATE INDEX idx_clients_nom_lower ON clients(LOWER(nom));

-- Permet des requ√™tes insensibles √† la casse
SELECT * FROM clients WHERE LOWER(nom) = 'dupont';

-- Index sur extraction de date
CREATE INDEX idx_commandes_annee ON commandes(EXTRACT(YEAR FROM date_commande));
```

#### Covering Index (INCLUDE)

L'option `INCLUDE` ajoute des colonnes √† l'index sans les utiliser pour le tri. Cela permet des **Index Only Scans**.

```sql
-- L'index inclut l'email pour √©viter de lire la table
CREATE INDEX idx_clients_ville_covering
ON clients(ville)
INCLUDE (nom, email);

-- Cette requ√™te peut √™tre satisfaite uniquement par l'index
SELECT nom, email FROM clients WHERE ville = 'Paris';
```

### 3.8 EXPLAIN : Comprendre le Plan d'Ex√©cution

`EXPLAIN` est votre meilleur ami pour comprendre et optimiser les requ√™tes.

#### Syntaxe de Base

```sql
-- Plan estim√© (sans ex√©cution)
EXPLAIN SELECT * FROM clients WHERE ville = 'Paris';

-- Plan r√©el avec statistiques d'ex√©cution
EXPLAIN ANALYZE SELECT * FROM clients WHERE ville = 'Paris';

-- Options compl√®tes
EXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT)
SELECT * FROM clients WHERE ville = 'Paris';
```

#### Lire un Plan d'Ex√©cution

```sql
EXPLAIN ANALYZE SELECT * FROM clients WHERE ville = 'Paris';
```

**R√©sultat** :

```
Seq Scan on clients  (cost=0.00..1.05 rows=1 width=236) (actual time=0.015..0.016 rows=2 loops=1)
  Filter: ((ville)::text = 'Paris'::text)
  Rows Removed by Filter: 2
Planning Time: 0.080 ms
Execution Time: 0.035 ms
```

D√©cryptage :
- **Seq Scan** : Type d'op√©ration (scan s√©quentiel)
- **cost=0.00..1.05** : Co√ªt estim√© (d√©marrage..total)
- **rows=1** : Nombre de lignes estim√©es
- **actual time** : Temps r√©el en millisecondes
- **rows=2** : Nombre r√©el de lignes retourn√©es
- **loops=1** : Nombre d'ex√©cutions de ce n≈ìud
- **Rows Removed by Filter** : Lignes lues mais non retenues

#### PostgreSQL 18 : Am√©liorations d'EXPLAIN

PostgreSQL 18 affiche automatiquement les statistiques de buffers avec `EXPLAIN ANALYZE`, sans avoir √† sp√©cifier `BUFFERS` :

```sql
EXPLAIN ANALYZE SELECT * FROM clients WHERE ville = 'Paris';
```

Affiche maintenant directement :
```
Seq Scan on clients  (...)
  Buffers: shared hit=1
```

#### Interpr√©ter les Diff√©rents Types de Scans

```sql
-- Seq Scan (pas d'index utilis√©)
Seq Scan on clients  (cost=0.00..1.05 rows=1 width=236)

-- Index Scan (index utilis√©, puis lecture de la table)
Index Scan using idx_clients_ville on clients  (cost=0.13..8.15 rows=1 width=236)
  Index Cond: ((ville)::text = 'Paris'::text)

-- Index Only Scan (lecture de l'index uniquement)
Index Only Scan using idx_clients_ville_covering on clients  (cost=0.13..4.15 rows=1 width=236)
  Index Cond: (ville = 'Paris'::text)

-- Bitmap Index Scan + Bitmap Heap Scan
Bitmap Heap Scan on clients  (cost=4.18..13.65 rows=3 width=236)
  Recheck Cond: (ville = 'Paris'::text)
  ->  Bitmap Index Scan on idx_clients_ville  (cost=0.00..4.18 rows=3 width=0)
        Index Cond: (ville = 'Paris'::text)
```

### 3.9 Statistiques et le Planificateur

PostgreSQL utilise des statistiques sur vos donn√©es pour choisir le meilleur plan d'ex√©cution.

#### Mettre √† Jour les Statistiques

```sql
-- Mettre √† jour les statistiques d'une table
ANALYZE clients;

-- Mettre √† jour les statistiques de toute la base
ANALYZE;
```

`ANALYZE` est ex√©cut√© automatiquement par l'autovacuum, mais vous pouvez le lancer manuellement apr√®s des modifications massives.

#### Consulter les Statistiques

```sql
-- Statistiques sur les colonnes
SELECT
    attname AS colonne,
    n_distinct AS valeurs_distinctes,
    null_frac AS proportion_null,
    avg_width AS largeur_moyenne
FROM pg_stats
WHERE tablename = 'clients';
```

### 3.10 PostgreSQL 18 : Optimisations du Planificateur

PostgreSQL 18 apporte plusieurs am√©liorations automatiques :

#### Auto-√©limination des Self-Joins Inutiles

```sql
-- Le planificateur d√©tecte que cette jointure est inutile
SELECT c1.nom
FROM clients c1
INNER JOIN clients c2 ON c1.id = c2.id
WHERE c2.ville = 'Paris';

-- Optimis√© automatiquement en :
SELECT nom FROM clients WHERE ville = 'Paris';
```

#### Optimisation IN (VALUES) vers ANY

```sql
-- Cette syntaxe...
SELECT * FROM clients WHERE id IN (VALUES (1), (2), (3));

-- Est automatiquement optimis√©e en :
SELECT * FROM clients WHERE id = ANY(ARRAY[1, 2, 3]);
```

#### R√©organisation des Colonnes DISTINCT

Le planificateur r√©organise automatiquement les colonnes dans `DISTINCT` pour une meilleure utilisation des index.

### 3.11 Maintenance des Index

Les index doivent √™tre maintenus pour rester efficaces.

#### REINDEX : Reconstruire un Index

```sql
-- Reconstruire un index sp√©cifique
REINDEX INDEX idx_clients_ville;

-- Reconstruire tous les index d'une table
REINDEX TABLE clients;

-- Reconstruire sans verrouillage exclusif (PostgreSQL 12+)
REINDEX INDEX CONCURRENTLY idx_clients_ville;
```

#### Identifier les Index Inutilis√©s

```sql
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan AS nombre_utilisations,
    pg_size_pretty(pg_relation_size(indexrelid)) AS taille
FROM pg_stat_user_indexes
WHERE idx_scan = 0  -- Index jamais utilis√©s
ORDER BY pg_relation_size(indexrelid) DESC;
```

#### Index Dupliqu√©s ou Redondants

```sql
-- Trouver les index potentiellement redondants
SELECT
    a.indexrelid::regclass AS index_potentiellement_inutile,
    b.indexrelid::regclass AS index_englobant
FROM pg_index a
JOIN pg_index b ON a.indrelid = b.indrelid
WHERE a.indexrelid != b.indexrelid
  AND a.indkey::text = ANY(string_to_array(b.indkey::text, ' '));
```

### 3.12 Bonnes Pratiques d'Indexation

1. **Indexez les cl√©s √©trang√®res** : PostgreSQL ne le fait pas automatiquement

```sql
-- Apr√®s avoir cr√©√© une FK
ALTER TABLE commandes ADD CONSTRAINT fk_client
    FOREIGN KEY (client_id) REFERENCES clients(id);

-- Cr√©ez l'index manuellement
CREATE INDEX idx_commandes_client_id ON commandes(client_id);
```

2. **Indexez les colonnes WHERE fr√©quentes** : Analysez vos requ√™tes les plus courantes

3. **√âvitez la sur-indexation** : Chaque index ralentit les INSERT/UPDATE/DELETE

4. **Utilisez des index partiels** quand vous filtrez souvent sur une condition

5. **Surveillez la taille et l'usage** : Supprimez les index inutilis√©s

6. **Utilisez EXPLAIN r√©guli√®rement** : V√©rifiez que vos index sont utilis√©s

### 3.13 Tableau R√©capitulatif des Index

| Type | Op√©rateurs Support√©s | Cas d'Usage |
|------|---------------------|-------------|
| B-Tree | `<`, `<=`, `=`, `>=`, `>`, `BETWEEN`, `IN`, `LIKE 'prefix%'` | Usage g√©n√©ral, cl√©s primaires |
| Hash | `=` | √âgalit√© stricte uniquement |
| GIN | `@>`, `<@`, `?`, `?&`, `?\|`, `@@` | JSONB, arrays, full-text |
| GiST | `<<`, `&<`, `&>`, `>>`, `@>`, `<@`, `~=`, `&&` | G√©om√©trie, plages, ltree |
| BRIN | `<`, `<=`, `=`, `>=`, `>` | Donn√©es s√©quentielles massives |
| SP-GiST | D√©pend du type | Arbres d√©s√©quilibr√©s, points |

---

## R√©sum√©

Ce chapitre interm√©diaire vous a pr√©sent√© trois piliers essentiels :

| Concept | Ce qu'il faut retenir |
|---------|----------------------|
| **Jointures** | INNER, LEFT, RIGHT, FULL, CROSS, LATERAL pour combiner les tables |
| **Agr√©gation** | COUNT, SUM, AVG, GROUP BY, HAVING, FILTER, ROLLUP, CUBE |
| **Indexation** | B-Tree, GIN, GiST, BRIN, index partiels, EXPLAIN pour optimiser |

### Points Cl√©s

- **Jointures** : Pr√©f√©rez INNER JOIN sauf besoin sp√©cifique, indexez les cl√©s √©trang√®res
- **Agr√©gation** : Toute colonne non agr√©g√©e doit √™tre dans GROUP BY, utilisez FILTER pour des conditions sp√©cifiques
- **Index** : Analysez vos requ√™tes avec EXPLAIN, √©vitez la sur-indexation, maintenez vos statistiques √† jour

### Prochaines √âtapes

Une fois ces concepts ma√Ætris√©s, vous pourrez explorer :

- Les **fonctions de fen√™trage** (Window Functions) pour des analyses avanc√©es
- Le **MVCC** et la gestion des transactions concurrentes
- La **r√©plication** et la haute disponibilit√©
- L'**optimisation avanc√©e** avec pg_stat_statements et le tuning

---


‚è≠Ô∏è [Avanc√© : MVCC, R√©plication, Optimisation, Production](/21-conclusion-et-perspectives/01.3-niveau-avance.md)
