ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 21.3.3. OAuth et SÃ©curitÃ© Moderne

## Introduction

PostgreSQL 18 marque un tournant majeur dans la sÃ©curitÃ© des bases de donnÃ©es en introduisant le support natif de **OAuth 2.0** et en renforÃ§ant l'ensemble de son architecture de sÃ©curitÃ©. Ces amÃ©liorations permettent Ã  PostgreSQL de s'intÃ©grer aux systÃ¨mes d'authentification modernes utilisÃ©s par les entreprises.

Cette section prÃ©sente les nouveautÃ©s en matiÃ¨re de sÃ©curitÃ© de PostgreSQL 18 de maniÃ¨re accessible, mÃªme si vous n'Ãªtes pas expert en sÃ©curitÃ© informatique.

---

## Les Concepts Fondamentaux de la SÃ©curitÃ©

Avant d'explorer les nouveautÃ©s, clarifions quelques concepts essentiels.

### Authentification vs Autorisation

Ces deux termes sont souvent confondus, mais dÃ©signent des processus distincts :

| Concept | Question PosÃ©e | Exemple |
|---------|----------------|---------|
| **Authentification** | "Qui Ãªtes-vous ?" | VÃ©rifier l'identitÃ© avec un mot de passe |
| **Autorisation** | "Qu'avez-vous le droit de faire ?" | VÃ©rifier les permissions sur une table |

PostgreSQL gÃ¨re ces deux aspects :
- **Authentification** : ConfigurÃ©e dans `pg_hba.conf`
- **Autorisation** : GÃ©rÃ©e par les rÃ´les et les privilÃ¨ges (`GRANT`/`REVOKE`)

### Les MÃ©thodes d'Authentification Traditionnelles

Historiquement, PostgreSQL proposait plusieurs mÃ©thodes :

| MÃ©thode | Description | SÃ©curitÃ© |
|---------|-------------|----------|
| `trust` | Aucune vÃ©rification | âŒ Aucune |
| `password` | Mot de passe en clair | âŒ TrÃ¨s faible |
| `md5` | Mot de passe hachÃ© en MD5 | âš ï¸ ObsolÃ¨te |
| `scram-sha-256` | Protocole challenge-response moderne | âœ… Forte |
| `cert` | Certificat SSL client | âœ… TrÃ¨s forte |
| `ldap` | Annuaire d'entreprise | âœ… Bonne |
| `oauth` | **Nouveau PG 18** â€” Tokens OAuth 2.0 | âœ… Moderne |

---

# Partie 1 : OAuth 2.0 â€” L'Authentification Moderne

## Qu'est-ce que OAuth 2.0 ?

### Une Analogie Simple

Imaginez que vous souhaitez entrer dans un immeuble de bureaux sÃ©curisÃ© :

**MÃ©thode traditionnelle (mot de passe) :**
1. Vous donnez votre nom et un code secret au gardien
2. Le gardien vÃ©rifie dans sa liste
3. Si le code correspond, vous entrez

**MÃ©thode OAuth 2.0 :**
1. Vous vous Ãªtes dÃ©jÃ  identifiÃ© auprÃ¨s du service de sÃ©curitÃ© central de l'entreprise
2. Ce service vous a donnÃ© un **badge temporaire** (le token)
3. Vous prÃ©sentez ce badge au gardien de l'immeuble
4. Le gardien vÃ©rifie que le badge est valide auprÃ¨s du service central
5. Si c'est bon, vous entrez

### Les Avantages de OAuth

| Avantage | Explication |
|----------|-------------|
| **Centralisation** | Un seul systÃ¨me gÃ¨re toutes les identitÃ©s |
| **Single Sign-On (SSO)** | Une seule connexion pour tous les services |
| **Tokens temporaires** | Plus sÃ»rs que des mots de passe permanents |
| **RÃ©vocation facile** | Un token compromis peut Ãªtre annulÃ© instantanÃ©ment |
| **Pas de mots de passe partagÃ©s** | La base de donnÃ©es ne stocke jamais votre mot de passe |

### Le Vocabulaire OAuth

Comprendre OAuth nÃ©cessite de connaÃ®tre quelques termes :

| Terme | Description | Exemple |
|-------|-------------|---------|
| **Resource Owner** | L'utilisateur qui possÃ¨de les droits | Vous, le dÃ©veloppeur |
| **Client** | L'application qui veut accÃ©der | psql, votre application |
| **Authorization Server** | Le serveur qui dÃ©livre les tokens | Google, Azure AD, Keycloak |
| **Resource Server** | Le service protÃ©gÃ© | PostgreSQL (votre base de donnÃ©es) |
| **Identity Provider (IdP)** | Le fournisseur d'identitÃ© | Google, Microsoft, Okta |
| **Bearer Token** | Le "badge" d'accÃ¨s temporaire | Une chaÃ®ne de caractÃ¨res opaque |
| **Issuer** | L'Ã©metteur du token | URL du fournisseur OAuth |

---

## OAuth 2.0 dans PostgreSQL 18

### Comment Ã‡a Fonctionne

PostgreSQL 18 agit comme un **Resource Server** : il ne dÃ©livre pas de tokens, mais il peut les **valider**.

Le flux d'authentification se dÃ©roule ainsi :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     1. Demande de token        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Client    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚  Authorization   â”‚
â”‚   (psql)    â”‚                                â”‚     Server       â”‚
â”‚             â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚  (Google, etc.)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     2. ReÃ§oit le token         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ 3. Connexion avec le token
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     4. Valide le token         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PostgreSQL â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚    Validator     â”‚
â”‚   (serveur) â”‚                                â”‚     Module       â”‚
â”‚             â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     5. Token OK/KO             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ 6. Connexion acceptÃ©e ou refusÃ©e
       â–¼
   [AccÃ¨s Ã  la base de donnÃ©es]
```

### Les Deux Modes de Connexion

PostgreSQL 18 supporte deux faÃ§ons de s'authentifier avec OAuth :

**Mode 1 : Token prÃ©-obtenu**
- L'application obtient le token en dehors de PostgreSQL
- Elle envoie directement le token lors de la connexion
- IdÃ©al pour les applications serveur et les scripts automatisÃ©s

**Mode 2 : Device Authorization Flow**
- Le client (psql) initie le flux OAuth
- Un navigateur s'ouvre pour l'authentification
- L'utilisateur se connecte sur le site du fournisseur
- Le client rÃ©cupÃ¨re le token automatiquement
- IdÃ©al pour les outils interactifs comme psql

### Configuration CÃ´tÃ© Serveur

#### PrÃ©requis

Pour utiliser OAuth, PostgreSQL doit Ãªtre compilÃ© avec :
- Support OpenSSL (`--with-openssl`)
- Support libcurl (`--with-libcurl`)

#### Ã‰tape 1 : Configurer postgresql.conf

```ini
# Activer les modules de validation OAuth
oauth_validator_libraries = 'mon_validateur'
```

Le paramÃ¨tre `oauth_validator_libraries` liste les bibliothÃ¨ques qui savent valider les tokens de votre fournisseur OAuth.

#### Ã‰tape 2 : Configurer pg_hba.conf

Le fichier `pg_hba.conf` contrÃ´le qui peut se connecter et comment :

```
# TYPE   DATABASE   USER        ADDRESS         METHOD    OPTIONS
host     myapp      all         0.0.0.0/0       oauth     issuer="https://accounts.google.com" scope="openid profile"
```

Les paramÃ¨tres OAuth dans pg_hba.conf :

| ParamÃ¨tre | Description | Obligatoire |
|-----------|-------------|-------------|
| `issuer` | URL du fournisseur OAuth | Oui |
| `scope` | Scopes OAuth requis | Oui |
| `validator` | Module de validation Ã  utiliser | Si plusieurs modules |
| `map` | Mapping des identitÃ©s (pg_ident.conf) | Non |

#### Ã‰tape 3 : Mapping des IdentitÃ©s (Optionnel)

Le fichier `pg_ident.conf` permet de faire correspondre les identitÃ©s OAuth aux rÃ´les PostgreSQL :

```
# MAPNAME       SYSTEM-USERNAME              PG-USERNAME
oauth_map       alice@example.com            alice
oauth_map       bob@example.com              bob
oauth_map       /^(.*)@example\.com$         \1
```

La derniÃ¨re ligne utilise une expression rÃ©guliÃ¨re pour mapper automatiquement tous les utilisateurs du domaine `example.com`.

### Exemple Complet de Configuration

**postgresql.conf :**
```ini
# Module de validation OAuth
oauth_validator_libraries = 'oauth_validator_google'

# TLS obligatoire pour OAuth
ssl = on
ssl_cert_file = '/etc/postgresql/server.crt'
ssl_key_file = '/etc/postgresql/server.key'
```

**pg_hba.conf :**
```
# Connexions OAuth pour l'application "production"
hostssl    production    all    0.0.0.0/0    oauth    issuer="https://accounts.google.com" scope="openid email" map=google_map

# Fallback SCRAM pour les anciens clients
hostssl    production    all    0.0.0.0/0    scram-sha-256
```

**pg_ident.conf :**
```
# Mapping Google vers rÃ´les PostgreSQL
google_map    alice@mycompany.com     app_admin
google_map    /^(.*)@mycompany\.com$  app_user
```

### Cas d'Usage Typiques

#### SSO d'Entreprise

IntÃ©gration avec Azure AD, Okta, ou un autre IdP d'entreprise :

```
# pg_hba.conf
hostssl  all  all  10.0.0.0/8  oauth  issuer="https://login.microsoftonline.com/tenant-id/v2.0" scope="openid profile"
```

Avantages :
- Les employÃ©s utilisent leurs identifiants d'entreprise
- RÃ©vocation automatique quand un employÃ© quitte l'entreprise
- Audit centralisÃ© des accÃ¨s

#### Applications Cloud-Native

Pour des microservices qui accÃ¨dent Ã  PostgreSQL :

```
# pg_hba.conf
hostssl  orders_db  order_service  0.0.0.0/0  oauth  issuer="https://auth.mycompany.com" scope="database:orders:read"
```

Avantages :
- Chaque service a son propre token avec des scopes limitÃ©s
- Rotation automatique des credentials
- Pas de secrets stockÃ©s dans les configurations

---

# Partie 2 : DÃ©prÃ©ciation de MD5 et Migration vers SCRAM

## Pourquoi MD5 Est ObsolÃ¨te

### Les Faiblesses de MD5

L'algorithme MD5 (Message Digest 5) a Ã©tÃ© conÃ§u en 1991. Depuis, de nombreuses failles ont Ã©tÃ© dÃ©couvertes :

| ProblÃ¨me | Explication |
|----------|-------------|
| **Collisions** | Deux entrÃ©es diffÃ©rentes peuvent produire le mÃªme hash |
| **Vitesse** | Trop rapide, facilitant les attaques par force brute |
| **Rainbow Tables** | Des tables prÃ©-calculÃ©es existent pour casser les hash MD5 |
| **Pas de sel (salt)** | Le hash est toujours le mÃªme pour un mot de passe donnÃ© |

### Ce Qui Change dans PostgreSQL 18

PostgreSQL 18 **dÃ©prÃ©cie officiellement** l'authentification MD5 :

- âš ï¸ MD5 fonctionne encore, mais gÃ©nÃ¨re des avertissements
- âš ï¸ MD5 sera **supprimÃ©** dans une future version majeure
- âœ… SCRAM-SHA-256 est maintenant la mÃ©thode recommandÃ©e

## SCRAM-SHA-256 : Le Remplacement

### Comment Fonctionne SCRAM

**SCRAM** (Salted Challenge Response Authentication Mechanism) est dÃ©fini dans la RFC 7677. Son fonctionnement est plus sophistiquÃ© :

```
Client                                    Serveur
   â”‚                                         â”‚
   â”‚  1. "Je veux me connecter"              â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚
   â”‚                                         â”‚
   â”‚  2. "Voici un dÃ©fi (salt + iterations)" â”‚
   â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚                                         â”‚
   â”‚  3. Calcul local avec le mot de passe   â”‚
   â”‚     + salt + itÃ©rations                 â”‚
   â”‚                                         â”‚
   â”‚  4. "Voici ma preuve"                   â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚
   â”‚                                         â”‚
   â”‚  5. VÃ©rification cÃ´tÃ© serveur           â”‚
   â”‚                                         â”‚
   â”‚  6. "OK, vous Ãªtes authentifiÃ©"         â”‚
   â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
```

### Avantages de SCRAM sur MD5

| Aspect | MD5 | SCRAM-SHA-256 |
|--------|-----|---------------|
| **Algorithme de hash** | MD5 (obsolÃ¨te) | SHA-256 (moderne) |
| **Sel (salt)** | Fixe (nom d'utilisateur) | AlÃ©atoire par utilisateur |
| **ItÃ©rations** | 1 | Configurable (4096 par dÃ©faut) |
| **Protection contre interception** | Partielle | ComplÃ¨te |
| **Attaque par rejeu** | Possible | Impossible |
| **Channel Binding** | Non | Oui (avec TLS) |

### Channel Binding : Protection SupplÃ©mentaire

SCRAM-SHA-256 supporte le **channel binding** (SCRAM-SHA-256-PLUS), qui lie l'authentification au certificat TLS du serveur :

- EmpÃªche les attaques "man-in-the-middle"
- Le token d'authentification est liÃ© Ã  la connexion TLS spÃ©cifique
- Un attaquant ne peut pas rÃ©utiliser les donnÃ©es d'authentification capturÃ©es

## Migration de MD5 vers SCRAM

### Ã‰tape 1 : VÃ©rifier les Clients

Avant de migrer, assurez-vous que tous vos clients supportent SCRAM :

- **libpq** : Version 10+ requise
- **psycopg2/psycopg3** : Versions rÃ©centes
- **JDBC** : Driver PostgreSQL 42.2.0+
- **node-postgres** : Version 7.0+
- **npgsql** : Version 4.0+

### Ã‰tape 2 : VÃ©rifier l'Ã‰tat Actuel des Mots de Passe

```sql
-- Voir quels utilisateurs ont encore des mots de passe MD5
SELECT
    rolname,
    CASE
        WHEN rolpassword LIKE 'md5%' THEN 'MD5 (Ã  migrer)'
        WHEN rolpassword LIKE 'SCRAM-SHA-256$%' THEN 'SCRAM (OK)'
        ELSE 'Autre/Aucun'
    END AS password_type
FROM pg_authid
WHERE rolcanlogin;
```

### Ã‰tape 3 : Configurer le Chiffrement des Nouveaux Mots de Passe

Dans `postgresql.conf` :

```ini
# Utiliser SCRAM pour tous les nouveaux mots de passe
password_encryption = scram-sha-256
```

Puis recharger la configuration :

```sql
SELECT pg_reload_conf();
```

### Ã‰tape 4 : RÃ©initialiser les Mots de Passe des Utilisateurs

Chaque utilisateur doit dÃ©finir un nouveau mot de passe pour qu'il soit hachÃ© en SCRAM :

```sql
-- En tant qu'administrateur
ALTER USER alice PASSWORD 'nouveau_mot_de_passe';

-- Ou l'utilisateur peut le faire lui-mÃªme
\password
```

### Ã‰tape 5 : Mettre Ã  Jour pg_hba.conf

Remplacer `md5` par `scram-sha-256` :

```
# Avant (obsolÃ¨te)
host    all    all    0.0.0.0/0    md5

# AprÃ¨s (recommandÃ©)
host    all    all    0.0.0.0/0    scram-sha-256
```

### CompatibilitÃ© Automatique

PostgreSQL offre une fonctionnalitÃ© de transition : si vous gardez `md5` dans pg_hba.conf mais qu'un utilisateur a un mot de passe SCRAM, PostgreSQL utilisera automatiquement SCRAM.

Cela permet une migration progressive, utilisateur par utilisateur.

---

# Partie 3 : TLS 1.3 et Chiffrement des Connexions

## NouveautÃ©s TLS dans PostgreSQL 18

### Le ParamÃ¨tre ssl_tls13_ciphers

PostgreSQL 18 introduit un nouveau paramÃ¨tre pour contrÃ´ler prÃ©cisÃ©ment les suites de chiffrement TLS 1.3 :

```ini
# postgresql.conf

# Activer TLS
ssl = on

# Versions TLS autorisÃ©es
ssl_min_protocol_version = 'TLSv1.2'
ssl_max_protocol_version = 'TLSv1.3'

# Suites de chiffrement TLS 1.2 (paramÃ¨tre existant)
ssl_ciphers = 'HIGH:!aNULL:!MD5'

# NOUVEAU PG 18 : Suites de chiffrement TLS 1.3
ssl_tls13_ciphers = 'TLS_AES_256_GCM_SHA384:TLS_AES_128_GCM_SHA256'
```

### Suites de Chiffrement TLS 1.3 RecommandÃ©es

| Suite | Algorithme | SÃ©curitÃ© |
|-------|------------|----------|
| `TLS_AES_256_GCM_SHA384` | AES 256 bits + SHA-384 | âœ… TrÃ¨s forte |
| `TLS_AES_128_GCM_SHA256` | AES 128 bits + SHA-256 | âœ… Forte |
| `TLS_CHACHA20_POLY1305_SHA256` | ChaCha20 + Poly1305 | âœ… Forte (optimisÃ© mobile) |

### VÃ©rifier la Configuration TLS

AprÃ¨s connexion, vous pouvez vÃ©rifier les paramÃ¨tres TLS :

```sql
-- Avec psql
\conninfo

-- RÃ©sultat (extrait) :
-- SSL Connection     | true
-- SSL Protocol       | TLSv1.3
-- SSL Cipher         | TLS_AES_256_GCM_SHA384
```

Ou via une requÃªte :

```sql
SELECT * FROM pg_stat_ssl WHERE pid = pg_backend_pid();
```

## Mode FIPS dans PostgreSQL 18

### Qu'est-ce que FIPS ?

**FIPS 140-2** (Federal Information Processing Standards) est une norme amÃ©ricaine qui dÃ©finit les exigences de sÃ©curitÃ© pour les modules cryptographiques. Certaines organisations (gouvernement, finance, santÃ©) doivent utiliser des systÃ¨mes conformes FIPS.

### Support FIPS dans PostgreSQL 18

PostgreSQL 18 amÃ©liore la validation du mode FIPS :

- **DÃ©tection automatique** : PostgreSQL dÃ©tecte si OpenSSL est en mode FIPS
- **Tests validÃ©s** : Toutes les suites de tests PostgreSQL passent en mode FIPS
- **MD5 bloquÃ©** : En mode FIPS, MD5 est automatiquement dÃ©sactivÃ© (car non approuvÃ© FIPS)

### Implications Pratiques

Si vous activez le mode FIPS dans OpenSSL :

```bash
# VÃ©rifier si FIPS est activÃ© (cÃ´tÃ© systÃ¨me)
openssl version -a | grep FIPS
```

Alors dans PostgreSQL :
- âŒ L'authentification MD5 Ã©chouera
- âŒ Les fonctions pgcrypto utilisant MD5 Ã©choueront
- âœ… SCRAM-SHA-256 fonctionnera normalement
- âœ… TLS avec suites approuvÃ©es FIPS fonctionnera

### ParamÃ¨tre builtin_crypto_enabled

PostgreSQL 18 ajoute ce paramÃ¨tre dans pgcrypto :

```sql
-- DÃ©sactiver les fonctions crypto non-FIPS
SET pgcrypto.builtin_crypto_enabled = off;
```

Cela garantit que seules les fonctions cryptographiques approuvÃ©es FIPS sont utilisables.

---

# Partie 4 : Autres AmÃ©liorations de SÃ©curitÃ©

## SCRAM Passthrough avec postgres_fdw et dblink

### Le ProblÃ¨me PrÃ©cÃ©dent

Avant PostgreSQL 18, lors de connexions Ã  des serveurs distants via `postgres_fdw` ou `dblink`, l'authentification SCRAM ne fonctionnait pas correctement car le serveur intermÃ©diaire ne pouvait pas transmettre les credentials SCRAM.

### La Solution PostgreSQL 18

PostgreSQL 18 supporte le **SCRAM passthrough** :

```sql
-- CrÃ©ation d'un serveur distant avec authentification SCRAM
CREATE SERVER serveur_distant
    FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (host 'remote.example.com', dbname 'production');

-- Mapping d'utilisateur avec transmission SCRAM
CREATE USER MAPPING FOR utilisateur_local
    SERVER serveur_distant
    OPTIONS (user 'utilisateur_distant', password 'mot_de_passe');
```

Le flux SCRAM est maintenant correctement transmis au serveur distant, permettant une authentification sÃ©curisÃ©e de bout en bout.

## Data Checksums ActivÃ©s par DÃ©faut

### Changement Important

Dans PostgreSQL 18, les **checksums de donnÃ©es** sont **activÃ©s par dÃ©faut** lors de l'initialisation d'un nouveau cluster :

```bash
# PostgreSQL 18 : checksums activÃ©s par dÃ©faut
initdb --pgdata=/var/lib/postgresql/18/main

# Pour dÃ©sactiver explicitement (non recommandÃ©)
initdb --pgdata=/var/lib/postgresql/18/main --no-data-checksums
```

### Pourquoi C'est Important

Les checksums dÃ©tectent la **corruption silencieuse** des donnÃ©es :

- Erreurs matÃ©rielles (disques, mÃ©moire)
- Bugs de firmware
- Corruption lors de transferts rÃ©seau

Sans checksums, PostgreSQL pourrait lire et retourner des donnÃ©es corrompues sans s'en apercevoir.

### VÃ©rifier l'Ã‰tat des Checksums

```sql
SHOW data_checksums;
-- RÃ©sultat : on (si activÃ©s)
```

## SHA-2 dans pgcrypto

PostgreSQL 18 amÃ©liore l'extension pgcrypto avec le support de **SHA-2 pour le hachage des mots de passe** :

```sql
-- Hacher un mot de passe avec SHA-512 (plus sÃ©curisÃ© que MD5)
SELECT crypt('mon_mot_de_passe', gen_salt('sha512'));
```

Les algorithmes disponibles :
- `bf` : Blowfish (recommandÃ© pour les mots de passe)
- `sha256` : SHA-256
- `sha512` : SHA-512
- `md5` : MD5 (dÃ©prÃ©ciÃ©, Ã©viter)

---

# Partie 5 : Bonnes Pratiques de SÃ©curitÃ©

## Checklist de SÃ©curitÃ© PostgreSQL 18

### Configuration de Base

```ini
# postgresql.conf

# 1. Forcer les connexions chiffrÃ©es
ssl = on
ssl_min_protocol_version = 'TLSv1.2'
ssl_prefer_server_ciphers = on

# 2. Utiliser SCRAM pour les mots de passe
password_encryption = scram-sha-256

# 3. Journalisation des connexions
log_connections = on
log_disconnections = on

# 4. Limiter les connexions superutilisateur
superuser_reserved_connections = 3
```

### Configuration pg_hba.conf SÃ©curisÃ©e

```
# TYPE   DATABASE        USER            ADDRESS                 METHOD

# Connexions locales (socket Unix)
local   all             postgres                                peer

# Rejeter les connexions en clair
hostnossl  all          all             0.0.0.0/0               reject

# OAuth pour les applications modernes
hostssl    app_db       app_users       10.0.0.0/8              oauth     issuer="..."

# SCRAM pour les connexions traditionnelles
hostssl    all          all             10.0.0.0/8              scram-sha-256

# Tout le reste est rejetÃ© implicitement
```

### Principes de SÃ©curitÃ©

| Principe | Application |
|----------|-------------|
| **Moindre privilÃ¨ge** | N'accordez que les droits nÃ©cessaires |
| **DÃ©fense en profondeur** | Combinez plusieurs mÃ©canismes (TLS + Auth + RLS) |
| **Rotation des secrets** | Changez rÃ©guliÃ¨rement les mots de passe/tokens |
| **Audit** | Journalisez les accÃ¨s et les modifications |
| **SÃ©paration des environnements** | Production â‰  DÃ©veloppement |

## Comparatif des MÃ©thodes d'Authentification

| MÃ©thode | SÃ©curitÃ© | FacilitÃ© | Cas d'Usage |
|---------|----------|----------|-------------|
| `trust` | âŒ Aucune | âœ… TrÃ¨s facile | DÃ©veloppement local uniquement |
| `md5` | âš ï¸ Faible | âœ… Facile | **DÃ©prÃ©ciÃ©** â€” Ã€ Ã©viter |
| `scram-sha-256` | âœ… Forte | âœ… Facile | Applications traditionnelles |
| `cert` | âœ… TrÃ¨s forte | âš ï¸ Complexe | Services automatisÃ©s, IoT |
| `oauth` | âœ… Moderne | âš ï¸ Complexe | SSO entreprise, Cloud |
| `ldap` | âœ… Bonne | âš ï¸ Moyenne | IntÃ©gration Active Directory |

---

## RÃ©sumÃ© des NouveautÃ©s SÃ©curitÃ© PostgreSQL 18

### OAuth 2.0

| Aspect | Description |
|--------|-------------|
| **Fonction** | Authentification par tokens OAuth 2.0 |
| **Configuration** | `pg_hba.conf` avec mÃ©thode `oauth` |
| **Validateurs** | Modules externes via `oauth_validator_libraries` |
| **Cas d'usage** | SSO, intÃ©gration IdP entreprise |

### DÃ©prÃ©ciation MD5

| Aspect | Description |
|--------|-------------|
| **Statut** | DÃ©prÃ©ciÃ©, sera supprimÃ© dans une future version |
| **Alternative** | SCRAM-SHA-256 |
| **Migration** | RÃ©initialiser les mots de passe aprÃ¨s configuration |

### TLS 1.3

| Aspect | Description |
|--------|-------------|
| **Nouveau paramÃ¨tre** | `ssl_tls13_ciphers` |
| **Fonction** | ContrÃ´le prÃ©cis des suites de chiffrement TLS 1.3 |
| **Recommandation** | Utiliser `TLS_AES_256_GCM_SHA384` |

### Autres AmÃ©liorations

| FonctionnalitÃ© | Description |
|----------------|-------------|
| **SCRAM Passthrough** | Authentification SCRAM via postgres_fdw/dblink |
| **Data Checksums** | ActivÃ©s par dÃ©faut (dÃ©tection de corruption) |
| **Mode FIPS** | Meilleure validation et support |
| **SHA-2 pgcrypto** | Hachage de mots de passe plus sÃ©curisÃ© |

---

## Conclusion

PostgreSQL 18 reprÃ©sente une avancÃ©e significative en matiÃ¨re de sÃ©curitÃ© :

1. **OAuth 2.0** permet l'intÃ©gration avec les systÃ¨mes d'authentification modernes et le SSO d'entreprise

2. **La dÃ©prÃ©ciation de MD5** encourage la migration vers des mÃ©thodes plus sÃ»res comme SCRAM-SHA-256

3. **Le contrÃ´le TLS 1.3** offre une flexibilitÃ© accrue pour les environnements Ã  haute sÃ©curitÃ©

4. **Les checksums par dÃ©faut** protÃ¨gent contre la corruption silencieuse des donnÃ©es

Ces amÃ©liorations positionnent PostgreSQL comme une base de donnÃ©es adaptÃ©e aux exigences de sÃ©curitÃ© modernes, que ce soit pour les startups cloud-native ou les grandes entreprises soumises Ã  des rÃ©glementations strictes.

---


â­ï¸ [Upgrade simplifiÃ© avec prÃ©servation statistiques](/21-conclusion-et-perspectives/03.4-upgrade-simplifie.md)
