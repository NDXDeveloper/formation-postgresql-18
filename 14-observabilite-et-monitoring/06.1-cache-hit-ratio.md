ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 14.6.1. Cache Hit Ratio (Buffer Cache)

## Introduction

Le **Cache Hit Ratio** (taux de succÃ¨s du cache) est l'une des mÃ©triques les plus importantes pour Ã©valuer la performance de votre base de donnÃ©es PostgreSQL. C'est un indicateur qui vous permet de savoir si votre base de donnÃ©es utilise efficacement la mÃ©moire disponible.

Dans ce chapitre, nous allons comprendre ce qu'est le cache, pourquoi il est crucial, et comment interprÃ©ter cette mÃ©trique pour optimiser les performances de votre systÃ¨me.

---

## Comprendre le Concept de Cache

### Qu'est-ce qu'un Cache ?

Imaginez que vous travaillez sur un projet et que vous devez consulter rÃ©guliÃ¨rement certains documents. Vous avez deux options :

1. **Ranger les documents sur votre bureau** (accÃ¨s rapide)
2. **Les ranger dans une armoire Ã  l'autre bout du bÃ¢timent** (accÃ¨s lent)

Naturellement, vous garderiez les documents les plus utilisÃ©s sur votre bureau pour y accÃ©der rapidement. C'est exactement le principe d'un **cache** en informatique.

### Le Cache dans PostgreSQL

PostgreSQL fonctionne de la mÃªme maniÃ¨re avec vos donnÃ©es :

- **Le disque dur** (ou SSD) = L'armoire lointaine (lent mais grande capacitÃ©)
- **La mÃ©moire RAM** (cache) = Votre bureau (rapide mais espace limitÃ©)

PostgreSQL utilise une zone de mÃ©moire appelÃ©e **Shared Buffers** (ou Buffer Cache) pour stocker temporairement les donnÃ©es les plus frÃ©quemment utilisÃ©es.

### Pourquoi c'est Important ?

La diffÃ©rence de vitesse est considÃ©rable :

- **Lecture depuis la RAM** : ~100 nanosecondes
- **Lecture depuis un SSD** : ~100 microsecondes (1000Ã— plus lent)
- **Lecture depuis un disque dur** : ~10 millisecondes (100 000Ã— plus lent !)

Un bon taux de cache peut donc amÃ©liorer vos performances de maniÃ¨re spectaculaire.

---

## Le Cache Hit Ratio : DÃ©finition

### Qu'est-ce que le Cache Hit Ratio ?

Le **Cache Hit Ratio** mesure le pourcentage de fois oÃ¹ PostgreSQL trouve les donnÃ©es dont il a besoin directement dans la mÃ©moire (cache), sans avoir Ã  aller les chercher sur le disque.

**Formule simplifiÃ©e :**

```
Cache Hit Ratio = (Lectures depuis le cache / Lectures totales) Ã— 100
```

### Les Deux ScÃ©narios

#### Cache Hit (SuccÃ¨s) âœ…

PostgreSQL cherche une donnÃ©e â†’ Elle est dans la RAM â†’ AccÃ¨s ultra-rapide

#### Cache Miss (Ã‰chec) âŒ

PostgreSQL cherche une donnÃ©e â†’ Elle n'est PAS dans la RAM â†’ Il doit aller la chercher sur le disque â†’ Beaucoup plus lent

---

## Comment Mesurer le Cache Hit Ratio

### La RequÃªte de Base

PostgreSQL fournit des statistiques systÃ¨me qui nous permettent de calculer ce ratio. Voici la requÃªte Ã  utiliser :

```sql
SELECT
    sum(heap_blks_read) as heap_read,
    sum(heap_blks_hit) as heap_hit,
    round(
        sum(heap_blks_hit) / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0) * 100,
        2
    ) as cache_hit_ratio
FROM pg_statio_user_tables;
```

#### Explication des Termes

- **heap_blks_read** : Nombre de blocs (morceaux de donnÃ©es) lus depuis le disque
- **heap_blks_hit** : Nombre de blocs trouvÃ©s directement dans le cache
- **cache_hit_ratio** : Le pourcentage de succÃ¨s du cache

### RequÃªte Plus DÃ©taillÃ©e (Par Table)

Si vous voulez voir le ratio pour chaque table individuellement :

```sql
SELECT
    schemaname,
    relname as table_name,
    heap_blks_read as disk_reads,
    heap_blks_hit as cache_reads,
    round(
        heap_blks_hit::numeric / nullif(heap_blks_hit + heap_blks_read, 0) * 100,
        2
    ) as cache_hit_ratio_percent
FROM pg_statio_user_tables
WHERE heap_blks_read + heap_blks_hit > 0
ORDER BY cache_hit_ratio_percent ASC, heap_blks_read DESC;
```

Cette requÃªte affiche :
- Le nom du schÃ©ma et de la table
- Le nombre de lectures disque
- Le nombre de lectures cache
- Le ratio en pourcentage

Les tables avec les ratios les plus faibles apparaissent en premier, ce qui vous permet d'identifier rapidement les tables problÃ©matiques.

---

## InterprÃ©ter les RÃ©sultats

### Les Seuils de RÃ©fÃ©rence

Voici comment interprÃ©ter votre Cache Hit Ratio :

| Ratio | Ã‰tat | Signification |
|-------|------|---------------|
| **> 99%** | ğŸŸ¢ Excellent | Votre cache est trÃ¨s efficace |
| **95-99%** | ğŸŸ¡ Bon | Acceptable, mais peut Ãªtre amÃ©liorÃ© |
| **90-95%** | ğŸŸ  Moyen | Des optimisations sont recommandÃ©es |
| **< 90%** | ğŸ”´ ProblÃ©matique | Action nÃ©cessaire |

### Exemple d'InterprÃ©tation

#### ScÃ©nario 1 : Bon Ratio

```
cache_hit_ratio: 99.5%
```

**Signification :** Sur 1000 lectures, 995 sont servies depuis la RAM et seulement 5 nÃ©cessitent un accÃ¨s disque. C'est excellent !

#### ScÃ©nario 2 : Ratio Faible

```
cache_hit_ratio: 85%
```

**Signification :** Sur 1000 lectures, 150 nÃ©cessitent un accÃ¨s disque. Cela signifie que votre systÃ¨me attend souvent aprÃ¨s le disque, ce qui ralentit les performances.

---

## Cas Particuliers et Exceptions

### Quand un Ratio Faible est Normal

Il existe des situations oÃ¹ un ratio plus faible est acceptable :

#### 1. DÃ©marrage RÃ©cent de PostgreSQL

Juste aprÃ¨s le dÃ©marrage, le cache est vide. Il faut du temps pour le "rÃ©chauffer" (warm-up).

**Que faire :** Attendre quelques heures d'utilisation normale avant de s'inquiÃ©ter.

#### 2. PremiÃ¨re RequÃªte sur de Nouvelles DonnÃ©es

Si vous interrogez des donnÃ©es qui n'ont jamais Ã©tÃ© accÃ©dÃ©es, elles ne peuvent pas Ãªtre dans le cache.

**C'est normal :** Le premier accÃ¨s sera toujours depuis le disque.

#### 3. Tables TrÃ¨s Volumineuses et Rarement AccÃ©dÃ©es

Si vous avez des tables d'archivage de 500 Go consultÃ©es une fois par mois, elles ne resteront pas en cache.

**C'est normal :** Ces donnÃ©es ne justifient pas d'occuper le cache.

#### 4. Scans SÃ©quentiels Massifs

Lorsque vous faites une sauvegarde complÃ¨te (pg_dump) ou un scan complet d'une grosse table, PostgreSQL peut volontairement ne pas mettre toutes ces donnÃ©es en cache pour ne pas "polluer" le cache avec des donnÃ©es utilisÃ©es une seule fois.

**C'est une protection :** PostgreSQL est intelligent et Ã©vite de gaspiller le cache.

---

## Facteurs InfluenÃ§ant le Cache Hit Ratio

### 1. Taille du Shared Buffers

Le paramÃ¨tre **shared_buffers** dÃ©termine la taille du cache PostgreSQL.

**Configuration typique :**

```ini
# Dans postgresql.conf
shared_buffers = 256MB    # Serveur petit
shared_buffers = 4GB      # Serveur moyen
shared_buffers = 16GB     # Serveur puissant
```

**RÃ¨gle gÃ©nÃ©rale :**
- Serveur dÃ©diÃ© : 25% de la RAM totale
- Serveur partagÃ© : 10-15% de la RAM totale

### 2. Taille de la Base de DonnÃ©es

Si votre base de donnÃ©es fait 100 GB et que vous n'avez que 4 GB de shared_buffers, toutes les donnÃ©es ne pourront jamais Ãªtre en cache simultanÃ©ment.

**Logique :**
- Base petite (< taille cache) â†’ Ratio peut atteindre 99%+
- Base grande (>>> taille cache) â†’ Ratio dÃ©pendra des patterns d'accÃ¨s

### 3. Pattern d'AccÃ¨s aux DonnÃ©es

#### Hot Data (DonnÃ©es Chaudes)

Les donnÃ©es frÃ©quemment accÃ©dÃ©es (ex: table "utilisateurs actifs").

**Impact :** Ratio Ã©levÃ© car ces donnÃ©es restent en cache.

#### Cold Data (DonnÃ©es Froides)

Les donnÃ©es rarement accÃ©dÃ©es (ex: archives de 5 ans).

**Impact :** Ratio plus faible car elles sont rechargÃ©es Ã  chaque accÃ¨s.

### 4. Type de Charge de Travail (Workload)

#### OLTP (Online Transaction Processing)

- Nombreuses petites transactions
- AccÃ¨s rÃ©pÃ©tÃ©s aux mÃªmes donnÃ©es
- **Ratio attendu :** 95-99%+

#### OLAP (Online Analytical Processing)

- Grosses requÃªtes analytiques
- Scans complets de tables
- **Ratio attendu :** Peut Ãªtre plus faible (85-95%)

---

## AmÃ©liorer le Cache Hit Ratio

Si votre ratio est insuffisant, voici les actions possibles :

### 1. Augmenter shared_buffers

**Comment :**

```ini
# Dans postgresql.conf
shared_buffers = 8GB  # Augmentation de la taille
```

**Attention :** AprÃ¨s modification, vous devez redÃ©marrer PostgreSQL.

**Limites :**
- Ne pas dÃ©passer 40% de la RAM totale
- Au-delÃ  de 16-32 GB, les gains diminuent

### 2. Optimiser les RequÃªtes

Des requÃªtes inefficaces peuvent parcourir inutilement beaucoup de donnÃ©es.

**Actions :**
- Ajouter des index appropriÃ©s
- Ã‰viter les `SELECT *` quand vous n'avez besoin que de quelques colonnes
- Utiliser des `WHERE` pour filtrer les donnÃ©es

### 3. Ajouter de la RAM au Serveur

Si votre serveur manque de mÃ©moire physique, augmenter la RAM est la solution la plus efficace.

**Exemple :** Passer de 8 GB Ã  32 GB de RAM permettra un shared_buffers plus grand.

### 4. Partitionner les Grandes Tables

Si vous avez des tables trÃ¨s volumineuses, le partitionnement permet de ne charger en cache que les partitions pertinentes.

**Exemple :** Table de logs partitionnÃ©e par mois â†’ Seul le mois en cours reste en cache.

### 5. Utiliser pg_prewarm

L'extension **pg_prewarm** permet de "prÃ©chauffer" le cache en chargeant des tables spÃ©cifiques en mÃ©moire au dÃ©marrage.

**Usage :**

```sql
-- Charger une table en cache
SELECT pg_prewarm('ma_table_importante');
```

---

## Cache Hit Ratio vs Autres MÃ©triques

Le Cache Hit Ratio est important, mais il ne raconte pas toute l'histoire. Voici comment il s'intÃ¨gre dans une vision globale :

### MÃ©triques ComplÃ©mentaires

#### 1. I/O Wait

MÃªme avec un bon cache hit ratio, si les 1% de cache misses gÃ©nÃ¨rent beaucoup d'attente I/O, vous avez un problÃ¨me de disque.

**Ã€ surveiller :** Le temps d'attente disque (iostat, iotop)

#### 2. Query Performance

Un ratio Ã©levÃ© ne garantit pas des requÃªtes rapides si celles-ci sont mal optimisÃ©es.

**Ã€ surveiller :** Les requÃªtes lentes (pg_stat_statements)

#### 3. Index Usage

Des index non utilisÃ©s ou manquants peuvent forcer des scans de table entiÃ¨re, rÃ©duisant le ratio.

**Ã€ surveiller :** pg_stat_user_indexes

---

## Le Cache de l'OS (Operating System)

### Il N'y a Pas Qu'un Seul Cache !

Outre le shared_buffers de PostgreSQL, le systÃ¨me d'exploitation (Linux, Windows) maintient son propre cache disque appelÃ© **Page Cache** (ou File System Cache).

**Architecture en couches :**

```
Application â†’ PostgreSQL Shared Buffers â†’ OS Page Cache â†’ Disque
```

### Implication Pratique

MÃªme si une donnÃ©e n'est pas dans les shared_buffers de PostgreSQL, elle peut Ãªtre dans le cache de l'OS, ce qui reste beaucoup plus rapide que d'aller sur le disque.

**Ratio rÃ©el :**
- Ratio PostgreSQL : 95%
- Ratio OS Cache : 4%
- Vraies lectures disque : 1%

### Mesurer le Cache de l'OS

Vous pouvez voir l'utilisation du cache systÃ¨me avec :

**Linux :**
```bash
free -h
# Regardez la ligne "buff/cache"
```

**PostgreSQL offre aussi des mÃ©triques :**
```sql
SELECT * FROM pg_statio_user_tables;
-- Colonne "heap_blks_read" = lectures ayant traversÃ© les caches
```

---

## Monitoring Continu

### Mettre en Place une Surveillance

Il est recommandÃ© de surveiller ce ratio de maniÃ¨re continue, pas seulement ponctuellement.

#### Solution Simple : Script PÃ©riodique

```sql
-- Vue personnalisÃ©e pour faciliter le monitoring
CREATE OR REPLACE VIEW cache_hit_ratio_view AS
SELECT
    'Global' as scope,
    round(
        sum(heap_blks_hit)::numeric /
        nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0) * 100,
        2
    ) as cache_hit_ratio_percent,
    sum(heap_blks_read) as total_disk_reads,
    sum(heap_blks_hit) as total_cache_reads
FROM pg_statio_user_tables;

-- Consulter facilement
SELECT * FROM cache_hit_ratio_view;
```

#### Solution Professionnelle : Monitoring Tools

Des outils comme **Grafana + Prometheus + postgres_exporter** permettent de visualiser l'Ã©volution du ratio au fil du temps avec des graphiques et des alertes.

**Avantages :**
- DÃ©tection automatique de dÃ©gradations
- Historique des performances
- Alertes en cas de problÃ¨me

---

## Questions FrÃ©quentes (FAQ)

### Q1 : Mon ratio est de 99.9%, dois-je encore l'optimiser ?

**RÃ©ponse :** Non, c'est excellent ! Concentrez-vous sur d'autres aspects (requÃªtes lentes, index, etc.).

### Q2 : Mon ratio a chutÃ© brutalement, que faire ?

**RÃ©ponse :** VÃ©rifiez si :
1. PostgreSQL a redÃ©marrÃ© (cache vidÃ©)
2. Une grosse requÃªte analytique a Ã©tÃ© lancÃ©e
3. Une nouvelle table volumineuse a Ã©tÃ© crÃ©Ã©e et massivement utilisÃ©e

### Q3 : Quelle est la taille idÃ©ale pour shared_buffers ?

**RÃ©ponse :** Il n'y a pas de valeur magique, mais :
- DÃ©marrez avec 25% de la RAM
- Surveillez le ratio
- Ajustez progressivement si nÃ©cessaire

### Q4 : Un ratio de 100% est-il possible ?

**RÃ©ponse :** ThÃ©oriquement oui, si votre base complÃ¨te tient en mÃ©moire et que toutes les donnÃ©es sont constamment accÃ©dÃ©es. En pratique, 99.5%+ est dÃ©jÃ  excellent.

### Q5 : Le ratio varie-t-il dans la journÃ©e ?

**RÃ©ponse :** Oui, c'est normal ! Il peut baisser pendant :
- Les sauvegardes
- Les rapports de fin de mois
- Les imports de donnÃ©es
- Le dÃ©marrage (warm-up)

---

## Points ClÃ©s Ã  Retenir

âœ… **Le Cache Hit Ratio mesure l'efficacitÃ© de votre mÃ©moire cache**
   - Plus il est Ã©levÃ©, moins PostgreSQL attend aprÃ¨s le disque

âœ… **Cible : > 95%, idÃ©alement > 99%**
   - Mais le contexte compte (OLTP vs OLAP)

âœ… **Facteurs influenÃ§ant le ratio :**
   - Taille du shared_buffers
   - Taille de la base de donnÃ©es
   - Patterns d'accÃ¨s aux donnÃ©es
   - Type de workload

âœ… **Actions d'amÃ©lioration :**
   - Augmenter shared_buffers (dans les limites raisonnables)
   - Optimiser les requÃªtes et les index
   - Ajouter de la RAM au serveur
   - Partitionner les grandes tables

âœ… **Ne pas oublier :**
   - Le cache de l'OS joue aussi un rÃ´le
   - Un bon ratio n'est qu'une mÃ©trique parmi d'autres
   - Le monitoring continu est essentiel

---

## Conclusion

Le **Cache Hit Ratio** est une mÃ©trique fondamentale pour comprendre les performances de votre base de donnÃ©es PostgreSQL. C'est un indicateur simple mais puissant qui vous dit si votre systÃ¨me exploite efficacement la mÃ©moire disponible.

Un bon ratio (> 99%) signifie que votre application passe la majoritÃ© de son temps Ã  traiter des donnÃ©es, pas Ã  attendre le disque. C'est la diffÃ©rence entre une application rÃ©active et une application frustrante pour les utilisateurs.

Maintenant que vous comprenez cette mÃ©trique, vous pouvez :
1. La mesurer rÃ©guliÃ¨rement
2. L'interprÃ©ter correctement
3. Agir en consÃ©quence pour optimiser vos performances

Dans la suite de cette formation, nous verrons d'autres mÃ©triques vitales qui complÃ¨tent cette vision globale des performances de PostgreSQL.

---


â­ï¸ [Table et Index Bloat](/14-observabilite-et-monitoring/06.2-table-index-bloat.md)
