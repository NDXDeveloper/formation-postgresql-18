üîù Retour au [Sommaire](/SOMMAIRE.md)

# 14.6.2. Table et Index Bloat

## Introduction

Le **Bloat** (gonflement en fran√ßais) est l'un des probl√®mes de performance les plus courants dans PostgreSQL, mais aussi l'un des moins bien compris par les d√©butants. Il s'agit d'un ph√©nom√®ne naturel qui se produit au fil du temps dans toutes les bases de donn√©es PostgreSQL actives.

Dans ce chapitre, nous allons comprendre ce qu'est le bloat, pourquoi il se produit, comment le d√©tecter, et surtout comment le g√©rer efficacement.

---

## Comprendre le Concept de Bloat

### Une Analogie Simple : Le Parking

Imaginez un parking de 100 places :

**Situation normale :**
- 80 voitures gar√©es
- 20 places vides r√©parties uniform√©ment
- Vous trouvez facilement une place

**Situation avec "bloat" :**
- Seules 40 voitures sont r√©ellement pr√©sentes
- Mais 40 autres emplacements sont marqu√©s "r√©serv√©s" avec des c√¥nes alors qu'aucune voiture n'y est
- Le parking semble rempli mais il est en r√©alit√© √† moiti√© vide
- Vous devez parcourir tout le parking pour trouver les vraies places disponibles

C'est exactement ce qui se passe avec le bloat dans PostgreSQL : de l'espace occup√© inutilement qui ralentit l'acc√®s aux vraies donn√©es.

### Le Bloat dans PostgreSQL

Le **bloat** est un espace disque occup√© par des donn√©es obsol√®tes ou inutilis√©es qui n'ont pas encore √©t√© r√©cup√©r√©es par PostgreSQL.

**En termes simples :**
- Votre table fait 10 GB sur le disque
- Mais seulement 6 GB contiennent des donn√©es r√©ellement utilisables
- Les 4 GB restants sont du "bloat" : de l'espace gaspill√©

---

## Pourquoi le Bloat Existe-t-il ?

### Le Principe MVCC (Multiversion Concurrency Control)

Pour comprendre le bloat, il faut comprendre comment PostgreSQL g√®re les modifications de donn√©es.

#### Sc√©nario : Mise √† Jour d'une Ligne

**Dans une base de donn√©es classique :**
```
Ligne originale : [id=1, nom="Alice", age=25]
UPDATE users SET age = 26 WHERE id = 1;
R√©sultat : La ligne est modifi√©e directement
```

**Dans PostgreSQL (MVCC) :**
```
Ligne originale : [id=1, nom="Alice", age=25]  ‚Üê Marqu√©e comme "ancienne version"
UPDATE users SET age = 26 WHERE id = 1;
Nouvelle ligne : [id=1, nom="Alice", age=26]   ‚Üê Cr√©√©e comme nouvelle version
```

**PostgreSQL ne supprime JAMAIS une ligne directement !**

Pourquoi ? Pour permettre aux transactions concurrentes de continuer √† lire l'ancienne version si n√©cessaire (isolation transactionnelle).

### Les Op√©rations Qui Cr√©ent du Bloat

#### 1. UPDATE

Chaque `UPDATE` cr√©e une nouvelle version de la ligne et marque l'ancienne comme obsol√®te.

**Exemple :**
```sql
-- Table initiale : 1000 lignes
SELECT pg_size_pretty(pg_relation_size('users'));
-- R√©sultat : 80 KB

-- 1000 updates
UPDATE users SET last_login = NOW();

-- Taille apr√®s updates
SELECT pg_size_pretty(pg_relation_size('users'));
-- R√©sultat : 160 KB (doubl√© !)
```

Les anciennes versions prennent de la place jusqu'√† ce qu'elles soient nettoy√©es.

#### 2. DELETE

Les `DELETE` ne lib√®rent pas l'espace imm√©diatement. Les lignes sont marqu√©es comme "mortes" mais restent physiquement sur le disque.

**Exemple :**
```sql
-- Table avec 10 000 lignes
DELETE FROM old_logs WHERE date < '2020-01-01';
-- 9 000 lignes supprim√©es

-- La taille de la table ne change pas imm√©diatement !
```

#### 3. INSERT Suivi de DELETE (Pattern Rotation)

Les tables avec beaucoup d'insertions et suppressions (logs, queues, sessions) accumulent rapidement du bloat.

**Exemple typique :**
```sql
-- Tous les jours :
INSERT INTO session_logs (...) VALUES (...);  -- 100 000 insertions
DELETE FROM session_logs WHERE created_at < NOW() - INTERVAL '7 days';  -- 100 000 suppressions
```

---

## Types de Bloat

### 1. Table Bloat (Bloat de Table)

De l'espace mort dans les fichiers de donn√©es des tables.

**Sympt√¥mes :**
- Tables anormalement volumineuses
- Scans s√©quentiels de plus en plus lents
- Sauvegardes de plus en plus grosses

### 2. Index Bloat (Bloat d'Index)

De l'espace mort dans les structures d'index.

**Sympt√¥mes :**
- Index tr√®s volumineux par rapport aux donn√©es
- Requ√™tes utilisant des index de plus en plus lentes
- Ratio taille_index / taille_table anormal

**Important :** Les index peuvent gonfler plus vite que les tables car ils r√©f√©rencent toutes les versions de lignes, m√™me obsol√®tes.

---

## Impact du Bloat sur les Performances

### 1. Performances de Requ√™tes D√©grad√©es

**Sans bloat :**
```
Table 100 GB, 100 millions de lignes utiles
Scan complet : 10 secondes
```

**Avec 50% de bloat :**
```
Table 200 GB, 100 millions de lignes utiles + 100 GB de bloat
Scan complet : 20 secondes (2√ó plus lent !)
```

PostgreSQL doit parcourir le bloat pour trouver les vraies donn√©es.

### 2. Utilisation Excessive du Disque

- Co√ªts de stockage augment√©s
- Sauvegardes plus volumineuses et plus longues
- R√©plication plus lente (plus de donn√©es √† transf√©rer)

### 3. Cache Moins Efficace

Le bloat occupe de la place dans le cache (shared_buffers), r√©duisant l'espace disponible pour les vraies donn√©es.

**R√©sultat :** Cache Hit Ratio plus faible.

### 4. VACUUM Plus Lents

Plus il y a de bloat, plus le VACUUM met de temps √† s'ex√©cuter, cr√©ant un cercle vicieux.

---

## Mesurer le Bloat

### Requ√™te Simple : Estimation du Bloat

Voici une requ√™te qui estime le pourcentage de bloat dans vos tables :

```sql
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    round(100 * pg_relation_size(schemaname||'.'||tablename) /
          NULLIF(pg_total_relation_size(schemaname||'.'||tablename), 0), 2) AS table_percent,
    n_dead_tup AS dead_tuples,
    n_live_tup AS live_tuples,
    round(100 * n_dead_tup::numeric / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS dead_tuple_percent
FROM pg_stat_user_tables
WHERE n_live_tup > 0
ORDER BY n_dead_tup DESC;
```

#### Interpr√©tation des Colonnes

- **total_size** : Taille totale (table + index + TOAST)
- **table_size** : Taille de la table seule
- **dead_tuples** : Nombre de lignes mortes (obsol√®tes)
- **live_tuples** : Nombre de lignes vivantes (actuelles)
- **dead_tuple_percent** : Pourcentage de bloat estim√©

#### Seuils d'Alerte

| Pourcentage | √âtat | Action |
|-------------|------|--------|
| **< 10%** | üü¢ Normal | Aucune action n√©cessaire |
| **10-20%** | üü° Surveill√© | Planifier un VACUUM |
| **20-40%** | üü† Pr√©occupant | VACUUM urgent recommand√© |
| **> 40%** | üî¥ Critique | Action imm√©diate n√©cessaire |

### Requ√™te Avanc√©e : Estimation Plus Pr√©cise

Pour une estimation plus pr√©cise (mais plus complexe) :

```sql
SELECT
    schemaname,
    tablename,
    pg_size_pretty(bloat_size) AS bloat_size,
    round(bloat_ratio, 2) AS bloat_ratio_percent
FROM (
    SELECT
        schemaname,
        tablename,
        (bs*tblpages)::bigint AS real_size,
        ((tblpages-est_tblpages)*bs)::bigint AS bloat_size,
        CASE WHEN tblpages > 0
            THEN 100 * (tblpages-est_tblpages)::float / tblpages
            ELSE 0
        END AS bloat_ratio
    FROM (
        SELECT
            schemaname,
            tablename,
            cc.reltuples,
            cc.relpages AS tblpages,
            bs,
            CEIL((cc.reltuples*((datahdr+ma-
                (CASE WHEN datahdr%ma=0 THEN ma ELSE datahdr%ma END))+nullhdr2+4))/(bs-20::float)) AS est_tblpages
        FROM (
            SELECT
                ma, bs, schemaname, tablename,
                (datawidth+(hdr+ma-(case when hdr%ma=0 THEN ma ELSE hdr%ma END)))::numeric AS datahdr,
                (maxfracsum*(nullhdr+ma-(case when nullhdr%ma=0 THEN ma ELSE nullhdr%ma END))) AS nullhdr2
            FROM (
                SELECT
                    schemaname, tablename, hdr, ma, bs,
                    SUM((1-null_frac)*avg_width) AS datawidth,
                    MAX(null_frac) AS maxfracsum,
                    hdr+(
                        SELECT 1+count(*)/8
                        FROM pg_stats s2
                        WHERE null_frac<>0 AND s2.schemaname = s.schemaname AND s2.tablename = s.tablename
                    ) AS nullhdr
                FROM pg_stats s, (
                    SELECT
                        (SELECT current_setting('block_size')::numeric) AS bs,
                        CASE WHEN substring(v,12,3) IN ('8.0','8.1','8.2') THEN 27 ELSE 23 END AS hdr,
                        CASE WHEN v ~ 'mingw32' THEN 8 ELSE 4 END AS ma
                    FROM (SELECT version() AS v) AS foo
                ) AS constants
                GROUP BY 1,2,3,4,5
            ) AS foo
        ) AS rs
        JOIN pg_class cc ON cc.relname = rs.tablename
        JOIN pg_namespace nn ON cc.relnamespace = nn.oid AND nn.nspname = rs.schemaname
    ) AS sml
) AS bloat_info
WHERE bloat_ratio > 10
ORDER BY bloat_size DESC;
```

**Note :** Cette requ√™te est complexe mais fournit une estimation plus r√©aliste bas√©e sur l'analyse de la structure interne des donn√©es.

### Mesurer le Bloat des Index

```sql
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,
    idx_scan AS index_scans,
    idx_tup_read AS tuples_read,
    idx_tup_fetch AS tuples_fetched
FROM pg_stat_user_indexes
WHERE idx_scan = 0  -- Index jamais utilis√©s (candidats au bloat ou √† la suppression)
ORDER BY pg_relation_size(indexrelid) DESC;
```

Cette requ√™te identifie :
- Les index volumineux
- Les index non utilis√©s (potentiellement inutiles ou gonfl√©s)

---

## Le Processus VACUUM : Le Nettoyeur de PostgreSQL

### Qu'est-ce que VACUUM ?

**VACUUM** est le processus de nettoyage qui r√©cup√®re l'espace occup√© par les lignes mortes (bloat).

**Analogie :** C'est comme un √©boueur qui passe r√©guli√®rement vider les poubelles du parking (enlever les c√¥nes "r√©serv√©s" inutiles).

### Les Deux Types de VACUUM

#### 1. VACUUM (Standard)

```sql
VACUUM table_name;
```

**Ce qu'il fait :**
- Marque l'espace des lignes mortes comme r√©utilisable
- Ne r√©duit PAS la taille du fichier sur disque
- Rapide et peu intrusif
- Peut s'ex√©cuter en parall√®le avec les requ√™tes normales

**R√©sultat :**
```
Avant : Table 200 MB (100 MB donn√©es + 100 MB bloat)
Apr√®s : Table 200 MB (mais 100 MB r√©utilisables pour nouvelles donn√©es)
```

L'espace est r√©cup√©r√© mais le fichier ne r√©tr√©cit pas.

#### 2. VACUUM FULL

```sql
VACUUM FULL table_name;
```

**Ce qu'il fait :**
- R√©√©crit compl√®tement la table
- √âlimine physiquement le bloat
- R√©duit r√©ellement la taille du fichier
- **Prend un verrou exclusif** (bloque toutes les op√©rations)
- Tr√®s lent et ressource-intensif

**R√©sultat :**
```
Avant : Table 200 MB (100 MB donn√©es + 100 MB bloat)
Apr√®s : Table 100 MB (bloat compl√®tement √©limin√©)
```

**‚ö†Ô∏è Attention :** VACUUM FULL n√©cessite de l'espace disque temporaire √©gal √† la taille de la table !

### Quand Utiliser Chaque Type ?

| Situation | Commande | Fr√©quence |
|-----------|----------|-----------|
| Maintenance r√©guli√®re | `VACUUM` | Automatique (autovacuum) |
| Bloat mod√©r√© (< 30%) | `VACUUM` | Hebdomadaire/Mensuel |
| Bloat s√©v√®re (> 40%) | `VACUUM FULL` | Exceptionnel |
| Migration/Maintenance planifi√©e | `VACUUM FULL` | Fen√™tre de maintenance |

---

## Autovacuum : Le Nettoyage Automatique

### Qu'est-ce que l'Autovacuum ?

**Autovacuum** est un processus d'arri√®re-plan qui ex√©cute automatiquement VACUUM sur les tables qui en ont besoin.

**Avantage :** Vous n'avez (presque) rien √† faire !

### V√©rifier que l'Autovacuum est Actif

```sql
SHOW autovacuum;
-- R√©sultat attendu : on
```

Si c'est "off", activez-le imm√©diatement :

```sql
-- Dans postgresql.conf
autovacuum = on
```

### Param√®tres Cl√©s de l'Autovacuum

#### 1. autovacuum_vacuum_scale_factor

**D√©finition :** Pourcentage de lignes modifi√©es avant d√©clenchement.

```ini
autovacuum_vacuum_scale_factor = 0.2  # 20% par d√©faut
```

**Signification :** L'autovacuum se d√©clenche quand 20% de la table a √©t√© modifi√©e.

**Pour une table de 1 million de lignes :**
- Seuil = 200 000 lignes mortes

**‚ö†Ô∏è Probl√®me sur grosses tables :**
- Table de 100 millions de lignes ‚Üí Seuil = 20 millions !
- L'autovacuum attend trop longtemps

**Solution :** R√©duire le facteur pour les grosses tables.

#### 2. autovacuum_vacuum_threshold

**D√©finition :** Nombre minimum de lignes mortes pour d√©clencher VACUUM.

```ini
autovacuum_vacuum_threshold = 50  # Par d√©faut
```

**Formule de d√©clenchement :**
```
Seuil = autovacuum_vacuum_threshold + (autovacuum_vacuum_scale_factor * nombre_lignes)
```

### Nouveaut√©s PostgreSQL 18

#### autovacuum_worker_slots

PostgreSQL 18 introduit des **ajustements dynamiques** pour optimiser l'autovacuum.

#### autovacuum_vacuum_max_threshold

Nouveau param√®tre permettant de plafonner le seuil de d√©clenchement pour les tr√®s grosses tables.

```ini
autovacuum_vacuum_max_threshold = 1000000  # Exemple
```

**Utilit√© :** Emp√™che l'autovacuum d'attendre trop longtemps sur des tables massives.

### Surveiller l'Autovacuum

#### Voir le Statut de l'Autovacuum

```sql
SELECT
    schemaname,
    relname,
    last_vacuum,
    last_autovacuum,
    n_tup_ins AS inserts,
    n_tup_upd AS updates,
    n_tup_del AS deletes,
    n_dead_tup AS dead_tuples
FROM pg_stat_user_tables
ORDER BY n_dead_tup DESC;
```

#### Colonnes Importantes

- **last_autovacuum** : Derni√®re ex√©cution automatique
- **dead_tuples** : Nombre de lignes mortes en attente

**‚ö†Ô∏è Alerte :** Si `last_autovacuum` est NULL ou ancien ET `dead_tuples` est √©lev√©, l'autovacuum ne fonctionne pas correctement.

### Statistiques Nouvelles dans PostgreSQL 18

```sql
-- Nouvelles statistiques VACUUM et ANALYZE
SELECT
    schemaname,
    relname,
    vacuum_count,
    autovacuum_count,
    analyze_count,
    autoanalyze_count
FROM pg_stat_all_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY autovacuum_count DESC;
```

---

## Optimiser la Configuration de l'Autovacuum

### Configuration Globale vs Par Table

#### Configuration Globale (postgresql.conf)

```ini
# Nombre de workers autovacuum
autovacuum_max_workers = 3

# D√©lai entre les runs
autovacuum_naptime = 1min

# Co√ªt et d√©lais (throttling)
autovacuum_vacuum_cost_delay = 2ms
autovacuum_vacuum_cost_limit = 200
```

#### Configuration Par Table (Recommand√© pour Tables Critiques)

```sql
-- Table avec beaucoup d'activit√© : autovacuum plus agressif
ALTER TABLE orders SET (
    autovacuum_vacuum_scale_factor = 0.05,  -- 5% au lieu de 20%
    autovacuum_vacuum_threshold = 1000
);

-- Table d'archivage : autovacuum moins fr√©quent
ALTER TABLE old_logs SET (
    autovacuum_vacuum_scale_factor = 0.5,   -- 50%
    autovacuum_vacuum_threshold = 5000
);
```

### Cas Pratiques de Tuning

#### Table avec Beaucoup d'UPDATEs

**Probl√®me :** Table "users" avec 10 millions de lignes, mise √† jour fr√©quente.

**Solution :**
```sql
ALTER TABLE users SET (
    autovacuum_vacuum_scale_factor = 0.02,     -- D√©clenchement √† 2%
    autovacuum_vacuum_cost_delay = 0,          -- Pas de throttling
    autovacuum_analyze_scale_factor = 0.05     -- Analyse plus fr√©quente
);
```

#### Table de Queue/Session

**Probl√®me :** Table avec constant INSERT/DELETE.

**Solution :**
```sql
ALTER TABLE job_queue SET (
    autovacuum_vacuum_scale_factor = 0.01,     -- Tr√®s agressif
    autovacuum_vacuum_threshold = 100,         -- Seuil bas
    autovacuum_vacuum_cost_delay = 0           -- Vitesse maximale
);
```

---

## Alternatives √† VACUUM FULL

### 1. pg_repack (Extension)

**pg_repack** permet de r√©organiser les tables sans verrou exclusif.

**Avantages :**
- Pas de downtime
- Plus s√ªr que VACUUM FULL
- Peut se faire en production

**Installation :**
```sql
CREATE EXTENSION pg_repack;
```

**Usage :**
```bash
# En ligne de commande
pg_repack -d mydb -t mytable
```

**Fonctionnement :**
1. Cr√©e une copie de la table sans bloat
2. Applique les modifications en continu
3. Bascule vers la nouvelle table
4. Supprime l'ancienne

### 2. CLUSTER

**CLUSTER** r√©organise physiquement une table selon un index.

```sql
-- Premi√®re fois : d√©finir l'index de clustering
CLUSTER mytable USING mytable_idx;

-- Ensuite : re-cluster si n√©cessaire
CLUSTER mytable;
```

**‚ö†Ô∏è Attention :** Prend aussi un verrou exclusif comme VACUUM FULL.

**Bonus :** Am√©liore aussi la performance des requ√™tes ordonn√©es.

---

## Pr√©venir le Bloat

### 1. Dimensionner Correctement l'Autovacuum

**R√®gle d'or :** L'autovacuum doit s'ex√©cuter AVANT que le bloat devienne probl√©matique.

**Configuration recommand√©e pour production :**
```ini
autovacuum_max_workers = 5
autovacuum_naptime = 30s
autovacuum_vacuum_cost_delay = 2ms
autovacuum_vacuum_cost_limit = 400
```

### 2. Surveillance Proactive

**Script de Monitoring :**
```sql
-- Cr√©er une vue pour surveillance quotidienne
CREATE VIEW bloat_monitor AS
SELECT
    schemaname,
    tablename,
    n_dead_tup AS dead_tuples,
    n_live_tup AS live_tuples,
    round(100 * n_dead_tup::numeric / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS bloat_percent,
    last_autovacuum,
    CASE
        WHEN n_dead_tup::numeric / NULLIF(n_live_tup + n_dead_tup, 0) > 0.3 THEN 'üî¥ CRITICAL'
        WHEN n_dead_tup::numeric / NULLIF(n_live_tup + n_dead_tup, 0) > 0.15 THEN 'üü† WARNING'
        ELSE 'üü¢ OK'
    END AS status
FROM pg_stat_user_tables
WHERE n_live_tup > 1000  -- Ignorer petites tables
ORDER BY bloat_percent DESC NULLS LAST;

-- Consultation
SELECT * FROM bloat_monitor WHERE status != 'üü¢ OK';
```

### 3. Optimiser les Sch√©mas

#### √âviter les UPDATEs Fr√©quents

**Anti-pattern :**
```sql
-- Mauvais : UPDATE fr√©quent d'un compteur
UPDATE users SET login_count = login_count + 1 WHERE id = 123;
```

**Better pattern :**
```sql
-- Bon : Table s√©par√©e pour donn√©es volatiles
INSERT INTO user_logins (user_id, login_time) VALUES (123, NOW());
-- Le compteur est calcul√© par requ√™te
```

#### Utiliser des Partitions

Les tables partitionn√©es permettent de :
- Supprimer des partitions enti√®res (rapide, pas de bloat)
- Vacuum seulement les partitions actives

**Exemple :**
```sql
-- Table partitionn√©e par mois
CREATE TABLE logs (
    id BIGSERIAL,
    created_at TIMESTAMP,
    message TEXT
) PARTITION BY RANGE (created_at);

-- Partitions
CREATE TABLE logs_2024_11 PARTITION OF logs
    FOR VALUES FROM ('2024-11-01') TO ('2024-12-01');

CREATE TABLE logs_2024_12 PARTITION OF logs
    FOR VALUES FROM ('2024-12-01') TO ('2025-01-01');

-- Suppression d'anciennes donn√©es : instantan√©, pas de bloat
DROP TABLE logs_2024_10;
```

### 4. Planifier des VACUUM Manuels

Pour les tables critiques, compl√©ter l'autovacuum par des VACUUM manuels pendant les heures creuses :

```bash
# Cron job quotidien
0 2 * * * psql -d mydb -c "VACUUM ANALYZE critical_table;"
```

---

## Strat√©gies de Rem√©diation du Bloat

### Sc√©nario 1 : Bloat Mod√©r√© (10-20%)

**Action :** VACUUM standard

```sql
VACUUM ANALYZE table_name;
```

**Timing :** Peut √™tre fait √† tout moment.

### Sc√©nario 2 : Bloat Important (20-40%)

**Action :** VACUUM r√©p√©t√© + ajustement autovacuum

```sql
-- VACUUM imm√©diat
VACUUM ANALYZE table_name;

-- Ajuster les param√®tres
ALTER TABLE table_name SET (
    autovacuum_vacuum_scale_factor = 0.05
);
```

**Timing :** Pendant heures creuses de pr√©f√©rence.

### Sc√©nario 3 : Bloat Critique (> 40%)

**Option A : VACUUM FULL (Downtime acceptable)**

```sql
-- ‚ö†Ô∏è Bloque la table !
VACUUM FULL ANALYZE table_name;
```

**Pr√©-requis :**
- Fen√™tre de maintenance planifi√©e
- Espace disque disponible = taille table
- Backup r√©cent

**Option B : pg_repack (Pas de downtime)**

```bash
# Pas de blocage, mais consomme des ressources
pg_repack -d mydb -t table_name
```

**Option C : Recr√©ation de Table**

Pour les tr√®s grosses tables :

```sql
BEGIN;

-- Cr√©er nouvelle table
CREATE TABLE table_name_new (LIKE table_name INCLUDING ALL);

-- Copier donn√©es
INSERT INTO table_name_new SELECT * FROM table_name;

-- Recr√©er index
-- (d√©j√† fait par INCLUDING ALL)

-- Renommer
DROP TABLE table_name;
ALTER TABLE table_name_new RENAME TO table_name;

COMMIT;
```

**‚ö†Ô∏è Attention :** N√©cessite double espace disque et gestion des FK.

---

## Cas Particuliers et Pi√®ges

### 1. TOAST et Bloat

Les donn√©es **TOAST** (The Oversized-Attribute Storage Technique) sont stock√©es s√©par√©ment pour les colonnes volumineuses (TEXT, JSONB, etc.).

**Probl√®me :** Le TOAST peut avoir son propre bloat !

**V√©rification :**
```sql
SELECT
    relname,
    pg_size_pretty(pg_relation_size(oid)) as size
FROM pg_class
WHERE relname LIKE '%toast%'
ORDER BY pg_relation_size(oid) DESC;
```

**Solution :**
```sql
-- Le VACUUM normal inclut le TOAST
VACUUM table_name;
```

### 2. Index Non Utilis√©s

Des index jamais utilis√©s mais gonfl√©s occupent inutilement de l'espace.

**D√©tection :**
```sql
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS size,
    idx_scan
FROM pg_stat_user_indexes
WHERE idx_scan = 0
ORDER BY pg_relation_size(indexrelid) DESC;
```

**Action :** Supprimer les index inutiles
```sql
DROP INDEX IF EXISTS unused_index_name;
```

### 3. Transactions Longues

Les transactions longues emp√™chent VACUUM de nettoyer les lignes mortes.

**Pourquoi ?** VACUUM ne peut pas supprimer une ligne si une transaction active pourrait encore la voir (isolation MVCC).

**D√©tection :**
```sql
SELECT
    pid,
    now() - xact_start AS duration,
    state,
    query
FROM pg_stat_activity
WHERE xact_start IS NOT NULL
ORDER BY xact_start;
```

**Solution :** Identifier et terminer (ou optimiser) les transactions trop longues.

### 4. Prepared Transactions

Les transactions pr√©par√©es (2PC - Two-Phase Commit) non termin√©es bloquent VACUUM.

**D√©tection :**
```sql
SELECT * FROM pg_prepared_xacts;
```

**Solution :** Commit ou rollback les transactions pr√©par√©es oubli√©es.

---

## Monitoring en Production

### Alertes Recommand√©es

#### Alerte 1 : Bloat Table > 20%

```sql
-- Requ√™te pour alerting (Prometheus, Grafana, etc.)
SELECT
    COUNT(*) as tables_with_bloat
FROM pg_stat_user_tables
WHERE n_dead_tup::numeric / NULLIF(n_live_tup + n_dead_tup, 0) > 0.20
AND n_live_tup > 10000;
```

**Seuil :** Si > 0, envoyer une alerte.

#### Alerte 2 : Autovacuum Non Ex√©cut√©

```sql
-- Tables non vacuum depuis > 24h
SELECT
    schemaname,
    relname,
    last_autovacuum
FROM pg_stat_user_tables
WHERE last_autovacuum < NOW() - INTERVAL '24 hours'
AND n_dead_tup > 10000;
```

#### Alerte 3 : Espace Disque Critique

```sql
-- Taille des tables critiques
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
LIMIT 20;
```

### Dashboard Grafana Recommand√©

**M√©triques √† afficher :**
1. Bloat percentage par table (top 10)
2. Dead tuples par table (top 10)
3. Fr√©quence d'autovacuum
4. Dur√©e moyenne des VACUUM
5. Espace disque utilis√© vs disponible

---

## Questions Fr√©quentes (FAQ)

### Q1 : VACUUM FULL est-il dangereux ?

**R√©ponse :** Pas dangereux mais perturbant :
- Bloque compl√®tement la table
- N√©cessite de l'espace disque temporaire
- Peut prendre des heures sur grosses tables

**Recommandation :** Pr√©f√©rer pg_repack en production.

### Q2 : Pourquoi mon autovacuum ne se d√©clenche jamais ?

**Causes possibles :**
1. `autovacuum = off` (v√©rifier la config)
2. Transactions longues qui bloquent le nettoyage
3. Seuils trop √©lev√©s (scale_factor trop grand)
4. Tous les workers autovacuum occup√©s

**Diagnostic :**
```sql
-- V√©rifier config
SHOW autovacuum;

-- V√©rifier workers
SELECT * FROM pg_stat_activity WHERE backend_type = 'autovacuum worker';
```

### Q3 : Peut-on avoir un bloat n√©gatif ?

**R√©ponse :** Non, mais l'estimation peut √™tre impr√©cise pour :
- Petites tables
- Tables r√©cemment cr√©√©es
- Tables avec beaucoup de donn√©es TOAST

### Q4 : VACUUM r√©duit-il r√©ellement la taille du fichier ?

**R√©ponse :**
- **VACUUM** : Non, il marque seulement l'espace comme r√©utilisable
- **VACUUM FULL** : Oui, il r√©duit physiquement le fichier

### Q5 : Quelle fr√©quence pour VACUUM manuel ?

**R√©ponse :** En th√©orie, l'autovacuum suffit. Mais pour tables critiques :
- OLTP intensif : VACUUM quotidien
- Tables mod√©r√©es : VACUUM hebdomadaire
- Tables stables : Autovacuum uniquement

### Q6 : Le bloat peut-il corrompre les donn√©es ?

**R√©ponse :** Non, le bloat n'affecte pas l'int√©grit√© des donn√©es. C'est uniquement un probl√®me de performance et d'espace disque.

---

## Points Cl√©s √† Retenir

‚úÖ **Le bloat est un ph√©nom√®ne naturel**
   - Caus√© par le fonctionnement MVCC de PostgreSQL
   - Se produit lors d'UPDATE et DELETE

‚úÖ **Types de bloat :**
   - Table bloat : espace mort dans les tables
   - Index bloat : espace mort dans les index

‚úÖ **Mesure du bloat :**
   - Surveiller `n_dead_tup` dans pg_stat_user_tables
   - Seuils : < 10% OK, 10-20% √† surveiller, > 20% action requise

‚úÖ **VACUUM : le nettoyeur de PostgreSQL**
   - VACUUM standard : r√©cup√®re l'espace sans r√©duire le fichier
   - VACUUM FULL : r√©duit le fichier mais bloque la table

‚úÖ **Autovacuum : votre meilleur alli√©**
   - Activ√© par d√©faut, s'ex√©cute automatiquement
   - Ajuster les param√®tres pour tables √† forte activit√©
   - PostgreSQL 18 : ajustements dynamiques am√©lior√©s

‚úÖ **Pr√©vention du bloat :**
   - Optimiser les sch√©mas (√©viter UPDATEs inutiles)
   - Utiliser le partitionnement
   - Surveiller r√©guli√®rement
   - Configurer l'autovacuum de mani√®re agressive

‚úÖ **Rem√©diation :**
   - Bloat mod√©r√© : VACUUM standard
   - Bloat important : VACUUM r√©p√©t√© + tuning autovacuum
   - Bloat critique : VACUUM FULL (fen√™tre maintenance) ou pg_repack

‚úÖ **Monitoring essentiel :**
   - Bloat percentage par table
   - Fr√©quence d'ex√©cution de l'autovacuum
   - Dead tuples count
   - Espace disque disponible

---

## Conclusion

Le **bloat** est un aspect in√©vitable du fonctionnement de PostgreSQL, mais il est parfaitement g√©rable avec les bons outils et les bonnes pratiques.

La cl√© du succ√®s r√©side dans :
1. **La compr√©hension** : Savoir pourquoi le bloat se produit
2. **La surveillance** : Mesurer r√©guli√®rement le bloat
3. **La pr√©vention** : Configurer correctement l'autovacuum
4. **L'action** : Intervenir rapidement quand n√©cessaire

Un autovacuum bien configur√© et surveill√© permet de maintenir votre base de donn√©es PostgreSQL en bonne sant√© sans intervention manuelle dans 95% des cas.

Les 5% restants concernent des situations exceptionnelles (migrations, charges inhabituelles) o√π des actions manuelles cibl√©es permettent de r√©soudre rapidement les probl√®mes.

---


‚è≠Ô∏è [I/O Wait et Disk Latency](/14-observabilite-et-monitoring/06.3-io-wait-disk-latency.md)
