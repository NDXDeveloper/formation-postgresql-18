üîù Retour au [Sommaire](/SOMMAIRE.md)

# 14.6.4. Connexions actives et pools satur√©s

## Introduction

La gestion des **connexions** est l'un des aspects les plus critiques mais souvent n√©glig√©s d'une base de donn√©es PostgreSQL en production. Une mauvaise gestion des connexions peut transformer une base de donn√©es performante en syst√®me satur√© et inutilisable, m√™me avec un excellent mat√©riel.

Dans ce chapitre, nous allons comprendre comment PostgreSQL g√®re les connexions, pourquoi il existe des limites, et surtout comment utiliser le **connection pooling** pour √©viter les probl√®mes de saturation.

---

## Comprendre les Connexions PostgreSQL

### Analogie : Le Restaurant

Imaginez un restaurant avec 100 places assises :

**Sc√©nario 1 : Restaurant bien g√©r√©**
- 80 clients pr√©sents
- Service fluide
- Tout le monde est servi rapidement

**Sc√©nario 2 : Restaurant surcharg√©**
- 150 clients se pr√©sentent en m√™me temps
- Pas assez de places
- Les serveurs sont d√©bord√©s
- 50 clients attendent dehors (frustration)
- Le service ralentit pour tout le monde

C'est exactement ce qui se passe quand votre PostgreSQL re√ßoit trop de connexions simultan√©es !

### Architecture Client-Serveur de PostgreSQL

#### Le Mod√®le Process-Per-Connection

PostgreSQL utilise un mod√®le **un processus par connexion** :

```
Application 1 ‚îÄ‚îÄ‚Üí Connexion 1 ‚îÄ‚îÄ‚Üí Backend Process 1
Application 2 ‚îÄ‚îÄ‚Üí Connexion 2 ‚îÄ‚îÄ‚Üí Backend Process 2
Application 3 ‚îÄ‚îÄ‚Üí Connexion 3 ‚îÄ‚îÄ‚Üí Backend Process 3
     ...              ...              ...
Application N ‚îÄ‚îÄ‚Üí Connexion N ‚îÄ‚îÄ‚Üí Backend Process N
```

**Particularit√© importante :** Chaque connexion cr√©e un **processus syst√®me complet** sur le serveur.

### Co√ªt d'une Connexion

#### Ressources Consomm√©es par Connexion

Chaque connexion PostgreSQL consomme :

1. **M√©moire** : 5-10 MB minimum par connexion
   - work_mem (m√©moire de travail)
   - temp_buffers (buffers temporaires)
   - Structures internes

2. **Processus Syst√®me** : 1 processus Linux/Unix complet
   - PID (Process ID)
   - Context switching overhead
   - Descripteurs de fichiers

3. **Ressources Kernel** :
   - Sockets r√©seau
   - Tables de routage

**Calcul simple :**
```
100 connexions √ó 10 MB/connexion = 1 GB de RAM minimum
500 connexions √ó 10 MB/connexion = 5 GB de RAM minimum
```

**Et cela n'inclut m√™me pas les donn√©es r√©elles trait√©es !**

#### Probl√®mes avec Trop de Connexions

##### 1. Saturation M√©moire

```
Serveur avec 32 GB RAM
shared_buffers = 8 GB
1000 connexions √ó 10 MB = 10 GB
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
18 GB utilis√©s juste pour les connexions !
```

**R√©sultat :** M√©moire restante insuffisante ‚Üí Swap ‚Üí Performances catastrophiques

##### 2. Context Switching Excessif

Le CPU passe son temps √† basculer entre les processus au lieu d'ex√©cuter r√©ellement du travail.

**Analogie :** Un serveur de restaurant qui court entre 100 tables sans jamais prendre de commande compl√®te.

##### 3. Contention sur les Ressources Partag√©es

- Lock tables satur√©es
- Buffer cache thrashing
- I/O contention

---

## Limites de Connexions dans PostgreSQL

### Le Param√®tre max_connections

**max_connections** d√©finit le nombre maximum de connexions simultan√©es accept√©es par PostgreSQL.

**V√©rifier la valeur actuelle :**
```sql
SHOW max_connections;
-- R√©sultat typique : 100
```

**Valeur par d√©faut :** 100 connexions

### Pourquoi Cette Limite Existe ?

C'est une **protection** contre la surcharge du serveur.

**Exemple concret :**

```
max_connections = 100

Connexion 1-100 : ‚úÖ Accept√©e
Connexion 101   : ‚ùå FATAL: sorry, too many clients already
```

Le message d'erreur complet :
```
FATAL: sorry, too many clients already
HINT: Increase "max_connections" and "shared_memory"
```

### Connexions R√©serv√©es

PostgreSQL r√©serve des connexions pour les superutilisateurs :

**superuser_reserved_connections** : 3 par d√©faut

**Calcul :**
```
Connexions disponibles pour utilisateurs normaux = max_connections - superuser_reserved_connections
                                                  = 100 - 3
                                                  = 97
```

**Pourquoi ?** Permet √† un admin de se connecter m√™me quand le syst√®me est satur√© pour investiguer.

### Modifier max_connections

**‚ö†Ô∏è Attention :** Augmenter max_connections n'est PAS toujours la solution !

```ini
# Dans postgresql.conf
max_connections = 200

# Red√©marrage n√©cessaire
sudo systemctl restart postgresql
```

**Cons√©quences :**
- ‚úÖ Plus de connexions accept√©es
- ‚ùå Plus de m√©moire consomm√©e
- ‚ùå Plus de context switching
- ‚ùå Performances possiblement d√©grad√©es

**R√®gle d'or :** Ne pas d√©passer 200-300 connexions sans connection pooling.

---

## Le Concept de Connection Pooling

### Qu'est-ce que le Connection Pooling ?

Le **connection pooling** est une technique qui r√©utilise un nombre limit√© de connexions PostgreSQL pour servir un grand nombre de clients.

### Analogie : Le Central T√©l√©phonique

**Sans pooling (ancien syst√®me) :**
- Chaque personne a sa propre ligne t√©l√©phonique d√©di√©e
- 1000 employ√©s = 1000 lignes physiques n√©cessaires
- Co√ªteux et inefficace

**Avec pooling (central moderne) :**
- 50 lignes partag√©es par 1000 employ√©s
- Le central route intelligemment les appels
- Beaucoup moins cher et tout aussi efficace
- Car tout le monde n'appelle pas en m√™me temps

### Principe du Pooling pour PostgreSQL

```
5000 clients application ‚îÄ‚îÄ‚îê
                           ‚îÇ
                           ‚îú‚îÄ‚îÄ‚Üí Connection Pool (100 connexions)
                           ‚îÇ
                           ‚îî‚îÄ‚îÄ‚Üí PostgreSQL (100 connexions actives)
```

**Magie :** 5000 clients peuvent travailler avec seulement 100 connexions PostgreSQL r√©elles !

**Comment ?** La plupart des clients passent 90% de leur temps √† ne PAS utiliser activement la connexion.

### Avantages du Connection Pooling

#### 1. R√©duction de la Charge Serveur

```
Sans pooling :
1000 clients ‚Üí 1000 connexions PostgreSQL ‚Üí Serveur satur√©

Avec pooling :
1000 clients ‚Üí Pool (50 connexions) ‚Üí PostgreSQL l√©ger
```

#### 2. Gestion Intelligente

- R√©utilisation des connexions (pas de cr√©ation/destruction constante)
- File d'attente quand le pool est plein
- Timeout automatique des connexions inactives

#### 3. Meilleure Performance Globale

- Moins de context switching
- Moins de m√©moire consomm√©e
- Plus de stabilit√©

#### 4. Protection Contre les Connection Storms

Lors d'un red√©marrage d'application, toutes les instances essaient de se connecter simultan√©ment.

**Sans pooling :**
```
Red√©marrage app ‚Üí 500 connexions en 2 secondes ‚Üí PostgreSQL satur√© ‚Üí Crash
```

**Avec pooling :**
```
Red√©marrage app ‚Üí Pool g√®re progressivement ‚Üí PostgreSQL stable
```

---

## PgBouncer : Le Pool de Connexions de R√©f√©rence

### Pr√©sentation

**PgBouncer** est le connection pooler le plus populaire pour PostgreSQL.

**Caract√©ristiques :**
- L√©ger (√©crit en C)
- Ultra-rapide
- Battle-tested (utilis√© par les plus gros sites)
- Open source

### Architecture

```
Applications (1000 clients)
         ‚Üì
   PgBouncer (middleware)
    Pool : 50 connexions
         ‚Üì
   PostgreSQL (50 connexions)
```

### Les Modes de Pooling

PgBouncer propose 3 modes de pooling :

#### 1. Session Pooling (Mode Session)

**Principe :** Une connexion PostgreSQL est attribu√©e √† un client pour toute la dur√©e de sa session.

```ini
pool_mode = session
```

**Comportement :**
- Client se connecte ‚Üí R√©cup√®re une connexion du pool
- Client travaille (peut faire plusieurs transactions)
- Client se d√©connecte ‚Üí Connexion retourne au pool

**Avantages :**
- ‚úÖ Compatible avec tout PostgreSQL (prepared statements, LISTEN/NOTIFY, etc.)
- ‚úÖ Comportement transparent

**Inconv√©nients :**
- ‚ùå Moins efficace (un client monopolise une connexion m√™me inactif)

**Usage :** Applications avec longues sessions interactives.

#### 2. Transaction Pooling (Mode Transaction)

**Principe :** Une connexion PostgreSQL est attribu√©e seulement pendant une transaction.

```ini
pool_mode = transaction  # Recommand√©
```

**Comportement :**
- Client commence transaction ‚Üí R√©cup√®re connexion
- Transaction commit/rollback ‚Üí Connexion retourne imm√©diatement au pool
- Client peut faire plusieurs transactions successives

**Avantages :**
- ‚úÖ Tr√®s efficace (r√©utilisation maximale)
- ‚úÖ Recommand√© pour la plupart des applications

**Inconv√©nients :**
- ‚ùå Incompatible avec prepared statements nomm√©s
- ‚ùå Incompatible avec LISTEN/NOTIFY
- ‚ùå Pas de variables de session temporaires

**Usage :** Applications web standards (REST APIs, sites web).

#### 3. Statement Pooling (Mode Statement)

**Principe :** Une connexion est retourn√©e au pool apr√®s chaque requ√™te SQL.

```ini
pool_mode = statement  # Rarement utilis√©
```

**Comportement :**
- Plus agressif que transaction
- M√™me les transactions multi-statements sont interrompues

**Avantages :**
- ‚úÖ R√©utilisation maximale absolue

**Inconv√©nients :**
- ‚ùå Casse les transactions
- ‚ùå Tr√®s peu d'applications compatibles

**Usage :** Tr√®s rare, seulement pour requ√™tes READ-ONLY ultra-simples.

### Configuration de PgBouncer

#### Installation

**Ubuntu/Debian :**
```bash
sudo apt install pgbouncer
```

**RHEL/CentOS :**
```bash
sudo yum install pgbouncer
```

#### Configuration de Base

**Fichier `/etc/pgbouncer/pgbouncer.ini` :**

```ini
[databases]
myapp = host=localhost port=5432 dbname=myapp_production

[pgbouncer]
# √âcoute sur toutes les interfaces, port 6432
listen_addr = *
listen_port = 6432

# Mode pooling (transaction recommand√©)
pool_mode = transaction

# Taille du pool
default_pool_size = 25          # Connexions PostgreSQL par base
max_client_conn = 500           # Clients maximum accept√©s

# Connexions de r√©serve
reserve_pool_size = 5           # Connexions en r√©serve
reserve_pool_timeout = 3        # Attente avant utiliser r√©serve (sec)

# Timeouts
server_idle_timeout = 600       # Fermer connexion inactive 10 min
query_timeout = 60              # Timeout requ√™te (60 sec)

# Logs
log_connections = 1
log_disconnections = 1
log_pooler_errors = 1

# Admin
admin_users = postgres
stats_users = monitoring_user
```

#### Fichier userlist.txt

Authentification des utilisateurs :

```
# /etc/pgbouncer/userlist.txt
"appuser" "md5d8578edf8458ce06fbc5bb76a58c5ca4"
"readonly" "md5xxxxxxxxxxxxxxxxxxxxxxxxxx"
```

**G√©n√©rer le hash MD5 :**
```bash
echo -n "passwordappuser" | md5sum
```

#### D√©marrage

```bash
sudo systemctl start pgbouncer
sudo systemctl enable pgbouncer
sudo systemctl status pgbouncer
```

### Connexion via PgBouncer

**Sans PgBouncer (direct √† PostgreSQL) :**
```bash
psql -h localhost -p 5432 -U appuser -d myapp_production
```

**Avec PgBouncer :**
```bash
psql -h localhost -p 6432 -U appuser -d myapp_production
# Port 6432 au lieu de 5432 !
```

**Dans votre application (exemple Python) :**
```python
import psycopg2

# Avant (direct)
conn = psycopg2.connect(
    host="localhost",
    port=5432,
    database="myapp_production",
    user="appuser",
    password="secret"
)

# Apr√®s (via PgBouncer)
conn = psycopg2.connect(
    host="localhost",
    port=6432,  # Port PgBouncer
    database="myapp_production",
    user="appuser",
    password="secret"
)
```

**Transparent pour l'application !**

---

## Dimensionner le Pool

### Formules de Calcul

#### Pool Size (Taille du Pool)

**R√®gle g√©n√©rale :**

```
pool_size = (2 √ó Nombre de CPU cores) + Nombre de disques effectifs
```

**Exemple :**
- Serveur avec 8 cores
- 2 disques (RAID 1)

```
pool_size = (2 √ó 8) + 2 = 18 connexions
```

**Recommandations par type d'application :**

| Type | Pool Size Recommand√© |
|------|---------------------|
| **Web app OLTP** | 20-30 |
| **API REST** | 15-25 |
| **Mixed (OLTP + analytique)** | 30-50 |
| **Serveur d√©di√© analytique** | 50-100 |

#### Max Client Connections

**R√®gle :**
```
max_client_conn = pool_size √ó 10 (minimum)
                = pool_size √ó 20 (confortable)
```

**Exemple avec pool_size = 25 :**
```
max_client_conn = 25 √ó 20 = 500 clients
```

### Monitoring de PgBouncer

#### Console Admin

**Connexion √† la console admin :**
```bash
psql -h localhost -p 6432 -U postgres pgbouncer
```

#### Commandes Essentielles

##### SHOW POOLS

Affiche l'√©tat des pools :

```sql
pgbouncer=# SHOW POOLS;
```

**Sortie :**
```
 database  | user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait
-----------+---------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 myapp     | appuser |        15 |          3 |        20 |       5 |       0 |         0 |        0 |       2
```

**Colonnes importantes :**
- **cl_active** : Clients actifs
- **cl_waiting** : Clients en attente (‚ö†Ô∏è si > 0, pool satur√©)
- **sv_active** : Connexions PostgreSQL actives
- **sv_idle** : Connexions PostgreSQL inactives disponibles
- **maxwait** : Temps d'attente max (secondes)

**‚ö†Ô∏è Alerte si :**
- `cl_waiting > 0` : Pool satur√©
- `maxwait > 5` : Attentes trop longues

##### SHOW STATS

Statistiques globales :

```sql
pgbouncer=# SHOW STATS;
```

**Sortie :**
```
 database  | total_xact_count | total_query_count | total_received | total_sent | avg_xact_time | avg_query_time
-----------+------------------+-------------------+----------------+------------+---------------+---------------
 myapp     |           125000 |            350000 |      500000000 |  800000000 |          12.5 |           8.3
```

##### SHOW CLIENTS

Liste des clients connect√©s :

```sql
pgbouncer=# SHOW CLIENTS;
```

##### SHOW SERVERS

Liste des connexions PostgreSQL :

```sql
pgbouncer=# SHOW SERVERS;
```

**Utile pour :** Voir combien de connexions sont r√©ellement ouvertes vers PostgreSQL.

##### Commandes Administratives

```sql
-- Recharger la configuration
RELOAD;

-- Fermer gracieusement les connexions inutilis√©es
RECONNECT database;

-- Suspendre temporairement
PAUSE database;

-- Reprendre
RESUME database;
```

---

## D√©tecter les Probl√®mes de Connexions

### Au Niveau PostgreSQL

#### 1. Voir les Connexions Actives

```sql
SELECT
    pid,
    usename,
    application_name,
    client_addr,
    state,
    backend_start,
    state_change,
    query
FROM pg_stat_activity
WHERE state != 'idle'
ORDER BY backend_start;
```

**Colonnes importantes :**
- **pid** : Process ID
- **state** : √âtat (active, idle, idle in transaction)
- **backend_start** : Moment de connexion
- **query** : Requ√™te en cours

#### 2. Compter les Connexions par √âtat

```sql
SELECT
    state,
    count(*) AS connection_count
FROM pg_stat_activity
GROUP BY state
ORDER BY connection_count DESC;
```

**Exemple de sortie :**
```
       state        | connection_count
--------------------+-----------------
 idle               |               45
 active             |               12
 idle in transaction|                3
```

**‚ö†Ô∏è Alerte si :**
- `idle in transaction` > 10 : Transactions oubli√©es (connection leaks)

#### 3. Connexions les Plus Anciennes

```sql
SELECT
    pid,
    usename,
    application_name,
    state,
    now() - backend_start AS connection_age,
    now() - state_change AS state_age
FROM pg_stat_activity
WHERE state != 'idle'
ORDER BY backend_start
LIMIT 20;
```

**‚ö†Ô∏è Alerte si :**
- Connexion ouverte depuis plusieurs heures en `idle in transaction`

#### 4. Utilisation vs Limite

```sql
SELECT
    (SELECT count(*) FROM pg_stat_activity) AS current_connections,
    (SELECT setting::int FROM pg_settings WHERE name = 'max_connections') AS max_connections,
    round(
        100.0 * (SELECT count(*) FROM pg_stat_activity) /
        (SELECT setting::int FROM pg_settings WHERE name = 'max_connections'),
        2
    ) AS usage_percent;
```

**Seuils :**
- < 70% : üü¢ OK
- 70-85% : üü° Surveill√©
- 85-95% : üü† Attention
- > 95% : üî¥ Critique (proche de la saturation)

### Sympt√¥mes de Saturation

#### C√¥t√© Application

**Erreurs visibles :**
```
FATAL: sorry, too many clients already
```

**Ou :**
```
Connection timeout
Could not connect to database
```

**Comportement :**
- Timeouts fr√©quents
- Erreurs intermittentes
- Performances en dents de scie

#### C√¥t√© Serveur

**Commande syst√®me :**
```bash
ps aux | grep postgres | wc -l
# Si proche de max_connections ‚Üí Probl√®me
```

**Logs PostgreSQL :**
```
/var/log/postgresql/postgresql-*.log
```

**Chercher :**
```bash
grep "too many clients" /var/log/postgresql/postgresql-*.log
```

---

## Connection Leaks (Fuites de Connexions)

### Qu'est-ce qu'un Connection Leak ?

Un **connection leak** se produit quand une application ouvre une connexion mais ne la ferme jamais.

**Analogie :** Ouvrir un robinet et partir sans le fermer.

### Causes Courantes

#### 1. Exceptions Non G√©r√©es

**Code probl√©matique (Python) :**
```python
# ‚ùå MAUVAIS
def mauvaise_fonction():
    conn = psycopg2.connect(...)
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users")
    # Si une exception se produit ici
    # la connexion n'est jamais ferm√©e !
    data = cursor.fetchall()
    conn.close()  # Cette ligne peut ne jamais s'ex√©cuter
```

**Code correct :**
```python
# ‚úÖ BON
def bonne_fonction():
    conn = None
    try:
        conn = psycopg2.connect(...)
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM users")
        data = cursor.fetchall()
        return data
    finally:
        if conn:
            conn.close()  # TOUJOURS ex√©cut√©
```

**Encore mieux (Python) :**
```python
# ‚úÖ MEILLEUR - Context manager
def meilleure_fonction():
    with psycopg2.connect(...) as conn:
        with conn.cursor() as cursor:
            cursor.execute("SELECT * FROM users")
            return cursor.fetchall()
    # Fermeture automatique garantie
```

#### 2. Transactions Oubli√©es

**Code probl√©matique :**
```python
# ‚ùå MAUVAIS
conn = psycopg2.connect(...)
conn.execute("BEGIN")
conn.execute("UPDATE users SET ...")
# Oubli de COMMIT ou ROLLBACK
# Connexion reste en "idle in transaction"
```

**Code correct :**
```python
# ‚úÖ BON
conn = psycopg2.connect(...)
try:
    conn.execute("BEGIN")
    conn.execute("UPDATE users SET ...")
    conn.execute("COMMIT")
except:
    conn.execute("ROLLBACK")
    raise
finally:
    conn.close()
```

#### 3. Pooling Applicatif Mal G√©r√©

Certains frameworks ont leur propre pooling. Si mal configur√© :

```python
# Configuration ORM (exemple)
# ‚ùå MAUVAIS
pool_size = 100      # Trop grand
max_overflow = 100   # Trop grand
```

### D√©tecter les Leaks

#### 1. Connexions "idle in transaction" Prolong√©es

```sql
SELECT
    pid,
    usename,
    application_name,
    client_addr,
    now() - state_change AS idle_time,
    query
FROM pg_stat_activity
WHERE state = 'idle in transaction'
    AND now() - state_change > interval '5 minutes'
ORDER BY idle_time DESC;
```

**Action :** Identifier l'application et corriger le code.

#### 2. Croissance Continue des Connexions

**Monitoring sur 1 heure :**
```bash
# Script de monitoring
while true; do
    echo "$(date): $(psql -t -c "SELECT count(*) FROM pg_stat_activity")"
    sleep 60
done
```

**Si le nombre augmente constamment :** Connection leak.

### Tuer des Connexions Bloqu√©es

**‚ö†Ô∏è √Ä utiliser avec prudence !**

#### Tuer une Connexion Sp√©cifique

```sql
-- 1. Identifier le PID
SELECT pid, usename, state, query
FROM pg_stat_activity
WHERE state = 'idle in transaction'
    AND now() - state_change > interval '30 minutes';

-- 2. Terminer gentiment
SELECT pg_terminate_backend(12345);  -- Remplacer 12345 par le PID

-- 3. Si √ßa ne fonctionne pas, forcer
SELECT pg_cancel_backend(12345);
```

#### Tuer Toutes les Connexions Idle

```sql
-- ‚ö†Ô∏è DANGEREUX - √Ä utiliser en dernier recours
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE state = 'idle in transaction'
    AND now() - state_change > interval '1 hour'
    AND pid != pg_backend_pid();  -- Ne pas se tuer soi-m√™me !
```

---

## Strat√©gies de Dimensionnement

### Approche par Type d'Application

#### Application Web (REST API)

**Caract√©ristiques :**
- Requ√™tes courtes (< 100ms)
- Trafic en rafales
- Nombreux clients simultan√©s

**Configuration recommand√©e :**

**PostgreSQL :**
```ini
max_connections = 100
```

**PgBouncer :**
```ini
pool_mode = transaction
default_pool_size = 25
max_client_conn = 1000
```

**Ratio :** 1 connexion PostgreSQL peut servir 40 clients.

#### Application Analytics/BI

**Caract√©ristiques :**
- Requ√™tes longues (plusieurs secondes)
- Peu de clients simultan√©s
- Grosses lectures

**Configuration recommand√©e :**

**PostgreSQL :**
```ini
max_connections = 50
```

**PgBouncer :**
```ini
pool_mode = session  # Requ√™tes longues
default_pool_size = 40
max_client_conn = 100
```

#### Application Mixte (OLTP + Analytics)

**Solution :** S√©parer les pools !

**PgBouncer :**
```ini
[databases]
myapp_oltp = host=localhost port=5432 dbname=myapp pool_size=25
myapp_analytics = host=localhost port=5432 dbname=myapp pool_size=15

[pgbouncer]
pool_mode = transaction  # Par d√©faut pour OLTP
```

**Usage :**
- Applications web ‚Üí Connecter √† `myapp_oltp`
- Rapports/Analytics ‚Üí Connecter √† `myapp_analytics`

### Formule de Calcul Compl√®te

```
Total connexions n√©cessaires =
    (Nombre d'app servers √ó Connexions par server) +
    (Nombre de workers background) +
    (Connexions outils de monitoring) +
    (Marge de s√©curit√© 20%)

Exemple :
    (10 app servers √ó 20 connexions) +
    (5 workers) +
    (3 monitoring) +
    (20% de 208) ‚âà 250 connexions max app

Avec pooling :
    Pool PgBouncer = 30-50 connexions PostgreSQL
    max_client_conn = 500-1000
```

---

## Alternatives et Outils Compl√©mentaires

### 1. PgPool-II

Alternative √† PgBouncer avec fonctionnalit√©s additionnelles :
- Connection pooling
- Load balancing
- R√©plication management

**Quand utiliser :**
- Besoin de load balancing automatique
- Architectures HA complexes

**Inconv√©nient :** Plus complexe √† configurer que PgBouncer.

### 2. Odyssey (Yandex)

Pooler moderne d√©velopp√© par Yandex.

**Avantages :**
- Multithread√© (meilleures perfs que PgBouncer sur multi-core)
- Configuration dynamique

**Inconv√©nient :** Moins mature que PgBouncer.

### 3. Connection Pooling Int√©gr√© (AWS RDS Proxy, etc.)

Les clouds providers proposent des solutions int√©gr√©es :

**AWS RDS Proxy :**
- Pooling g√©r√©
- Failover automatique
- Scaling transparent

**Avantages :**
- Z√©ro configuration
- Maintenance g√©r√©e

**Inconv√©nients :**
- Co√ªt suppl√©mentaire
- Moins de contr√¥le

### 4. Application-Level Pooling

De nombreux frameworks ont leur propre pooling :

**Python (SQLAlchemy) :**
```python
from sqlalchemy import create_engine

engine = create_engine(
    'postgresql://user:pass@localhost/db',
    pool_size=10,          # Taille du pool
    max_overflow=20,       # Connexions suppl√©mentaires possibles
    pool_timeout=30,       # Timeout si pool plein
    pool_recycle=3600      # Recycler connexions apr√®s 1h
)
```

**Java (HikariCP) :**
```java
HikariConfig config = new HikariConfig();
config.setJdbcUrl("jdbc:postgresql://localhost:5432/mydb");
config.setUsername("user");
config.setPassword("password");
config.setMaximumPoolSize(20);
config.setMinimumIdle(5);

HikariDataSource ds = new HikariDataSource(config);
```

**Node.js (node-postgres) :**
```javascript
const { Pool } = require('pg');

const pool = new Pool({
    host: 'localhost',
    port: 5432,
    database: 'mydb',
    user: 'user',
    password: 'password',
    max: 20,              // Taille max du pool
    idleTimeoutMillis: 30000,
    connectionTimeoutMillis: 2000,
});
```

**‚ö†Ô∏è Important :**
- Ne pas combiner pooling applicatif ET PgBouncer sans r√©flexion
- Risque de sur-pooling : 10 app servers √ó 20 connexions = 200 connexions r√©elles

**Recommandation :**
- **Petite app (1 serveur)** : Pooling applicatif suffit
- **Moyenne app (2-5 serveurs)** : Pooling applicatif + PgBouncer
- **Grande app (10+ serveurs)** : PgBouncer obligatoire

---

## Monitoring en Production

### M√©triques Essentielles

#### 1. Nombre de Connexions Actives

**Requ√™te PostgreSQL :**
```sql
SELECT count(*) as active_connections
FROM pg_stat_activity
WHERE state = 'active';
```

**Alerte :** Si > 80% de max_connections.

#### 2. Connexions Idle in Transaction

```sql
SELECT count(*) as idle_in_tx
FROM pg_stat_activity
WHERE state = 'idle in transaction';
```

**Alerte :** Si > 10.

#### 3. √âtat du Pool PgBouncer

```sql
-- Via console admin PgBouncer
SHOW POOLS;
```

**Alerte :** Si `cl_waiting > 0`.

#### 4. Max Wait Time

**PgBouncer :**
```sql
SELECT database, user, maxwait
FROM SHOW POOLS
WHERE maxwait > 5;
```

**Alerte :** Si `maxwait > 5 secondes`.

### Dashboard Grafana Recommand√©

**Panels √† cr√©er :**

1. **Active Connections** (Gauge)
   - Valeur actuelle vs max_connections
   - Seuil warning √† 70%, critical √† 85%

2. **Connections by State** (Pie chart)
   - active, idle, idle in transaction

3. **Connection Age Distribution** (Heatmap)
   - Dur√©e de vie des connexions

4. **PgBouncer Pool Status** (Time series)
   - cl_active, cl_waiting, sv_active, sv_idle

5. **Connection Rate** (Time series)
   - Nouvelles connexions / minute

6. **Top Applications by Connections** (Table)
   - Group by application_name

### Alertes Recommand√©es

#### Alerte 1 : Saturation Proche

```sql
-- Prometheus QL
(pg_stat_activity_count / pg_settings_max_connections) > 0.85
```

**Action :** V√©rifier origine des connexions, envisager scaling.

#### Alerte 2 : Connection Leaks

```sql
pg_stat_activity_idle_in_transaction_count > 10
```

**Action :** Investiguer applications, corriger code.

#### Alerte 3 : PgBouncer Pool Satur√©

```
pgbouncer_pools_cl_waiting > 0
```

**Action :** Augmenter pool_size ou investiguer requ√™tes lentes.

#### Alerte 4 : Connexions Anciennes

```sql
SELECT count(*)
FROM pg_stat_activity
WHERE state = 'active'
    AND now() - query_start > interval '5 minutes';
```

**Action :** Identifier et optimiser requ√™tes lentes.

---

## Troubleshooting : Sc√©narios Courants

### Sc√©nario 1 : "Too many clients already"

**Sympt√¥mes :**
- Erreur `FATAL: sorry, too many clients already`
- Application ne peut plus se connecter

**Diagnostic :**

```sql
-- V√©rifier utilisation
SELECT count(*) as current,
       (SELECT setting::int FROM pg_settings WHERE name = 'max_connections') as max
FROM pg_stat_activity;
```

**Causes possibles :**
1. Pas de connection pooling
2. Connection leaks dans le code
3. max_connections trop bas

**Solutions :**

**Court terme :**
```sql
-- Tuer connexions idle longues
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE state = 'idle'
    AND now() - state_change > interval '30 minutes';
```

**Moyen terme :**
- Impl√©menter PgBouncer

**Long terme :**
- Corriger connection leaks dans le code
- Dimensionner correctement

### Sc√©nario 2 : Performances D√©grad√©es avec Peu de Connexions

**Sympt√¥mes :**
- Seulement 30 connexions actives
- Mais syst√®me tr√®s lent

**Diagnostic :**

```sql
-- Identifier requ√™tes longues
SELECT pid, now() - query_start as duration, query
FROM pg_stat_activity
WHERE state = 'active'
    AND now() - query_start > interval '10 seconds'
ORDER BY duration DESC;
```

**Cause :** Requ√™tes lentes bloquant les connexions.

**Solution :**
- Optimiser les requ√™tes (voir section 13 Indexation)
- Augmenter le timeout
- Scaler les connexions disponibles

### Sc√©nario 3 : PgBouncer avec Clients en Attente

**Sympt√¥mes :**
- `cl_waiting > 0` dans SHOW POOLS
- Timeouts c√¥t√© application

**Diagnostic :**

```sql
-- Console PgBouncer
SHOW POOLS;
```

**Causes possibles :**
1. Pool trop petit
2. Requ√™tes qui prennent trop de temps
3. Mode pooling inadapt√©

**Solutions :**

```ini
# Augmenter pool
default_pool_size = 50  # Au lieu de 25

# Augmenter r√©serve
reserve_pool_size = 10

# Augmenter timeout si requ√™tes l√©gitimement longues
query_timeout = 120
```

### Sc√©nario 4 : Connexions Zombie

**Sympt√¥mes :**
- Connexions `idle in transaction` depuis des heures
- Bloat qui augmente (VACUUM bloqu√©)

**Diagnostic :**

```sql
SELECT pid, usename, application_name, client_addr,
       now() - state_change as idle_duration, query
FROM pg_stat_activity
WHERE state = 'idle in transaction'
ORDER BY state_change;
```

**Cause :** Application ne commit/rollback pas les transactions.

**Solution :**

**Imm√©diat :**
```sql
-- Tuer ces connexions
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE state = 'idle in transaction'
    AND now() - state_change > interval '1 hour';
```

**Pr√©vention :**
```ini
# postgresql.conf
idle_in_transaction_session_timeout = 300000  # 5 minutes en ms
```

---

## Bonnes Pratiques

### 1. Toujours Utiliser Connection Pooling en Production

**Sans exception**, d√®s que vous avez plus d'un serveur d'application.

### 2. Dimensionner Correctement

**R√®gles :**
- Ne jamais d√©passer 200 connexions PostgreSQL sans tr√®s bonne raison
- Pool PgBouncer : 2-4√ó le nombre de cores CPU
- Pr√©voir 20% de marge

### 3. G√©rer Proprement les Connexions dans le Code

```python
# ‚úÖ BON - Toujours utiliser context managers
with get_db_connection() as conn:
    with conn.cursor() as cursor:
        cursor.execute(...)
# Fermeture automatique garantie
```

### 4. Monitorer en Continu

**M√©triques critiques :**
- Nombre de connexions actives
- Connexions idle in transaction
- √âtat du pool PgBouncer
- Temps d'attente (maxwait)

### 5. Configurer des Timeouts

**PostgreSQL :**
```ini
statement_timeout = 30s               # Timeout requ√™te
idle_in_transaction_session_timeout = 5min  # Timeout transaction idle
```

**PgBouncer :**
```ini
query_timeout = 60        # 60 secondes max par requ√™te
server_idle_timeout = 600 # 10 minutes
```

### 6. S√©parer les Workloads

**Utilisez des pools diff√©rents pour :**
- Requ√™tes OLTP (rapides)
- Requ√™tes Analytics (lentes)
- Batch jobs
- Monitoring

### 7. Tester sous Charge

**Avant la production :**
- Load testing avec JMeter, Gatling, etc.
- Simuler connection storms
- V√©rifier comportement en saturation

---

## Questions Fr√©quentes (FAQ)

### Q1 : Combien de connexions max_connections dois-je configurer ?

**R√©ponse :**
- **Avec PgBouncer** : 100-200 (rarement plus)
- **Sans pooling** : 2√ó le nombre d'app servers √ó connexions par serveur

### Q2 : PgBouncer ou pooling applicatif ?

**R√©ponse :**
- **< 50 connexions totales** : Pooling applicatif suffit
- **> 50 connexions** : PgBouncer recommand√©
- **> 100 connexions** : PgBouncer obligatoire

### Q3 : Quel mode PgBouncer choisir ?

**R√©ponse :**
- **Transaction** : 90% des cas (recommand√©)
- **Session** : Si vous utilisez prepared statements ou LISTEN/NOTIFY
- **Statement** : Tr√®s rare

### Q4 : Connection leaks : comment les √©viter ?

**R√©ponse :**
- Toujours utiliser try/finally ou context managers
- Configurer `idle_in_transaction_session_timeout`
- Monitorer les connexions idle in transaction

### Q5 : Puis-je augmenter max_connections √† 1000 ?

**R√©ponse :**
**Techniquement oui, mais ne le faites pas !**
- Chaque connexion = 10 MB RAM
- 1000 connexions = 10 GB rien que pour les connexions
- Context switching catastrophique
- Utilisez PgBouncer √† la place

### Q6 : Mon pool PgBouncer est toujours plein, que faire ?

**R√©ponses possibles :**
1. Augmenter pool_size (jusqu'√† 2-4√ó CPU cores)
2. Optimiser les requ√™tes lentes
3. V√©rifier pas de connexions bloqu√©es
4. Scaler horizontalement (plus de serveurs PostgreSQL)

---

## Points Cl√©s √† Retenir

‚úÖ **PostgreSQL = 1 processus par connexion**
   - Co√ªteux en ressources (m√©moire, CPU)
   - Limitation par max_connections (d√©faut : 100)

‚úÖ **Connection Pooling = Solution incontournable**
   - R√©utilise un petit pool pour servir beaucoup de clients
   - PgBouncer = Standard de facto

‚úÖ **Modes de pooling :**
   - Transaction : Recommand√© (90% des cas)
   - Session : Compatible tout PostgreSQL
   - Statement : Tr√®s rare

‚úÖ **Dimensionnement :**
   - Pool size : 2-4√ó CPU cores
   - max_client_conn : 10-20√ó pool_size
   - Ne jamais d√©passer 200 connexions PostgreSQL sans raison

‚úÖ **Connection leaks = Probl√®me fr√©quent**
   - Toujours fermer les connexions (try/finally)
   - Monitorer "idle in transaction"
   - Configurer timeouts

‚úÖ **Monitoring essentiel :**
   - Nombre connexions actives vs max
   - √âtat du pool PgBouncer
   - Connexions idle in transaction
   - Temps d'attente (maxwait)

‚úÖ **Signaux d'alerte :**
   - "Too many clients already"
   - cl_waiting > 0 dans PgBouncer
   - Connexions > 80% de max
   - Idle in transaction > 10

---

## Conclusion

La gestion des **connexions** est un aspect critique souvent sous-estim√© de PostgreSQL. Une mauvaise configuration peut transformer une base de donn√©es puissante en goulot d'√©tranglement majeur.

Les points essentiels √† retenir :

1. **Comprendre le co√ªt** : Chaque connexion est un processus complet avec son overhead
2. **Utiliser le pooling** : PgBouncer est votre meilleur ami en production
3. **Dimensionner intelligemment** : Moins c'est souvent mieux (qualit√© > quantit√©)
4. **√âviter les leaks** : Code propre avec gestion d'erreurs appropri√©e
5. **Monitorer activement** : D√©tecter les probl√®mes avant qu'ils deviennent critiques

Avec **PgBouncer** correctement configur√©, vous pouvez facilement supporter des milliers de clients applicatifs avec seulement 50-100 connexions PostgreSQL r√©elles. C'est la diff√©rence entre un syst√®me qui scale et un syst√®me qui s'effondre sous la charge.

L'investissement dans une bonne architecture de connexions se paye au centuple en stabilit√©, performances et s√©r√©nit√© op√©rationnelle.

---


‚è≠Ô∏è [Checkpoints et WAL generation](/14-observabilite-et-monitoring/06.5-checkpoints-wal-generation.md)
