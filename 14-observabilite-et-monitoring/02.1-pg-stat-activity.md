üîù Retour au [Sommaire](/SOMMAIRE.md)

# 14.2.1. pg_stat_activity : Activit√© en cours

## Introduction

La vue `pg_stat_activity` est l'une des vues syst√®me les plus importantes de PostgreSQL. Elle vous permet de voir en temps r√©el ce qui se passe dans votre base de donn√©es : quelles requ√™tes sont en cours d'ex√©cution, qui les ex√©cute, depuis combien de temps elles tournent, et bien plus encore.

Pensez √† `pg_stat_activity` comme √† un tableau de bord en direct de votre base de donn√©es. C'est souvent le premier endroit o√π vous regarderez lorsque vous voudrez diagnostiquer un probl√®me de performance ou comprendre ce qui se passe actuellement dans PostgreSQL.

## Pourquoi pg_stat_activity est importante ?

Dans un environnement de production, vous devez pouvoir r√©pondre √† des questions comme :

- Combien de connexions actives sont ouvertes en ce moment ?
- Quelle requ√™te est en train de bloquer les autres ?
- Pourquoi ma base de donn√©es est-elle lente ?
- Qui est connect√© et depuis combien de temps ?
- Y a-t-il des requ√™tes qui tournent anormalement longtemps ?

`pg_stat_activity` vous donne les r√©ponses √† toutes ces questions.

## Acc√©der √† pg_stat_activity

Pour consulter cette vue, il suffit d'ex√©cuter une simple requ√™te SQL :

```sql
SELECT * FROM pg_stat_activity;
```

Cependant, cette requ√™te retourne beaucoup de colonnes (plus de 20 !). En pratique, on s√©lectionne g√©n√©ralement uniquement les colonnes qui nous int√©ressent.

## Les colonnes principales de pg_stat_activity

Voici les colonnes les plus importantes √† conna√Ætre :

### 1. **datid** et **datname**
- **datid** : L'identifiant num√©rique de la base de donn√©es
- **datname** : Le nom de la base de donn√©es √† laquelle la session est connect√©e

**Exemple d'usage :**
```sql
SELECT datname, count(*)
FROM pg_stat_activity
GROUP BY datname;
```
Cette requ√™te vous montre combien de connexions sont actives par base de donn√©es.

### 2. **pid**
Le **Process ID** (identifiant du processus backend PostgreSQL). C'est un nombre unique pour chaque connexion active. Si vous devez tuer une connexion probl√©matique, vous utiliserez ce PID.

**Exemple :**
```sql
-- Trouver le PID d'une connexion sp√©cifique
SELECT pid, usename, query
FROM pg_stat_activity
WHERE usename = 'mon_utilisateur';
```

### 3. **usename**
Le nom de l'utilisateur PostgreSQL qui a ouvert la connexion.

**Cas d'usage :** Identifier qui ex√©cute une requ√™te particuli√®re ou combien de connexions un utilisateur sp√©cifique a ouvertes.

### 4. **application_name**
Le nom de l'application cliente qui a √©tabli la connexion. Cela peut √™tre configur√© par l'application (par exemple : "mon_api", "job_nocturne", "psql").

**Pourquoi c'est utile ?** Dans un environnement avec plusieurs applications connect√©es √† la m√™me base, cela vous aide √† identifier quelle application cause un probl√®me.

### 5. **client_addr** et **client_port**
- **client_addr** : L'adresse IP du client
- **client_port** : Le port utilis√© par le client

**Cas d'usage :** Identifier d'o√π viennent les connexions, d√©tecter des connexions suspectes.

### 6. **backend_start**
L'horodatage indiquant quand la connexion a √©t√© √©tablie.

**Exemple :**
```sql
-- Trouver les connexions ouvertes depuis plus de 1 heure
SELECT pid, usename, backend_start, now() - backend_start AS duree_connexion
FROM pg_stat_activity
WHERE now() - backend_start > interval '1 hour';
```

### 7. **state**
L'√©tat actuel de la session. C'est l'une des colonnes les plus importantes !

**Valeurs possibles :**

- **active** : La session ex√©cute actuellement une requ√™te
- **idle** : La session est connect√©e mais n'ex√©cute rien (en attente de commande)
- **idle in transaction** : La session est dans une transaction mais n'ex√©cute pas de requ√™te (‚ö†Ô∏è peut √™tre probl√©matique !)
- **idle in transaction (aborted)** : Une transaction a √©chou√© mais n'a pas √©t√© ferm√©e
- **fastpath function call** : La session ex√©cute une fonction en mode "fast-path"
- **disabled** : Le suivi est d√©sactiv√© pour ce backend

**Exemple d'analyse des √©tats :**
```sql
SELECT state, count(*)
FROM pg_stat_activity
GROUP BY state;
```

**‚ö†Ô∏è Attention √† "idle in transaction" !**

Une session en `idle in transaction` garde des verrous et peut bloquer d'autres op√©rations. Si vous voyez beaucoup de ces sessions, ou qu'elles durent longtemps, c'est un signe de probl√®me dans votre code applicatif (transactions non ferm√©es proprement).

### 8. **query**
Le texte de la requ√™te SQL actuellement en cours d'ex√©cution (ou la derni√®re requ√™te ex√©cut√©e si la session est idle).

**Note :** Par d√©faut, seule la requ√™te en cours est visible. Les requ√™tes pass√©es ne sont pas conserv√©es dans cette vue.

**Exemple :**
```sql
-- Voir toutes les requ√™tes actives
SELECT pid, usename, state, query
FROM pg_stat_activity
WHERE state = 'active';
```

### 9. **query_start**
L'horodatage indiquant quand la requ√™te actuelle a commenc√©.

**Cas d'usage crucial :** Identifier les requ√™tes qui tournent trop longtemps.

**Exemple - Trouver les requ√™tes lentes :**
```sql
SELECT
    pid,
    usename,
    now() - query_start AS duree,
    state,
    query
FROM pg_stat_activity
WHERE state = 'active'
  AND now() - query_start > interval '5 minutes'
ORDER BY duree DESC;
```

### 10. **xact_start**
L'horodatage indiquant quand la transaction actuelle a commenc√©.

**Diff√©rence avec query_start :** Une transaction peut contenir plusieurs requ√™tes. `xact_start` vous indique le d√©but de la transaction, tandis que `query_start` indique le d√©but de la requ√™te en cours.

### 11. **wait_event_type** et **wait_event**
Ces colonnes vous indiquent si la session est en attente et pourquoi.

**wait_event_type** peut √™tre :
- **LWLock** : Attente d'un verrou l√©ger (light-weight lock)
- **Lock** : Attente d'un verrou classique
- **BufferPin** : Attente pour acc√©der √† un buffer
- **IO** : Attente d'une op√©ration disque
- **Client** : En attente du client
- **Extension** : En attente dans une extension
- **Timeout** : En attente d'un timeout

**wait_event** donne plus de d√©tails sur l'√©v√©nement pr√©cis.

**Exemple - Identifier les sessions bloqu√©es :**
```sql
SELECT
    pid,
    usename,
    wait_event_type,
    wait_event,
    query
FROM pg_stat_activity
WHERE wait_event_type IS NOT NULL
  AND state = 'active';
```

### 12. **backend_type**
Le type de processus backend. Cela permet de distinguer les connexions clients des processus internes.

**Valeurs possibles :**
- **client backend** : Connexion cliente normale
- **autovacuum worker** : Processus autovacuum
- **logical replication worker** : Travailleur de r√©plication logique
- **parallel worker** : Travailleur parall√®le
- **background writer** : Processus d'√©criture en arri√®re-plan
- **checkpointer** : Processus de checkpoint
- **walwriter** : Processus d'√©criture WAL
- etc.

**Exemple - Voir uniquement les connexions clients :**
```sql
SELECT pid, usename, state, query
FROM pg_stat_activity
WHERE backend_type = 'client backend';
```

## Requ√™tes pratiques courantes

### 1. Voir toutes les connexions actives avec requ√™tes en cours

```sql
SELECT
    pid,
    usename,
    application_name,
    client_addr,
    state,
    query_start,
    query
FROM pg_stat_activity
WHERE state = 'active'
ORDER BY query_start;
```

### 2. Compter le nombre de connexions par √©tat

```sql
SELECT
    state,
    count(*) AS nombre_connexions
FROM pg_stat_activity
GROUP BY state
ORDER BY count(*) DESC;
```

### 3. Identifier les requ√™tes longues (> 10 minutes)

```sql
SELECT
    pid,
    usename,
    application_name,
    now() - query_start AS duree,
    state,
    left(query, 100) AS requete_tronquee -- On tronque pour la lisibilit√©
FROM pg_stat_activity
WHERE state = 'active'
  AND now() - query_start > interval '10 minutes'
ORDER BY duree DESC;
```

### 4. Trouver les transactions en attente (idle in transaction)

```sql
SELECT
    pid,
    usename,
    application_name,
    now() - xact_start AS duree_transaction,
    state,
    query
FROM pg_stat_activity
WHERE state LIKE 'idle in transaction%'
  AND xact_start IS NOT NULL
ORDER BY xact_start;
```

**‚ö†Ô∏è Ces transactions peuvent causer des probl√®mes de performance !**

### 5. Compter les connexions par utilisateur

```sql
SELECT
    usename,
    count(*) AS nombre_connexions
FROM pg_stat_activity
WHERE backend_type = 'client backend'
GROUP BY usename
ORDER BY count(*) DESC;
```

### 6. Compter les connexions par application

```sql
SELECT
    application_name,
    count(*) AS nombre_connexions
FROM pg_stat_activity
GROUP BY application_name
ORDER BY count(*) DESC;
```

### 7. Identifier les sessions bloqu√©es et bloquantes

Cette requ√™te est plus avanc√©e mais tr√®s utile :

```sql
SELECT
    blocked.pid AS blocked_pid,
    blocked.usename AS blocked_user,
    blocking.pid AS blocking_pid,
    blocking.usename AS blocking_user,
    blocked.query AS blocked_query,
    blocking.query AS blocking_query
FROM pg_stat_activity AS blocked
JOIN pg_locks AS blocked_locks ON blocked.pid = blocked_locks.pid
JOIN pg_locks AS blocking_locks ON
    blocked_locks.locktype = blocking_locks.locktype
    AND blocked_locks.database IS NOT DISTINCT FROM blocking_locks.database
    AND blocked_locks.relation IS NOT DISTINCT FROM blocking_locks.relation
    AND blocked_locks.page IS NOT DISTINCT FROM blocking_locks.page
    AND blocked_locks.tuple IS NOT DISTINCT FROM blocking_locks.tuple
    AND blocked_locks.virtualxid IS NOT DISTINCT FROM blocking_locks.virtualxid
    AND blocked_locks.transactionid IS NOT DISTINCT FROM blocking_locks.transactionid
    AND blocked_locks.classid IS NOT DISTINCT FROM blocking_locks.classid
    AND blocked_locks.objid IS NOT DISTINCT FROM blocking_locks.objid
    AND blocked_locks.objsubid IS NOT DISTINCT FROM blocking_locks.objsubid
    AND blocked_locks.pid != blocking_locks.pid
JOIN pg_stat_activity AS blocking ON blocking_locks.pid = blocking.pid
WHERE NOT blocked_locks.granted;
```

**Note :** Cette requ√™te combine `pg_stat_activity` avec `pg_locks` (vue des verrous).

### 8. Vue simplifi√©e avec les informations essentielles

```sql
SELECT
    pid,
    usename AS utilisateur,
    application_name AS application,
    client_addr AS adresse_ip,
    state AS etat,
    CASE
        WHEN state = 'active' THEN now() - query_start
        ELSE NULL
    END AS duree_requete,
    CASE
        WHEN state LIKE 'idle in transaction%' THEN now() - xact_start
        ELSE NULL
    END AS duree_transaction,
    left(query, 80) AS requete
FROM pg_stat_activity
WHERE backend_type = 'client backend'
ORDER BY
    CASE state
        WHEN 'active' THEN 1
        WHEN 'idle in transaction' THEN 2
        ELSE 3
    END,
    query_start;
```

## G√©rer les connexions probl√©matiques

### Terminer une connexion sp√©cifique

Si vous identifiez une connexion probl√©matique (requ√™te bloquante, transaction longue), vous pouvez la terminer :

```sql
-- Terminer proprement une connexion (permet au client de nettoyer)
SELECT pg_cancel_backend(PID);

-- Terminer imm√©diatement une connexion (plus brutal)
SELECT pg_terminate_backend(PID);
```

**Diff√©rence :**
- `pg_cancel_backend()` : Envoie un signal d'annulation. Le client peut intercepter et nettoyer.
- `pg_terminate_backend()` : Ferme imm√©diatement la connexion. Plus radical.

**Exemple pratique :**
```sql
-- Annuler toutes les requ√™tes actives de plus de 30 minutes
SELECT pg_cancel_backend(pid)
FROM pg_stat_activity
WHERE state = 'active'
  AND now() - query_start > interval '30 minutes'
  AND pid != pg_backend_pid(); -- Ne pas se tuer soi-m√™me !
```

## Permissions et s√©curit√©

**Important :** Tous les utilisateurs ne peuvent pas voir toutes les sessions dans `pg_stat_activity`.

- Les **superutilisateurs** voient toutes les sessions
- Les **utilisateurs normaux** voient uniquement leurs propres sessions
- Les membres du r√¥le `pg_read_all_stats` peuvent voir toutes les sessions

**Pour donner l'acc√®s en lecture √† un utilisateur :**
```sql
GRANT pg_read_all_stats TO mon_utilisateur;
```

## Limitations et consid√©rations

### 1. Performance
Interroger `pg_stat_activity` est g√©n√©ralement tr√®s rapide, mais dans un syst√®me avec des milliers de connexions, cela peut avoir un l√©ger impact. √âvitez de l'interroger en boucle trop rapidement.

### 2. Le param√®tre track_activities
Si `track_activities` est d√©sactiv√© dans la configuration PostgreSQL, `pg_stat_activity` ne montrera pas les requ√™tes. Par d√©faut, ce param√®tre est activ√© (`on`).

```sql
-- V√©rifier la configuration
SHOW track_activities;
```

### 3. Visibilit√© de la colonne query
Par d√©faut, seule la requ√™te en cours ou la derni√®re requ√™te ex√©cut√©e est visible. PostgreSQL ne garde pas d'historique des requ√™tes dans cette vue.

Pour un historique complet, vous devez utiliser `pg_stat_statements` (extension √† activer s√©par√©ment).

## Cas d'usage en production

### Sc√©nario 1 : "Ma base de donn√©es est lente !"

**√âtapes de diagnostic :**

1. **V√©rifier les requ√™tes actives longues :**
```sql
SELECT pid, usename, now() - query_start AS duree, query
FROM pg_stat_activity
WHERE state = 'active'
ORDER BY duree DESC
LIMIT 10;
```

2. **V√©rifier les transactions idle :**
```sql
SELECT count(*), max(now() - xact_start) AS max_duree
FROM pg_stat_activity
WHERE state LIKE 'idle in transaction%';
```

3. **V√©rifier le nombre de connexions :**
```sql
SELECT count(*) AS total_connexions, max_connections
FROM pg_stat_activity, (SELECT setting::int AS max_connections FROM pg_settings WHERE name = 'max_connections') AS config;
```

### Sc√©nario 2 : "Combien de connexions puis-je encore ouvrir ?"

```sql
SELECT
    (SELECT setting::int FROM pg_settings WHERE name = 'max_connections') AS max_connexions,
    count(*) AS connexions_actives,
    (SELECT setting::int FROM pg_settings WHERE name = 'max_connections') - count(*) AS connexions_disponibles
FROM pg_stat_activity;
```

### Sc√©nario 3 : "Une application ne r√©pond plus"

```sql
-- Identifier les sessions de l'application
SELECT
    pid,
    state,
    now() - query_start AS duree,
    query
FROM pg_stat_activity
WHERE application_name = 'mon_application'
ORDER BY query_start;
```

Si vous voyez des requ√™tes bloqu√©es, cherchez les verrous avec `pg_locks`.

## Monitoring automatis√©

Dans un environnement de production, vous ne devez pas consulter `pg_stat_activity` manuellement. Utilisez des outils de monitoring qui le font pour vous :

- **Prometheus + postgres_exporter** : Exporte des m√©triques comme le nombre de connexions, les requ√™tes longues, etc.
- **pgBadger** : Analyse les logs pour identifier les probl√®mes
- **pgAdmin, DBeaver, DataGrip** : Interfaces graphiques avec vues temps r√©el
- **Solutions cloud** : AWS RDS Performance Insights, Azure Database Insights, etc.

**Exemple de m√©trique Prometheus :**
```sql
-- Nombre de connexions actives par √©tat
SELECT state, count(*)
FROM pg_stat_activity
GROUP BY state;
```

Cette requ√™te peut √™tre export√©e et visualis√©e dans Grafana.

## Bonnes pratiques

1. **Ne restez pas connect√© inutilement** : Fermez les connexions quand vous ne les utilisez plus.

2. **Fermez vos transactions** : Les transactions `idle in transaction` sont un probl√®me majeur. Assurez-vous que votre code applicatif fait toujours un `COMMIT` ou `ROLLBACK`.

3. **Utilisez un connection pooler** : Des outils comme **PgBouncer** limitent le nombre de connexions r√©elles √† PostgreSQL et am√©liorent les performances.

4. **Configurez des timeouts** : Le param√®tre `idle_in_transaction_session_timeout` peut automatiquement tuer les transactions idle apr√®s un d√©lai.

```sql
-- Exemple : Tuer automatiquement les transactions idle apr√®s 10 minutes
ALTER SYSTEM SET idle_in_transaction_session_timeout = '10min';
SELECT pg_reload_conf();
```

5. **Surveillez r√©guli√®rement** : Mettez en place des alertes sur :
   - Nombre de connexions approchant `max_connections`
   - Requ√™tes d√©passant un certain temps (ex: 1 minute)
   - Transactions `idle in transaction` de plus de 5 minutes

## R√©sum√©

`pg_stat_activity` est votre fen√™tre en temps r√©el sur l'activit√© de PostgreSQL. Les colonnes principales √† retenir :

| Colonne | Description |
|---------|-------------|
| **pid** | Identifiant du processus (pour tuer une connexion) |
| **usename** | Utilisateur connect√© |
| **state** | √âtat de la session (active, idle, idle in transaction) |
| **query** | Requ√™te SQL en cours ou derni√®re ex√©cut√©e |
| **query_start** | D√©but de la requ√™te en cours |
| **xact_start** | D√©but de la transaction en cours |
| **wait_event** | √âv√©nement d'attente (si bloqu√©) |
| **backend_type** | Type de processus (client, autovacuum, etc.) |

**Points cl√©s :**
- Identifiez rapidement les requ√™tes lentes avec `query_start`
- Surveillez les transactions `idle in transaction` (probl√©matiques !)
- Utilisez `pg_cancel_backend()` ou `pg_terminate_backend()` pour g√©rer les connexions probl√©matiques
- Combinez avec `pg_locks` pour analyser les blocages
- Automatisez le monitoring en production

Avec `pg_stat_activity`, vous avez un outil puissant pour comprendre et diagnostiquer ce qui se passe dans votre base de donn√©es PostgreSQL. C'est un incontournable pour tout d√©veloppeur ou administrateur de bases de donn√©es.

---

**Prochaines √©tapes :** Explorez les autres vues syst√®me comme `pg_stat_database`, `pg_stat_user_tables`, et `pg_locks` pour une vision encore plus compl√®te de votre instance PostgreSQL.

‚è≠Ô∏è [pg_stat_database : M√©triques par base](/14-observabilite-et-monitoring/02.2-pg-stat-database.md)
