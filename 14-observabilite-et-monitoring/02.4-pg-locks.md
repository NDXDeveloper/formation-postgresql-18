üîù Retour au [Sommaire](/SOMMAIRE.md)

# 14.2.4. pg_locks : Verrous actifs

## Introduction

La vue `pg_locks` est une vue syst√®me qui affiche tous les verrous (locks) actuellement actifs ou en attente dans votre instance PostgreSQL. C'est l'outil de diagnostic principal pour comprendre les probl√®mes de blocage entre transactions, les deadlocks, et les contentions de ressources.

Imaginez `pg_locks` comme un registre en temps r√©el de "qui utilise quoi" dans votre base de donn√©es. Chaque fois qu'une transaction lit ou modifie des donn√©es, PostgreSQL pose des verrous pour garantir la coh√©rence. Cette vue vous montre tous ces verrous actifs.

## Pourquoi les verrous existent-ils ?

Les verrous sont essentiels pour maintenir l'int√©grit√© des donn√©es dans un syst√®me multi-utilisateurs. Sans verrous, vous pourriez avoir :

- **Lectures sales (Dirty Reads)** : Lire des donn√©es non valid√©es d'une autre transaction
- **√âcrasements de donn√©es** : Deux transactions modifient la m√™me ligne simultan√©ment
- **Incoh√©rences** : Lire des donn√©es dans un √©tat transitoire invalide

PostgreSQL utilise un syst√®me de verrous sophistiqu√© pour permettre √† plusieurs transactions de travailler en parall√®le tout en garantissant l'isolation et la coh√©rence (principes ACID).

## Comprendre les concepts de base

### Qu'est-ce qu'un verrou (lock) ?

Un verrou est une marque pos√©e sur une ressource (table, ligne, index, etc.) qui indique qu'une transaction l'utilise. Il existe diff√©rents types de verrous avec diff√©rents niveaux de restriction :

- **Verrous partag√©s (SHARE)** : Plusieurs transactions peuvent lire, mais aucune ne peut √©crire
- **Verrous exclusifs (EXCLUSIVE)** : Une seule transaction peut acc√©der √† la ressource

### Types de ressources verrouillables

PostgreSQL peut poser des verrous sur :

1. **Relations** : Tables, index, s√©quences, vues mat√©rialis√©es
2. **Lignes (Tuples)** : Lignes individuelles dans une table
3. **Pages** : Blocs de donn√©es
4. **Transactions** : Identifiants de transaction
5. **Objets** : Autres objets de la base

### Conflits de verrous

Un conflit se produit quand une transaction demande un verrou incompatible avec un verrou d√©j√† pos√© par une autre transaction. Dans ce cas :

- La transaction demandeuse **attend** que le verrou soit lib√©r√©
- Si toutes les transactions attendent mutuellement ‚Üí **Deadlock** (interblocage)

## Acc√©der √† pg_locks

```sql
SELECT * FROM pg_locks;
```

Cette requ√™te montre tous les verrous actifs dans l'instance. Vous verrez g√©n√©ralement beaucoup de lignes, m√™me sur un syst√®me peu charg√©, car PostgreSQL pose des verrous pour presque toutes les op√©rations.

**Vue simplifi√©e :**
```sql
SELECT
    locktype,
    database,
    relation::regclass AS table_name,
    mode,
    granted,
    pid
FROM pg_locks
WHERE NOT granted  -- Verrous en attente uniquement
ORDER BY pid;
```

## Les colonnes principales de pg_locks

### 1. **locktype**

Le type de ressource verrouill√©e. C'est la colonne la plus importante pour comprendre ce qui est bloqu√©.

**Valeurs principales :**

- **relation** : Verrou sur une table, index, s√©quence, ou vue mat√©rialis√©e
- **tuple** : Verrou sur une ligne sp√©cifique (rare, g√©n√©ralement lors d'un UPDATE/DELETE)
- **transactionid** : Verrou sur un identifiant de transaction (tr√®s courant)
- **virtualxid** : Verrou sur un identifiant de transaction virtuel
- **object** : Verrou sur un objet de base de donn√©es (fonction, type personnalis√©, etc.)
- **page** : Verrou sur une page sp√©cifique (rare)
- **advisory** : Verrou applicatif personnalis√© (Advisory Lock)

**Exemple :**
```sql
SELECT locktype, count(*)
FROM pg_locks
GROUP BY locktype
ORDER BY count(*) DESC;
```

### 2. **database**

L'OID de la base de donn√©es o√π se trouve la ressource verrouill√©e. Peut √™tre NULL pour les verrous globaux.

**Traduire l'OID en nom de base :**
```sql
SELECT
    l.locktype,
    d.datname AS database_name,
    l.mode,
    l.granted
FROM pg_locks l
LEFT JOIN pg_database d ON l.database = d.oid
ORDER BY d.datname;
```

### 3. **relation**

L'OID de la relation (table, index, s√©quence) verrouill√©e. NULL si le verrou n'est pas sur une relation.

**Traduire l'OID en nom de table :**
```sql
SELECT
    locktype,
    relation::regclass AS table_name,
    mode,
    granted,
    pid
FROM pg_locks
WHERE relation IS NOT NULL
ORDER BY relation;
```

**Note :** La conversion `::regclass` transforme automatiquement l'OID en nom lisible de table.

### 4. **mode**

Le mode du verrou demand√©. C'est crucial pour comprendre le niveau de restriction.

**Modes de verrous sur les tables (du moins au plus restrictif) :**

1. **AccessShareLock** : Lecture simple (SELECT)
   - Compatible avec presque tout sauf AccessExclusiveLock

2. **RowShareLock** : SELECT FOR UPDATE/SHARE
   - Emp√™che les modifications de structure (ALTER, DROP)

3. **RowExclusiveLock** : INSERT, UPDATE, DELETE
   - Emp√™che LOCK TABLE en mode SHARE ou plus restrictif

4. **ShareUpdateExclusiveLock** : VACUUM, ANALYZE, CREATE INDEX CONCURRENTLY
   - Emp√™che les modifications de sch√©ma et autres VACUUM

5. **ShareLock** : CREATE INDEX (non concurrent)
   - Emp√™che les √©critures (INSERT, UPDATE, DELETE)

6. **ShareRowExclusiveLock** : Rare, combinaison de SHARE et ROW EXCLUSIVE

7. **ExclusiveLock** : REFRESH MATERIALIZED VIEW CONCURRENTLY
   - Emp√™che tout sauf AccessShareLock

8. **AccessExclusiveLock** : ALTER TABLE, DROP TABLE, TRUNCATE, REINDEX, VACUUM FULL
   - Bloque TOUT acc√®s (lecture et √©criture)

**Matrice de compatibilit√© :**

| Mode demand√© | Conflits avec |
|--------------|---------------|
| AccessShareLock | AccessExclusiveLock |
| RowShareLock | ExclusiveLock, AccessExclusiveLock |
| RowExclusiveLock | ShareLock, ShareRowExclusiveLock, ExclusiveLock, AccessExclusiveLock |
| ShareUpdateExclusiveLock | ShareUpdateExclusiveLock, ShareLock, ShareRowExclusiveLock, ExclusiveLock, AccessExclusiveLock |
| ShareLock | RowExclusiveLock, ShareUpdateExclusiveLock, ShareRowExclusiveLock, ExclusiveLock, AccessExclusiveLock |
| ShareRowExclusiveLock | Tout sauf AccessShareLock et RowShareLock |
| ExclusiveLock | Tout sauf AccessShareLock |
| AccessExclusiveLock | TOUT |

**Exemple - Voir les verrous par mode :**
```sql
SELECT mode, count(*)
FROM pg_locks
GROUP BY mode
ORDER BY count(*) DESC;
```

### 5. **granted**

Bool√©en indiquant si le verrou a √©t√© obtenu ou s'il est en attente.

- **TRUE** : Le verrou est acquis, la transaction peut continuer
- **FALSE** : Le verrou est en attente d'√™tre accord√© (blocage)

**C'est la colonne cl√© pour d√©tecter les probl√®mes de performance !**

**Voir les verrous en attente :**
```sql
SELECT
    locktype,
    relation::regclass AS table_name,
    mode,
    pid,
    page,
    tuple
FROM pg_locks
WHERE NOT granted  -- granted = FALSE
ORDER BY pid;
```

Si cette requ√™te retourne des lignes, vous avez des transactions bloqu√©es !

### 6. **pid**

Le Process ID (PID) du backend PostgreSQL qui d√©tient ou attend ce verrou.

Vous pouvez croiser avec `pg_stat_activity` pour voir quelle requ√™te est associ√©e :

```sql
SELECT
    l.pid,
    l.locktype,
    l.mode,
    l.granted,
    a.usename,
    a.query,
    a.state
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
WHERE NOT l.granted
ORDER BY l.pid;
```

### 7. **transactionid** et **virtualxid**

- **transactionid** : L'identifiant de transaction r√©el (XID) verrouill√©
- **virtualxid** : L'identifiant de transaction virtuel (utilis√© avant qu'un XID r√©el soit assign√©)

**Pourquoi c'est important ?**

Chaque transaction qui modifie des donn√©es obtient un verrou exclusif sur son propre `transactionid`. Si une transaction A essaie de lire une ligne modifi√©e par une transaction B non encore committ√©e, A devra attendre le verrou sur le `transactionid` de B.

**Exemple :**
```sql
SELECT
    locktype,
    transactionid,
    virtualxid,
    mode,
    granted,
    pid
FROM pg_locks
WHERE locktype IN ('transactionid', 'virtualxid')
ORDER BY pid;
```

### 8. **page** et **tuple**

Pour les verrous de type `tuple` (verrous sur des lignes), ces colonnes indiquent :
- **page** : Le num√©ro de page (bloc) o√π se trouve la ligne
- **tuple** : L'index de la ligne dans cette page

**Exemple de verrou sur une ligne sp√©cifique :**
```sql
SELECT
    locktype,
    relation::regclass AS table_name,
    page,
    tuple,
    mode,
    granted,
    pid
FROM pg_locks
WHERE locktype = 'tuple'
ORDER BY relation, page, tuple;
```

### 9. **classid**, **objid**, **objsubid**

Pour les verrous de type `object`, ces colonnes identifient l'objet sp√©cifique verrouill√© (fonction, type, etc.).

Ces colonnes sont moins fr√©quemment utilis√©es dans le diagnostic quotidien.

## Requ√™tes pratiques courantes

### 1. Voir tous les verrous actifs (vue simplifi√©e)

```sql
SELECT
    l.locktype,
    d.datname AS database,
    l.relation::regclass AS table_name,
    l.page,
    l.tuple,
    l.virtualxid,
    l.transactionid,
    l.mode,
    l.granted,
    a.usename AS user,
    a.query,
    a.state
FROM pg_locks l
LEFT JOIN pg_database d ON l.database = d.oid
LEFT JOIN pg_stat_activity a ON l.pid = a.pid
ORDER BY l.granted, l.pid;
```

### 2. Identifier les transactions bloqu√©es

```sql
SELECT
    l.pid AS blocked_pid,
    a.usename AS blocked_user,
    a.query AS blocked_query,
    l.locktype,
    l.mode,
    l.relation::regclass AS blocked_table
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
WHERE NOT l.granted
ORDER BY l.pid;
```

**Si cette requ√™te retourne des lignes, vous avez un probl√®me de blocage actif !**

### 3. Identifier qui bloque qui

C'est LA requ√™te la plus importante pour diagnostiquer les blocages :

```sql
SELECT
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_statement,
    blocking_activity.query AS blocking_statement,
    blocked_locks.mode AS blocked_mode,
    blocking_locks.mode AS blocking_mode
FROM pg_locks blocked_locks
JOIN pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_locks blocking_locks ON blocking_locks.locktype = blocked_locks.locktype
    AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database
    AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
    AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
    AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
    AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
    AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
    AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
    AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
    AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
    AND blocking_locks.pid != blocked_locks.pid
JOIN pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;
```

**Note :** Cette requ√™te est complexe mais essentielle. Elle croise `pg_locks` avec lui-m√™me et `pg_stat_activity` pour trouver les relations bloqueuse/bloqu√©e.

### 4. Version simplifi√©e avec pg_blocking_pids (PostgreSQL 9.6+)

PostgreSQL fournit une fonction auxiliaire qui simplifie grandement le diagnostic :

```sql
SELECT
    a.pid AS blocked_pid,
    a.usename AS blocked_user,
    a.query AS blocked_query,
    a.wait_event_type,
    a.wait_event,
    blocking.pid AS blocking_pid,
    blocking.query AS blocking_query,
    blocking.state AS blocking_state
FROM pg_stat_activity a
JOIN pg_stat_activity blocking ON blocking.pid = ANY(pg_blocking_pids(a.pid))
WHERE a.wait_event_type = 'Lock'
ORDER BY a.pid;
```

**Beaucoup plus simple !** Cette requ√™te utilise `pg_blocking_pids(pid)` qui retourne directement les PIDs bloquants.

### 5. Compter les verrous par type et mode

```sql
SELECT
    locktype,
    mode,
    count(*) AS nombre_verrous
FROM pg_locks
GROUP BY locktype, mode
ORDER BY count(*) DESC;
```

### 6. Voir les verrous sur une table sp√©cifique

```sql
SELECT
    l.pid,
    l.mode,
    l.granted,
    a.usename,
    a.query,
    a.state
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
WHERE l.relation = 'ma_table'::regclass
ORDER BY l.granted DESC, l.pid;
```

**Remplacer `'ma_table'` par le nom de votre table.**

### 7. D√©tecter les AccessExclusiveLock (dangereux en production)

Les `AccessExclusiveLock` bloquent TOUT acc√®s (lecture et √©criture) √† une table. C'est typiquement caus√© par :
- ALTER TABLE
- DROP TABLE
- TRUNCATE
- VACUUM FULL
- REINDEX

```sql
SELECT
    l.pid,
    l.relation::regclass AS table_name,
    l.mode,
    l.granted,
    a.usename,
    a.query,
    now() - a.query_start AS duree
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
WHERE l.mode = 'AccessExclusiveLock'
  AND l.granted
ORDER BY (now() - a.query_start) DESC;
```

**En production, des AccessExclusiveLock de longue dur√©e peuvent paralyser l'application !**

### 8. Voir les verrous par base de donn√©es

```sql
SELECT
    d.datname AS database,
    l.locktype,
    count(*) AS nombre_verrous
FROM pg_locks l
LEFT JOIN pg_database d ON l.database = d.oid
GROUP BY d.datname, l.locktype
ORDER BY count(*) DESC;
```

### 9. Trouver les transactions en attente avec dur√©e

```sql
SELECT
    l.pid,
    l.locktype,
    l.relation::regclass AS table_name,
    l.mode,
    a.usename,
    a.query,
    now() - a.query_start AS temps_attente,
    a.state
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
WHERE NOT l.granted
ORDER BY (now() - a.query_start) DESC;
```

**Si une transaction attend depuis plus de quelques secondes, c'est anormal.**

### 10. Identifier les tables les plus contendues

```sql
SELECT
    relation::regclass AS table_name,
    count(*) AS nombre_verrous,
    count(*) FILTER (WHERE NOT granted) AS verrous_en_attente
FROM pg_locks
WHERE relation IS NOT NULL
GROUP BY relation
ORDER BY count(*) DESC
LIMIT 20;
```

Les tables avec beaucoup de `verrous_en_attente` ont des probl√®mes de contention.

## Cas d'usage en production

### Sc√©nario 1 : "Mon application ne r√©pond plus !"

**√âtape 1 : V√©rifier s'il y a des blocages**
```sql
SELECT count(*) AS transactions_bloquees
FROM pg_locks
WHERE NOT granted;
```

Si le r√©sultat > 0, il y a des blocages.

**√âtape 2 : Identifier qui bloque qui**
```sql
SELECT
    blocked.pid AS blocked_pid,
    blocked.usename AS blocked_user,
    blocked.query AS blocked_query,
    blocker.pid AS blocker_pid,
    blocker.usename AS blocker_user,
    blocker.query AS blocker_query,
    blocker.state AS blocker_state
FROM pg_stat_activity blocked
JOIN LATERAL (
    SELECT *
    FROM pg_stat_activity
    WHERE pid = ANY(pg_blocking_pids(blocked.pid))
) blocker ON true
WHERE blocked.wait_event_type = 'Lock';
```

**√âtape 3 : D√©cider de l'action**

Options :
1. **Attendre** que la transaction bloquante se termine
2. **Annuler** la transaction bloquante avec `pg_cancel_backend(pid)`
3. **Tuer** la transaction bloquante avec `pg_terminate_backend(pid)` (plus brutal)

```sql
-- Annuler une requ√™te (propre)
SELECT pg_cancel_backend(12345);  -- Remplacer par le PID blocker

-- Tuer une connexion (brutal)
SELECT pg_terminate_backend(12345);
```

### Sc√©nario 2 : "Deadlock d√©tect√©"

PostgreSQL d√©tecte automatiquement les deadlocks et annule une des transactions. Vous verrez dans les logs :

```
ERROR:  deadlock detected
DETAIL:  Process 12345 waits for ShareLock on transaction 67890; blocked by process 54321.
Process 54321 waits for ShareLock on transaction 23456; blocked by process 12345.
```

**Analyser un deadlock :**

1. **Consulter les logs PostgreSQL** (souvent dans `/var/log/postgresql/` ou via journald)
2. **Identifier les tables/lignes impliqu√©es**
3. **Revoir l'ordre des op√©rations dans le code applicatif**

**Pr√©vention :**
- Toujours acc√©der aux tables dans le m√™me ordre
- Garder les transactions courtes
- Utiliser des niveaux d'isolation appropri√©s

### Sc√©nario 3 : "ALTER TABLE bloque tout"

Un d√©veloppeur lance un `ALTER TABLE` en production sans s'en rendre compte :

```sql
ALTER TABLE commandes ADD COLUMN statut VARCHAR(50);
```

Cette commande prend un `AccessExclusiveLock` qui bloque :
- Toutes les lectures (SELECT)
- Toutes les √©critures (INSERT, UPDATE, DELETE)

**Diagnostic :**
```sql
SELECT
    l.pid,
    l.relation::regclass AS table_name,
    l.mode,
    a.query,
    now() - a.query_start AS duree
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
WHERE l.mode = 'AccessExclusiveLock'
  AND l.locktype = 'relation'
ORDER BY duree DESC;
```

**Solution imm√©diate :**
```sql
-- Annuler l'ALTER TABLE
SELECT pg_cancel_backend(pid);
```

**Pr√©vention :**
- Utiliser `LOCK TABLE ... NOWAIT` pour √©chouer imm√©diatement si la table est utilis√©e
- Planifier les migrations en fen√™tre de maintenance
- Utiliser des outils comme `pg_repack` ou migrations "zero-downtime"

### Sc√©nario 4 : "Transactions idle in transaction bloquent tout"

Une application mal cod√©e ouvre une transaction, lit une ligne, puis reste en attente de l'utilisateur sans committer :

```sql
BEGIN;
SELECT * FROM produits WHERE id = 123 FOR UPDATE;
-- L'application attend maintenant l'input utilisateur pendant 10 minutes...
```

Pendant ce temps, la ligne est verrouill√©e !

**Diagnostic :**
```sql
SELECT
    a.pid,
    a.state,
    a.query,
    now() - a.xact_start AS duree_transaction,
    l.locktype,
    l.mode,
    l.relation::regclass AS table_name
FROM pg_stat_activity a
JOIN pg_locks l ON a.pid = l.pid
WHERE a.state = 'idle in transaction'
  AND (now() - a.xact_start) > interval '5 minutes'
  AND l.granted
ORDER BY duree_transaction DESC;
```

**Solution :**
```sql
-- Tuer la transaction zombie
SELECT pg_terminate_backend(pid);
```

**Pr√©vention :**
- Configurer `idle_in_transaction_session_timeout`
- Revoir le code applicatif pour fermer les transactions rapidement
- Utiliser des connection poolers avec timeout

### Sc√©nario 5 : "Contention sur une s√©quence"

Les s√©quences (utilis√©es pour SERIAL ou IDENTITY) peuvent devenir un point de contention si beaucoup d'INSERT concurrents ont lieu.

**Diagnostic :**
```sql
SELECT
    l.relation::regclass AS sequence_name,
    count(*) AS nombre_verrous_actifs,
    count(*) FILTER (WHERE NOT l.granted) AS verrous_en_attente
FROM pg_locks l
JOIN pg_class c ON l.relation = c.oid
WHERE c.relkind = 'S'  -- S = Sequence
GROUP BY l.relation
ORDER BY count(*) DESC;
```

**Solution :**
- Augmenter le `CACHE` de la s√©quence
- Utiliser UUID au lieu de SERIAL
- Partitionner la table si possible

## Advisory Locks : Verrous applicatifs

PostgreSQL permet de cr√©er des verrous personnalis√©s au niveau applicatif avec les **Advisory Locks**.

### Utilisation des Advisory Locks

**Obtenir un verrou advisory :**
```sql
-- Verrou exclusif sur l'entier 12345
SELECT pg_advisory_lock(12345);

-- Verrou partag√©
SELECT pg_advisory_lock_shared(12345);
```

**Lib√©rer le verrou :**
```sql
SELECT pg_advisory_unlock(12345);
```

**Essayer d'obtenir sans attendre (non-bloquant) :**
```sql
SELECT pg_try_advisory_lock(12345);  -- Retourne TRUE si acquis, FALSE sinon
```

**Voir les advisory locks actifs :**
```sql
SELECT
    l.pid,
    l.objid,
    l.classid,
    l.mode,
    l.granted,
    a.query
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
WHERE l.locktype = 'advisory'
ORDER BY l.pid;
```

**Cas d'usage :**
- √âviter que deux workers traitent le m√™me job
- Impl√©menter des mutex/s√©maphores au niveau base
- Coordination distribu√©e

**Exemple : Job queue avec advisory lock**
```sql
-- Worker essaie d'obtenir le lock sur un job
SELECT pg_try_advisory_lock(job_id) FROM jobs WHERE status = 'pending' LIMIT 1;

-- Si TRUE, le worker traite le job
-- Si FALSE, un autre worker l'a d√©j√† pris
```

## Monitoring et alertes

### Alertes critiques √† configurer

1. **Transactions bloqu√©es depuis > 30 secondes**
```sql
SELECT count(*)
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
WHERE NOT l.granted
  AND (now() - a.query_start) > interval '30 seconds';
```

2. **AccessExclusiveLock actifs**
```sql
SELECT count(*)
FROM pg_locks
WHERE mode = 'AccessExclusiveLock'
  AND locktype = 'relation'
  AND granted;
```

3. **Transactions idle in transaction avec verrous**
```sql
SELECT count(*)
FROM pg_stat_activity a
JOIN pg_locks l ON a.pid = l.pid
WHERE a.state LIKE 'idle in transaction%'
  AND (now() - a.xact_start) > interval '5 minutes'
  AND l.granted;
```

### Dashboard de monitoring

```sql
-- Vue synth√©tique des verrous
CREATE OR REPLACE VIEW v_lock_monitoring AS
SELECT
    CASE
        WHEN NOT l.granted THEN 'üî¥ Bloqu√©'
        WHEN l.mode = 'AccessExclusiveLock' THEN 'üü† Access Exclusive'
        WHEN a.state = 'idle in transaction' AND (now() - a.xact_start) > interval '1 minute' THEN 'üü° Idle in TX'
        ELSE 'üü¢ Normal'
    END AS statut,
    l.pid,
    a.usename,
    l.locktype,
    l.relation::regclass AS table_name,
    l.mode,
    l.granted,
    a.state,
    a.query,
    now() - a.xact_start AS duree_transaction,
    ARRAY(SELECT pg_blocking_pids(l.pid)) AS blocked_by
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
WHERE l.locktype IN ('relation', 'transactionid', 'tuple')
ORDER BY
    CASE statut
        WHEN 'üî¥ Bloqu√©' THEN 1
        WHEN 'üü† Access Exclusive' THEN 2
        WHEN 'üü° Idle in TX' THEN 3
        ELSE 4
    END,
    duree_transaction DESC;

-- Utilisation
SELECT * FROM v_lock_monitoring WHERE statut != 'üü¢ Normal';
```

## Outils de diagnostic avanc√©s

### 1. pg_blocking_pids() - PostgreSQL 9.6+

```sql
-- Trouver qui bloque un PID sp√©cifique
SELECT pg_blocking_pids(12345);  -- Retourne un array de PIDs

-- Utilisation dans une requ√™te
SELECT
    pid,
    query,
    pg_blocking_pids(pid) AS blocked_by
FROM pg_stat_activity
WHERE cardinality(pg_blocking_pids(pid)) > 0;
```

### 2. pg_lock_status - Extension tierce

L'extension `pg_lock_status` fournit des vues simplifi√©es :

```sql
-- Installation
CREATE EXTENSION pg_lock_status;

-- Voir les blocages
SELECT * FROM pg_lock_status();
```

### 3. Logs PostgreSQL

Configurez PostgreSQL pour logger les verrous longs :

```ini
# postgresql.conf
log_lock_waits = on
deadlock_timeout = 1s  # Log apr√®s 1 seconde d'attente
```

Apr√®s un red√©marrage ou reload, les attentes de verrous appara√Ætront dans les logs.

## Bonnes pratiques

1. **Gardez les transactions courtes**
   - Ne jamais attendre l'input utilisateur dans une transaction
   - Commit ou Rollback le plus t√¥t possible

2. **Utilisez NOWAIT quand appropri√©**
   ```sql
   SELECT * FROM produits WHERE id = 123 FOR UPDATE NOWAIT;
   -- √âchoue imm√©diatement si la ligne est verrouill√©e
   ```

3. **Configurez des timeouts**
   ```sql
   SET lock_timeout = '5s';  -- √âchoue apr√®s 5 secondes d'attente
   SET idle_in_transaction_session_timeout = '10min';
   ```

4. **√âvitez les deadlocks**
   - Acc√©dez toujours aux tables dans le m√™me ordre
   - Utilisez des niveaux d'isolation appropri√©s
   - Gardez les transactions simples

5. **Surveillez en continu**
   - Alertes sur blocages > 30 secondes
   - Dashboards avec pg_locks
   - Analyse r√©guli√®re des logs

6. **√âvitez les DDL en production**
   - Planifiez les ALTER TABLE en fen√™tre de maintenance
   - Utilisez des outils comme `pg_repack` pour les r√©orgs
   - Testez les migrations sur un clone de prod

7. **Utilisez FOR UPDATE judicieusement**
   ```sql
   -- Limite le scope du verrouillage
   SELECT * FROM commandes WHERE id = 123 FOR UPDATE;
   -- Mieux que de verrouiller toute la table
   ```

8. **Exploitez les Advisory Locks pour la coordination**
   - Plut√¥t que de faire du polling applicatif
   - Pour les jobs queues distribu√©es
   - Pour les t√¢ches p√©riodiques exclusives

## Diff√©rences entre types de verrous

### Table-level locks vs Row-level locks

**Table-level (relation locks) :**
- Pos√©s par les DDL (ALTER, DROP, TRUNCATE)
- Impactent toute la table
- Visibles avec `locktype = 'relation'`

**Row-level (tuple locks) :**
- Pos√©s par UPDATE, DELETE, SELECT FOR UPDATE
- N'impactent que les lignes concern√©es
- Visibles avec `locktype = 'tuple'` (rare dans pg_locks)
- Principalement g√©r√©s via MVCC (versions de lignes)

### Transaction locks

Les verrous sur `transactionid` sont fondamentaux √† MVCC :
- Chaque transaction modifiant des donn√©es obtient un XID
- Les autres transactions doivent attendre si elles veulent lire des lignes non commit√©es

## Limitations et consid√©rations

### 1. pg_locks montre l'√©tat instantan√©

`pg_locks` est une vue dynamique. Entre deux lectures, les verrous peuvent changer. Pour un diagnostic fiable, combinez avec `pg_stat_activity`.

### 2. Performance

Sur des syst√®mes tr√®s charg√©s (milliers de connexions), `pg_locks` peut devenir lent √† interroger. Utilisez des filtres (`WHERE NOT granted`) pour limiter les r√©sultats.

### 3. Verrous non visibles

Certains verrous l√©gers (lightweight locks, spinlocks) utilis√©s en interne ne sont pas visibles dans `pg_locks`.

### 4. Interpr√©tation complexe

La matrice de compatibilit√© des modes de verrous est complexe. En cas de doute, r√©f√©rez-vous √† la documentation officielle.

## R√©sum√© des colonnes cl√©s

| Colonne | Description | Usage principal |
|---------|-------------|-----------------|
| **locktype** | Type de ressource (relation, tuple, transactionid) | Identifier ce qui est verrouill√© |
| **mode** | Mode du verrou (AccessShareLock, RowExclusiveLock, etc.) | Comprendre le niveau de restriction |
| **granted** | Verrou obtenu ou en attente | **D√©tecter les blocages** |
| **pid** | Process ID | Croiser avec pg_stat_activity |
| **relation** | OID de la table/index | Identifier la table bloqu√©e |
| **transactionid** | ID de transaction | Blocages li√©s √† MVCC |

## Conclusion

`pg_locks` est l'outil indispensable pour :

- ‚úÖ **Diagnostiquer les blocages** : Qui attend qui ?
- ‚úÖ **Identifier les goulots d'√©tranglement** : Contention sur tables/s√©quences
- ‚úÖ **D√©tecter les transactions probl√©matiques** : Idle in transaction avec verrous
- ‚úÖ **Comprendre les deadlocks** : Analyser les conflits circulaires
- ‚úÖ **Optimiser la concurrence** : R√©duire les contentions

**Points critiques √† surveiller :**
- Verrous en attente (`granted = FALSE`)
- `AccessExclusiveLock` sur tables fr√©quemment utilis√©es
- Transactions longues avec verrous
- Deadlocks r√©currents

**Requ√™te essentielle √† retenir :**
```sql
-- Qui bloque qui ?
SELECT
    blocked.pid AS blocked_pid,
    blocked.query AS blocked_query,
    blocker.pid AS blocker_pid,
    blocker.query AS blocker_query
FROM pg_stat_activity blocked
JOIN LATERAL (
    SELECT *
    FROM pg_stat_activity
    WHERE pid = ANY(pg_blocking_pids(blocked.pid))
) blocker ON true
WHERE blocked.wait_event_type = 'Lock';
```

Combinez `pg_locks` avec `pg_stat_activity` pour une vision compl√®te de ce qui se passe dans votre base de donn√©es.

---

**Prochaines √©tapes :** Apprenez √† optimiser les niveaux d'isolation des transactions, et explorez les strat√©gies de r√©duction des contentions (partitionnement, r√©plication en lecture, pooling).

‚è≠Ô∏è [pg_catalog : M√©tadonn√©es syst√®me](/14-observabilite-et-monitoring/02.5-pg-catalog.md)
