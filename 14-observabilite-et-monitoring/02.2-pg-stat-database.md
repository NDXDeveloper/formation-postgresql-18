üîù Retour au [Sommaire](/SOMMAIRE.md)

# 14.2.2. pg_stat_database : M√©triques par base

## Introduction

La vue `pg_stat_database` est un tableau de bord statistique qui vous donne une vue d'ensemble de l'activit√© et de la sant√© de chaque base de donn√©es dans votre instance PostgreSQL. Contrairement √† `pg_stat_activity` qui montre l'activit√© en temps r√©el, `pg_stat_database` accumule des statistiques depuis le d√©marrage du serveur (ou depuis la derni√®re r√©initialisation des statistiques).

Imaginez `pg_stat_database` comme un compteur kilom√©trique pour chaque base de donn√©es : elle vous indique le nombre de transactions effectu√©es, le nombre de lignes lues, les erreurs de cache, et bien d'autres m√©triques essentielles pour √©valuer la performance et l'utilisation de vos bases.

## Pourquoi pg_stat_database est importante ?

Cette vue vous permet de r√©pondre √† des questions critiques :

- Quelle base de donn√©es g√©n√®re le plus de charge ?
- Combien de transactions sont effectu√©es par seconde ?
- Quel est le taux de succ√®s du cache (cache hit ratio) ?
- Y a-t-il beaucoup de deadlocks dans une base ?
- Combien de temps CPU et I/O consomment mes requ√™tes ?
- Quand a eu lieu la derni√®re sauvegarde ou le dernier VACUUM ?

Ces informations sont essentielles pour optimiser les performances et planifier la capacit√© de votre infrastructure.

## Acc√©der √† pg_stat_database

Pour consulter cette vue, ex√©cutez simplement :

```sql
SELECT * FROM pg_stat_database;
```

Vous verrez une ligne par base de donn√©es dans votre instance PostgreSQL, y compris les bases syst√®me (`template0`, `template1`, `postgres`).

**Vue simplifi√©e :**
```sql
SELECT datname, numbackends, xact_commit, xact_rollback, blks_read, blks_hit
FROM pg_stat_database
WHERE datname IS NOT NULL
ORDER BY datname;
```

## Les colonnes principales de pg_stat_database

### 1. **datid** et **datname**

- **datid** : L'identifiant num√©rique (OID) de la base de donn√©es
- **datname** : Le nom de la base de donn√©es

**Note :** Il existe une ligne sp√©ciale avec `datname = NULL` qui agr√®ge les statistiques de toutes les bases, incluant les bases qui ont √©t√© supprim√©es.

**Exemple :**
```sql
-- Voir uniquement les bases actives
SELECT datname FROM pg_stat_database WHERE datname IS NOT NULL;
```

### 2. **numbackends**

Le nombre de connexions actives (backends) actuellement connect√©es √† cette base de donn√©es.

**Cas d'usage :** Identifier quelle base a le plus de connexions actives.

**Exemple :**
```sql
SELECT datname, numbackends
FROM pg_stat_database
ORDER BY numbackends DESC;
```

**‚ö†Ô∏è Diff√©rence avec pg_stat_activity :**
- `pg_stat_activity` montre le d√©tail de chaque connexion
- `pg_stat_database.numbackends` donne juste le compte total par base

### 3. **xact_commit** et **xact_rollback**

- **xact_commit** : Nombre total de transactions valid√©es (committed) depuis le d√©marrage ou la r√©initialisation des stats
- **xact_rollback** : Nombre total de transactions annul√©es (rolled back)

**Pourquoi c'est important ?**

Le ratio rollback/commit peut indiquer des probl√®mes applicatifs. Un taux de rollback √©lev√© peut signifier :
- Erreurs fr√©quentes dans le code applicatif
- Deadlocks r√©p√©t√©s
- Violations de contraintes d'int√©grit√©

**Calculer le taux de rollback :**
```sql
SELECT
    datname,
    xact_commit,
    xact_rollback,
    CASE
        WHEN (xact_commit + xact_rollback) > 0
        THEN round(100.0 * xact_rollback / (xact_commit + xact_rollback), 2)
        ELSE 0
    END AS taux_rollback_pct
FROM pg_stat_database
WHERE datname IS NOT NULL
ORDER BY taux_rollback_pct DESC;
```

**Benchmark :** Un taux de rollback sup√©rieur √† 5-10% m√©rite investigation.

### 4. **blks_read** et **blks_hit**

Ces colonnes sont parmi les plus importantes pour √©valuer les performances I/O :

- **blks_read** : Nombre de blocs (pages de 8 Ko par d√©faut) lus depuis le disque
- **blks_hit** : Nombre de blocs trouv√©s dans le cache m√©moire (shared buffers)

**Le Cache Hit Ratio (CHR) :**

C'est l'une des m√©triques les plus surveill√©es en production. Elle indique le pourcentage de lectures satisfaites par le cache plut√¥t que par le disque.

**Formule :**
```
Cache Hit Ratio = blks_hit / (blks_hit + blks_read) √ó 100
```

**Calculer le CHR :**
```sql
SELECT
    datname,
    blks_hit,
    blks_read,
    CASE
        WHEN (blks_hit + blks_read) > 0
        THEN round(100.0 * blks_hit / (blks_hit + blks_read), 2)
        ELSE 0
    END AS cache_hit_ratio
FROM pg_stat_database
WHERE datname IS NOT NULL
ORDER BY cache_hit_ratio;
```

**Interpr√©tation :**
- **> 99%** : Excellent. La plupart des donn√©es sont en cache.
- **95-99%** : Bon, mais pourrait √™tre am√©lior√©.
- **< 95%** : Probl√©matique. Vous lisez trop sur disque. Envisagez d'augmenter `shared_buffers`.

**‚ö†Ô∏è Attention :** Un CHR bas peut aussi indiquer des requ√™tes qui scannent de grandes tables (sequential scans). Ce n'est pas toujours un probl√®me de configuration m√©moire.

### 5. **tup_returned**, **tup_fetched**, **tup_inserted**, **tup_updated**, **tup_deleted**

Ces colonnes comptent le nombre de lignes (tuples) manipul√©es :

- **tup_returned** : Nombre total de lignes retourn√©es par les requ√™tes
- **tup_fetched** : Nombre de lignes r√©ellement r√©cup√©r√©es par les requ√™tes
- **tup_inserted** : Nombre de lignes ins√©r√©es
- **tup_updated** : Nombre de lignes mises √† jour
- **tup_deleted** : Nombre de lignes supprim√©es

**Diff√©rence entre `returned` et `fetched` :**

- **returned** : Lignes scann√©es (potentiellement filtr√©es ensuite)
- **fetched** : Lignes r√©ellement renvoy√©es au client apr√®s filtrage

Un grand √©cart entre ces deux valeurs peut indiquer des requ√™tes inefficaces (scans complets avec beaucoup de filtrage).

**Ratio de s√©lectivit√© :**
```sql
SELECT
    datname,
    tup_returned,
    tup_fetched,
    CASE
        WHEN tup_returned > 0
        THEN round(100.0 * tup_fetched / tup_returned, 2)
        ELSE 0
    END AS selectivite_pct
FROM pg_stat_database
WHERE datname IS NOT NULL;
```

**Interpr√©tation :**
- S√©lectivit√© basse (< 10%) : Beaucoup de lignes scann√©es pour peu de r√©sultats. Manque d'index ?
- S√©lectivit√© √©lev√©e (> 90%) : Requ√™tes bien optimis√©es.

**Exemple - Voir l'activit√© d'√©criture :**
```sql
SELECT
    datname,
    tup_inserted AS insertions,
    tup_updated AS mises_a_jour,
    tup_deleted AS suppressions,
    (tup_inserted + tup_updated + tup_deleted) AS total_ecritures
FROM pg_stat_database
WHERE datname IS NOT NULL
ORDER BY total_ecritures DESC;
```

### 6. **conflicts** et **deadlocks**

- **conflicts** : Nombre de requ√™tes annul√©es √† cause de conflits de r√©cup√©ration (surtout sur les replicas en lecture)
- **deadlocks** : Nombre de deadlocks d√©tect√©s

**Les deadlocks :**

Un deadlock se produit quand deux transactions s'attendent mutuellement, cr√©ant un blocage circulaire. PostgreSQL d√©tecte automatiquement ces situations et annule l'une des transactions.

**Surveiller les deadlocks :**
```sql
SELECT
    datname,
    deadlocks,
    deadlocks::numeric / GREATEST(xact_commit + xact_rollback, 1) * 100000 AS deadlocks_par_100k_tx
FROM pg_stat_database
WHERE datname IS NOT NULL
ORDER BY deadlocks DESC;
```

**‚ö†Ô∏è Important :** M√™me un seul deadlock r√©gulier peut √™tre probl√©matique. Cela indique un probl√®me de conception dans l'ordre des verrous.

### 7. **temp_files** et **temp_bytes**

- **temp_files** : Nombre de fichiers temporaires cr√©√©s
- **temp_bytes** : Volume total de donn√©es √©crites dans les fichiers temporaires

**Pourquoi c'est important ?**

PostgreSQL cr√©e des fichiers temporaires quand une op√©ration (tri, jointure, agr√©gation) ne tient pas en m√©moire (work_mem). Les op√©rations qui utilisent le disque temporaire sont **beaucoup plus lentes**.

**Indicateur de probl√®me :**
```sql
SELECT
    datname,
    temp_files,
    pg_size_pretty(temp_bytes) AS volume_temp,
    temp_bytes / GREATEST(temp_files, 1) AS taille_moyenne_fichier
FROM pg_stat_database
WHERE datname IS NOT NULL AND temp_files > 0
ORDER BY temp_bytes DESC;
```

**Solutions si temp_bytes est √©lev√© :**
1. Augmenter `work_mem` (m√©moire pour les op√©rations de tri/jointure)
2. Optimiser les requ√™tes (ajout d'index, r√©√©criture)
3. Ajouter plus de RAM au serveur

### 8. **blk_read_time** et **blk_write_time**

- **blk_read_time** : Temps total (en millisecondes) pass√© √† lire des blocs depuis le disque
- **blk_write_time** : Temps total pass√© √† √©crire des blocs sur le disque

**‚ö†Ô∏è Pr√©requis :** Ces statistiques n√©cessitent que `track_io_timing` soit activ√© dans `postgresql.conf` :

```sql
-- V√©rifier si le tracking I/O est activ√©
SHOW track_io_timing;

-- Si 'off', l'activer (n√©cessite red√©marrage ou reload)
ALTER SYSTEM SET track_io_timing = 'on';
SELECT pg_reload_conf();
```

**Analyser les temps I/O :**
```sql
SELECT
    datname,
    blks_read,
    blk_read_time,
    CASE
        WHEN blks_read > 0
        THEN round(blk_read_time / blks_read, 2)
        ELSE 0
    END AS temps_moyen_lecture_ms
FROM pg_stat_database
WHERE datname IS NOT NULL AND blks_read > 0
ORDER BY blk_read_time DESC;
```

**Interpr√©tation :**
- Temps moyen < 1 ms : Excellent (probablement SSD ou cache OS)
- Temps moyen 1-5 ms : Bon (SSD)
- Temps moyen > 10 ms : Lent (HDD traditionnel ou probl√®me de performance disque)

### 9. **stats_reset**

L'horodatage de la derni√®re r√©initialisation des statistiques pour cette base.

**Pourquoi c'est utile ?**

Toutes les statistiques sont cumulatives depuis `stats_reset`. Pour calculer des m√©triques par unit√© de temps (transactions/seconde, cache hit ratio sur une p√©riode), vous devez conna√Ætre ce timestamp.

**Exemple :**
```sql
SELECT
    datname,
    stats_reset,
    now() - stats_reset AS duree_collecte
FROM pg_stat_database
WHERE datname IS NOT NULL;
```

**R√©initialiser les statistiques (rarement n√©cessaire) :**
```sql
-- R√©initialiser pour une base sp√©cifique
SELECT pg_stat_reset_single_table_counters(NULL);

-- R√©initialiser toutes les stats de la base actuelle
SELECT pg_stat_reset();
```

### 10. Colonnes de checksum et de session (PostgreSQL 12+)

- **checksum_failures** : Nombre d'√©checs de checksum d√©tect√©s (corruption de donn√©es)
- **checksum_last_failure** : Date du dernier √©chec de checksum

**‚ö†Ô∏è Les checksums de donn√©es :**

Si activ√©s (option `--data-checksums` √† l'init), PostgreSQL d√©tecte les corruptions silencieuses sur disque.

**Surveiller les corruptions :**
```sql
SELECT
    datname,
    checksum_failures,
    checksum_last_failure
FROM pg_stat_database
WHERE checksum_failures > 0;
```

**üö® Si checksum_failures > 0 : C'EST GRAVE !**

Cela indique une corruption de donn√©es. Actions imm√©diates :
1. V√©rifier l'int√©grit√© du stockage (disques, RAID)
2. Restaurer depuis une sauvegarde saine
3. Contacter votre √©quipe infrastructure

### 11. **session_time**, **active_time**, **idle_in_transaction_time** (PostgreSQL 14+)

√Ä partir de PostgreSQL 14, des statistiques de temps de session ont √©t√© ajout√©es :

- **session_time** : Temps total de toutes les sessions (en ms)
- **active_time** : Temps pass√© √† ex√©cuter des requ√™tes
- **idle_in_transaction_time** : Temps pass√© en √©tat "idle in transaction"

**Calculer le pourcentage de temps actif :**
```sql
SELECT
    datname,
    round(100.0 * active_time / GREATEST(session_time, 1), 2) AS pct_temps_actif,
    round(100.0 * idle_in_transaction_time / GREATEST(session_time, 1), 2) AS pct_idle_in_tx
FROM pg_stat_database
WHERE datname IS NOT NULL;
```

**Interpr√©tation :**
- Si `pct_idle_in_tx` > 10% : Probl√®me applicatif (transactions non ferm√©es)

## Requ√™tes pratiques courantes

### 1. Vue d'ensemble de toutes les bases

```sql
SELECT
    datname AS base,
    numbackends AS connexions,
    xact_commit AS commits,
    xact_rollback AS rollbacks,
    blks_read AS blocs_disque,
    blks_hit AS blocs_cache,
    round(100.0 * blks_hit / GREATEST(blks_hit + blks_read, 1), 2) AS cache_hit_ratio,
    deadlocks,
    temp_files AS fichiers_temp,
    pg_size_pretty(temp_bytes) AS volume_temp
FROM pg_stat_database
WHERE datname IS NOT NULL
ORDER BY datname;
```

### 2. Identifier la base la plus active

```sql
SELECT
    datname,
    xact_commit + xact_rollback AS total_transactions,
    tup_inserted + tup_updated + tup_deleted AS total_modifications,
    blks_read + blks_hit AS total_blocs_accedes
FROM pg_stat_database
WHERE datname IS NOT NULL
ORDER BY total_transactions DESC
LIMIT 5;
```

### 3. Calculer les transactions par seconde

```sql
SELECT
    datname,
    xact_commit + xact_rollback AS total_tx,
    EXTRACT(EPOCH FROM (now() - stats_reset)) AS secondes_depuis_reset,
    round((xact_commit + xact_rollback)::numeric /
          EXTRACT(EPOCH FROM (now() - stats_reset)), 2) AS tx_par_seconde
FROM pg_stat_database
WHERE datname IS NOT NULL
  AND stats_reset IS NOT NULL
ORDER BY tx_par_seconde DESC;
```

**Note :** Cette m√©trique est plus pertinente si les stats n'ont pas √©t√© r√©initialis√©es r√©cemment.

### 4. Analyser le cache hit ratio de toutes les bases

```sql
SELECT
    datname,
    blks_hit AS cache,
    blks_read AS disque,
    blks_hit + blks_read AS total,
    round(100.0 * blks_hit / GREATEST(blks_hit + blks_read, 1), 2) AS cache_hit_pct
FROM pg_stat_database
WHERE datname IS NOT NULL
ORDER BY cache_hit_pct;
```

**Alerte si une base a un CHR < 95% :**
```sql
SELECT
    datname,
    round(100.0 * blks_hit / GREATEST(blks_hit + blks_read, 1), 2) AS chr
FROM pg_stat_database
WHERE datname IS NOT NULL
  AND (blks_hit + blks_read) > 1000  -- Filtrer les bases peu utilis√©es
  AND 100.0 * blks_hit / (blks_hit + blks_read) < 95
ORDER BY chr;
```

### 5. D√©tecter les probl√®mes de fichiers temporaires

```sql
SELECT
    datname,
    temp_files,
    pg_size_pretty(temp_bytes) AS volume_temp,
    round(temp_bytes::numeric / GREATEST(temp_files, 1) / 1024 / 1024, 2) AS taille_moy_mb
FROM pg_stat_database
WHERE datname IS NOT NULL
  AND temp_files > 0
ORDER BY temp_bytes DESC;
```

**Si volume_temp est √©lev√© :** V√©rifiez `work_mem` et les requ√™tes lourdes (tri, jointures).

### 6. Surveiller les deadlocks

```sql
SELECT
    datname,
    deadlocks,
    xact_commit + xact_rollback AS total_tx,
    CASE
        WHEN (xact_commit + xact_rollback) > 0
        THEN round(deadlocks::numeric / (xact_commit + xact_rollback) * 100000, 2)
        ELSE 0
    END AS deadlocks_par_100k_tx
FROM pg_stat_database
WHERE datname IS NOT NULL
  AND deadlocks > 0
ORDER BY deadlocks DESC;
```

**Benchmark :** M√™me 1 deadlock par 100k transactions peut √™tre probl√©matique si c'est r√©gulier.

### 7. Temps I/O par base (si track_io_timing = on)

```sql
SELECT
    datname,
    blks_read,
    round(blk_read_time::numeric, 2) AS temps_lecture_ms,
    CASE
        WHEN blks_read > 0
        THEN round(blk_read_time / blks_read, 2)
        ELSE 0
    END AS temps_moyen_lecture_ms,
    round(blk_write_time::numeric, 2) AS temps_ecriture_ms
FROM pg_stat_database
WHERE datname IS NOT NULL
ORDER BY blk_read_time DESC;
```

### 8. Comparer l'activit√© entre bases

```sql
SELECT
    datname,
    round(100.0 * xact_commit / GREATEST(SUM(xact_commit) OVER (), 1), 2) AS pct_commits,
    round(100.0 * (blks_read + blks_hit) / GREATEST(SUM(blks_read + blks_hit) OVER (), 1), 2) AS pct_io
FROM pg_stat_database
WHERE datname IS NOT NULL
ORDER BY pct_commits DESC;
```

Cette requ√™te montre quelle base consomme quel pourcentage de l'activit√© totale.

### 9. Vue combin√©e avec taille des bases

```sql
SELECT
    d.datname,
    pg_size_pretty(pg_database_size(d.datname)) AS taille,
    s.numbackends AS connexions,
    s.xact_commit + s.xact_rollback AS transactions,
    round(100.0 * s.blks_hit / GREATEST(s.blks_hit + s.blks_read, 1), 2) AS cache_hit_ratio,
    s.deadlocks
FROM pg_database d
JOIN pg_stat_database s ON d.datname = s.datname
WHERE d.datname IS NOT NULL
ORDER BY pg_database_size(d.datname) DESC;
```

### 10. Statistiques depuis le dernier reset

```sql
SELECT
    datname,
    stats_reset,
    age(now(), stats_reset) AS age_stats,
    xact_commit AS commits,
    xact_rollback AS rollbacks,
    deadlocks,
    temp_files
FROM pg_stat_database
WHERE datname IS NOT NULL
ORDER BY stats_reset DESC NULLS LAST;
```

## Monitoring et alertes recommand√©s

### M√©triques critiques √† surveiller en production

1. **Cache Hit Ratio < 95%**
   ```sql
   -- Alerte si CHR trop bas
   SELECT datname, round(100.0 * blks_hit / (blks_hit + blks_read), 2) AS chr
   FROM pg_stat_database
   WHERE datname IS NOT NULL
     AND (blks_hit + blks_read) > 1000
     AND 100.0 * blks_hit / (blks_hit + blks_read) < 95;
   ```

2. **Taux de rollback > 5%**
   ```sql
   -- Alerte si trop de rollbacks
   SELECT datname,
          round(100.0 * xact_rollback / (xact_commit + xact_rollback), 2) AS rollback_pct
   FROM pg_stat_database
   WHERE datname IS NOT NULL
     AND (xact_commit + xact_rollback) > 100
     AND 100.0 * xact_rollback / (xact_commit + xact_rollback) > 5;
   ```

3. **Deadlocks d√©tect√©s**
   ```sql
   -- Alerte si deadlocks
   SELECT datname, deadlocks
   FROM pg_stat_database
   WHERE datname IS NOT NULL AND deadlocks > 0;
   ```

4. **Fichiers temporaires excessifs**
   ```sql
   -- Alerte si > 1 GB de fichiers temp
   SELECT datname, pg_size_pretty(temp_bytes) AS volume_temp
   FROM pg_stat_database
   WHERE datname IS NOT NULL
     AND temp_bytes > 1073741824;  -- 1 GB
   ```

5. **Corruptions de donn√©es (checksums)**
   ```sql
   -- üö® ALERTE CRITIQUE üö®
   SELECT datname, checksum_failures, checksum_last_failure
   FROM pg_stat_database
   WHERE checksum_failures > 0;
   ```

## Combiner pg_stat_database avec d'autres vues

### Avec pg_stat_activity (connexions actives)

```sql
SELECT
    d.datname,
    d.numbackends AS connexions_selon_stat,
    COUNT(a.pid) AS connexions_actives_reelles,
    d.xact_commit + d.xact_rollback AS total_tx
FROM pg_stat_database d
LEFT JOIN pg_stat_activity a ON d.datname = a.datname
WHERE d.datname IS NOT NULL
GROUP BY d.datname, d.numbackends, d.xact_commit, d.xact_rollback
ORDER BY connexions_actives_reelles DESC;
```

### Avec pg_database (informations syst√®me)

```sql
SELECT
    d.datname,
    pg_encoding_to_char(d.encoding) AS encodage,
    d.datcollate AS collation,
    pg_size_pretty(pg_database_size(d.datname)) AS taille,
    s.xact_commit + s.xact_rollback AS transactions
FROM pg_database d
LEFT JOIN pg_stat_database s ON d.datname = s.datname
WHERE d.datname IS NOT NULL
ORDER BY pg_database_size(d.datname) DESC;
```

## R√©initialiser les statistiques

**Quand r√©initialiser ?**

Rarement ! La r√©initialisation supprime tout l'historique. Cas d'usage l√©gitimes :
- Apr√®s une maintenance majeure
- Pour mesurer les performances d'un changement sp√©cifique
- Apr√®s correction d'un probl√®me et besoin de statistiques "propres"

**R√©initialiser les stats de la base actuelle :**
```sql
SELECT pg_stat_reset();
```

**R√©initialiser les stats d'une base sp√©cifique :**
```sql
-- Se connecter d'abord √† cette base
\c ma_base
SELECT pg_stat_reset();
```

**‚ö†Ô∏è Attention :** Cela affecte aussi `pg_stat_statements` et autres statistiques !

## Configuration recommand√©e

Pour obtenir des statistiques compl√®tes, configurez ces param√®tres dans `postgresql.conf` :

```ini
# Activer le tracking I/O (indispensable pour blk_read_time)
track_io_timing = on

# Activer les statistiques de fonctions (optionnel)
track_functions = all

# Niveau de d√©tail des statistiques d'activit√©
track_activities = on
track_counts = on
```

Apr√®s modification :
```sql
SELECT pg_reload_conf();
```

## Diff√©rences selon les versions PostgreSQL

### PostgreSQL 12+
- Ajout de `checksum_failures` et `checksum_last_failure`

### PostgreSQL 13+
- Am√©lioration des statistiques de WAL

### PostgreSQL 14+
- Ajout de `session_time`, `active_time`, `idle_in_transaction_time`
- Ajout de `sessions`, `sessions_abandoned`, `sessions_fatal`, `sessions_killed`

### PostgreSQL 15+
- Am√©lioration du tracking des sessions

### PostgreSQL 18+ (Septembre 2025)
- Statistiques I/O et WAL par backend
- Am√©liorations du sous-syst√®me I/O asynchrone

## Cas d'usage en production

### Sc√©nario 1 : "Identifier la base qui consomme le plus de ressources"

```sql
SELECT
    datname,
    round(100.0 * (xact_commit + xact_rollback) /
          SUM(xact_commit + xact_rollback) OVER (), 2) AS pct_transactions,
    round(100.0 * (blks_read + blks_hit) /
          SUM(blks_read + blks_hit) OVER (), 2) AS pct_io,
    pg_size_pretty(pg_database_size(datname)) AS taille
FROM pg_stat_database
WHERE datname IS NOT NULL
ORDER BY (xact_commit + xact_rollback) DESC;
```

### Sc√©nario 2 : "Audit de performance mensuel"

```sql
WITH stats AS (
    SELECT
        datname,
        xact_commit + xact_rollback AS total_tx,
        round(100.0 * blks_hit / GREATEST(blks_hit + blks_read, 1), 2) AS chr,
        deadlocks,
        temp_files,
        pg_size_pretty(temp_bytes) AS vol_temp,
        stats_reset
    FROM pg_stat_database
    WHERE datname IS NOT NULL
)
SELECT * FROM stats
WHERE total_tx > 0
ORDER BY total_tx DESC;
```

Exportez ce r√©sultat r√©guli√®rement pour suivre les tendances.

### Sc√©nario 3 : "Capacit√© restante (connexions)"

```sql
SELECT
    (SELECT setting::int FROM pg_settings WHERE name = 'max_connections') AS max_conn,
    SUM(numbackends) AS conn_utilisees,
    (SELECT setting::int FROM pg_settings WHERE name = 'max_connections') -
    SUM(numbackends) AS conn_disponibles
FROM pg_stat_database;
```

### Sc√©nario 4 : "D√©tecter une base zombie ou inutilis√©e"

```sql
SELECT
    datname,
    xact_commit + xact_rollback AS total_tx,
    stats_reset,
    age(now(), stats_reset) AS age_stats
FROM pg_stat_database
WHERE datname IS NOT NULL
  AND datname NOT IN ('postgres', 'template0', 'template1')
  AND (xact_commit + xact_rollback) < 100  -- Tr√®s peu d'activit√©
  AND age(now(), stats_reset) > interval '7 days'
ORDER BY total_tx;
```

## Int√©gration avec des outils de monitoring

### Prometheus + postgres_exporter

Les m√©triques de `pg_stat_database` sont automatiquement export√©es :

```yaml
# Exemple de m√©triques Prometheus
pg_stat_database_xact_commit
pg_stat_database_xact_rollback
pg_stat_database_blks_read
pg_stat_database_blks_hit
pg_stat_database_tup_returned
pg_stat_database_deadlocks
```

### Grafana

Cr√©ez des dashboards avec :
- Graphiques de transactions/sec par base
- Cache hit ratio en temps r√©el
- Nombre de deadlocks cumul√©s
- Volume de fichiers temporaires

### Requ√™te d'export pour Grafana

```sql
SELECT
    datname AS metric,
    EXTRACT(EPOCH FROM now()) AS time,
    xact_commit + xact_rollback AS transactions,
    round(100.0 * blks_hit / GREATEST(blks_hit + blks_read, 1), 2) AS cache_hit_ratio,
    deadlocks
FROM pg_stat_database
WHERE datname IS NOT NULL;
```

## Bonnes pratiques

1. **Surveillez le cache hit ratio** : Objectif > 99% pour les bases OLTP

2. **Activez track_io_timing** : Essentiel pour diagnostiquer les probl√®mes I/O

3. **Configurez des alertes** : Sur deadlocks, rollback rate, temp_bytes, checksum_failures

4. **Ne r√©initialisez jamais les stats en production** : Sauf raison exceptionnelle et document√©e

5. **Corr√©lation temporelle** : Utilisez `stats_reset` pour calculer des m√©triques par p√©riode

6. **Combinez avec pg_stat_activity** : Pour une vue compl√®te (agr√©g√© + d√©tail)

7. **Exportez r√©guli√®rement** : Pour l'analyse de tendances (weekly/monthly reports)

8. **Documentez les baselines** : Connaissez vos m√©triques normales pour d√©tecter les anomalies

## R√©sum√© des colonnes cl√©s

| Colonne | Description | Seuil d'alerte |
|---------|-------------|----------------|
| **numbackends** | Connexions actives | Proche de max_connections |
| **xact_commit / xact_rollback** | Transactions valid√©es/annul√©es | Rollback > 5% |
| **blks_hit / blks_read** | Cache vs disque | Cache hit ratio < 95% |
| **deadlocks** | Deadlocks d√©tect√©s | > 0 r√©guli√®rement |
| **temp_files / temp_bytes** | Fichiers temporaires | > 1 GB |
| **blk_read_time / blk_write_time** | Temps I/O | > 10 ms moyen |
| **checksum_failures** | Corruptions d√©tect√©es | > 0 (CRITIQUE) |

## Diff√©rences avec pg_stat_activity

| Aspect | pg_stat_database | pg_stat_activity |
|--------|------------------|------------------|
| **Granularit√©** | Par base de donn√©es | Par connexion |
| **Type de donn√©es** | Statistiques cumulatives | √âtat en temps r√©el |
| **P√©riode** | Depuis stats_reset | Instantan√© |
| **Usage principal** | Performance, tendances | Diagnostic, troubleshooting |

**En pratique :**
- Utilisez `pg_stat_database` pour les dashboards et l'analyse de tendances
- Utilisez `pg_stat_activity` pour le troubleshooting et les investigations

## Conclusion

`pg_stat_database` est votre tableau de bord de sant√© pour chaque base de donn√©es PostgreSQL. Les m√©triques essentielles √† retenir :

- ‚úÖ **Cache hit ratio** : > 99% id√©alement
- ‚úÖ **Taux de rollback** : < 5%
- ‚úÖ **Deadlocks** : 0 ou tr√®s peu
- ‚úÖ **Temp files** : Le moins possible
- ‚úÖ **Checksum failures** : JAMAIS (si activ√©s)

Combinez ces statistiques avec `pg_stat_activity` (temps r√©el) et `pg_stat_user_tables` (d√©tail par table) pour une vision compl√®te de votre instance PostgreSQL.

**Prochaines √©tapes :** Explorez `pg_stat_user_tables` pour des statistiques au niveau des tables, et `pg_stat_statements` pour analyser les requ√™tes individuelles.

---

**Ressources compl√©mentaires :**
- Documentation officielle : [Monitoring Database Activity](https://www.postgresql.org/docs/current/monitoring-stats.html)
- Outils : Prometheus, Grafana, pgBadger, pg_stat_monitor

‚è≠Ô∏è [pg_stat_user_tables : Statistiques de tables](/14-observabilite-et-monitoring/02.3-pg-stat-user-tables.md)
