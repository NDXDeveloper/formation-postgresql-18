üîù Retour au [Sommaire](/SOMMAIRE.md)

# 14.7.2. pg_stat_kcache : M√©triques syst√®me (CPU, I/O)

## Introduction

Lorsque vous optimisez une base de donn√©es PostgreSQL, comprendre les **requ√™tes SQL lentes** ne suffit pas. Il faut aussi savoir **comment ces requ√™tes utilisent les ressources syst√®me** : processeur (CPU), m√©moire, et entr√©es/sorties disque (I/O).

**pg_stat_kcache** est une extension PostgreSQL qui comble pr√©cis√©ment ce besoin en enrichissant les statistiques de requ√™tes avec des **m√©triques syst√®me au niveau du noyau (kernel)**.

### Le probl√®me sans pg_stat_kcache

Imaginez cette situation :

```sql
-- Requ√™te A : 100ms
SELECT * FROM orders WHERE date > NOW() - INTERVAL '1 day';

-- Requ√™te B : 100ms
SELECT * FROM products WHERE stock = 0;
```

Les deux requ√™tes prennent 100ms. Sont-elles √©quivalentes en termes de charge syst√®me ?

**Non !** L'une peut √™tre :
- **CPU-intensive** : Calculs complexes, tris en m√©moire
- **I/O-intensive** : Lecture massive depuis le disque

Sans pg_stat_kcache, **vous ne savez pas quelle ressource est r√©ellement consomm√©e**. Vous optimiseriez √† l'aveugle.

### La solution : pg_stat_kcache

pg_stat_kcache ajoute √† chaque requ√™te track√©e des m√©triques comme :
- ‚è±Ô∏è **Temps CPU** (user + system)
- üíæ **I/O physiques** (lectures et √©critures disque)
- üìä **Page faults** (d√©fauts de page)

Ainsi, vous pouvez distinguer :
```
Requ√™te A : 100ms = 90ms CPU + 10ms I/O wait ‚Üí Optimiser l'algorithme
Requ√™te B : 100ms = 10ms CPU + 90ms I/O wait ‚Üí Ajouter un index, augmenter la RAM
```

**pg_stat_kcache transforme les statistiques SQL en diagnostics syst√®me exploitables.**

---

## Qu'est-ce que pg_stat_kcache ?

### D√©finition

**pg_stat_kcache** (PostgreSQL Statistics Kernel Cache) est une **extension PostgreSQL** qui :
1. S'int√®gre √† **pg_stat_statements** (l'extension standard de statistiques de requ√™tes)
2. R√©cup√®re des **m√©triques syst√®me au niveau kernel** via les appels syst√®me Linux
3. Associe ces m√©triques √† chaque requ√™te SQL ex√©cut√©e

### Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        Application / Utilisateur            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ Requ√™te SQL
                   ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            PostgreSQL Server                ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ  ‚îÇ     pg_stat_statements           ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ  (Statistiques de requ√™tes)      ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Temps d'ex√©cution             ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Nombre d'appels               ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Plans d'ex√©cution             ‚îÇ       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
‚îÇ                 ‚îÇ                           ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ  ‚îÇ       pg_stat_kcache             ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ  (M√©triques syst√®me)             ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Temps CPU                     ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ I/O disque                    ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Page faults                   ‚îÇ       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
                  ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Kernel Linux (Syst√®me)              ‚îÇ
‚îÇ  ‚Ä¢ Compteurs CPU (getrusage)                ‚îÇ
‚îÇ  ‚Ä¢ Statistiques I/O (/proc/[pid]/io)        ‚îÇ
‚îÇ  ‚Ä¢ M√©triques m√©moire                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Pourquoi "kcache" ?

Le nom **kcache** vient de **"kernel cache"**, car l'extension interroge les statistiques du **noyau syst√®me** (kernel) pour obtenir des informations sur :
- L'utilisation du cache syst√®me
- Les acc√®s disque r√©els (I/O physiques)
- Le temps CPU consomm√©

---

## Concepts fondamentaux : Comprendre les m√©triques

Avant de plonger dans pg_stat_kcache, comprenons les m√©triques syst√®me qu'il expose.

### 1. Temps CPU (CPU Time)

Le **temps CPU** repr√©sente le temps r√©ellement utilis√© par le processeur pour ex√©cuter des instructions.

#### User Time vs System Time

Le temps CPU se divise en deux cat√©gories :

| Type | Description | Exemple d'op√©rations |
|------|-------------|----------------------|
| **User Time** | Temps pass√© en mode utilisateur (code applicatif) | Tri de donn√©es, calculs, jointures, agr√©gations |
| **System Time** | Temps pass√© en mode noyau (appels syst√®me) | Lecture/√©criture fichiers, allocation m√©moire, gestion r√©seau |

**Formule** :
```
Temps CPU total = User Time + System Time
```

#### Temps CPU vs Temps r√©el (Wall-clock time)

**Distinction importante** :
- **Temps r√©el** : Temps √©coul√© du d√©but √† la fin de la requ√™te (ce que vous voyez avec `\timing` dans psql)
- **Temps CPU** : Temps o√π le CPU a r√©ellement travaill√© pour cette requ√™te

**Exemple** :
```
Requ√™te SELECT : 1000ms de temps r√©el
                 100ms de temps CPU

‚Üí 900ms d'attente : I/O disque, verrous, r√©seau, etc.
‚Üí 100ms de calcul effectif par le CPU
```

**Pourquoi cette diff√©rence ?**
Pendant les 900ms d'attente, le CPU ne fait rien pour cette requ√™te. Il attend :
- Que le disque lise les donn√©es
- Qu'un verrou soit lib√©r√©
- Qu'un r√©seau r√©ponde (dans le cas de Foreign Data Wrappers)

### 2. I/O disque (Disk I/O)

Les **I/O disque** repr√©sentent les op√©rations de lecture et √©criture physiques sur le disque.

#### Lectures (Reads)

| M√©trique | Description |
|----------|-------------|
| **Physical reads** | Lectures r√©elles depuis le disque (lent) |
| **Logical reads** | Lectures depuis le cache m√©moire (rapide) |

**Objectif d'optimisation** : Maximiser les logical reads (cache hit) et minimiser les physical reads.

#### √âcritures (Writes)

| Type | Description |
|------|-------------|
| **Dirty pages** | Pages modifi√©es en m√©moire, pas encore √©crites |
| **Write I/O** | √âcritures r√©elles vers le disque |

**Note** : PostgreSQL utilise le WAL (Write-Ahead Log) pour optimiser les √©critures.

#### Pourquoi mesurer les I/O ?

Les I/O sont **le principal goulot d'√©tranglement** des bases de donn√©es :

| Op√©ration | Latence typique |
|-----------|-----------------|
| Acc√®s RAM | ~100 nanosecondes |
| Acc√®s SSD | ~100 microsecondes (1000√ó plus lent) |
| Acc√®s HDD | ~10 millisecondes (100 000√ó plus lent) |

**Une seule lecture disque peut co√ªter plus cher que 1000 op√©rations en RAM.**

### 3. Page Faults (D√©fauts de page)

Un **page fault** survient lorsque PostgreSQL demande une page m√©moire qui n'est pas en RAM.

#### Types de page faults

| Type | Description | Impact |
|------|-------------|--------|
| **Minor page fault** | La page est en m√©moire mais non mapp√©e | Faible (quelques microsecondes) |
| **Major page fault** | La page doit √™tre charg√©e depuis le disque | √âlev√© (plusieurs millisecondes) |

**Indicateur** :
- **Beaucoup de minor faults** : Gestion m√©moire normale
- **Beaucoup de major faults** : Manque de RAM, thrashing possible

### R√©sum√© visuel des m√©triques

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Ex√©cution d'une requ√™te                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                         ‚îÇ
‚îÇ  Temps r√©el (1000ms)                                    ‚îÇ
‚îÇ  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê    ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ CPU  ‚îÇ  I/O    ‚îÇCPU ‚îÇ Lock ‚îÇ  I/O   ‚îÇ CPU ‚îÇCPU ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ 50ms ‚îÇ wait    ‚îÇ20ms‚îÇ wait ‚îÇ  500ms ‚îÇwait ‚îÇ30ms‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò 200ms   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò 100ms‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò50ms ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  CPU total = 50 + 20 + 30 = 100ms                       ‚îÇ
‚îÇ  I/O total = 200 + 500 = 700ms                          ‚îÇ
‚îÇ  Wait (locks) = 100 + 50 = 150ms                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Installation et configuration de pg_stat_kcache

### Pr√©requis

1. **Syst√®me d'exploitation** : Linux (pg_stat_kcache utilise des APIs sp√©cifiques Linux)
2. **PostgreSQL** : Version 9.4 ou sup√©rieure
3. **pg_stat_statements** : Doit √™tre install√© et activ√©

**Note** : pg_stat_kcache ne fonctionne pas sur Windows ou macOS car il d√©pend d'interfaces Linux (`/proc/[pid]/io`).

### √âtape 1 : Installer l'extension

#### Sur Debian/Ubuntu

```bash
# Installer le paquet
sudo apt-get install postgresql-contrib

# Ou pour une version sp√©cifique
sudo apt-get install postgresql-18-pg-stat-kcache
```

#### Sur Red Hat/CentOS

```bash
sudo yum install pg_stat_kcache_18
```

#### Compilation depuis les sources (si non disponible en paquet)

```bash
# T√©l√©charger
git clone https://github.com/powa-team/pg_stat_kcache.git
cd pg_stat_kcache

# Compiler
make
sudo make install
```

### √âtape 2 : Configuration PostgreSQL

√âditer le fichier **postgresql.conf** :

```ini
# 1. Charger les extensions au d√©marrage
shared_preload_libraries = 'pg_stat_statements,pg_stat_kcache'

# 2. Configuration de pg_stat_statements (pr√©requis)
pg_stat_statements.max = 10000
pg_stat_statements.track = all
pg_stat_statements.track_utility = on

# 3. Pas de configuration sp√©cifique pour pg_stat_kcache
# (il h√©rite de pg_stat_statements)
```

**Explication** :
- `shared_preload_libraries` : Charge les extensions au d√©marrage du serveur
- `pg_stat_statements.max` : Nombre max de requ√™tes distinctes track√©es
- `pg_stat_statements.track = all` : Track toutes les requ√™tes (m√™me dans les fonctions)

### √âtape 3 : Red√©marrer PostgreSQL

```bash
# Red√©marrage n√©cessaire pour charger les extensions
sudo systemctl restart postgresql

# Ou selon votre installation
sudo pg_ctlcluster 18 main restart
```

### √âtape 4 : Cr√©er les extensions dans la base

Se connecter √† la base de donn√©es cible :

```sql
-- Cr√©er pg_stat_statements d'abord
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- Puis cr√©er pg_stat_kcache
CREATE EXTENSION IF NOT EXISTS pg_stat_kcache;
```

### V√©rification de l'installation

```sql
-- V√©rifier que les extensions sont actives
SELECT * FROM pg_extension
WHERE extname IN ('pg_stat_statements', 'pg_stat_kcache');

-- V√©rifier que les vues sont disponibles
\d pg_stat_kcache
```

**R√©sultat attendu** :
```
         View "public.pg_stat_kcache"
      Column       |  Type   | Collation | ...
-------------------+---------+-----------+----
 queryid           | bigint  |           |
 top               | boolean |           |
 userid            | oid     |           |
 dbid              | oid     |           |
 plan_user_time    | double  |           |
 plan_system_time  | double  |           |
 exec_user_time    | double  |           |
 exec_system_time  | double  |           |
 reads             | bigint  |           |
 writes            | bigint  |           |
 ...
```

---

## Comprendre les vues et les colonnes

pg_stat_kcache expose principalement une vue : **pg_stat_kcache**.

### Structure de la vue pg_stat_kcache

#### Colonnes de liaison

| Colonne | Type | Description |
|---------|------|-------------|
| `queryid` | bigint | Identifiant unique de la requ√™te (hash) |
| `userid` | oid | OID de l'utilisateur ayant ex√©cut√© la requ√™te |
| `dbid` | oid | OID de la base de donn√©es |
| `top` | boolean | true si requ√™te de niveau top (pas dans une fonction) |

**Note** : Ces colonnes permettent de **joindre** avec `pg_stat_statements`.

#### Colonnes de m√©triques CPU

| Colonne | Type | Unit√© | Description |
|---------|------|-------|-------------|
| `plan_user_time` | double | secondes | Temps CPU user pour la phase de planification |
| `plan_system_time` | double | secondes | Temps CPU syst√®me pour la phase de planification |
| `exec_user_time` | double | secondes | Temps CPU user pour l'ex√©cution |
| `exec_system_time` | double | secondes | Temps CPU syst√®me pour l'ex√©cution |

**Formules d√©riv√©es** :
```sql
-- Temps CPU total de planification
plan_user_time + plan_system_time

-- Temps CPU total d'ex√©cution
exec_user_time + exec_system_time

-- Temps CPU total (plan + exec)
plan_user_time + plan_system_time + exec_user_time + exec_system_time
```

#### Colonnes de m√©triques I/O

| Colonne | Type | Unit√© | Description |
|---------|------|-------|-------------|
| `reads` | bigint | octets | Nombre d'octets lus depuis le disque |
| `writes` | bigint | octets | Nombre d'octets √©crits sur le disque |
| `user_time` | double | secondes | Temps CPU user total (deprecated, utiliser exec_user_time) |
| `system_time` | double | secondes | Temps CPU syst√®me total (deprecated) |

**Conversion en unit√©s lisibles** :
```sql
-- Convertir les octets en MB
reads / (1024.0 * 1024.0) AS reads_mb
writes / (1024.0 * 1024.0) AS writes_mb

-- Convertir en GB
reads / (1024.0 * 1024.0 * 1024.0) AS reads_gb
```

### Jointure avec pg_stat_statements

**La vraie puissance** de pg_stat_kcache vient de sa combinaison avec pg_stat_statements :

```sql
SELECT
    pss.query,                              -- Texte de la requ√™te
    pss.calls,                              -- Nombre d'ex√©cutions
    pss.mean_exec_time,                     -- Temps moyen d'ex√©cution (ms)
    pss.total_exec_time,                    -- Temps total cumul√© (ms)

    -- M√©triques CPU de pg_stat_kcache
    psk.exec_user_time * 1000 AS cpu_user_ms,
    psk.exec_system_time * 1000 AS cpu_system_ms,
    (psk.exec_user_time + psk.exec_system_time) * 1000 AS cpu_total_ms,

    -- M√©triques I/O de pg_stat_kcache
    psk.reads / (1024 * 1024) AS reads_mb,
    psk.writes / (1024 * 1024) AS writes_mb

FROM pg_stat_statements pss
JOIN pg_stat_kcache psk
    ON pss.queryid = psk.queryid
    AND pss.userid = psk.userid
    AND pss.dbid = psk.dbid
ORDER BY pss.total_exec_time DESC
LIMIT 20;
```

---

## Cas d'usage pratiques

### 1. Identifier les requ√™tes CPU-intensives

**Objectif** : Trouver les requ√™tes qui consomment le plus de temps CPU.

```sql
SELECT
    LEFT(pss.query, 80) AS query_preview,
    pss.calls,
    ROUND(pss.mean_exec_time::numeric, 2) AS avg_time_ms,

    -- Temps CPU total (en secondes)
    ROUND((psk.exec_user_time + psk.exec_system_time)::numeric, 2) AS total_cpu_sec,

    -- Temps CPU par ex√©cution (en millisecondes)
    ROUND((psk.exec_user_time + psk.exec_system_time) * 1000 / pss.calls, 2) AS cpu_per_call_ms,

    -- Pourcentage du temps pass√© en CPU
    ROUND(100.0 * (psk.exec_user_time + psk.exec_system_time) /
          (pss.total_exec_time / 1000.0), 1) AS cpu_percent

FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
WHERE pss.calls > 10
ORDER BY (psk.exec_user_time + psk.exec_system_time) DESC
LIMIT 15;
```

**Interpr√©tation** :

| cpu_percent | Signification | Action recommand√©e |
|-------------|---------------|-------------------|
| > 80% | Requ√™te CPU-bound | Optimiser l'algorithme, r√©duire les calculs, indexer |
| 50-80% | Mixte CPU/I/O | Optimiser les deux aspects |
| < 20% | Requ√™te I/O-bound | Optimiser les acc√®s disque, ajouter des index, augmenter le cache |

**Exemple de r√©sultat** :
```
query_preview                                    | calls | avg_time_ms | total_cpu_sec | cpu_per_call_ms | cpu_percent
-------------------------------------------------+-------+-------------+---------------+-----------------+------------
SELECT COUNT(*) FROM orders GROUP BY product_id | 5000  | 250         | 1200          | 240             | 96
```
‚Üí **96% du temps en CPU** : Cette requ√™te fait beaucoup de calculs. Solutions possibles :
- Ajouter un index sur `product_id`
- Cr√©er une vue mat√©rialis√©e avec les agr√©gations pr√©-calcul√©es
- Utiliser un index GIN si c'est pour de la recherche full-text

### 2. Identifier les requ√™tes I/O-intensives

**Objectif** : Trouver les requ√™tes qui font beaucoup d'acc√®s disque.

```sql
SELECT
    LEFT(pss.query, 80) AS query_preview,
    pss.calls,
    ROUND(pss.mean_exec_time::numeric, 2) AS avg_time_ms,

    -- I/O total (en MB)
    ROUND((psk.reads / 1024.0 / 1024.0)::numeric, 2) AS total_reads_mb,
    ROUND((psk.writes / 1024.0 / 1024.0)::numeric, 2) AS total_writes_mb,

    -- I/O par appel (en KB)
    ROUND((psk.reads / 1024.0 / pss.calls)::numeric, 1) AS reads_per_call_kb,

    -- Ratio I/O wait
    ROUND(100.0 * (1 - (psk.exec_user_time + psk.exec_system_time) /
          (pss.total_exec_time / 1000.0)), 1) AS io_wait_percent

FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
WHERE pss.calls > 10
ORDER BY psk.reads DESC
LIMIT 15;
```

**Interpr√©tation** :

| io_wait_percent | Signification | Action recommand√©e |
|-----------------|---------------|-------------------|
| > 80% | I/O-bound | Ajouter des index, augmenter shared_buffers, optimiser le cache |
| 50-80% | Mixte | Optimiser √† la fois la requ√™te et les I/O |
| < 20% | CPU-bound | Focus sur l'optimisation algorithmique |

**Exemple de r√©sultat** :
```
query_preview                           | calls | avg_time_ms | total_reads_mb | reads_per_call_kb | io_wait_percent
----------------------------------------+-------+-------------+----------------+-------------------+----------------
SELECT * FROM logs WHERE date > $1      | 1000  | 500         | 5000           | 5120              | 95
```
‚Üí **95% du temps en attente I/O**, 5MB lus par appel : Cette requ√™te scan une grosse table sans index.

**Solutions** :
- Cr√©er un index sur la colonne `date`
- Partitionner la table `logs` par date (Range partitioning)
- Archiver les vieilles donn√©es

### 3. Comparer les performances avant/apr√®s optimisation

**Sc√©nario** : Vous avez ajout√© un index. Quel est l'impact r√©el ?

```sql
-- 1. Reset des statistiques AVANT optimisation
SELECT pg_stat_statements_reset();

-- 2. Ex√©cuter les tests de charge
-- ... (votre application / tests)

-- 3. Capturer les m√©triques AVANT
CREATE TEMP TABLE metrics_before AS
SELECT
    queryid,
    query,
    calls,
    total_exec_time,
    exec_user_time + exec_system_time AS total_cpu_time,
    reads,
    writes
FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid);

-- 4. Appliquer l'optimisation (ex: CREATE INDEX)
CREATE INDEX idx_orders_date ON orders(date);

-- 5. Reset et re-test
SELECT pg_stat_statements_reset();
-- ... (re-ex√©cuter les m√™mes tests)

-- 6. Comparer
SELECT
    b.query,

    -- Am√©lioration du temps total
    ROUND(100.0 * (b.total_exec_time - a.total_exec_time) /
          b.total_exec_time, 1) AS time_improvement_pct,

    -- Am√©lioration CPU
    ROUND(100.0 * (b.total_cpu_time - a.total_cpu_time) /
          b.total_cpu_time, 1) AS cpu_improvement_pct,

    -- R√©duction des I/O
    ROUND(100.0 * (b.reads - a.reads) / b.reads, 1) AS io_reduction_pct

FROM metrics_before b
JOIN (
    SELECT
        queryid, calls, total_exec_time,
        exec_user_time + exec_system_time AS total_cpu_time,
        reads, writes
    FROM pg_stat_statements pss
    JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
) a USING (queryid)
WHERE b.calls > 10
ORDER BY time_improvement_pct DESC;
```

**Exemple de r√©sultat** :
```
query                                    | time_improvement_pct | cpu_improvement_pct | io_reduction_pct
-----------------------------------------+----------------------+---------------------+-----------------
SELECT * FROM orders WHERE date > $1     | 85                   | 20                  | 95
```
‚Üí **Interpr√©tation** :
- Temps total r√©duit de 85% ‚úÖ
- CPU r√©duit de 20% (faible impact, normal)
- I/O r√©duits de 95% ‚úÖ (impact majeur de l'index)

**Conclusion** : L'optimisation a principalement r√©duit les I/O, ce qui est coh√©rent avec l'ajout d'un index.

### 4. D√©tecter les requ√™tes avec un mauvais ratio CPU/temps r√©el

**Objectif** : Identifier les requ√™tes qui passent beaucoup de temps √† "attendre" plut√¥t qu'√† calculer.

```sql
SELECT
    LEFT(pss.query, 80) AS query_preview,
    pss.calls,
    ROUND(pss.mean_exec_time::numeric, 2) AS avg_time_ms,

    -- Temps CPU moyen par appel
    ROUND((psk.exec_user_time + psk.exec_system_time) * 1000 / pss.calls, 2) AS cpu_per_call_ms,

    -- Temps d'attente moyen (temps r√©el - temps CPU)
    ROUND(pss.mean_exec_time -
          (psk.exec_user_time + psk.exec_system_time) * 1000 / pss.calls, 2) AS wait_time_ms,

    -- Ratio d'efficacit√© (plus c'est haut, plus c'est efficace)
    ROUND(100.0 * (psk.exec_user_time + psk.exec_system_time) * 1000 /
          (pss.total_exec_time), 1) AS efficiency_pct

FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
WHERE pss.calls > 10
ORDER BY efficiency_pct ASC  -- Les moins efficaces en premier
LIMIT 20;
```

**Interpr√©tation** :

| efficiency_pct | Cause probable | Investigation |
|----------------|----------------|---------------|
| < 10% | I/O ou verrous | V√©rifier les index, pg_locks, autovacuum |
| 10-30% | I/O + calculs | Optimisation mixte |
| > 70% | Principalement CPU | Optimisation algorithmique |

**Exemple** :
```
query_preview                        | avg_time_ms | cpu_per_call_ms | wait_time_ms | efficiency_pct
-------------------------------------+-------------+-----------------+--------------+---------------
UPDATE products SET stock = stock-$1 | 2000        | 50              | 1950         | 2.5
```
‚Üí **2.5% d'efficacit√©** : La requ√™te passe 1950ms sur 2000ms √† attendre !

**Causes possibles** :
- Verrous (row-level locks) ‚Üí V√©rifier avec `pg_locks`
- Checkpoints lents ‚Üí V√©rifier `log_checkpoints`
- Disque satur√© ‚Üí V√©rifier `iostat`, `iotop`

### 5. Surveiller l'√©volution dans le temps

**Objectif** : Cr√©er une base de donn√©es historique des m√©triques.

```sql
-- Cr√©er une table d'historique
CREATE TABLE query_metrics_history (
    snapshot_time TIMESTAMP DEFAULT NOW(),
    queryid BIGINT,
    query TEXT,
    calls BIGINT,
    total_time_ms NUMERIC,
    avg_time_ms NUMERIC,
    total_cpu_sec NUMERIC,
    reads_mb NUMERIC,
    writes_mb NUMERIC
);

-- Job quotidien (via pg_cron ou cron syst√®me)
INSERT INTO query_metrics_history
SELECT
    NOW(),
    pss.queryid,
    LEFT(pss.query, 200),
    pss.calls,
    pss.total_exec_time,
    pss.mean_exec_time,
    psk.exec_user_time + psk.exec_system_time,
    psk.reads / 1024.0 / 1024.0,
    psk.writes / 1024.0 / 1024.0
FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
WHERE pss.calls > 10;

-- Analyse des tendances
SELECT
    DATE_TRUNC('day', snapshot_time) AS day,
    query,
    AVG(avg_time_ms) AS avg_time_trend,
    AVG(total_cpu_sec) AS avg_cpu_trend,
    AVG(reads_mb) AS avg_reads_trend
FROM query_metrics_history
WHERE snapshot_time > NOW() - INTERVAL '30 days'
GROUP BY 1, 2
ORDER BY 1 DESC, 3 DESC;
```

**B√©n√©fice** : D√©tecter les **r√©gressions de performance** au fil du temps.

---

## Limitations et consid√©rations

### Limitations techniques

#### 1. Support Linux uniquement

pg_stat_kcache utilise des interfaces sp√©cifiques Linux :
- `/proc/[pid]/io` pour les m√©triques I/O
- `getrusage()` pour les m√©triques CPU

**Cons√©quence** : Ne fonctionne pas sur Windows, macOS, BSD.

**Alternative** : Utiliser les m√©triques syst√®me globales (Prometheus, node_exporter) mais sans corr√©lation par requ√™te.

#### 2. Overhead de monitoring

pg_stat_kcache ajoute un **l√©ger overhead** :
- Appels syst√®me suppl√©mentaires pour chaque requ√™te
- Impact estim√© : **0.5-2%** de CPU suppl√©mentaire

**Recommandation** : Acceptable en production, mais √† √©valuer selon votre contexte.

#### 3. Pr√©cision des m√©triques

Les m√©triques sont **cumulatives** et **approximatives** :
- Arrondis dus √† la granularit√© du kernel
- Possible attribution impr√©cise en cas de forte concurrence
- Les m√©triques I/O peuvent ne pas refl√©ter 100% des acc√®s disque (cache filesystem)

**Utilisation** : Pour les **tendances** et **comparaisons relatives**, pas pour des mesures absolues au microseconde pr√®s.

### Consid√©rations op√©rationnelles

#### 1. Taille de pg_stat_statements.max

Si `pg_stat_statements.max` est trop petit, les anciennes entr√©es sont √©vinc√©es.

**Cons√©quence** : Perte d'historique, m√©triques incompl√®tes.

**Recommandation** :
```ini
pg_stat_statements.max = 10000  # Minimum
pg_stat_statements.max = 50000  # Pour grandes applications
```

#### 2. Reset des statistiques

Les m√©triques sont **cumulatives** depuis le dernier reset ou red√©marrage.

**Commandes** :
```sql
-- Reset complet (pg_stat_statements + pg_stat_kcache)
SELECT pg_stat_statements_reset();

-- Attention : perte de tout l'historique !
```

**Strat√©gie** : Sauvegarder les m√©triques dans une table historique avant reset.

#### 3. Interpr√©tation en environnement conteneuris√©

Dans **Docker/Kubernetes**, les m√©triques peuvent √™tre fauss√©es :
- Limites CPU (cgroups) non refl√©t√©es
- I/O du conteneur vs I/O de l'h√¥te

**Recommandation** : Corr√©ler avec les m√©triques du conteneur (cAdvisor, Kubernetes metrics).

---

## Int√©gration avec d'autres outils

### 1. PoWA (PostgreSQL Workload Analyzer)

**PoWA** est une suite d'outils qui int√®gre naturellement pg_stat_kcache.

#### Qu'est-ce que PoWA ?

PoWA collecte et visualise les m√©triques PostgreSQL dans le temps, incluant :
- pg_stat_statements
- pg_stat_kcache
- pg_qualstats (statistiques sur les pr√©dicats WHERE)
- pg_wait_sampling (√©chantillonnage des wait events)

#### Installation rapide

```bash
# Installer PoWA
sudo apt-get install postgresql-18-powa

# Cr√©er l'extension
CREATE EXTENSION powa;
CREATE EXTENSION pg_stat_kcache;

# D√©marrer l'interface web PoWA-web
pip install powa-web
powa-web
```

**Interface web** : Graphiques interactifs montrant l'√©volution de CPU, I/O, et temps d'ex√©cution par requ√™te.

### 2. Grafana + Prometheus

Exporter les m√©triques pg_stat_kcache vers Prometheus.

#### Utiliser postgres_exporter

```yaml
# Dans postgres_exporter, ajouter une query custom
- name: pg_stat_kcache
  query: |
    SELECT
      queryid,
      exec_user_time,
      exec_system_time,
      reads,
      writes
    FROM pg_stat_kcache
```

**Visualisation Grafana** :
- Graphiques de CPU par requ√™te
- Graphiques d'I/O par requ√™te
- Alertes sur seuils (ex: > 10s CPU total)

### 3. pgBadger

pgBadger peut **partiellement** extraire des m√©triques syst√®me depuis les logs, mais c'est moins pr√©cis que pg_stat_kcache.

**Compl√©mentarit√©** :
- **pgBadger** : Analyse historique des logs (texte des requ√™tes, erreurs)
- **pg_stat_kcache** : M√©triques syst√®me temps r√©el, pr√©cises, par requ√™te

**Utilisation combin√©e** :
1. pg_stat_kcache pour identifier les requ√™tes probl√©matiques
2. pgBadger pour analyser les logs et le contexte d'ex√©cution

### 4. Datadog, New Relic (APM)

Les outils APM peuvent ing√©rer les m√©triques pg_stat_kcache via des int√©grations.

**Exemple avec Datadog** :
```yaml
# datadog.yaml - Custom queries
custom_queries:
  - query: |
      SELECT
        query,
        calls,
        total_exec_time,
        exec_user_time + exec_system_time AS cpu_time
      FROM pg_stat_statements pss
      JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
    columns:
      - name: query
        type: tag
      - name: calls
        type: gauge
      - name: cpu_time
        type: gauge
```

---

## Bonnes pratiques

### 1. D√©finir des seuils d'alerte

| M√©trique | Seuil d'alerte | Action |
|----------|----------------|--------|
| CPU total par requ√™te | > 10 secondes | Optimiser l'algorithme |
| I/O reads par requ√™te | > 100 MB | Ajouter des index, revoir le cache |
| I/O wait % | > 80% | Probl√®me de disque ou index manquants |
| Efficiency % | < 10% | Investigation approfondie (locks, I/O) |

### 2. Automatiser la collecte

**Script quotidien** (via cron ou pg_cron) :
```sql
-- Sauvegarder les top 50 requ√™tes
INSERT INTO query_metrics_history
SELECT NOW(), * FROM (
    SELECT
        pss.queryid, pss.query, pss.calls, pss.total_exec_time,
        psk.exec_user_time, psk.exec_system_time, psk.reads, psk.writes
    FROM pg_stat_statements pss
    JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
    ORDER BY pss.total_exec_time DESC
    LIMIT 50
) top_queries;
```

### 3. Corr√©ler avec les m√©triques syst√®me

Ne jamais analyser pg_stat_kcache en isolation :
- V√©rifier la charge CPU globale (`top`, `htop`)
- V√©rifier les I/O globaux (`iostat -x 1`)
- V√©rifier la m√©moire (`free -h`, cache hit ratio)

**Exemple de corr√©lation** :
```
pg_stat_kcache : 5 requ√™tes consomment 90% du CPU
htop : CPU √† 100%, load average = 20
‚Üí Conclusion : Ces 5 requ√™tes saturent le serveur
```

### 4. Documenter les optimisations

**Template de documentation** :
```markdown
## Optimisation : Requ√™te lente SELECT orders

**Date** : 2025-11-21
**Probl√®me identifi√©** :
- Temps d'ex√©cution : 2.5s
- CPU : 200ms (8%)
- I/O wait : 2.3s (92%)
- Reads : 500MB par appel

**Cause racine** : Scan s√©quentiel sur table orders (5M lignes), pas d'index sur date.

**Solution appliqu√©e** :
CREATE INDEX idx_orders_date ON orders(created_at);

**R√©sultat** :
- Temps d'ex√©cution : 150ms (94% plus rapide)
- CPU : 50ms
- I/O wait : 100ms (96% de r√©duction)
- Reads : 5MB par appel
```

### 5. Former les d√©veloppeurs

**Sensibiliser l'√©quipe** aux m√©triques syst√®me :
- Expliquer la diff√©rence CPU vs I/O
- Montrer comment interpr√©ter les m√©triques
- Int√©grer l'analyse dans le code review

**Exemple de checklist PR** :
```
[ ] Requ√™tes SQL optimis√©es
[ ] M√©triques pg_stat_kcache v√©rifi√©es en staging
[ ] Pas de r√©gression de performance (temps, CPU, I/O)
[ ] Index appropri√©s cr√©√©s
```

---

## Comparaison avec d'autres outils

### pg_stat_kcache vs EXPLAIN ANALYZE

| Crit√®re | pg_stat_kcache | EXPLAIN ANALYZE |
|---------|----------------|-----------------|
| **Usage** | Monitoring continu | Analyse ponctuelle |
| **M√©triques** | CPU, I/O r√©els | Plan d'ex√©cution, estimations |
| **Overhead** | Tr√®s faible | √âlev√© (peut ralentir la requ√™te) |
| **Historique** | Oui (cumulatif) | Non |
| **Niveau** | Toutes les requ√™tes | Une requ√™te √† la fois |

**Compl√©mentarit√©** :
1. **pg_stat_kcache** pour identifier les requ√™tes probl√©matiques
2. **EXPLAIN ANALYZE** pour comprendre pourquoi elles sont lentes

### pg_stat_kcache vs auto_explain

**auto_explain** : Extension qui log automatiquement le plan des requ√™tes lentes.

| Crit√®re | pg_stat_kcache | auto_explain |
|---------|----------------|--------------|
| **Activation** | Toujours actif | Seulement si seuil d√©pass√© |
| **Output** | M√©triques SQL | Plans d'ex√©cution dans les logs |
| **Analyse** | Requ√™tes SQL | Lecture des logs |
| **Performance** | Faible impact | Impact mod√©r√© |

**Utilisation combin√©e** :
```ini
# postgresql.conf
shared_preload_libraries = 'pg_stat_statements,pg_stat_kcache,auto_explain'

auto_explain.log_min_duration = 1000  # Log si > 1s
auto_explain.log_analyze = on
auto_explain.log_buffers = on
```

### pg_stat_kcache vs outils syst√®me (iostat, top)

| Crit√®re | pg_stat_kcache | iostat/top |
|---------|----------------|------------|
| **Granularit√©** | Par requ√™te SQL | Global (serveur) |
| **Corr√©lation** | SQL ‚Üî ressources | Non |
| **Historique** | Oui (cumulatif) | Non (snapshot) |
| **Setup** | Extension PostgreSQL | Outils syst√®me standard |

**Les deux sont n√©cessaires** :
- **pg_stat_kcache** : Identifier quelle requ√™te consomme
- **iostat/top** : V√©rifier la sant√© globale du syst√®me

---

## D√©pannage (Troubleshooting)

### Probl√®me 1 : Extension non disponible

**Sympt√¥me** :
```sql
CREATE EXTENSION pg_stat_kcache;
ERROR:  could not open extension control file "...": No such file or directory
```

**Causes possibles** :
1. Extension non install√©e
2. Mauvaise version PostgreSQL

**Solution** :
```bash
# V√©rifier disponibilit√©
apt search pg_stat_kcache

# Installer la bonne version
sudo apt install postgresql-18-pg-stat-kcache
```

### Probl√®me 2 : Vue vide

**Sympt√¥me** :
```sql
SELECT * FROM pg_stat_kcache;
-- Retourne 0 lignes
```

**Causes** :
1. `shared_preload_libraries` mal configur√©
2. Extension charg√©e apr√®s le d√©marrage
3. Pas d'activit√© depuis le d√©marrage

**Solution** :
```sql
-- V√©rifier que l'extension est charg√©e
SHOW shared_preload_libraries;
-- Doit contenir 'pg_stat_kcache'

-- Si absent, √©diter postgresql.conf et red√©marrer
```

### Probl√®me 3 : M√©triques I/O √† z√©ro

**Sympt√¥me** :
```sql
SELECT * FROM pg_stat_kcache;
-- reads et writes = 0 pour toutes les requ√™tes
```

**Cause** : Sur certains syst√®mes, `/proc/[pid]/io` n√©cessite des permissions sp√©ciales.

**Solution** :
```bash
# V√©rifier les permissions
sudo cat /proc/self/io

# Si erreur "Permission denied", ajuster les permissions
# (n√©cessite root ou modification du syst√®me)
```

### Probl√®me 4 : Overhead trop √©lev√©

**Sympt√¥me** : CPU du serveur augmente apr√®s activation de pg_stat_kcache.

**Solution** :
1. R√©duire `pg_stat_statements.max` (moins de requ√™tes track√©es)
2. D√©sactiver temporairement si n√©cessaire :
```sql
-- D√©sactiver temporairement
ALTER SYSTEM SET shared_preload_libraries = 'pg_stat_statements';
SELECT pg_reload_conf();
-- (n√©cessite red√©marrage pour effet complet)
```

---

## Conclusion

### Ce qu'il faut retenir

**pg_stat_kcache est un outil essentiel** pour comprendre la **consommation r√©elle des ressources syst√®me** par vos requ√™tes SQL.

**Points cl√©s** :
- ‚úÖ Compl√®te pg_stat_statements avec des m√©triques CPU et I/O
- ‚úÖ Permet de distinguer les requ√™tes CPU-bound vs I/O-bound
- ‚úÖ Aide √† prioriser les optimisations selon l'impact syst√®me
- ‚úÖ Faible overhead, adapt√© √† la production
- ‚úÖ Int√©gration facile avec d'autres outils (PoWA, Grafana, APM)

**Limitations** :
- ‚ö†Ô∏è Linux uniquement
- ‚ö†Ô∏è M√©triques cumulatives, pas temps r√©el pur
- ‚ö†Ô∏è N√©cessite pg_stat_statements

### Workflow recommand√©

```
1. Identifier les requ√™tes lentes (pg_stat_statements)
   ‚Üì
2. Analyser le profil syst√®me (pg_stat_kcache)
   ‚Üì
3. D√©terminer si CPU-bound ou I/O-bound
   ‚Üì
4. Appliquer l'optimisation appropri√©e :
   - CPU-bound ‚Üí Optimiser algorithme, index
   - I/O-bound ‚Üí Index, cache, partitionnement
   ‚Üì
5. Valider l'am√©lioration (comparer avant/apr√®s)
   ‚Üì
6. Documenter et monitorer dans le temps
```

### Prochaines √©tapes

Apr√®s avoir ma√Ætris√© pg_stat_kcache, vous pouvez explorer :
1. **PoWA** : Interface graphique pour pg_stat_kcache
2. **pg_wait_sampling** : Analyse des wait events
3. **pg_qualstats** : Statistiques sur les pr√©dicats WHERE
4. **auto_explain** : Logging automatique des plans lents
5. **Prometheus + Grafana** : Dashboards de m√©triques en temps r√©el

**pg_stat_kcache transforme les statistiques de requ√™tes en diagnostics syst√®me exploitables.** C'est un pilier de l'observabilit√© PostgreSQL moderne.

---

## Ressources compl√©mentaires

### Documentation officielle

- **GitHub** : https://github.com/powa-team/pg_stat_kcache
- **PoWA Project** : https://powa.readthedocs.io/
- **pg_stat_statements** : https://www.postgresql.org/docs/current/pgstatstatements.html

### Articles recommand√©s

- "Understanding PostgreSQL Query Performance" - 2ndQuadrant Blog
- "Advanced PostgreSQL Monitoring" - Percona Blog
- "CPU vs I/O Bound Queries" - Cybertec PostgreSQL Blog

### Communaut√©

- **PostgreSQL Performance Mailing List** : pgsql-performance@postgresql.org
- **Reddit** : r/PostgreSQL
- **Stack Overflow** : Tag [postgresql-performance]

---

## Glossaire

| Terme | D√©finition |
|-------|------------|
| **User Time** | Temps CPU pass√© en mode utilisateur (code applicatif) |
| **System Time** | Temps CPU pass√© en appels syst√®me (kernel) |
| **Wall-clock Time** | Temps r√©el √©coul√© du d√©but √† la fin |
| **I/O wait** | Temps pass√© √† attendre les op√©rations disque |
| **Page fault** | D√©faut de page m√©moire (acc√®s √† une page non charg√©e) |
| **Physical reads** | Lectures r√©elles depuis le disque |
| **Logical reads** | Lectures depuis le cache m√©moire |
| **CPU-bound** | Limit√© par la capacit√© de calcul du CPU |
| **I/O-bound** | Limit√© par la vitesse des acc√®s disque |
| **Kernel** | Noyau du syst√®me d'exploitation |
| **getrusage()** | Appel syst√®me pour obtenir l'utilisation des ressources |

---


‚è≠Ô∏è [Prometheus + postgres_exporter + Grafana](/14-observabilite-et-monitoring/07.3-prometheus-postgres-exporter-grafana.md)
