üîù Retour au [Sommaire](/SOMMAIRE.md)

# 14.6.5. Checkpoints et WAL generation

## Introduction

Les **Checkpoints** et le **WAL (Write-Ahead Log)** sont deux m√©canismes fondamentaux qui garantissent la **durabilit√©** et la **performance** de PostgreSQL. Bien qu'invisibles pour la plupart des utilisateurs, ils jouent un r√¥le crucial dans la fiabilit√© de votre base de donn√©es.

Dans ce chapitre, nous allons d√©mystifier ces concepts souvent mal compris et vous donner les cl√©s pour optimiser leur fonctionnement.

---

## Le Concept de WAL (Write-Ahead Log)

### Qu'est-ce que le WAL ?

Le **WAL** (Write-Ahead Log), aussi appel√© **journal de transactions**, est un fichier s√©quentiel o√π PostgreSQL enregistre **toutes les modifications** avant de les appliquer r√©ellement aux fichiers de donn√©es.

### Analogie : Le Cahier de Brouillon

Imaginez que vous √©crivez un livre important :

**M√©thode risqu√©e (sans WAL) :**
- Vous √©crivez directement dans le livre d√©finitif
- Si vous renversez du caf√© ‚Üí Catastrophe irr√©versible
- Si vous faites une erreur ‚Üí Difficile √† corriger

**M√©thode s√©curis√©e (avec WAL) :**
- Vous √©crivez d'abord sur un cahier de brouillon (WAL)
- Une fois que tout est valid√©, vous recopiez proprement dans le livre
- Si accident ‚Üí Vous avez toujours le brouillon pour tout refaire
- Si erreur ‚Üí Facile d'annuler dans le brouillon

Le WAL est le **cahier de brouillon** de PostgreSQL.

### Le Principe Write-Ahead

**"Write-Ahead"** signifie **"√âcrire en avance"**.

**Ordre des op√©rations :**

```
1. Application demande : UPDATE users SET name = 'Alice' WHERE id = 1
2. PostgreSQL √©crit d'abord dans le WAL : "Modifier ligne 1, name = Alice"
3. COMMIT
4. PostgreSQL confirme √† l'application : ‚úÖ "Transaction valid√©e"
5. Plus tard, PostgreSQL applique r√©ellement aux fichiers de donn√©es
```

**Point crucial :** √Ä l'√©tape 4, les donn√©es ne sont PAS encore dans les fichiers d√©finitifs, mais **c'est garanti** qu'elles le seront gr√¢ce au WAL.

### Pourquoi le WAL est Essentiel

#### 1. Garantie de Durabilit√© (ACID - Durability)

**Sans WAL :**
```
Application : UPDATE ...
PostgreSQL : OK, en train d'√©crire...
üí• CRASH serveur
R√©sultat : Donn√©es perdues ‚ùå
```

**Avec WAL :**
```
Application : UPDATE ...
PostgreSQL : √âcrit dans WAL ‚Üí Sync disque ‚Üí COMMIT
Application : Re√ßoit confirmation ‚úÖ
üí• CRASH serveur
Au red√©marrage : PostgreSQL relit le WAL et applique les changements ‚úÖ
R√©sultat : Aucune donn√©e perdue ‚úÖ
```

#### 2. Performance

√âcrire dans le WAL est **beaucoup plus rapide** qu'√©crire dans les fichiers de donn√©es :

**WAL :**
- √âcriture s√©quentielle (un fichier qui grandit)
- Tr√®s rapide, m√™me sur HDD
- Pas de recherche de position

**Fichiers de donn√©es :**
- √âcriture al√©atoire (donn√©es dispers√©es)
- Beaucoup plus lent
- N√©cessite recherche de position

**Analogie :** C'est comme √©crire dans un cahier de bas en haut (rapide) vs √©crire sur des post-it √©parpill√©s dans tout le bureau (lent).

#### 3. Coh√©rence

Le WAL garantit que les transactions sont **atomiques** (tout ou rien).

**Exemple :**
```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

**Sans WAL :** Risque que la premi√®re UPDATE r√©ussisse et la seconde √©choue (incoh√©rence).

**Avec WAL :** Soit les deux sont appliqu√©es, soit aucune (atomicit√© garantie).

---

## Structure et Fonctionnement du WAL

### Les Fichiers WAL

#### Emplacement

Les fichiers WAL se trouvent dans :
```
/var/lib/postgresql/{version}/main/pg_wal/
```

**Exemple :**
```bash
ls -lh /var/lib/postgresql/18/main/pg_wal/
```

**Sortie typique :**
```
-rw------- 1 postgres postgres 16M Nov 21 10:00 000000010000000000000001
-rw------- 1 postgres postgres 16M Nov 21 10:15 000000010000000000000002
-rw------- 1 postgres postgres 16M Nov 21 10:30 000000010000000000000003
-rw------- 1 postgres postgres 16M Nov 21 10:45 000000010000000000000004
```

#### Caract√©ristiques

**Taille fixe :** Chaque fichier WAL fait **16 MB** (par d√©faut, configurable).

**Rotation :** Quand un fichier est plein, PostgreSQL cr√©e le suivant.

**Nommage s√©quentiel :** Les fichiers sont num√©rot√©s de mani√®re continue.

### Cycle de Vie d'une Modification

**√âtapes d√©taill√©es :**

```
1. Transaction BEGIN
   ‚Üì
2. Commandes SQL (INSERT, UPDATE, DELETE)
   ‚Üì
3. Modifications √©crites dans le WAL buffer (RAM)
   ‚Üì
4. COMMIT d√©clenche :
   a. Flush du WAL buffer vers le disque (fsync)
   b. Confirmation √† l'application
   ‚Üì
5. Plus tard (de mani√®re asynchrone) :
   Modifications appliqu√©es aux fichiers de donn√©es
   ‚Üì
6. Checkpoint :
   Synchronise tout et marque les WAL comme recyclables
```

### Types de Records WAL

Le WAL contient diff√©rents types d'entr√©es :

| Type | Description | Exemple |
|------|-------------|---------|
| **INSERT** | Nouvelle ligne | "Ins√©rer ligne X dans table Y" |
| **UPDATE** | Modification | "Modifier ligne X, colonne A = nouvelle valeur" |
| **DELETE** | Suppression | "Supprimer ligne X de table Y" |
| **COMMIT** | Validation transaction | "Transaction 12345 valid√©e" |
| **CHECKPOINT** | Point de sauvegarde | "Checkpoint d√©marr√©" |
| **VACUUM** | Nettoyage | "VACUUM sur table Z" |

### Monitoring du WAL

#### V√©rifier la G√©n√©ration de WAL

```sql
-- Emplacement actuel dans le WAL
SELECT pg_current_wal_lsn();
```

**R√©sultat exemple :**
```
 pg_current_wal_lsn
--------------------
 0/1A234567
```

**LSN** = Log Sequence Number (num√©ro de s√©quence dans le journal)

#### Calculer le Volume de WAL G√©n√©r√©

```sql
-- WAL g√©n√©r√© depuis un certain moment
SELECT
    pg_size_pretty(
        pg_wal_lsn_diff(pg_current_wal_lsn(), '0/1A000000')
    ) AS wal_generated;
```

#### Nouveaut√© PostgreSQL 18 : Statistiques WAL par Backend

PostgreSQL 18 offre des statistiques d√©taill√©es sur la g√©n√©ration de WAL par processus.

```sql
SELECT
    pid,
    usename,
    application_name,
    wal_records,
    wal_bytes,
    pg_size_pretty(wal_bytes) AS wal_bytes_pretty
FROM pg_stat_activity
WHERE wal_bytes > 0
ORDER BY wal_bytes DESC;
```

**Utilit√© :** Identifier quelles requ√™tes/processus g√©n√®rent le plus de WAL.

---

## Qu'est-ce qu'un Checkpoint ?

### D√©finition

Un **checkpoint** est un processus qui synchronise toutes les modifications en m√©moire (dirty buffers) vers le disque.

**En termes simples :** C'est le moment o√π PostgreSQL recopie proprement du brouillon (WAL) vers le livre d√©finitif (fichiers de donn√©es).

### Analogie : La Sauvegarde de Jeu Vid√©o

Quand vous jouez √† un jeu vid√©o :

**Sans sauvegarde (sans checkpoint) :**
- Vous jouez pendant 2 heures
- üí• Crash
- Vous devez tout recommencer depuis le d√©but

**Avec sauvegardes r√©guli√®res (checkpoints) :**
- Le jeu se sauvegarde toutes les 15 minutes
- üí• Crash
- Vous reprenez depuis la derni√®re sauvegarde (max 15 min perdues)

Les checkpoints sont les **points de sauvegarde** de PostgreSQL.

### Pourquoi les Checkpoints Existent

#### 1. R√©cup√©ration Rapide Apr√®s Crash

**Sans checkpoint :**
```
Crash serveur ‚Üí Red√©marrage
PostgreSQL doit relire TOUT le WAL depuis le d√©but (peut-√™tre des Go)
Temps de r√©cup√©ration : Des heures ‚ùå
```

**Avec checkpoints r√©guliers :**
```
Crash serveur ‚Üí Red√©marrage
PostgreSQL relit seulement depuis le dernier checkpoint (quelques MB)
Temps de r√©cup√©ration : Quelques secondes ‚úÖ
```

#### 2. Recyclage du WAL

Les fichiers WAL peuvent √™tre r√©utilis√©s apr√®s un checkpoint :

```
Checkpoint N ‚Üí Tout avant le checkpoint N est s√ªrement sur disque
            ‚Üí Anciens fichiers WAL peuvent √™tre supprim√©s/recycl√©s
            ‚Üí Espace disque r√©cup√©r√©
```

#### 3. Coh√©rence des Donn√©es

Un checkpoint garantit que les donn√©es sur disque sont dans un √©tat **coh√©rent** √† un instant T.

---

## Types de Checkpoints

### 1. Timed Checkpoints (Checkpoint Temporis√©s)

D√©clench√©s automatiquement selon un **intervalle de temps**.

**Param√®tre :**
```ini
checkpoint_timeout = 5min  # Par d√©faut
```

**Exemple :**
```
10:00 ‚Üí Checkpoint
10:05 ‚Üí Checkpoint
10:10 ‚Üí Checkpoint
...
```

**Avantage :** Pr√©visible et r√©gulier.

### 2. Requested Checkpoints (Checkpoint Requis)

D√©clench√©s automatiquement quand le WAL atteint une **taille limite**.

**Param√®tre :**
```ini
max_wal_size = 1GB  # Par d√©faut
```

**Exemple :**
```
WAL atteint 1 GB ‚Üí Checkpoint d√©clench√© imm√©diatement
```

**Probl√®me :** Si votre charge est intense, le WAL peut atteindre la limite avant le timeout ‚Üí Checkpoints plus fr√©quents que pr√©vu.

### 3. Manual Checkpoints (Checkpoint Manuels)

D√©clench√©s par commande SQL.

```sql
CHECKPOINT;
```

**Usage :** Rarement n√©cessaire, sauf pour :
- Avant une sauvegarde physique
- Avant maintenance planifi√©e
- Tests

---

## Impact Performance des Checkpoints

### Le Probl√®me des "Checkpoint Spikes"

**Sympt√¥me :** Pics de lenteur p√©riodiques et pr√©visibles.

**Cause :** Pendant un checkpoint, PostgreSQL √©crit massivement sur le disque.

**Visualisation :**
```
Performance normale : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
Checkpoint d√©marre  : ‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
                         ‚Üë
                    Ralentissement
```

**Utilisateurs :** "Pourquoi l'application est lente toutes les 5 minutes ?!"

### Pourquoi les Checkpoints Ralentissent

#### 1. I/O Burst (Rafale d'√âcritures)

Le checkpoint doit √©crire tous les "dirty buffers" (pages modifi√©es en m√©moire) sur le disque.

**Exemple :**
```
Shared buffers = 8 GB
50% de pages modifi√©es = 4 GB √† √©crire
Checkpoint a 5 minutes pour tout √©crire
‚Üí 800 MB/sec d'√©critures pendant 5 minutes
```

Sur un disque limit√© √† 500 MB/sec ‚Üí Saturation ‚Üí Ralentissement global.

#### 2. Contention I/O

Les √©critures du checkpoint entrent en comp√©tition avec :
- Les requ√™tes normales
- Les VACUUM
- Les index scans
- Les autres processus

**R√©sultat :** Tout ralentit.

#### 3. Flush Synchrone

√Ä la fin du checkpoint, PostgreSQL fait un **fsync** (force la synchronisation disque).

**Sur certains syst√®mes :** Peut bloquer pendant plusieurs secondes.

---

## Configuration et Optimisation

### Param√®tres Cl√©s

#### 1. checkpoint_timeout

**D√©finition :** Temps maximum entre deux checkpoints.

```ini
# postgresql.conf
checkpoint_timeout = 5min   # D√©faut : 5 minutes
```

**Recommandations :**

| Charge | Valeur | Raison |
|--------|--------|--------|
| **Faible** | 5-10 min | D√©faut suffisant |
| **Moyenne** | 10-15 min | R√©duit fr√©quence |
| **√âlev√©e (OLTP)** | 15-30 min | Moins d'interruptions |
| **Tr√®s √©lev√©e** | 30-60 min | Max avant risques |

**‚ö†Ô∏è Attention :** Augmenter trop ‚Üí Temps de r√©cup√©ration apr√®s crash plus long.

#### 2. max_wal_size

**D√©finition :** Taille max de WAL avant d√©clencher un checkpoint.

```ini
# postgresql.conf
max_wal_size = 1GB   # D√©faut : 1 GB
```

**Recommandations :**

| Charge | Valeur | Raison |
|--------|--------|--------|
| **Faible** | 1-2 GB | D√©faut suffisant |
| **Moyenne** | 2-4 GB | Plus de marge |
| **√âlev√©e** | 4-8 GB | √âvite checkpoints requis |
| **Tr√®s √©lev√©e (batch)** | 8-16 GB | Grosses transactions |

**Calcul :**
```
Si vous g√©n√©rez 200 MB WAL/minute
max_wal_size = 4 GB
‚Üí Checkpoint requis toutes les 20 minutes environ
```

**üí° Astuce :** Augmenter `max_wal_size` r√©duit la fr√©quence des checkpoints requis.

#### 3. checkpoint_completion_target

**D√©finition :** Pourcentage du checkpoint_timeout pendant lequel √©taler les √©critures.

```ini
# postgresql.conf
checkpoint_completion_target = 0.9   # D√©faut : 0.9 (90%)
```

**Fonctionnement :**

```
checkpoint_timeout = 10 min
checkpoint_completion_target = 0.9

Checkpoint d√©marre √† 10:00
Objectif : Finir en 9 minutes (90% de 10 min)
‚Üí √âcritures √©tal√©es entre 10:00 et 10:09
‚Üí Derni√®re minute (10:09-10:10) : Finalisation et fsync
```

**Effet :** Lisse les √©critures au lieu d'avoir un pic brutal.

**Visualisation :**

**Sans lissage (target = 0.1) :**
```
I/O : ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
      ‚Üë                              ‚Üë
      Checkpoint                   Tout √©crit d'un coup
```

**Avec lissage (target = 0.9) :**
```
I/O : ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà‚ñá‚ñÜ‚ñÖ‚ñÑ‚ñÉ‚ñÇ‚ñÅ‚ñë‚ñë‚ñë‚ñë
      ‚Üë                          ‚Üë              ‚Üë
      Checkpoint             √âtal√©            Fin
```

**Recommandation :** Garder √† 0.9 (valeur optimale pour la plupart des cas).

#### 4. min_wal_size

**D√©finition :** Taille minimale de WAL √† conserver.

```ini
# postgresql.conf
min_wal_size = 80MB   # D√©faut : 80 MB
```

**Usage :** PostgreSQL garde toujours au moins cette quantit√© de WAL, m√™me apr√®s un checkpoint.

**Pourquoi ?** √âvite de recr√©er constamment des fichiers WAL (co√ªteux).

#### 5. wal_level

**D√©finition :** Quantit√© d'informations √©crites dans le WAL.

```ini
# postgresql.conf
wal_level = replica   # D√©faut : replica
```

**Valeurs possibles :**

| Valeur | Description | Usage |
|--------|-------------|-------|
| **minimal** | WAL minimal | Standalone, pas de r√©plication |
| **replica** | Streaming replication | D√©faut, recommand√© |
| **logical** | R√©plication logique | Publications/Subscriptions |

**Recommandation :** Garder `replica` ou `logical` selon besoins de r√©plication.

### Configuration Optimis√©e par Type de Charge

#### Configuration OLTP (Haute Performance)

```ini
# postgresql.conf

# WAL
wal_level = replica
wal_buffers = 16MB
max_wal_size = 4GB
min_wal_size = 1GB

# Checkpoints
checkpoint_timeout = 15min
checkpoint_completion_target = 0.9

# Permet plus de workers pour checkpoints longs
max_wal_senders = 10
```

#### Configuration OLAP (Analytics)

```ini
# postgresql.conf

# WAL
max_wal_size = 8GB
min_wal_size = 2GB

# Checkpoints
checkpoint_timeout = 30min
checkpoint_completion_target = 0.9

# Grosses transactions OK
```

#### Configuration Batch Processing

```ini
# postgresql.conf

# WAL
max_wal_size = 16GB      # Tr√®s √©lev√©
checkpoint_timeout = 60min

# Pour imports massifs
maintenance_work_mem = 2GB
```

---

## Monitoring des Checkpoints

### Statistiques de Base

#### Vue pg_stat_bgwriter

Cette vue fournit des statistiques sur les checkpoints.

```sql
SELECT
    checkpoints_timed,
    checkpoints_req,
    checkpoint_write_time,
    checkpoint_sync_time,
    buffers_checkpoint,
    buffers_clean,
    buffers_backend
FROM pg_stat_bgwriter;
```

**Colonnes importantes :**

- **checkpoints_timed** : Nombre de checkpoints d√©clench√©s par timeout
- **checkpoints_req** : Nombre de checkpoints d√©clench√©s par WAL plein
- **checkpoint_write_time** : Temps total d'√©criture (ms)
- **checkpoint_sync_time** : Temps total de sync (ms)
- **buffers_checkpoint** : Buffers √©crits par checkpoints
- **buffers_clean** : Buffers √©crits par bgwriter
- **buffers_backend** : Buffers √©crits directement par backends

#### Calculer le Ratio de Checkpoints Forc√©s

```sql
SELECT
    checkpoints_timed,
    checkpoints_req,
    round(
        100.0 * checkpoints_req /
        NULLIF(checkpoints_timed + checkpoints_req, 0),
        2
    ) AS forced_checkpoint_pct
FROM pg_stat_bgwriter;
```

**Interpr√©tation :**

| Pourcentage | √âtat | Action |
|-------------|------|--------|
| **< 10%** | üü¢ Excellent | RAS |
| **10-30%** | üü° Acceptable | Surveiller |
| **30-50%** | üü† Pr√©occupant | Augmenter max_wal_size |
| **> 50%** | üî¥ Probl√©matique | Action urgente |

**Objectif :** Avoir < 10% de checkpoints forc√©s.

**Pourquoi ?** Les checkpoints forc√©s sont non planifi√©s et peuvent causer des pics de latence.

### Nouveaut√© PostgreSQL 18 : Statistiques Am√©lior√©es

#### Statistiques VACUUM et ANALYZE

```sql
SELECT
    schemaname,
    relname,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze,
    vacuum_count,
    autovacuum_count,
    analyze_count,
    autoanalyze_count
FROM pg_stat_all_tables
WHERE schemaname = 'public'
ORDER BY last_autovacuum DESC NULLS LAST;
```

#### Statistiques I/O par Backend (inclut WAL)

```sql
SELECT
    pid,
    usename,
    application_name,
    wal_records,
    wal_fpi,
    wal_bytes,
    pg_size_pretty(wal_bytes) as wal_size
FROM pg_stat_activity
WHERE backend_type = 'client backend'
ORDER BY wal_bytes DESC;
```

**wal_fpi** = Full Page Images (images compl√®tes de pages apr√®s checkpoint)

### Logs PostgreSQL

#### Activer le Logging des Checkpoints

```ini
# postgresql.conf
log_checkpoints = on
```

**R√©sultat dans les logs :**
```
2024-11-21 10:15:23.456 UTC [12345] LOG:  checkpoint starting: time
2024-11-21 10:20:45.789 UTC [12345] LOG:  checkpoint complete: wrote 12543 buffers (76.5 MB);
    0 WAL file(s) added, 0 removed, 2 recycled; write=322.145 s, sync=0.234 s, total=322.456 s;
    sync files=156, longest=0.123 s, average=0.001 s; distance=512345 kB, estimate=512890 kB
```

**Informations cl√©s :**
- **wrote 12543 buffers** : Nombre de pages √©crites
- **write=322.145 s** : Temps d'√©criture (5+ minutes)
- **sync=0.234 s** : Temps de synchronisation
- **total=322.456 s** : Temps total

**‚ö†Ô∏è Attention :** Si `write` est proche de `checkpoint_timeout`, les checkpoints se chevauchent !

### Requ√™te de Monitoring Compl√®te

```sql
-- Vue personnalis√©e pour monitoring
CREATE VIEW checkpoint_health AS
SELECT
    checkpoints_timed,
    checkpoints_req,
    round(
        100.0 * checkpoints_req /
        NULLIF(checkpoints_timed + checkpoints_req, 0),
        2
    ) AS forced_checkpoint_pct,
    pg_size_pretty(
        (SELECT setting::int FROM pg_settings WHERE name = 'checkpoint_timeout')::bigint * 1000 *
        buffers_checkpoint * 8192 /
        NULLIF(checkpoint_write_time, 0)
    ) AS avg_write_speed,
    round(
        checkpoint_write_time::numeric /
        NULLIF(checkpoints_timed + checkpoints_req, 0) / 1000,
        2
    ) AS avg_checkpoint_duration_sec,
    CASE
        WHEN checkpoints_req::numeric / NULLIF(checkpoints_timed + checkpoints_req, 0) > 0.3
        THEN 'üî¥ Augmenter max_wal_size'
        WHEN checkpoints_req::numeric / NULLIF(checkpoints_timed + checkpoints_req, 0) > 0.1
        THEN 'üü° Surveiller'
        ELSE 'üü¢ OK'
    END AS status
FROM pg_stat_bgwriter;

-- Consultation
SELECT * FROM checkpoint_health;
```

---

## Probl√®mes Courants et Solutions

### Probl√®me 1 : Checkpoints Trop Fr√©quents

**Sympt√¥mes :**
- Pics de lenteur r√©guliers (toutes les 5 min)
- `forced_checkpoint_pct` > 30%
- Logs montrent checkpoints toutes les minutes

**Diagnostic :**

```sql
SELECT * FROM checkpoint_health;
```

**Cause :** `max_wal_size` trop petit pour la charge.

**Solution :**

```ini
# Augmenter progressivement
max_wal_size = 4GB   # Au lieu de 1 GB
```

**Red√©marrage requis ?** Non, reload suffit :
```sql
ALTER SYSTEM SET max_wal_size = '4GB';
SELECT pg_reload_conf();
```

### Probl√®me 2 : Checkpoints Trop Longs

**Sympt√¥mes :**
- Checkpoint prend 10+ minutes
- Logs montrent `write=600+ s`
- Performances d√©grad√©es pendant toute la dur√©e

**Diagnostic :**

```bash
# V√©rifier logs
grep "checkpoint complete" /var/log/postgresql/postgresql-*.log | tail -20
```

**Causes possibles :**
1. `shared_buffers` trop grand
2. Disque lent
3. Trop de donn√©es modifi√©es entre checkpoints

**Solutions :**

**1. R√©duire checkpoint_timeout (plus fr√©quent = moins √† √©crire) :**
```ini
checkpoint_timeout = 10min   # Au lieu de 30min
```

**2. V√©rifier shared_buffers :**
```ini
shared_buffers = 8GB   # Pas plus de 25% RAM
```

**3. Am√©liorer I/O :**
- Migrer vers SSD
- Utiliser RAID
- Placer WAL sur disque s√©par√©

### Probl√®me 3 : Espace Disque WAL Qui Explose

**Sympt√¥mes :**
- R√©pertoire `pg_wal/` atteint 50+ GB
- Alerte "disk full"

**Diagnostic :**

```bash
du -sh /var/lib/postgresql/*/main/pg_wal/
```

**Causes possibles :**
1. R√©plication en retard (standby lent)
2. Slots de r√©plication non utilis√©s
3. Archiving activ√© mais script d√©faillant

**V√©rifications :**

```sql
-- V√©rifier slots de r√©plication
SELECT * FROM pg_replication_slots;

-- V√©rifier WAL senders
SELECT * FROM pg_stat_replication;
```

**Solutions :**

**1. Supprimer slots inactifs :**
```sql
SELECT pg_drop_replication_slot('old_slot_name');
```

**2. V√©rifier archiving :**
```sql
SHOW archive_mode;
SHOW archive_command;

-- Si archive_command √©choue, corriger ou d√©sactiver temporairement
```

**3. Si urgence, forcer checkpoint :**
```sql
CHECKPOINT;
```

### Probl√®me 4 : WAL Generation Excessive

**Sympt√¥mes :**
- G√©n√©ration de plusieurs GB de WAL en quelques minutes
- Checkpoints tr√®s fr√©quents malgr√© configuration correcte

**Diagnostic :**

```sql
-- PostgreSQL 18
SELECT
    pid,
    usename,
    application_name,
    pg_size_pretty(wal_bytes) AS wal_generated,
    query
FROM pg_stat_activity
WHERE wal_bytes > 0
ORDER BY wal_bytes DESC
LIMIT 10;
```

**Causes fr√©quentes :**
1. Grosses transactions (COPY, bulk INSERT)
2. Nombreux UPDATE sur colonnes index√©es
3. VACUUM FULL en cours

**Solutions :**

**Pour imports massifs :**
```sql
-- Temporairement d√©sactiver autovacuum
ALTER TABLE big_table SET (autovacuum_enabled = false);

-- Import
COPY big_table FROM '/data/file.csv';

-- R√©activer
ALTER TABLE big_table SET (autovacuum_enabled = true);
VACUUM ANALYZE big_table;
```

**Pour updates massifs :**
```sql
-- Utiliser batching
DO $$
DECLARE
    batch_size INT := 10000;
BEGIN
    LOOP
        UPDATE my_table
        SET column = new_value
        WHERE ctid IN (
            SELECT ctid
            FROM my_table
            WHERE condition
            LIMIT batch_size
        );

        EXIT WHEN NOT FOUND;
        COMMIT;
    END LOOP;
END $$;
```

---

## WAL Archiving et Point-in-Time Recovery

### Concept de WAL Archiving

**WAL Archiving** permet de sauvegarder les fichiers WAL avant qu'ils soient recycl√©s.

**Utilit√© :**
- Restauration √† un instant pr√©cis (PITR)
- R√©plication vers standby distant
- Audit et compliance

### Configuration Basique

```ini
# postgresql.conf
archive_mode = on
archive_command = 'cp %p /mnt/backup/wal/%f'
```

**Variables :**
- `%p` : Chemin complet du fichier WAL
- `%f` : Nom du fichier WAL

### Script d'Archivage Robuste

```bash
#!/bin/bash
# /usr/local/bin/archive_wal.sh

WAL_FILE=$1
DEST_DIR="/mnt/backup/wal"

# Copier avec v√©rification
cp "$WAL_FILE" "$DEST_DIR/" || exit 1

# V√©rifier checksum
md5sum "$WAL_FILE" > "$DEST_DIR/$(basename $WAL_FILE).md5"

exit 0
```

**Configuration :**
```ini
archive_command = '/usr/local/bin/archive_wal.sh %p'
```

### Point-in-Time Recovery (PITR)

**Sc√©nario :** Suppression accidentelle de donn√©es √† 14:30.

**Restauration √† 14:25 (avant l'erreur) :**

```bash
# 1. Arr√™ter PostgreSQL
sudo systemctl stop postgresql

# 2. Restaurer backup de base (ex: backup de ce matin)
rm -rf /var/lib/postgresql/18/main/*
tar xzf /backup/base_backup_20241121_0600.tar.gz -C /var/lib/postgresql/18/main/

# 3. Cr√©er recovery.signal
touch /var/lib/postgresql/18/main/recovery.signal

# 4. Configurer recovery
cat > /var/lib/postgresql/18/main/postgresql.auto.conf << EOF
restore_command = 'cp /mnt/backup/wal/%f %p'
recovery_target_time = '2024-11-21 14:25:00'
EOF

# 5. Red√©marrer
sudo systemctl start postgresql

# PostgreSQL va :
# - Appliquer le backup de base
# - Rejouer les WAL jusqu'√† 14:25
# - S'arr√™ter √† 14:25
```

---

## Optimisations Avanc√©es

### 1. S√©parer WAL et Donn√©es

**Principe :** Placer WAL et fichiers de donn√©es sur des disques diff√©rents.

**Avantages :**
- R√©duit contention I/O
- WAL sur disque rapide (SSD) m√™me si donn√©es sur HDD
- Parall√©lisation des √©critures

**Configuration :**

```bash
# D√©placer pg_wal
sudo systemctl stop postgresql
mv /var/lib/postgresql/18/main/pg_wal /mnt/fast-ssd/pg_wal
ln -s /mnt/fast-ssd/pg_wal /var/lib/postgresql/18/main/pg_wal
sudo systemctl start postgresql
```

### 2. Optimiser fsync

**Le probl√®me du fsync :** Force synchronisation disque, peut bloquer.

**Param√®tres :**

```ini
# postgresql.conf
fsync = on   # Ne JAMAIS d√©sactiver en production !

# M√©thode de sync
wal_sync_method = fdatasync   # Linux: fdatasync (d√©faut et optimal)
```

**Options wal_sync_method :**

| M√©thode | Performance | S√©curit√© | OS |
|---------|-------------|----------|-----|
| **fdatasync** | Rapide | √âlev√©e | Linux (recommand√©) |
| **fsync** | Moyen | √âlev√©e | Tous |
| **open_sync** | Lent | √âlev√©e | Tous |
| **open_datasync** | Lent | √âlev√©e | Certains Unix |

**Recommandation :** Garder `fdatasync` sur Linux.

### 3. Ajuster wal_buffers

**D√©finition :** Taille du buffer WAL en m√©moire avant √©criture disque.

```ini
# postgresql.conf
wal_buffers = 16MB   # D√©faut : -1 (auto, 1/32 de shared_buffers)
```

**Recommandations :**

| shared_buffers | wal_buffers | Charge |
|----------------|-------------|--------|
| < 1 GB | 16 MB | L√©g√®re |
| 4 GB | 16 MB | Moyenne |
| 8 GB | 16 MB | √âlev√©e |
| 16+ GB | 32 MB | Tr√®s √©lev√©e |

**üí° Astuce :** Rarement besoin de d√©passer 16 MB, sauf charge extr√™me.

### 4. Commit Asynchrone (‚ö†Ô∏è Risqu√©)

Pour applications acceptant perte de quelques transactions en cas de crash.

```ini
# postgresql.conf
synchronous_commit = off   # ‚ö†Ô∏è Perte potentielle de donn√©es
```

**Gain :** Performance√ó2-5 sur √©critures.

**Risque :** Perte des derni√®res transactions (< 1 sec) en cas de crash.

**Usage :** Acceptable pour :
- Logs non critiques
- Sessions temporaires
- Donn√©es recalculables

**Ne JAMAIS utiliser pour :** Donn√©es financi√®res, commandes, etc.

### 5. Compression WAL (PostgreSQL 15+)

```ini
# postgresql.conf
wal_compression = on
```

**Avantages :**
- R√©duit taille WAL de 50-70%
- Moins d'I/O disque
- Meilleur pour archiving

**Inconv√©nient :** L√©ger co√ªt CPU (n√©gligeable sur serveurs modernes).

**Recommandation :** Activer si I/O est le goulot.

---

## Monitoring avec Grafana

### Dashboard Recommand√©

**M√©triques essentielles √† afficher :**

#### 1. Checkpoint Frequency (Time series)
```
Rate de checkpoints (timed vs requested)
```

#### 2. Checkpoint Duration (Time series)
```
Dur√©e moyenne des checkpoints
Seuil warning : > 5 min
```

#### 3. Forced Checkpoint Ratio (Gauge)
```
Pourcentage de checkpoints forc√©s
Seuil warning : > 10%
Seuil critical : > 30%
```

#### 4. WAL Generation Rate (Time series)
```
MB de WAL g√©n√©r√© par seconde
```

#### 5. WAL Disk Usage (Gauge)
```
Taille du r√©pertoire pg_wal/
Seuil warning : > 10 GB
Seuil critical : > 50 GB
```

#### 6. Buffers Written by Type (Stacked area)
```
- buffers_checkpoint
- buffers_clean
- buffers_backend
```

### Requ√™tes Prometheus

**Checkpoint rate :**
```promql
rate(pg_stat_bgwriter_checkpoints_timed[5m])
rate(pg_stat_bgwriter_checkpoints_req[5m])
```

**Forced checkpoint ratio :**
```promql
pg_stat_bgwriter_checkpoints_req /
(pg_stat_bgwriter_checkpoints_timed + pg_stat_bgwriter_checkpoints_req)
```

---

## Checklist de Sant√© WAL/Checkpoints

### ‚úÖ Configuration

- [ ] `max_wal_size` dimensionn√© correctement (> 1 GB pour charge moyenne)
- [ ] `checkpoint_timeout` entre 10-30 min selon charge
- [ ] `checkpoint_completion_target = 0.9`
- [ ] `log_checkpoints = on`
- [ ] `wal_compression = on` (si I/O limit√©)

### ‚úÖ Monitoring

- [ ] Dashboard Grafana avec m√©triques checkpoints
- [ ] Alerte si forced_checkpoint_ratio > 10%
- [ ] Alerte si checkpoint_duration > 5 min
- [ ] Alerte si pg_wal/ > 10 GB
- [ ] Logs PostgreSQL consult√©s r√©guli√®rement

### ‚úÖ Performance

- [ ] Forced checkpoints < 10%
- [ ] Dur√©e checkpoint < checkpoint_timeout
- [ ] Pas de contention I/O visible pendant checkpoints
- [ ] WAL sur disque d√©di√© (id√©alement)

### ‚úÖ S√©curit√©

- [ ] `fsync = on` (JAMAIS off en production)
- [ ] WAL archiving configur√© (si PITR n√©cessaire)
- [ ] Tests de restauration r√©guliers
- [ ] Backups test√©s et valid√©s

---

## Questions Fr√©quentes (FAQ)

### Q1 : Puis-je d√©sactiver fsync pour plus de performances ?

**R√©ponse :** **NON, JAMAIS en production !**

Sans fsync, un crash peut corrompre toute votre base de donn√©es.

**Exception :** Environnements de test/dev uniquement.

### Q2 : Pourquoi mes checkpoints prennent 15 minutes ?

**R√©ponses possibles :**
1. `shared_buffers` trop grand (> 25% RAM)
2. Disque lent (HDD)
3. Beaucoup de donn√©es modifi√©es
4. `checkpoint_timeout` trop long

**Solution :** R√©duire checkpoint_timeout ou am√©liorer I/O.

### Q3 : Mon pg_wal/ fait 50 GB, est-ce normal ?

**R√©ponse :** Non, c'est anormal.

**Causes :**
- R√©plication en retard
- Slots de r√©plication abandonn√©s
- Archiving d√©faillant

**Action :** V√©rifier `pg_replication_slots` et corriger.

### Q4 : Quelle est la taille id√©ale de max_wal_size ?

**R√©ponse :** D√©pend de votre charge.

**Formule approximative :**
```
max_wal_size = WAL g√©n√©r√© par minute √ó checkpoint_timeout √ó 1.5
```

**Exemple :**
```
G√©n√©ration : 100 MB/min
checkpoint_timeout : 15 min
max_wal_size = 100 √ó 15 √ó 1.5 = 2.25 GB ‚Üí Configurer 3 GB
```

### Q5 : Les checkpoints peuvent-ils causer un downtime ?

**R√©ponse :** Non, jamais.

Ils ralentissent les performances mais ne bloquent pas PostgreSQL.

### Q6 : Dois-je activer wal_compression ?

**R√©ponse :** Oui, dans la plupart des cas.

**Avantages :** Moins d'I/O, moins d'espace disque
**Co√ªt :** N√©gligeable en CPU

**Exception :** Si CPU d√©j√† satur√©.

---

## Points Cl√©s √† Retenir

‚úÖ **WAL (Write-Ahead Log) = Journal de transactions**
   - Toutes modifications √©crites d'abord dans le WAL
   - Garantit durabilit√© (ACID)
   - √âcriture s√©quentielle = rapide

‚úÖ **Checkpoints = Points de sauvegarde**
   - Synchronisent modifications m√©moire ‚Üí disque
   - Permettent r√©cup√©ration rapide apr√®s crash
   - Permettent recyclage du WAL

‚úÖ **Types de checkpoints :**
   - Timed (par timeout) : Pr√©visible
   - Requested (par taille WAL) : √Ä minimiser
   - Manual : Rarement n√©cessaire

‚úÖ **Impact performance :**
   - Checkpoints g√©n√®rent I/O burst
   - Peuvent causer pics de latence
   - Liss√©s avec checkpoint_completion_target

‚úÖ **Configuration cl√©s :**
   - `max_wal_size` : 2-8 GB selon charge
   - `checkpoint_timeout` : 10-30 min
   - `checkpoint_completion_target` : 0.9 (optimal)
   - `log_checkpoints` : on (monitoring)

‚úÖ **PostgreSQL 18 :**
   - Statistiques WAL par backend
   - Meilleure observabilit√©
   - I/O asynchrone am√©liore checkpoints

‚úÖ **Monitoring essentiel :**
   - Forced checkpoint ratio < 10%
   - Dur√©e checkpoint < timeout
   - Taille pg_wal/ stable
   - Logs consult√©s r√©guli√®rement

‚úÖ **Optimisations :**
   - S√©parer WAL et donn√©es (disques diff√©rents)
   - Compression WAL (si I/O limit√©)
   - SSD pour meilleurs performances
   - Ne JAMAIS d√©sactiver fsync en production

---

## Conclusion

Le **WAL** et les **Checkpoints** sont les gardiens invisibles de votre base de donn√©es PostgreSQL. Le WAL garantit que chaque transaction valid√©e est **d√©finitivement** sauvegard√©e, m√™me en cas de crash, tandis que les checkpoints permettent une **r√©cup√©ration rapide** et le **recyclage efficace** de l'espace disque.

Comprendre ces m√©canismes vous permet de :

1. **Optimiser les performances** en r√©duisant l'impact des checkpoints
2. **Garantir la fiabilit√©** avec une configuration WAL appropri√©e
3. **Monitorer efficacement** pour d√©tecter les probl√®mes avant qu'ils deviennent critiques
4. **R√©cup√©rer rapidement** en cas de d√©sastre gr√¢ce au WAL archiving

Les configurations par d√©faut de PostgreSQL sont bonnes, mais les ajuster selon votre charge sp√©cifique peut apporter des gains significatifs en performance et stabilit√©.

**R√®gle d'or :** Ne sacrifiez JAMAIS la durabilit√© pour la performance. Un syst√®me rapide mais qui perd des donn√©es n'a aucune valeur.

Avec PostgreSQL 18 et ses am√©liorations sur les statistiques WAL et l'I/O asynchrone, vous avez maintenant tous les outils n√©cessaires pour optimiser et surveiller ces aspects critiques de votre base de donn√©es.

---


‚è≠Ô∏è [Outils de monitoring](/14-observabilite-et-monitoring/07-outils-de-monitoring.md)
