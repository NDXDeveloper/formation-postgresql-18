üîù Retour au [Sommaire](/SOMMAIRE.md)

# 14.2.3. pg_stat_user_tables : Statistiques de tables

## Introduction

La vue `pg_stat_user_tables` est une vue syst√®me essentielle qui fournit des statistiques d√©taill√©es sur l'utilisation de chaque table utilisateur dans votre base de donn√©es. C'est l'√©quivalent de `pg_stat_database`, mais au niveau granulaire de chaque table.

Imaginez cette vue comme un rapport d'activit√© individuel pour chaque table : combien de fois elle a √©t√© lue, combien de lignes ont √©t√© ins√©r√©es/modifi√©es/supprim√©es, quand a eu lieu le dernier VACUUM, combien de lignes "mortes" s'accumulent, etc.

**Diff√©rence importante :**
- `pg_stat_all_tables` : Inclut les tables syst√®me ET utilisateur
- `pg_stat_user_tables` : Uniquement les tables cr√©√©es par vous (exclut les tables `pg_*`)
- `pg_stat_sys_tables` : Uniquement les tables syst√®me

En production, vous utiliserez principalement `pg_stat_user_tables`.

## Pourquoi pg_stat_user_tables est cruciale ?

Cette vue vous permet de r√©pondre √† des questions essentielles pour l'optimisation et la maintenance :

- **Indexation** : Quelles tables sont scann√©es s√©quentiellement ? (manque d'index ?)
- **Performance** : Quels index sont vraiment utilis√©s ? Lesquels sont inutiles ?
- **Maintenance** : Quelles tables ont besoin d'un VACUUM urgent ?
- **Bloat** : Y a-t-il beaucoup de lignes mortes qui ralentissent les requ√™tes ?
- **Activit√©** : Quelles tables sont les plus lues/√©crites ?
- **Cache** : Quel est le taux de cache pour chaque table ?

## Acc√©der √† pg_stat_user_tables

```sql
SELECT * FROM pg_stat_user_tables;
```

Cette requ√™te retourne une ligne par table utilisateur. Le nombre de colonnes est important (25+), donc on s√©lectionne g√©n√©ralement les colonnes pertinentes.

**Vue simplifi√©e :**
```sql
SELECT
    schemaname,
    relname,
    seq_scan,
    idx_scan,
    n_tup_ins,
    n_tup_upd,
    n_tup_del,
    n_live_tup,
    n_dead_tup
FROM pg_stat_user_tables
ORDER BY seq_scan DESC;
```

## Les colonnes principales de pg_stat_user_tables

### 1. **relid**, **schemaname**, **relname**

- **relid** : L'OID (Object ID) de la table dans le catalogue syst√®me
- **schemaname** : Le nom du sch√©ma contenant la table (ex: `public`, `sales`, `analytics`)
- **relname** : Le nom de la table

**Exemple :**
```sql
-- Lister toutes les tables avec leur sch√©ma
SELECT schemaname, relname
FROM pg_stat_user_tables
ORDER BY schemaname, relname;
```

### 2. **seq_scan** et **seq_tup_read**

- **seq_scan** : Nombre de scans s√©quentiels effectu√©s sur la table
- **seq_tup_read** : Nombre total de lignes lues lors de ces scans s√©quentiels

**Qu'est-ce qu'un scan s√©quentiel ?**

Un scan s√©quentiel (ou "full table scan") signifie que PostgreSQL lit toute la table ligne par ligne, sans utiliser d'index. C'est g√©n√©ralement plus lent pour les grandes tables.

**Pourquoi c'est important ?**

Un grand nombre de scans s√©quentiels sur une grande table peut indiquer :
- Manque d'index appropri√©
- Requ√™tes mal √©crites (pas de clause WHERE)
- Index existants non utilis√©s par le planificateur

**Identifier les tables avec trop de scans s√©quentiels :**
```sql
SELECT
    schemaname,
    relname,
    seq_scan,
    seq_tup_read,
    idx_scan,
    CASE
        WHEN seq_scan + idx_scan > 0
        THEN round(100.0 * seq_scan / (seq_scan + idx_scan), 2)
        ELSE 0
    END AS pct_seq_scan
FROM pg_stat_user_tables
WHERE seq_scan > 0
ORDER BY seq_scan DESC
LIMIT 20;
```

**Interpr√©tation :**
- Si `pct_seq_scan > 50%` et que la table est grande (millions de lignes), il faut investiguer
- Les petites tables (< 1000 lignes) peuvent √™tre scann√©es s√©quentiellement sans probl√®me

**Calculer le nombre moyen de lignes lues par scan :**
```sql
SELECT
    relname,
    seq_scan,
    seq_tup_read,
    CASE
        WHEN seq_scan > 0
        THEN round(seq_tup_read::numeric / seq_scan, 2)
        ELSE 0
    END AS lignes_par_scan
FROM pg_stat_user_tables
WHERE seq_scan > 0
ORDER BY lignes_par_scan DESC;
```

### 3. **idx_scan** et **idx_tup_fetch**

- **idx_scan** : Nombre de scans d'index effectu√©s sur la table
- **idx_tup_fetch** : Nombre de lignes r√©cup√©r√©es via les index

**Diff√©rence avec seq_scan :**

Un scan d'index est g√©n√©ralement beaucoup plus rapide car PostgreSQL va directement aux lignes pertinentes au lieu de lire toute la table.

**Ratio index vs s√©quentiel :**
```sql
SELECT
    relname,
    seq_scan,
    idx_scan,
    seq_scan + idx_scan AS total_scans,
    CASE
        WHEN (seq_scan + idx_scan) > 0
        THEN round(100.0 * idx_scan / (seq_scan + idx_scan), 2)
        ELSE 0
    END AS pct_index_scan
FROM pg_stat_user_tables
WHERE (seq_scan + idx_scan) > 100  -- Tables avec activit√© significative
ORDER BY pct_index_scan;
```

**Benchmark :**
- Pour les grandes tables actives, visez `pct_index_scan > 90%`
- Si < 50%, c'est probablement un probl√®me d'indexation

**‚ö†Ô∏è Important :** Un `idx_scan = 0` sur une table fr√©quemment interrog√©e indique soit :
- Aucun index n'existe
- Les index existants ne sont pas utilis√©s (mauvaise conception)

### 4. **n_tup_ins**, **n_tup_upd**, **n_tup_del**

- **n_tup_ins** : Nombre de lignes ins√©r√©es depuis le d√©marrage (ou reset des stats)
- **n_tup_upd** : Nombre de lignes mises √† jour
- **n_tup_del** : Nombre de lignes supprim√©es

**Identifier les tables les plus modifi√©es :**
```sql
SELECT
    relname,
    n_tup_ins AS insertions,
    n_tup_upd AS mises_a_jour,
    n_tup_del AS suppressions,
    (n_tup_ins + n_tup_upd + n_tup_del) AS total_modifications
FROM pg_stat_user_tables
ORDER BY total_modifications DESC
LIMIT 20;
```

**Cas d'usage :**

1. **Tables d'audit** : Beaucoup d'insertions, peu de mises √† jour/suppressions
2. **Tables de r√©f√©rence** : Peu de modifications
3. **Tables transactionnelles** : Insertions et mises √† jour fr√©quentes
4. **Tables de cache** : Beaucoup d'insertions et de suppressions

**Ratio INSERT vs UPDATE vs DELETE :**
```sql
SELECT
    relname,
    n_tup_ins,
    n_tup_upd,
    n_tup_del,
    CASE
        WHEN (n_tup_ins + n_tup_upd + n_tup_del) > 0
        THEN round(100.0 * n_tup_ins / (n_tup_ins + n_tup_upd + n_tup_del), 2)
        ELSE 0
    END AS pct_insertions,
    CASE
        WHEN (n_tup_ins + n_tup_upd + n_tup_del) > 0
        THEN round(100.0 * n_tup_upd / (n_tup_ins + n_tup_upd + n_tup_del), 2)
        ELSE 0
    END AS pct_updates
FROM pg_stat_user_tables
WHERE (n_tup_ins + n_tup_upd + n_tup_del) > 1000
ORDER BY (n_tup_ins + n_tup_upd + n_tup_del) DESC;
```

### 5. **n_tup_hot_upd**

Cette colonne compte les **HOT updates** (Heap-Only Tuple updates).

**Qu'est-ce qu'un HOT update ?**

Quand vous faites un UPDATE dans PostgreSQL, le syst√®me cr√©e une nouvelle version de la ligne (MVCC). Normalement, tous les index doivent √™tre mis √† jour. Mais si :
1. La mise √† jour n'affecte pas les colonnes index√©es
2. Il y a de l'espace sur la m√™me page (bloc) de donn√©es

PostgreSQL peut faire un "HOT update" : la nouvelle version reste sur la m√™me page et les index ne sont PAS mis √† jour. C'est **beaucoup plus rapide**.

**Ratio HOT updates :**
```sql
SELECT
    relname,
    n_tup_upd AS total_updates,
    n_tup_hot_upd AS hot_updates,
    CASE
        WHEN n_tup_upd > 0
        THEN round(100.0 * n_tup_hot_upd / n_tup_upd, 2)
        ELSE 0
    END AS pct_hot_updates
FROM pg_stat_user_tables
WHERE n_tup_upd > 100
ORDER BY n_tup_upd DESC;
```

**Interpr√©tation :**
- **> 80%** : Excellent ! La plupart des updates sont HOT.
- **< 50%** : Probl√©matique. Les updates sont lents car les index sont constamment mis √† jour.

**Causes d'un faible taux de HOT updates :**
1. Trop d'index sur la table
2. Colonnes index√©es fr√©quemment mises √† jour
3. Table mal dimensionn√©e (fillfactor trop √©lev√©)
4. Manque de VACUUM r√©gulier

**Solution :** Ajustez le `fillfactor` pour laisser de l'espace pour les HOT updates :
```sql
-- Laisser 10% d'espace libre pour les updates
ALTER TABLE ma_table SET (fillfactor = 90);
VACUUM FULL ma_table;  -- N√©cessaire pour appliquer
```

### 6. **n_live_tup** et **n_dead_tup**

- **n_live_tup** : Estimation du nombre de lignes "vivantes" (visibles pour les transactions en cours)
- **n_dead_tup** : Estimation du nombre de lignes "mortes" (supprim√©es ou anciennes versions suite √† UPDATE)

**Qu'est-ce qu'une ligne morte ?**

Dans PostgreSQL (MVCC), quand vous faites un DELETE ou UPDATE :
- La ligne n'est pas imm√©diatement supprim√©e physiquement
- Elle est marqu√©e comme "morte"
- Elle reste sur le disque jusqu'au prochain VACUUM

**Pourquoi c'est critique ?**

Beaucoup de lignes mortes causent :
- **Ralentissement des requ√™tes** (PostgreSQL doit scanner des lignes inutiles)
- **Gonflement de la table** (bloat)
- **Gaspillage d'espace disque**
- **D√©gradation du cache**

**Identifier les tables avec trop de lignes mortes :**
```sql
SELECT
    schemaname,
    relname,
    n_live_tup AS lignes_vivantes,
    n_dead_tup AS lignes_mortes,
    CASE
        WHEN n_live_tup > 0
        THEN round(100.0 * n_dead_tup / n_live_tup, 2)
        ELSE 0
    END AS pct_dead_tuples,
    pg_size_pretty(pg_total_relation_size(relid)) AS taille_totale
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000  -- Au moins 1000 lignes mortes
ORDER BY n_dead_tup DESC
LIMIT 20;
```

**Seuils d'alerte :**
- **> 20%** de lignes mortes : Planifiez un VACUUM
- **> 50%** : VACUUM urgent n√©cessaire
- **> 100%** (plus de lignes mortes que vivantes) : Probl√®me majeur !

**Solution :**
```sql
-- VACUUM manuel sur une table sp√©cifique
VACUUM ma_table;

-- VACUUM ANALYZE pour mettre √† jour aussi les statistiques
VACUUM ANALYZE ma_table;
```

### 7. **n_mod_since_analyze**

Nombre de lignes modifi√©es (INSERT, UPDATE, DELETE) depuis le dernier ANALYZE.

**Pourquoi c'est important ?**

ANALYZE collecte des statistiques sur la distribution des donn√©es. Le planificateur PostgreSQL utilise ces stats pour choisir le meilleur plan d'ex√©cution. Des statistiques obsol√®tes = plans d'ex√©cution sous-optimaux.

**Identifier les tables avec statistiques obsol√®tes :**
```sql
SELECT
    relname,
    n_live_tup,
    n_mod_since_analyze,
    CASE
        WHEN n_live_tup > 0
        THEN round(100.0 * n_mod_since_analyze / n_live_tup, 2)
        ELSE 0
    END AS pct_modifie,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
WHERE n_mod_since_analyze > 1000
ORDER BY n_mod_since_analyze DESC;
```

**Seuil d'alerte :**
- Si `pct_modifie > 10%` : ANALYZE recommand√©
- Si `pct_modifie > 25%` : ANALYZE urgent

**Solution :**
```sql
ANALYZE ma_table;
```

### 8. **last_vacuum** et **last_autovacuum**

- **last_vacuum** : Date/heure du dernier VACUUM manuel
- **last_autovacuum** : Date/heure du dernier VACUUM automatique (autovacuum)

**Diff√©rence :**
- **Autovacuum** : Processus automatique de PostgreSQL qui VACUUM les tables selon des seuils configur√©s
- **VACUUM manuel** : Vous l'ex√©cutez vous-m√™me

**Identifier les tables jamais VACUUM√©es :**
```sql
SELECT
    schemaname,
    relname,
    n_dead_tup,
    last_vacuum,
    last_autovacuum,
    COALESCE(last_vacuum, last_autovacuum) AS dernier_vacuum,
    CASE
        WHEN COALESCE(last_vacuum, last_autovacuum) IS NOT NULL
        THEN age(now(), COALESCE(last_vacuum, last_autovacuum))
        ELSE NULL
    END AS temps_depuis_vacuum
FROM pg_stat_user_tables
ORDER BY COALESCE(last_vacuum, last_autovacuum) NULLS FIRST;
```

**Alerte si :**
- `last_vacuum` et `last_autovacuum` sont tous deux NULL (jamais VACUUM√©)
- Plus de 7 jours sans VACUUM sur une table active
- Combinaison de : temps long + beaucoup de `n_dead_tup`

### 9. **last_analyze** et **last_autoanalyze**

- **last_analyze** : Date/heure du dernier ANALYZE manuel
- **last_autoanalyze** : Date/heure du dernier ANALYZE automatique

**Identifier les tables avec statistiques anciennes :**
```sql
SELECT
    relname,
    n_live_tup,
    n_mod_since_analyze,
    last_analyze,
    last_autoanalyze,
    COALESCE(last_analyze, last_autoanalyze) AS dernier_analyze,
    age(now(), COALESCE(last_analyze, last_autoanalyze)) AS age_stats
FROM pg_stat_user_tables
WHERE COALESCE(last_analyze, last_autoanalyze) < now() - interval '7 days'
   OR (COALESCE(last_analyze, last_autoanalyze) IS NULL AND n_live_tup > 0)
ORDER BY age_stats DESC NULLS FIRST;
```

### 10. **vacuum_count** et **autovacuum_count**

- **vacuum_count** : Nombre de VACUUM manuels depuis le d√©marrage
- **autovacuum_count** : Nombre de VACUUM automatiques

**Analyser la fr√©quence de VACUUM :**
```sql
SELECT
    relname,
    vacuum_count,
    autovacuum_count,
    vacuum_count + autovacuum_count AS total_vacuums,
    last_vacuum,
    last_autovacuum
FROM pg_stat_user_tables
ORDER BY (vacuum_count + autovacuum_count) DESC
LIMIT 20;
```

**Interpr√©tation :**
- Tables avec `autovacuum_count` tr√®s √©lev√© : Beaucoup d'activit√© d'√©criture, c'est normal
- Tables avec `vacuum_count = 0` et `autovacuum_count = 0` : Jamais nettoy√©es !

### 11. **analyze_count** et **autoanalyze_count**

M√™me principe que pour VACUUM, mais pour ANALYZE.

```sql
SELECT
    relname,
    analyze_count,
    autoanalyze_count,
    n_mod_since_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
ORDER BY n_mod_since_analyze DESC;
```

### 12. Statistiques PostgreSQL 18+ : Nouveaut√©s

√Ä partir de PostgreSQL 18 (Septembre 2025), de nouvelles colonnes ont √©t√© ajout√©es pour suivre les op√©rations de VACUUM et ANALYZE plus finement.

**Nouvelles colonnes (PG 18+) :**
- Statistiques d√©taill√©es sur les performances de VACUUM
- M√©triques I/O par table
- Suivi des op√©rations de maintenance

## Requ√™tes pratiques courantes

### 1. Vue d'ensemble de toutes les tables

```sql
SELECT
    schemaname || '.' || relname AS table_complete,
    pg_size_pretty(pg_total_relation_size(relid)) AS taille,
    n_live_tup AS lignes,
    seq_scan AS scans_seq,
    idx_scan AS scans_index,
    n_tup_ins AS insertions,
    n_tup_upd AS updates,
    n_tup_del AS deletes,
    n_dead_tup AS lignes_mortes
FROM pg_stat_user_tables
ORDER BY pg_total_relation_size(relid) DESC
LIMIT 20;
```

### 2. Identifier les tables sans index utilis√©s

```sql
SELECT
    schemaname,
    relname,
    seq_scan,
    idx_scan,
    n_live_tup,
    pg_size_pretty(pg_total_relation_size(relid)) AS taille
FROM pg_stat_user_tables
WHERE idx_scan = 0  -- Aucun scan d'index
  AND seq_scan > 0  -- Mais des scans s√©quentiels
  AND n_live_tup > 1000  -- Tables non triviales
ORDER BY seq_scan DESC;
```

**Action :** V√©rifiez si ces tables ont besoin d'index :
```sql
-- Voir les index existants sur une table
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'ma_table';
```

### 3. Tables avec le plus de lignes mortes

```sql
SELECT
    schemaname,
    relname,
    n_live_tup,
    n_dead_tup,
    round(100.0 * n_dead_tup / GREATEST(n_live_tup, 1), 2) AS pct_dead,
    pg_size_pretty(pg_total_relation_size(relid)) AS taille,
    last_autovacuum
FROM pg_stat_user_tables
WHERE n_dead_tup > 0
ORDER BY n_dead_tup DESC
LIMIT 20;
```

### 4. Tables n√©cessitant un VACUUM urgent

```sql
SELECT
    schemaname,
    relname,
    n_live_tup,
    n_dead_tup,
    round(100.0 * n_dead_tup / GREATEST(n_live_tup, 1), 2) AS pct_dead,
    last_vacuum,
    last_autovacuum
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
  AND (
    n_dead_tup::float / GREATEST(n_live_tup, 1) > 0.2  -- > 20% de lignes mortes
    OR last_autovacuum < now() - interval '7 days'
    OR last_autovacuum IS NULL
  )
ORDER BY pct_dead DESC;
```

### 5. Tables avec statistiques obsol√®tes

```sql
SELECT
    relname,
    n_live_tup,
    n_mod_since_analyze,
    round(100.0 * n_mod_since_analyze / GREATEST(n_live_tup, 1), 2) AS pct_modifie,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
WHERE n_mod_since_analyze > 1000
  AND (
    n_mod_since_analyze::float / GREATEST(n_live_tup, 1) > 0.1  -- > 10% modifi√©
    OR last_autoanalyze < now() - interval '7 days'
    OR last_autoanalyze IS NULL
  )
ORDER BY n_mod_since_analyze DESC;
```

### 6. Performance des index par table

```sql
SELECT
    relname,
    seq_scan,
    idx_scan,
    CASE
        WHEN (seq_scan + idx_scan) > 0
        THEN round(100.0 * idx_scan / (seq_scan + idx_scan), 2)
        ELSE 0
    END AS pct_index_usage,
    n_live_tup
FROM pg_stat_user_tables
WHERE (seq_scan + idx_scan) > 0
ORDER BY pct_index_usage, seq_scan DESC;
```

### 7. Taux de HOT updates par table

```sql
SELECT
    relname,
    n_tup_upd,
    n_tup_hot_upd,
    CASE
        WHEN n_tup_upd > 0
        THEN round(100.0 * n_tup_hot_upd / n_tup_upd, 2)
        ELSE 0
    END AS pct_hot_updates
FROM pg_stat_user_tables
WHERE n_tup_upd > 100
ORDER BY pct_hot_updates;
```

### 8. Tables les plus actives (lecture)

```sql
SELECT
    relname,
    seq_scan + idx_scan AS total_scans,
    seq_tup_read + idx_tup_fetch AS total_lignes_lues,
    pg_size_pretty(pg_total_relation_size(relid)) AS taille
FROM pg_stat_user_tables
ORDER BY (seq_scan + idx_scan) DESC
LIMIT 20;
```

### 9. Tables les plus actives (√©criture)

```sql
SELECT
    relname,
    n_tup_ins + n_tup_upd + n_tup_del AS total_ecritures,
    n_tup_ins AS insertions,
    n_tup_upd AS updates,
    n_tup_del AS deletes,
    pg_size_pretty(pg_total_relation_size(relid)) AS taille
FROM pg_stat_user_tables
ORDER BY (n_tup_ins + n_tup_upd + n_tup_del) DESC
LIMIT 20;
```

### 10. Rapport complet de sant√© d'une table

```sql
SELECT
    schemaname,
    relname,
    -- Taille
    pg_size_pretty(pg_total_relation_size(relid)) AS taille_totale,
    -- Lignes
    n_live_tup AS lignes_vivantes,
    n_dead_tup AS lignes_mortes,
    round(100.0 * n_dead_tup / GREATEST(n_live_tup, 1), 2) AS pct_dead,
    -- Scans
    seq_scan AS scans_sequentiels,
    idx_scan AS scans_index,
    CASE
        WHEN (seq_scan + idx_scan) > 0
        THEN round(100.0 * idx_scan / (seq_scan + idx_scan), 2)
        ELSE 0
    END AS pct_index_usage,
    -- Modifications
    n_tup_ins + n_tup_upd + n_tup_del AS total_modifs,
    -- HOT updates
    CASE
        WHEN n_tup_upd > 0
        THEN round(100.0 * n_tup_hot_upd / n_tup_upd, 2)
        ELSE 0
    END AS pct_hot_updates,
    -- Maintenance
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
WHERE relname = 'ma_table';  -- Remplacer par votre table
```

### 11. Combiner avec pg_stat_user_indexes

```sql
SELECT
    t.schemaname,
    t.relname AS table_name,
    t.seq_scan,
    t.idx_scan AS table_idx_scans,
    COUNT(i.indexrelname) AS nombre_index,
    SUM(i.idx_scan) AS total_index_scans
FROM pg_stat_user_tables t
LEFT JOIN pg_stat_user_indexes i ON t.relid = i.relid
GROUP BY t.schemaname, t.relname, t.seq_scan, t.idx_scan
ORDER BY t.seq_scan DESC
LIMIT 20;
```

### 12. Cache hit ratio par table

```sql
SELECT
    relname,
    heap_blks_read AS blocs_disque,
    heap_blks_hit AS blocs_cache,
    CASE
        WHEN (heap_blks_hit + heap_blks_read) > 0
        THEN round(100.0 * heap_blks_hit / (heap_blks_hit + heap_blks_read), 2)
        ELSE 0
    END AS cache_hit_ratio
FROM pg_statio_user_tables
WHERE (heap_blks_hit + heap_blks_read) > 1000
ORDER BY cache_hit_ratio;
```

**Note :** Cette requ√™te utilise `pg_statio_user_tables` (vue compl√©mentaire pour les stats I/O).

## Relation avec pg_statio_user_tables

La vue `pg_statio_user_tables` fournit des statistiques I/O compl√©mentaires :

- **heap_blks_read** : Blocs lus depuis le disque
- **heap_blks_hit** : Blocs trouv√©s en cache
- **idx_blks_read** : Blocs d'index lus depuis le disque
- **idx_blks_hit** : Blocs d'index en cache
- **toast_blks_read** / **toast_blks_hit** : Pour les donn√©es TOAST (grandes valeurs)

**Vue combin√©e :**
```sql
SELECT
    s.relname,
    s.n_live_tup,
    s.seq_scan,
    s.idx_scan,
    io.heap_blks_read,
    io.heap_blks_hit,
    CASE
        WHEN (io.heap_blks_hit + io.heap_blks_read) > 0
        THEN round(100.0 * io.heap_blks_hit / (io.heap_blks_hit + io.heap_blks_read), 2)
        ELSE 0
    END AS cache_hit_ratio
FROM pg_stat_user_tables s
JOIN pg_statio_user_tables io ON s.relid = io.relid
WHERE (io.heap_blks_hit + io.heap_blks_read) > 100
ORDER BY cache_hit_ratio;
```

## Cas d'usage en production

### Sc√©nario 1 : "Ma base de donn√©es est lente"

**√âtape 1 : Identifier les tables probl√©matiques**
```sql
-- Tables avec beaucoup de scans s√©quentiels
SELECT relname, seq_scan, n_live_tup, pg_size_pretty(pg_total_relation_size(relid)) AS taille
FROM pg_stat_user_tables
WHERE seq_scan > 1000 AND n_live_tup > 10000
ORDER BY seq_scan DESC;
```

**√âtape 2 : V√©rifier le bloat (lignes mortes)**
```sql
SELECT relname, n_live_tup, n_dead_tup,
       round(100.0 * n_dead_tup / GREATEST(n_live_tup, 1), 2) AS pct_dead
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY pct_dead DESC;
```

**√âtape 3 : V√©rifier les statistiques**
```sql
SELECT relname, n_mod_since_analyze, last_autoanalyze
FROM pg_stat_user_tables
WHERE n_mod_since_analyze > 1000
ORDER BY n_mod_since_analyze DESC;
```

### Sc√©nario 2 : "Optimisation de l'indexation"

```sql
-- Trouver les tables candidates pour de nouveaux index
SELECT
    relname,
    seq_scan,
    idx_scan,
    n_live_tup,
    CASE
        WHEN (seq_scan + idx_scan) > 0
        THEN round(100.0 * seq_scan / (seq_scan + idx_scan), 2)
        ELSE 0
    END AS pct_seq_scan
FROM pg_stat_user_tables
WHERE n_live_tup > 1000
  AND seq_scan > 100
  AND (seq_scan + idx_scan) > 0
ORDER BY seq_scan * n_live_tup DESC;  -- Impact estim√©
```

**Puis analysez les requ√™tes lentes :**
```sql
-- Combiner avec pg_stat_statements (extension)
SELECT query, calls, mean_exec_time
FROM pg_stat_statements
WHERE query LIKE '%ma_table%'
ORDER BY mean_exec_time DESC;
```

### Sc√©nario 3 : "Planifier la maintenance"

```sql
-- Liste des tables n√©cessitant une attention imm√©diate
SELECT
    relname,
    CASE
        WHEN n_dead_tup > 1000 AND n_dead_tup::float / GREATEST(n_live_tup, 1) > 0.2
        THEN 'VACUUM urgent'
        WHEN n_mod_since_analyze > 1000
        THEN 'ANALYZE recommand√©'
        WHEN last_autovacuum < now() - interval '7 days'
        THEN 'VACUUM overdue'
        ELSE 'OK'
    END AS action_recommandee,
    n_dead_tup,
    n_mod_since_analyze,
    last_autovacuum
FROM pg_stat_user_tables
WHERE relname NOT LIKE 'pg_%'
ORDER BY
    CASE action_recommandee
        WHEN 'VACUUM urgent' THEN 1
        WHEN 'ANALYZE recommand√©' THEN 2
        WHEN 'VACUUM overdue' THEN 3
        ELSE 4
    END;
```

### Sc√©nario 4 : "Audit de performance mensuel"

```sql
-- Cr√©er un snapshot des m√©triques cl√©s
CREATE TABLE IF NOT EXISTS perf_snapshot (
    snapshot_date timestamp DEFAULT now(),
    table_name text,
    table_size bigint,
    n_live_tup bigint,
    n_dead_tup bigint,
    seq_scan bigint,
    idx_scan bigint,
    n_tup_ins bigint,
    n_tup_upd bigint,
    n_tup_del bigint
);

-- Ins√©rer le snapshot mensuel
INSERT INTO perf_snapshot (
    table_name, table_size, n_live_tup, n_dead_tup,
    seq_scan, idx_scan, n_tup_ins, n_tup_upd, n_tup_del
)
SELECT
    relname,
    pg_total_relation_size(relid),
    n_live_tup,
    n_dead_tup,
    seq_scan,
    idx_scan,
    n_tup_ins,
    n_tup_upd,
    n_tup_del
FROM pg_stat_user_tables;

-- Analyser la croissance sur 3 mois
SELECT
    p1.table_name,
    pg_size_pretty(p1.table_size) AS taille_actuelle,
    pg_size_pretty(p1.table_size - p3.table_size) AS croissance_3_mois,
    round(100.0 * (p1.table_size - p3.table_size) / GREATEST(p3.table_size, 1), 2) AS pct_croissance
FROM perf_snapshot p1
LEFT JOIN perf_snapshot p3 ON p1.table_name = p3.table_name
    AND p3.snapshot_date = (SELECT max(snapshot_date) FROM perf_snapshot WHERE snapshot_date < now() - interval '90 days')
WHERE p1.snapshot_date = (SELECT max(snapshot_date) FROM perf_snapshot)
ORDER BY pct_croissance DESC;
```

## Monitoring et alertes recommand√©s

### Alertes critiques

1. **Bloat excessif (> 20% lignes mortes)**
```sql
SELECT count(*)
FROM pg_stat_user_tables
WHERE n_dead_tup::float / GREATEST(n_live_tup, 1) > 0.2
  AND n_dead_tup > 1000;
```

2. **Statistiques obsol√®tes (> 10% modifi√©)**
```sql
SELECT count(*)
FROM pg_stat_user_tables
WHERE n_mod_since_analyze::float / GREATEST(n_live_tup, 1) > 0.1
  AND n_mod_since_analyze > 1000;
```

3. **Tables jamais VACUUM√©es**
```sql
SELECT count(*)
FROM pg_stat_user_tables
WHERE last_vacuum IS NULL
  AND last_autovacuum IS NULL
  AND n_live_tup > 1000;
```

4. **Trop de scans s√©quentiels sur grandes tables**
```sql
SELECT count(*)
FROM pg_stat_user_tables
WHERE seq_scan > 1000
  AND n_live_tup > 100000
  AND seq_scan::float / GREATEST(seq_scan + idx_scan, 1) > 0.5;
```

### Script de monitoring complet

```sql
-- Vue de monitoring quotidien
CREATE OR REPLACE VIEW v_table_health AS
SELECT
    schemaname,
    relname,
    pg_size_pretty(pg_total_relation_size(relid)) AS taille,
    n_live_tup,
    n_dead_tup,
    round(100.0 * n_dead_tup / GREATEST(n_live_tup, 1), 2) AS pct_bloat,
    seq_scan,
    idx_scan,
    round(100.0 * idx_scan / GREATEST(seq_scan + idx_scan, 1), 2) AS pct_index_usage,
    n_mod_since_analyze,
    CASE
        WHEN n_dead_tup::float / GREATEST(n_live_tup, 1) > 0.2 AND n_dead_tup > 1000
            THEN 'üî¥ VACUUM urgent'
        WHEN n_mod_since_analyze::float / GREATEST(n_live_tup, 1) > 0.1 AND n_mod_since_analyze > 1000
            THEN 'üü° ANALYZE recommand√©'
        WHEN seq_scan > 1000 AND n_live_tup > 10000 AND idx_scan = 0
            THEN 'üü† Manque d''index ?'
        ELSE 'üü¢ OK'
    END AS statut,
    last_autovacuum,
    last_autoanalyze
FROM pg_stat_user_tables
ORDER BY
    CASE
        WHEN n_dead_tup::float / GREATEST(n_live_tup, 1) > 0.2 THEN 1
        WHEN n_mod_since_analyze::float / GREATEST(n_live_tup, 1) > 0.1 THEN 2
        WHEN seq_scan > 1000 AND idx_scan = 0 THEN 3
        ELSE 4
    END,
    n_dead_tup DESC;

-- Utilisation
SELECT * FROM v_table_health WHERE statut != 'üü¢ OK';
```

## Automatisation de la maintenance

### Script de VACUUM intelligent

```sql
-- Fonction pour VACUUM uniquement les tables qui en ont besoin
CREATE OR REPLACE FUNCTION smart_vacuum()
RETURNS TABLE (table_name text, action text)
LANGUAGE plpgsql AS $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN
        SELECT schemaname, relname, n_dead_tup, n_live_tup
        FROM pg_stat_user_tables
        WHERE n_dead_tup > 1000
          AND n_dead_tup::float / GREATEST(n_live_tup, 1) > 0.1
        ORDER BY n_dead_tup DESC
    LOOP
        EXECUTE format('VACUUM ANALYZE %I.%I', r.schemaname, r.relname);
        table_name := r.schemaname || '.' || r.relname;
        action := format('VACUUMed (had %s dead tuples)', r.n_dead_tup);
        RETURN NEXT;
    END LOOP;
END;
$$;

-- Ex√©cution
SELECT * FROM smart_vacuum();
```

## Bonnes pratiques

1. **Surveillez r√©guli√®rement le bloat**
   - Cr√©ez des alertes pour `n_dead_tup`
   - Objectif : < 10% de lignes mortes

2. **Optimisez les HOT updates**
   - Ajustez le `fillfactor` si n√©cessaire
   - Cible : > 80% de HOT updates sur les tables mises √† jour fr√©quemment

3. **Gardez les statistiques √† jour**
   - ANALYZE automatique ou manuel r√©gulier
   - Critique apr√®s des modifications en masse

4. **Identifiez les missing indexes**
   - Tables avec beaucoup de `seq_scan` et peu de `idx_scan`
   - Focus sur les grandes tables (> 10,000 lignes)

5. **Suivez les tendances**
   - Exportez r√©guli√®rement les m√©triques
   - Comparez mois par mois

6. **Configurez autovacuum correctement**
   - Ajustez les seuils selon votre charge
   - Ne d√©sactivez JAMAIS autovacuum en production !

7. **Combinez avec d'autres vues**
   - `pg_stat_user_indexes` : Utilisation des index
   - `pg_statio_user_tables` : Stats I/O
   - `pg_stat_statements` : Requ√™tes lentes

## R√©sum√© des colonnes cl√©s

| Colonne | Description | Objectif/Seuil |
|---------|-------------|----------------|
| **seq_scan / idx_scan** | Scans s√©quentiels vs index | > 90% index sur grandes tables |
| **n_live_tup / n_dead_tup** | Lignes vivantes vs mortes | < 10% lignes mortes |
| **n_tup_hot_upd** | HOT updates | > 80% de tous les updates |
| **n_mod_since_analyze** | Modifs depuis ANALYZE | < 10% de n_live_tup |
| **last_vacuum / last_autovacuum** | Dernier VACUUM | < 7 jours sur tables actives |
| **last_analyze / last_autoanalyze** | Dernier ANALYZE | < 7 jours sur tables actives |

## Conclusion

`pg_stat_user_tables` est votre outil principal pour :

- ‚úÖ **Identifier les probl√®mes de performance** (scans s√©quentiels, bloat)
- ‚úÖ **Optimiser l'indexation** (analyser seq_scan vs idx_scan)
- ‚úÖ **Planifier la maintenance** (VACUUM, ANALYZE)
- ‚úÖ **Surveiller la sant√©** (lignes mortes, statistiques obsol√®tes)
- ‚úÖ **Comprendre l'utilisation** (lectures, √©critures, HOT updates)

**Points critiques √† surveiller :**
- Bloat (lignes mortes) > 10%
- Statistiques obsol√®tes (n_mod_since_analyze √©lev√©)
- Scans s√©quentiels sur grandes tables
- Faible taux de HOT updates (< 50%)
- Tables jamais VACUUM√©es ou ANALYZ√âes

Combinez cette vue avec `pg_stat_user_indexes`, `pg_statio_user_tables` et `pg_stat_statements` pour une vision compl√®te et d√©taill√©e de vos performances PostgreSQL.

---

**Prochaines √©tapes :** Explorez `pg_stat_user_indexes` pour analyser l'utilisation de vos index, et apprenez √† optimiser vos requ√™tes avec EXPLAIN ANALYZE.

‚è≠Ô∏è [pg_locks : Verrous actifs](/14-observabilite-et-monitoring/02.4-pg-locks.md)
