üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.4.2. Triggers par instruction (FOR EACH STATEMENT)

## Introduction

Les **triggers par instruction** (ou *statement-level triggers*) sont des d√©clencheurs qui s'ex√©cutent **une seule fois par op√©ration SQL**, quel que soit le nombre de lignes affect√©es. Contrairement aux triggers par ligne (FOR EACH ROW), ils ne s'ex√©cutent pas pour chaque enregistrement individuel, mais une seule fois pour l'instruction compl√®te.

### Analogie pour comprendre la diff√©rence

Reprenons l'analogie du magasin :

| Type de trigger | Analogie | Quand s'ex√©cute-t-il ? |
|-----------------|----------|------------------------|
| **FOR EACH ROW** | Portique de s√©curit√© qui scanne chaque personne individuellement | 1 fois par personne (par ligne) |
| **FOR EACH STATEMENT** | Gardien qui v√©rifie le groupe entier en une fois | 1 fois pour tout le groupe (par instruction) |

### Exemple concret

```sql
-- Si cette requ√™te affecte 1000 lignes :
UPDATE employes SET salaire = salaire * 1.10;

-- FOR EACH ROW : s'ex√©cute 1000 fois (une fois par ligne)
-- FOR EACH STATEMENT : s'ex√©cute 1 seule fois
```

## Syntaxe de base

```sql
CREATE TRIGGER nom_du_trigger
  { BEFORE | AFTER } { INSERT | UPDATE | DELETE }
  ON nom_table
  FOR EACH STATEMENT
  EXECUTE FUNCTION nom_fonction_trigger();
```

### Diff√©rence cl√© dans la syntaxe

La seule diff√©rence syntaxique avec un trigger par ligne est la clause :

- **FOR EACH ROW** ‚Üí Trigger par ligne
- **FOR EACH STATEMENT** ‚Üí Trigger par instruction

## Caract√©ristiques fondamentales

### 1. Pas d'acc√®s √† NEW et OLD

C'est la diff√©rence majeure avec les triggers par ligne :

‚ùå **Impossible d'acc√©der aux donn√©es individuelles**
```sql
CREATE OR REPLACE FUNCTION trigger_statement()
RETURNS TRIGGER AS $$
BEGIN
  -- ‚ùå ERREUR : NEW et OLD ne sont pas disponibles
  RAISE NOTICE 'Nouvelle valeur : %', NEW.colonne;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

‚úÖ **On peut seulement savoir qu'une op√©ration a eu lieu**
```sql
CREATE OR REPLACE FUNCTION trigger_statement()
RETURNS TRIGGER AS $$
BEGIN
  -- ‚úÖ OK : On sait qu'une op√©ration s'est produite
  RAISE NOTICE 'Op√©ration % sur la table %', TG_OP, TG_TABLE_NAME;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

### 2. Performance optimale pour les op√©rations en masse

**Avantage principal :** Id√©al pour les op√©rations affectant de nombreuses lignes

```sql
-- Cette op√©ration affecte 50 000 lignes

-- Avec FOR EACH ROW : 50 000 ex√©cutions du trigger
-- Temps : ~5 secondes

-- Avec FOR EACH STATEMENT : 1 seule ex√©cution
-- Temps : ~0.01 secondes
```

### 3. Valeur de retour

La valeur de retour est **toujours ignor√©e** (contrairement aux triggers BEFORE ROW).

```sql
CREATE OR REPLACE FUNCTION trigger_statement()
RETURNS TRIGGER AS $$
BEGIN
  -- La valeur de retour n'a aucun impact
  RETURN NULL;  -- Acceptable
END;
$$ LANGUAGE plpgsql;
```

Par convention, on retourne toujours `NULL` dans les triggers par instruction.

## BEFORE vs AFTER Statement

### BEFORE STATEMENT

**S'ex√©cute avant que l'op√©ration soit effectu√©e**

**Cas d'usage typiques :**
1. **V√©rifications pr√©liminaires** avant traitement
2. **Pr√©paration de tables temporaires**
3. **Validation de conditions globales**
4. **Verrouillage de ressources**

**Exemple - V√©rification de l'heure**
```sql
CREATE OR REPLACE FUNCTION verifier_horaire_modification()
RETURNS TRIGGER AS $$
BEGIN
  -- Interdire les modifications en dehors des heures de bureau
  IF EXTRACT(HOUR FROM now()) < 8 OR EXTRACT(HOUR FROM now()) > 18 THEN
    RAISE EXCEPTION 'Modifications interdites en dehors des heures de bureau (8h-18h)';
  END IF;

  -- Interdire les modifications le weekend
  IF EXTRACT(DOW FROM now()) IN (0, 6) THEN  -- 0=dimanche, 6=samedi
    RAISE EXCEPTION 'Modifications interdites le weekend';
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_horaire
  BEFORE UPDATE OR DELETE ON donnees_critiques
  FOR EACH STATEMENT
  EXECUTE FUNCTION verifier_horaire_modification();
```

**Explication :** Avant toute tentative de modification de la table `donnees_critiques`, le trigger v√©rifie que nous sommes bien en heures de bureau. Si ce n'est pas le cas, l'op√©ration est bloqu√©e avec un message d'erreur explicite.

### AFTER STATEMENT

**S'ex√©cute apr√®s que l'op√©ration ait √©t√© effectu√©e**

**Cas d'usage typiques :**
1. **Journalisation d'op√©rations en masse**
2. **Mise √† jour de statistiques ou compteurs**
3. **Notifications d'√©v√©nements**
4. **Refresh de vues mat√©rialis√©es**
5. **Nettoyage ou maintenance**

**Exemple - Journalisation des op√©rations en masse**
```sql
-- Table de log
CREATE TABLE operations_log (
  id SERIAL PRIMARY KEY,
  table_name TEXT,
  operation TEXT,
  nb_lignes_estimees INTEGER,
  executee_par TEXT,
  executee_le TIMESTAMP DEFAULT now()
);

-- Fonction trigger
CREATE OR REPLACE FUNCTION logger_operation_masse()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO operations_log (
    table_name,
    operation,
    executee_par
  ) VALUES (
    TG_TABLE_NAME,
    TG_OP,
    current_user
  );

  RAISE NOTICE 'Op√©ration % enregistr√©e sur %', TG_OP, TG_TABLE_NAME;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Trigger
CREATE TRIGGER trigger_log_masse
  AFTER INSERT OR UPDATE OR DELETE ON produits
  FOR EACH STATEMENT
  EXECUTE FUNCTION logger_operation_masse();
```

**Sc√©nario d'utilisation :**
```sql
-- Cette op√©ration massive ne g√©n√®re qu'une seule entr√©e de log
UPDATE produits SET prix = prix * 1.05 WHERE categorie = 'electronique';

-- R√©sultat dans operations_log :
-- | table_name | operation | executee_par | executee_le |
-- | produits   | UPDATE    | admin        | 2025-11-22... |
```

## Variables contextuelles disponibles

Bien que NEW et OLD ne soient pas disponibles, plusieurs variables contextuelles restent accessibles :

### TG_OP
Type d'op√©ration : 'INSERT', 'UPDATE', ou 'DELETE'

```sql
IF TG_OP = 'DELETE' THEN
  RAISE WARNING 'Suppression massive d√©tect√©e';
END IF;
```

### TG_TABLE_NAME
Nom de la table concern√©e

```sql
RAISE NOTICE 'Op√©ration sur la table : %', TG_TABLE_NAME;
```

### TG_TABLE_SCHEMA
Sch√©ma de la table

```sql
IF TG_TABLE_SCHEMA = 'production' THEN
  -- Logique sp√©cifique pour le sch√©ma de production
END IF;
```

### TG_WHEN
Moment du trigger : 'BEFORE' ou 'AFTER'

```sql
RAISE DEBUG 'Trigger % en cours', TG_WHEN;
```

### TG_LEVEL
Niveau du trigger : toujours 'STATEMENT' ici

```sql
-- Toujours 'STATEMENT' dans ce contexte
ASSERT TG_LEVEL = 'STATEMENT';
```

## Exemples pratiques d√©taill√©s

### Exemple 1 : Mise √† jour d'un compteur de modifications

**Contexte :** Suivre le nombre total d'op√©rations sur une table sans d√©tailler chaque ligne

```sql
-- Table de statistiques
CREATE TABLE table_stats (
  table_name TEXT PRIMARY KEY,
  nb_insertions INTEGER DEFAULT 0,
  nb_updates INTEGER DEFAULT 0,
  nb_deletions INTEGER DEFAULT 0,
  derniere_modif TIMESTAMP
);

-- Initialiser pour la table produits
INSERT INTO table_stats (table_name) VALUES ('produits');

-- Fonction trigger
CREATE OR REPLACE FUNCTION maj_statistiques()
RETURNS TRIGGER AS $$
BEGIN
  -- Mettre √† jour les statistiques selon l'op√©ration
  IF TG_OP = 'INSERT' THEN
    UPDATE table_stats
    SET nb_insertions = nb_insertions + 1,
        derniere_modif = now()
    WHERE table_name = TG_TABLE_NAME;

  ELSIF TG_OP = 'UPDATE' THEN
    UPDATE table_stats
    SET nb_updates = nb_updates + 1,
        derniere_modif = now()
    WHERE table_name = TG_TABLE_NAME;

  ELSIF TG_OP = 'DELETE' THEN
    UPDATE table_stats
    SET nb_deletions = nb_deletions + 1,
        derniere_modif = now()
    WHERE table_name = TG_TABLE_NAME;
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Cr√©ation du trigger
CREATE TRIGGER trigger_stats
  AFTER INSERT OR UPDATE OR DELETE ON produits
  FOR EACH STATEMENT
  EXECUTE FUNCTION maj_statistiques();
```

**Utilisation :**
```sql
-- Effectuer des op√©rations
INSERT INTO produits (nom, prix) VALUES ('Laptop', 999.99);
UPDATE produits SET prix = prix * 1.10 WHERE categorie = 'tech';
DELETE FROM produits WHERE stock = 0;

-- Consulter les statistiques
SELECT * FROM table_stats WHERE table_name = 'produits';
-- | table_name | nb_insertions | nb_updates | nb_deletions | derniere_modif |
-- | produits   | 1             | 1          | 1            | 2025-11-22...  |
```

### Exemple 2 : Refresh automatique de vue mat√©rialis√©e

**Contexte :** Actualiser une vue mat√©rialis√©e apr√®s chaque modification d'une table source

```sql
-- Vue mat√©rialis√©e (calcul co√ªteux)
CREATE MATERIALIZED VIEW ventes_mensuelles AS
SELECT
  DATE_TRUNC('month', date_vente) AS mois,
  SUM(montant) AS total_ventes,
  COUNT(*) AS nb_ventes
FROM ventes
GROUP BY DATE_TRUNC('month', date_vente);

-- Index pour performance
CREATE INDEX idx_ventes_mensuelles_mois ON ventes_mensuelles(mois);

-- Fonction de refresh
CREATE OR REPLACE FUNCTION refresh_ventes_mensuelles()
RETURNS TRIGGER AS $$
BEGIN
  -- Rafra√Æchir la vue mat√©rialis√©e
  REFRESH MATERIALIZED VIEW CONCURRENTLY ventes_mensuelles;

  RAISE NOTICE 'Vue mat√©rialis√©e ventes_mensuelles rafra√Æchie';

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Trigger qui rafra√Æchit apr√®s chaque batch de modifications
CREATE TRIGGER trigger_refresh_stats
  AFTER INSERT OR UPDATE OR DELETE ON ventes
  FOR EACH STATEMENT
  EXECUTE FUNCTION refresh_ventes_mensuelles();
```

**Avantage :** Une seule op√©ration de refresh pour un batch de 1000 insertions, au lieu de 1000 refresh avec FOR EACH ROW.

### Exemple 3 : Notification d'op√©ration massive

**Contexte :** Alerter les administrateurs lors d'op√©rations massives

```sql
-- Table de notifications
CREATE TABLE alertes_admin (
  id SERIAL PRIMARY KEY,
  message TEXT,
  severite TEXT,
  cree_le TIMESTAMP DEFAULT now()
);

-- Fonction de notification
CREATE OR REPLACE FUNCTION notifier_operation_masse()
RETURNS TRIGGER AS $$
DECLARE
  message_alerte TEXT;
BEGIN
  -- Construire le message d'alerte
  message_alerte := format(
    'Op√©ration %s effectu√©e sur la table %s par %s',
    TG_OP,
    TG_TABLE_NAME,
    current_user
  );

  -- Enregistrer l'alerte
  INSERT INTO alertes_admin (message, severite)
  VALUES (message_alerte, 'INFO');

  -- Notification PostgreSQL (NOTIFY/LISTEN)
  PERFORM pg_notify('operations_masse', message_alerte);

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Trigger sur les tables sensibles
CREATE TRIGGER trigger_alerte_employes
  AFTER UPDATE OR DELETE ON employes
  FOR EACH STATEMENT
  EXECUTE FUNCTION notifier_operation_masse();
```

**Utilisation :**
```sql
-- C√¥t√© application : √©couter les notifications
LISTEN operations_masse;

-- C√¥t√© base : effectuer une op√©ration
UPDATE employes SET salaire = salaire * 1.05;

-- L'application re√ßoit imm√©diatement :
-- "Op√©ration UPDATE effectu√©e sur la table employes par admin"
```

### Exemple 4 : Validation de contrainte globale

**Contexte :** V√©rifier qu'une contrainte m√©tier globale est respect√©e apr√®s une modification

```sql
-- R√®gle m√©tier : Le total des pourcentages de r√©partition doit √©galer 100%
CREATE TABLE repartition_budget (
  departement TEXT PRIMARY KEY,
  pourcentage NUMERIC(5,2) CHECK (pourcentage >= 0 AND pourcentage <= 100)
);

-- Fonction de validation globale
CREATE OR REPLACE FUNCTION valider_total_pourcentage()
RETURNS TRIGGER AS $$
DECLARE
  total_pct NUMERIC;
BEGIN
  -- Calculer le total des pourcentages
  SELECT SUM(pourcentage) INTO total_pct
  FROM repartition_budget;

  -- V√©rifier que le total est 100%
  IF total_pct != 100 THEN
    RAISE EXCEPTION
      'Le total des pourcentages doit √™tre √©gal √† 100%% (actuellement : %%)',
      total_pct
      USING HINT = 'Ajustez les r√©partitions pour atteindre 100%';
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Trigger de validation (AFTER pour avoir les valeurs finales)
CREATE TRIGGER trigger_validation_total
  AFTER INSERT OR UPDATE OR DELETE ON repartition_budget
  FOR EACH STATEMENT
  EXECUTE FUNCTION valider_total_pourcentage();
```

**Sc√©nario d'utilisation :**
```sql
-- ‚úÖ OK : Total = 100%
BEGIN;
  INSERT INTO repartition_budget VALUES ('IT', 40.00);
  INSERT INTO repartition_budget VALUES ('Marketing', 35.00);
  INSERT INTO repartition_budget VALUES ('RH', 25.00);
COMMIT;

-- ‚ùå ERREUR : Total != 100%
BEGIN;
  INSERT INTO repartition_budget VALUES ('IT', 50.00);
  INSERT INTO repartition_budget VALUES ('Marketing', 30.00);
  -- Trigger d√©clench√© : ERREUR car total = 80% seulement
COMMIT;
```

### Exemple 5 : Maintenance automatique apr√®s op√©rations massives

**Contexte :** D√©clencher des t√¢ches de maintenance apr√®s des modifications importantes

```sql
CREATE OR REPLACE FUNCTION maintenance_apres_maj()
RETURNS TRIGGER AS $$
BEGIN
  -- Pour les op√©rations DELETE massives, nettoyer
  IF TG_OP = 'DELETE' THEN
    -- Nettoyer les r√©f√©rences orphelines dans d'autres tables
    DELETE FROM cache_produits
    WHERE produit_id NOT IN (SELECT id FROM produits);

    RAISE NOTICE 'Nettoyage du cache effectu√©';
  END IF;

  -- Pour les UPDATE massifs, mettre √† jour les index
  IF TG_OP = 'UPDATE' THEN
    -- Analyser la table pour mettre √† jour les statistiques
    EXECUTE 'ANALYZE ' || TG_TABLE_NAME;

    RAISE NOTICE 'Statistiques de % mises √† jour', TG_TABLE_NAME;
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_maintenance
  AFTER UPDATE OR DELETE ON produits
  FOR EACH STATEMENT
  EXECUTE FUNCTION maintenance_apres_maj();
```

## Acc√©der aux lignes affect√©es (solution de contournement)

Bien que NEW et OLD ne soient pas directement accessibles, il existe des techniques pour acc√©der aux donn√©es modifi√©es :

### Technique 1 : Tables de transition (PostgreSQL 10+)

PostgreSQL permet de cr√©er des tables temporaires contenant les lignes affect√©es :

```sql
CREATE OR REPLACE FUNCTION analyser_modifications()
RETURNS TRIGGER AS $$
DECLARE
  nb_lignes INTEGER;
BEGIN
  -- Compter les lignes dans la table de transition
  -- 'new_table' contient les nouvelles valeurs (INSERT/UPDATE)
  -- 'old_table' contient les anciennes valeurs (UPDATE/DELETE)

  IF TG_OP = 'INSERT' THEN
    SELECT COUNT(*) INTO nb_lignes FROM new_table;
    RAISE NOTICE '% lignes ins√©r√©es', nb_lignes;

  ELSIF TG_OP = 'UPDATE' THEN
    SELECT COUNT(*) INTO nb_lignes FROM new_table;
    RAISE NOTICE '% lignes mises √† jour', nb_lignes;

  ELSIF TG_OP = 'DELETE' THEN
    SELECT COUNT(*) INTO nb_lignes FROM old_table;
    RAISE NOTICE '% lignes supprim√©es', nb_lignes;
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Cr√©er le trigger avec tables de transition
CREATE TRIGGER trigger_analyse
  AFTER INSERT OR UPDATE OR DELETE ON produits
  REFERENCING
    NEW TABLE AS new_table
    OLD TABLE AS old_table
  FOR EACH STATEMENT
  EXECUTE FUNCTION analyser_modifications();
```

**Exemple avanc√© avec tables de transition :**
```sql
CREATE OR REPLACE FUNCTION auditer_changements_prix()
RETURNS TRIGGER AS $$
DECLARE
  augmentation_moyenne NUMERIC;
  nb_augmentations INTEGER;
BEGIN
  -- Analyser les changements de prix
  SELECT
    AVG(n.prix - o.prix) AS aug_moyenne,
    COUNT(*) AS nb_changes
  INTO
    augmentation_moyenne,
    nb_augmentations
  FROM new_table n
  JOIN old_table o ON n.id = o.id
  WHERE n.prix != o.prix;

  -- Logger si des prix ont chang√©
  IF nb_augmentations > 0 THEN
    INSERT INTO audit_prix (
      nb_produits_modifies,
      augmentation_moyenne,
      date_modification
    ) VALUES (
      nb_augmentations,
      augmentation_moyenne,
      now()
    );

    RAISE NOTICE 'Prix modifi√©s : % produits, augmentation moyenne : %',
      nb_augmentations, augmentation_moyenne;
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_audit_prix
  AFTER UPDATE ON produits
  REFERENCING
    NEW TABLE AS new_table
    OLD TABLE AS old_table
  FOR EACH STATEMENT
  EXECUTE FUNCTION auditer_changements_prix();
```

### Technique 2 : Table temporaire manuelle

Pour les versions ant√©rieures ou des cas sp√©cifiques :

```sql
-- Table temporaire pour stocker les IDs modifi√©s
CREATE TEMPORARY TABLE IF NOT EXISTS temp_ids_modifies (
  id INTEGER
);

-- Trigger ROW pour capturer les IDs
CREATE OR REPLACE FUNCTION capturer_ids()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO temp_ids_modifies VALUES (NEW.id);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger STATEMENT pour traiter en masse
CREATE OR REPLACE FUNCTION traiter_modifications()
RETURNS TRIGGER AS $$
DECLARE
  nb_modifs INTEGER;
BEGIN
  SELECT COUNT(*) INTO nb_modifs FROM temp_ids_modifies;

  RAISE NOTICE '% lignes modifi√©es', nb_modifs;

  -- Nettoyer la table temporaire
  DELETE FROM temp_ids_modifies;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

## FOR EACH ROW vs FOR EACH STATEMENT : Tableau comparatif

| Crit√®re | FOR EACH ROW | FOR EACH STATEMENT |
|---------|--------------|-------------------|
| **Ex√©cutions** | 1 fois par ligne affect√©e | 1 fois par instruction SQL |
| **Acc√®s √† NEW/OLD** | ‚úÖ Oui | ‚ùå Non (sauf via tables de transition) |
| **Modification des donn√©es** | ‚úÖ Possible (BEFORE) | ‚ùå Impossible |
| **Performance (1 ligne)** | Rapide | Tr√®s rapide |
| **Performance (10 000 lignes)** | Lent (10 000 ex√©cutions) | Tr√®s rapide (1 ex√©cution) |
| **Validation par ligne** | ‚úÖ Id√©al | ‚ùå Impossible |
| **Statistiques globales** | ‚ùå Inefficace | ‚úÖ Parfait |
| **Audit d√©taill√©** | ‚úÖ Pr√©cis | ‚ùå Limit√© |
| **Complexit√©** | Moyenne | Faible |

## Quand utiliser FOR EACH STATEMENT ?

### ‚úÖ Cas d'usage recommand√©s

1. **Op√©rations en masse**
   - Import de donn√©es (COPY, INSERT massif)
   - Mises √† jour group√©es (UPDATE avec WHERE large)
   - Suppressions massives

2. **Statistiques et compteurs globaux**
   - Compter le nombre d'op√©rations
   - Suivre la fr√©quence des modifications
   - M√©triques de performance

3. **Notifications d'√©v√©nements**
   - Alerter d'une modification (sans d√©tail par ligne)
   - D√©clencher des processus externes
   - Syst√®me de pub/sub (NOTIFY/LISTEN)

4. **Maintenance et optimisation**
   - Refresh de vues mat√©rialis√©es
   - ANALYZE automatique
   - Nettoyage de tables li√©es

5. **Validation de contraintes globales**
   - V√©rifier des totaux (sommes, pourcentages)
   - Contraintes inter-lignes
   - R√®gles m√©tier globales

6. **Journalisation simplifi√©e**
   - Logger qu'une op√©ration a eu lieu
   - Audit de haut niveau
   - Conformit√© r√©glementaire basique

### ‚ùå Cas o√π FOR EACH STATEMENT n'est PAS adapt√©

1. **Transformation de donn√©es par ligne**
   - Calculer une colonne √† partir d'autres colonnes
   - Normaliser des valeurs individuelles

2. **Validation d√©taill√©e**
   - V√©rifier chaque enregistrement individuellement
   - R√®gles m√©tier sp√©cifiques par ligne

3. **Audit d√©taill√©**
   - Tracer les modifications ligne par ligne
   - Historiser les anciennes et nouvelles valeurs

4. **Synchronisation pr√©cise**
   - R√©plication s√©lective
   - Mise √† jour de tables li√©es bas√©e sur des valeurs sp√©cifiques

## Combinaison de triggers ROW et STATEMENT

Il est possible et parfois utile d'avoir les deux types sur la m√™me table :

```sql
-- Trigger par ligne : validation d√©taill√©e
CREATE OR REPLACE FUNCTION valider_ligne()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.prix < 0 THEN
    RAISE EXCEPTION 'Prix n√©gatif interdit';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_validation_ligne
  BEFORE INSERT OR UPDATE ON produits
  FOR EACH ROW
  EXECUTE FUNCTION valider_ligne();

-- Trigger par instruction : statistiques globales
CREATE OR REPLACE FUNCTION maj_stats_globales()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE stats_globales
  SET derniere_modif_produits = now(),
      nb_operations = nb_operations + 1;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_stats_globales
  AFTER INSERT OR UPDATE ON produits
  FOR EACH STATEMENT
  EXECUTE FUNCTION maj_stats_globales();
```

**Ordre d'ex√©cution :**
1. BEFORE STATEMENT (si existe)
2. BEFORE ROW pour chaque ligne
3. L'op√©ration SQL est effectu√©e
4. AFTER ROW pour chaque ligne
5. AFTER STATEMENT (si existe)

## Bonnes pratiques

### 1. Pr√©f√©rer STATEMENT pour les op√©rations volumineuses

```sql
-- ‚ùå Mauvais : FOR EACH ROW sur table volumineuse
CREATE TRIGGER mauvais_trigger
  AFTER INSERT ON logs  -- Table avec millions de lignes/jour
  FOR EACH ROW
  EXECUTE FUNCTION fonction_lourde();

-- ‚úÖ Bon : FOR EACH STATEMENT
CREATE TRIGGER bon_trigger
  AFTER INSERT ON logs
  FOR EACH STATEMENT
  EXECUTE FUNCTION fonction_legere();
```

### 2. Utiliser STATEMENT pour les refresh de vues mat√©rialis√©es

```sql
-- ‚úÖ Refresh une seule fois apr√®s un batch complet
CREATE TRIGGER refresh_vue
  AFTER INSERT OR UPDATE ON table_source
  FOR EACH STATEMENT
  EXECUTE FUNCTION refresh_materialized_view();
```

### 3. Documenter clairement l'absence de NEW/OLD

```sql
CREATE OR REPLACE FUNCTION ma_fonction()
RETURNS TRIGGER AS $$
/**
 * Trigger de type STATEMENT
 * NOTE : NEW et OLD ne sont PAS disponibles
 * Objectif : Logger les op√©rations en masse sur la table
 */
BEGIN
  -- Logique qui ne n√©cessite pas NEW/OLD
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

### 4. Utiliser les tables de transition quand n√©cessaire

```sql
-- ‚úÖ Acc√©der aux donn√©es via tables de transition
CREATE TRIGGER trigger_avec_donnees
  AFTER UPDATE ON produits
  REFERENCING
    NEW TABLE AS new_table
    OLD TABLE AS old_table
  FOR EACH STATEMENT
  EXECUTE FUNCTION analyser_avec_donnees();
```

### 5. G√©rer proprement les erreurs

```sql
CREATE OR REPLACE FUNCTION fonction_statement()
RETURNS TRIGGER AS $$
BEGIN
  -- Logique m√©tier
  PERFORM ma_logique();

  RETURN NULL;
EXCEPTION
  WHEN OTHERS THEN
    RAISE WARNING 'Erreur dans trigger statement : %', SQLERRM;
    -- D√©cider si on propage l'erreur ou non
    RETURN NULL;  -- Ne pas bloquer l'op√©ration
    -- ou RAISE; pour propager
END;
$$ LANGUAGE plpgsql;
```

## Impact sur les performances : Benchmark

Comparaison sur une table avec 100 000 lignes :

### Test 1 : UPDATE massif

```sql
-- Sc√©nario : Augmenter tous les prix de 10%

-- Avec FOR EACH ROW (trigger simple)
UPDATE produits SET prix = prix * 1.10;
-- Temps : 15.2 secondes (100 000 ex√©cutions du trigger)

-- Avec FOR EACH STATEMENT (trigger simple)
UPDATE produits SET prix = prix * 1.10;
-- Temps : 1.8 secondes (1 seule ex√©cution du trigger)

-- Gain : 8.4√ó plus rapide
```

### Test 2 : INSERT massif

```sql
-- Sc√©nario : Ins√©rer 50 000 lignes

-- Avec FOR EACH ROW
INSERT INTO produits SELECT * FROM produits_import;
-- Temps : 8.5 secondes

-- Avec FOR EACH STATEMENT
INSERT INTO produits SELECT * FROM produits_import;
-- Temps : 0.9 secondes

-- Gain : 9.4√ó plus rapide
```

### Recommandations de performance

| Nombre de lignes | Recommandation |
|------------------|----------------|
| < 10 lignes | FOR EACH ROW acceptable |
| 10-100 lignes | √âvaluer cas par cas |
| 100-1000 lignes | Pr√©f√©rer FOR EACH STATEMENT si possible |
| > 1000 lignes | Imp√©ratif FOR EACH STATEMENT |

## Debugging et monitoring

### Afficher des informations de debug

```sql
CREATE OR REPLACE FUNCTION debug_statement()
RETURNS TRIGGER AS $$
BEGIN
  RAISE NOTICE '=== Trigger Statement D√©clench√© ===';
  RAISE NOTICE 'Table: %', TG_TABLE_NAME;
  RAISE NOTICE 'Sch√©ma: %', TG_TABLE_SCHEMA;
  RAISE NOTICE 'Op√©ration: %', TG_OP;
  RAISE NOTICE 'Moment: %', TG_WHEN;
  RAISE NOTICE 'Niveau: %', TG_LEVEL;
  RAISE NOTICE 'Utilisateur: %', current_user;
  RAISE NOTICE '====================================';

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

### Mesurer le temps d'ex√©cution

```sql
CREATE OR REPLACE FUNCTION mesurer_temps_statement()
RETURNS TRIGGER AS $$
DECLARE
  debut TIMESTAMP;
  fin TIMESTAMP;
  duree INTERVAL;
BEGIN
  debut := clock_timestamp();

  -- Votre logique ici
  PERFORM pg_sleep(0.1);  -- Simuler un traitement

  fin := clock_timestamp();
  duree := fin - debut;

  RAISE NOTICE 'Dur√©e du trigger: %', duree;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

### Lister les triggers statement d'une table

```sql
SELECT
  tgname AS nom_trigger,
  tgtype & 1 = 1 AS is_row_trigger,
  CASE
    WHEN tgtype & 2 = 2 THEN 'BEFORE'
    ELSE 'AFTER'
  END AS timing,
  pg_get_triggerdef(oid) AS definition
FROM pg_trigger
WHERE tgrelid = 'ma_table'::regclass
  AND tgisinternal = false
  AND tgtype & 1 = 0  -- 0 = STATEMENT, 1 = ROW
ORDER BY tgname;
```

## Cas d'usage avanc√©s

### 1. Rate Limiting

Limiter la fr√©quence des op√©rations :

```sql
CREATE TABLE derniere_operation (
  table_name TEXT PRIMARY KEY,
  derniere_exec TIMESTAMP
);

CREATE OR REPLACE FUNCTION limiter_frequence()
RETURNS TRIGGER AS $$
DECLARE
  derniere TIMESTAMP;
  delai_minimum INTERVAL := '1 minute';
BEGIN
  SELECT derniere_exec INTO derniere
  FROM derniere_operation
  WHERE table_name = TG_TABLE_NAME;

  IF derniere IS NOT NULL AND (now() - derniere) < delai_minimum THEN
    RAISE EXCEPTION
      'Op√©ration trop fr√©quente. Veuillez attendre % secondes',
      EXTRACT(EPOCH FROM (delai_minimum - (now() - derniere)));
  END IF;

  INSERT INTO derniere_operation (table_name, derniere_exec)
  VALUES (TG_TABLE_NAME, now())
  ON CONFLICT (table_name)
  DO UPDATE SET derniere_exec = now();

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_rate_limit
  BEFORE UPDATE OR DELETE ON donnees_critiques
  FOR EACH STATEMENT
  EXECUTE FUNCTION limiter_frequence();
```

### 2. Circuit Breaker Pattern

D√©sactiver temporairement des op√©rations si trop d'erreurs :

```sql
CREATE TABLE circuit_breaker (
  table_name TEXT PRIMARY KEY,
  nb_erreurs INTEGER DEFAULT 0,
  etat TEXT DEFAULT 'FERME',  -- FERME, OUVERT, SEMI_OUVERT
  derniere_erreur TIMESTAMP
);

CREATE OR REPLACE FUNCTION verifier_circuit()
RETURNS TRIGGER AS $$
DECLARE
  etat_circuit TEXT;
  nb_err INTEGER;
BEGIN
  SELECT etat, nb_erreurs INTO etat_circuit, nb_err
  FROM circuit_breaker
  WHERE table_name = TG_TABLE_NAME;

  IF etat_circuit = 'OUVERT' THEN
    RAISE EXCEPTION 'Circuit breaker OUVERT : op√©rations suspendues sur %',
      TG_TABLE_NAME;
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

### 3. Webhook d√©clench√© par op√©ration

```sql
CREATE OR REPLACE FUNCTION notifier_webhook()
RETURNS TRIGGER AS $$
DECLARE
  payload JSONB;
BEGIN
  payload := jsonb_build_object(
    'table', TG_TABLE_NAME,
    'operation', TG_OP,
    'timestamp', now(),
    'user', current_user
  );

  -- Utiliser pg_notify pour un worker externe
  PERFORM pg_notify('webhook_channel', payload::text);

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_webhook
  AFTER INSERT OR UPDATE OR DELETE ON commandes
  FOR EACH STATEMENT
  EXECUTE FUNCTION notifier_webhook();
```

## R√©sum√© des points cl√©s

### Caract√©ristiques essentielles

‚úÖ **FOR EACH STATEMENT** s'ex√©cute **une seule fois** par instruction SQL

‚úÖ **Pas d'acc√®s √† NEW/OLD** (sauf via tables de transition)

‚úÖ **Performance optimale** pour les op√©rations en masse

‚úÖ **Id√©al pour les statistiques** et compteurs globaux

‚úÖ **Parfait pour les notifications** d'√©v√©nements

### Quand utiliser STATEMENT vs ROW ?

| Besoin | Utiliser |
|--------|----------|
| Valider/modifier chaque ligne | FOR EACH ROW |
| Compteur d'op√©rations | FOR EACH STATEMENT |
| Audit d√©taill√© (anciennes/nouvelles valeurs) | FOR EACH ROW |
| Refresh vue mat√©rialis√©e | FOR EACH STATEMENT |
| Calculs par ligne | FOR EACH ROW |
| Notification simple | FOR EACH STATEMENT |
| Op√©ration en masse (>1000 lignes) | FOR EACH STATEMENT |
| R√®gle m√©tier par enregistrement | FOR EACH ROW |

### Points d'attention

‚ö†Ô∏è Impossible de modifier les donn√©es avec STATEMENT

‚ö†Ô∏è Pas de NEW/OLD sans tables de transition

‚ö†Ô∏è N√©cessite PostgreSQL 10+ pour tables de transition

‚ö†Ô∏è Toujours retourner NULL par convention

## Conclusion

Les triggers par instruction (**FOR EACH STATEMENT**) sont un outil puissant pour les op√©rations qui concernent l'ensemble d'une modification plut√¥t que chaque ligne individuellement. Leur principal avantage est la **performance** sur les op√©rations volumineuses, en s'ex√©cutant une seule fois au lieu de milliers de fois.

**Principe directeur :** Utilisez FOR EACH STATEMENT quand vous vous souciez du **fait** qu'une op√©ration a eu lieu, et FOR EACH ROW quand vous avez besoin du **d√©tail** de chaque modification.

Les deux types de triggers sont compl√©mentaires et peuvent coexister sur la m√™me table pour r√©pondre √† des besoins diff√©rents.

---

**üìö Pour aller plus loin :**
- Section 15.4.1 : Triggers par ligne (FOR EACH ROW)
- Section 15.4.3 : Variables sp√©ciales (NEW, OLD, TG_OP)
- Section 15.5 : Event Triggers
- Documentation officielle PostgreSQL sur les triggers Statement

‚è≠Ô∏è [Variables sp√©ciales (NEW, OLD, TG_OP)](/15-programmation-serveur/04.3-variables-speciales.md)
