üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.4.1. Triggers par ligne (FOR EACH ROW)

## Introduction

Les **triggers par ligne** (ou *row-level triggers*) sont des d√©clencheurs qui s'ex√©cutent **une fois pour chaque ligne affect√©e** par une op√©ration DML (INSERT, UPDATE ou DELETE). C'est le type de trigger le plus couramment utilis√© en PostgreSQL car il permet d'intervenir au niveau granulaire de chaque enregistrement modifi√©.

### Analogie pour comprendre

Imaginez un syst√®me de s√©curit√© dans un magasin :
- Un **trigger par instruction** serait comme un gardien qui v√©rifie qu'un groupe de personnes peut entrer (une seule v√©rification pour tout le groupe)
- Un **trigger par ligne** serait comme un portique de s√©curit√© qui v√©rifie chaque personne individuellement au passage

## Syntaxe de base

```sql
CREATE TRIGGER nom_du_trigger
  { BEFORE | AFTER } { INSERT | UPDATE | DELETE }
  ON nom_table
  FOR EACH ROW
  EXECUTE FUNCTION nom_fonction_trigger();
```

### D√©composition de la syntaxe

1. **`CREATE TRIGGER nom_du_trigger`** : D√©finit le nom unique du trigger
2. **`BEFORE | AFTER`** : D√©termine quand le trigger s'ex√©cute
   - `BEFORE` : Avant que la modification soit effectu√©e dans la table
   - `AFTER` : Apr√®s que la modification a √©t√© appliqu√©e
3. **`INSERT | UPDATE | DELETE`** : L'op√©ration qui d√©clenche le trigger
4. **`ON nom_table`** : La table sur laquelle le trigger est attach√©
5. **`FOR EACH ROW`** : **C'est la clause qui d√©finit un trigger par ligne**
6. **`EXECUTE FUNCTION nom_fonction_trigger()`** : La fonction PL/pgSQL √† ex√©cuter

## Les variables sp√©ciales NEW et OLD

Dans un trigger par ligne, PostgreSQL met √† disposition deux variables sp√©ciales qui repr√©sentent l'√©tat de la ligne :

### Variable NEW

- **Contient** : Les **nouvelles valeurs** de la ligne
- **Disponible pour** : `INSERT` et `UPDATE`
- **Utilisation** : Acc√©der ou modifier les donn√©es qui vont √™tre ins√©r√©es/mises √† jour
- **Exemple** : `NEW.prix`, `NEW.nom_client`

### Variable OLD

- **Contient** : Les **anciennes valeurs** de la ligne (avant modification)
- **Disponible pour** : `UPDATE` et `DELETE`
- **Utilisation** : Consulter les valeurs originales avant la modification
- **Exemple** : `OLD.prix`, `OLD.nom_client`

### Tableau r√©capitulatif

| Op√©ration | NEW disponible ? | OLD disponible ? |
|-----------|------------------|------------------|
| INSERT    | ‚úÖ Oui           | ‚ùå Non           |
| UPDATE    | ‚úÖ Oui           | ‚úÖ Oui           |
| DELETE    | ‚ùå Non           | ‚úÖ Oui           |

## BEFORE vs AFTER : Quand utiliser quoi ?

### BEFORE Triggers

**Caract√©ristiques :**
- S'ex√©cutent **avant** que la modification soit √©crite dans la table
- Peuvent **modifier les valeurs** de NEW avant l'insertion/mise √† jour
- Peuvent **annuler l'op√©ration** en retournant NULL

**Cas d'usage typiques :**
1. **Validation avanc√©e** : V√©rifier des r√®gles m√©tier complexes
2. **Transformation de donn√©es** : Normaliser, nettoyer ou calculer des valeurs
3. **Valeurs par d√©faut dynamiques** : Calculer des valeurs automatiques
4. **Pr√©vention d'op√©rations** : Bloquer certaines modifications

**Exemple conceptuel :**
```sql
-- Fonction qui normalise un email en minuscules avant insertion
CREATE OR REPLACE FUNCTION normaliser_email()
RETURNS TRIGGER AS $$
BEGIN
  -- Transformer l'email en minuscules
  NEW.email := LOWER(NEW.email);

  -- Retourner la ligne modifi√©e
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_normaliser_email
  BEFORE INSERT OR UPDATE ON utilisateurs
  FOR EACH ROW
  EXECUTE FUNCTION normaliser_email();
```

**Explication :** Avant chaque insertion ou mise √† jour, l'email est automatiquement converti en minuscules. La valeur modifi√©e est ensuite ins√©r√©e dans la table.

### AFTER Triggers

**Caract√©ristiques :**
- S'ex√©cutent **apr√®s** que la modification a √©t√© appliqu√©e
- **Ne peuvent pas modifier** les valeurs de NEW (trop tard)
- Peuvent effectuer des actions sur **d'autres tables**
- Utiles pour la **journalisation** et les **effets de bord**

**Cas d'usage typiques :**
1. **Audit et historisation** : Enregistrer les modifications dans une table d'audit
2. **Synchronisation** : Mettre √† jour des tables li√©es
3. **Notifications** : D√©clencher des alertes ou des √©v√©nements
4. **Statistiques** : Mettre √† jour des compteurs ou agr√©gations

**Exemple conceptuel :**
```sql
-- Fonction qui enregistre toute modification dans une table d'audit
CREATE OR REPLACE FUNCTION auditer_modifications()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO audit_log (
    table_name,
    operation,
    user_name,
    timestamp,
    old_data,
    new_data
  ) VALUES (
    TG_TABLE_NAME,
    TG_OP,
    current_user,
    now(),
    row_to_json(OLD),
    row_to_json(NEW)
  );

  RETURN NEW; -- ou OLD pour DELETE
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_audit
  AFTER INSERT OR UPDATE OR DELETE ON produits
  FOR EACH ROW
  EXECUTE FUNCTION auditer_modifications();
```

**Explication :** Apr√®s chaque modification sur la table `produits`, une entr√©e est automatiquement cr√©√©e dans `audit_log` avec les anciennes et nouvelles valeurs.

## Valeurs de retour et leur signification

Dans une fonction trigger `FOR EACH ROW`, la valeur de retour est **cruciale** :

### Pour BEFORE Triggers

| Retour | Signification | Utilisation |
|--------|---------------|-------------|
| `NEW` | Continuer avec les valeurs (potentiellement modifi√©es) | Valider et/ou transformer les donn√©es |
| `OLD` | Utiliser les anciennes valeurs (rare) | Annuler les modifications propos√©es |
| `NULL` | **Annuler compl√®tement l'op√©ration** | Bloquer l'INSERT/UPDATE/DELETE |

**Exemple - Bloquer une op√©ration :**
```sql
CREATE OR REPLACE FUNCTION interdire_suppression_admin()
RETURNS TRIGGER AS $$
BEGIN
  IF OLD.role = 'admin' THEN
    RAISE EXCEPTION 'Impossible de supprimer un administrateur';
    -- Alternative : RETURN NULL; (annule silencieusement)
  END IF;

  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_protection_admin
  BEFORE DELETE ON utilisateurs
  FOR EACH ROW
  EXECUTE FUNCTION interdire_suppression_admin();
```

### Pour AFTER Triggers

La valeur de retour est **ignor√©e** (mais par convention on retourne NEW ou OLD).

```sql
-- La valeur de retour n'a pas d'impact sur l'op√©ration
RETURN NULL;  -- Acceptable mais d√©conseill√©
RETURN NEW;   -- Convention pour INSERT/UPDATE
RETURN OLD;   -- Convention pour DELETE
```

## Exemples pratiques d√©taill√©s

### Exemple 1 : Calculer automatiquement une colonne

**Contexte :** Une table de commandes o√π le montant total doit √™tre calcul√© automatiquement.

```sql
-- Cr√©ation de la table
CREATE TABLE commandes (
  id SERIAL PRIMARY KEY,
  produit TEXT NOT NULL,
  quantite INTEGER NOT NULL,
  prix_unitaire NUMERIC(10,2) NOT NULL,
  montant_total NUMERIC(10,2)  -- Sera calcul√© automatiquement
);

-- Fonction trigger
CREATE OR REPLACE FUNCTION calculer_montant_total()
RETURNS TRIGGER AS $$
BEGIN
  -- Calculer le montant total avant insertion/mise √† jour
  NEW.montant_total := NEW.quantite * NEW.prix_unitaire;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Cr√©ation du trigger
CREATE TRIGGER trigger_calcul_montant
  BEFORE INSERT OR UPDATE ON commandes
  FOR EACH ROW
  EXECUTE FUNCTION calculer_montant_total();
```

**Sc√©nario d'utilisation :**
```sql
-- L'utilisateur n'a pas besoin de calculer le montant
INSERT INTO commandes (produit, quantite, prix_unitaire)
VALUES ('Ordinateur', 2, 999.99);

-- Le trigger calcule automatiquement : montant_total = 1999.98
```

### Exemple 2 : Horodatage automatique

**Contexte :** Enregistrer automatiquement la date de cr√©ation et de derni√®re modification.

```sql
-- Table avec colonnes d'horodatage
CREATE TABLE articles (
  id SERIAL PRIMARY KEY,
  titre TEXT NOT NULL,
  contenu TEXT,
  cree_le TIMESTAMP,
  modifie_le TIMESTAMP
);

-- Fonction pour g√©rer les timestamps
CREATE OR REPLACE FUNCTION gerer_timestamps()
RETURNS TRIGGER AS $$
BEGIN
  -- Pour les insertions
  IF TG_OP = 'INSERT' THEN
    NEW.cree_le := now();
    NEW.modifie_le := now();

  -- Pour les mises √† jour
  ELSIF TG_OP = 'UPDATE' THEN
    NEW.cree_le := OLD.cree_le;  -- Pr√©server la date de cr√©ation
    NEW.modifie_le := now();      -- Mettre √† jour la date de modification
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger
CREATE TRIGGER trigger_timestamps
  BEFORE INSERT OR UPDATE ON articles
  FOR EACH ROW
  EXECUTE FUNCTION gerer_timestamps();
```

### Exemple 3 : Validation m√©tier avanc√©e

**Contexte :** Emp√™cher qu'un employ√© ait un salaire sup√©rieur √† son manager.

```sql
CREATE TABLE employes (
  id SERIAL PRIMARY KEY,
  nom TEXT NOT NULL,
  salaire NUMERIC(10,2),
  manager_id INTEGER REFERENCES employes(id)
);

CREATE OR REPLACE FUNCTION verifier_salaire()
RETURNS TRIGGER AS $$
DECLARE
  salaire_manager NUMERIC(10,2);
BEGIN
  -- Si l'employ√© a un manager
  IF NEW.manager_id IS NOT NULL THEN
    -- R√©cup√©rer le salaire du manager
    SELECT salaire INTO salaire_manager
    FROM employes
    WHERE id = NEW.manager_id;

    -- V√©rifier que le salaire est coh√©rent
    IF NEW.salaire > salaire_manager THEN
      RAISE EXCEPTION
        'Le salaire (%) ne peut pas d√©passer celui du manager (%)',
        NEW.salaire, salaire_manager;
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_validation_salaire
  BEFORE INSERT OR UPDATE ON employes
  FOR EACH ROW
  EXECUTE FUNCTION verifier_salaire();
```

### Exemple 4 : Historisation compl√®te

**Contexte :** Conserver l'historique de toutes les modifications dans une table d√©di√©e.

```sql
-- Table principale
CREATE TABLE clients (
  id SERIAL PRIMARY KEY,
  nom TEXT NOT NULL,
  email TEXT UNIQUE,
  telephone TEXT,
  statut TEXT DEFAULT 'actif'
);

-- Table d'historique
CREATE TABLE clients_historique (
  id SERIAL PRIMARY KEY,
  client_id INTEGER NOT NULL,
  operation TEXT NOT NULL,  -- 'INSERT', 'UPDATE', 'DELETE'
  ancienne_ligne JSONB,
  nouvelle_ligne JSONB,
  modifie_par TEXT DEFAULT current_user,
  modifie_le TIMESTAMP DEFAULT now()
);

-- Fonction d'historisation
CREATE OR REPLACE FUNCTION historiser_client()
RETURNS TRIGGER AS $$
BEGIN
  -- Selon l'op√©ration, enregistrer diff√©remment
  IF TG_OP = 'INSERT' THEN
    INSERT INTO clients_historique (
      client_id, operation, nouvelle_ligne
    ) VALUES (
      NEW.id, 'INSERT', row_to_json(NEW)::jsonb
    );
    RETURN NEW;

  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO clients_historique (
      client_id, operation, ancienne_ligne, nouvelle_ligne
    ) VALUES (
      NEW.id, 'UPDATE',
      row_to_json(OLD)::jsonb,
      row_to_json(NEW)::jsonb
    );
    RETURN NEW;

  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO clients_historique (
      client_id, operation, ancienne_ligne
    ) VALUES (
      OLD.id, 'DELETE', row_to_json(OLD)::jsonb
    );
    RETURN OLD;
  END IF;
END;
$$ LANGUAGE plpgsql;

-- Trigger apr√®s modification (pour avoir l'ID g√©n√©r√©)
CREATE TRIGGER trigger_historique_client
  AFTER INSERT OR UPDATE OR DELETE ON clients
  FOR EACH ROW
  EXECUTE FUNCTION historiser_client();
```

**Utilit√© :** Permet de consulter l'historique complet des modifications :
```sql
-- Voir l'historique d'un client
SELECT
  operation,
  ancienne_ligne->>'nom' as ancien_nom,
  nouvelle_ligne->>'nom' as nouveau_nom,
  modifie_le
FROM clients_historique
WHERE client_id = 123
ORDER BY modifie_le DESC;
```

## Variables sp√©ciales du contexte trigger

En plus de NEW et OLD, PostgreSQL fournit des variables contextuelles utiles :

### TG_OP
Type d'op√©ration en cours : 'INSERT', 'UPDATE' ou 'DELETE'

```sql
IF TG_OP = 'DELETE' THEN
  -- Traitement sp√©cifique pour les suppressions
END IF;
```

### TG_TABLE_NAME
Nom de la table d√©clenchant le trigger

```sql
RAISE NOTICE 'Modification sur la table %', TG_TABLE_NAME;
```

### TG_WHEN
Moment du trigger : 'BEFORE' ou 'AFTER'

```sql
IF TG_WHEN = 'BEFORE' THEN
  -- Logique sp√©cifique aux triggers BEFORE
END IF;
```

### TG_LEVEL
Niveau du trigger : 'ROW' ou 'STATEMENT'

```sql
IF TG_LEVEL = 'ROW' THEN
  RAISE NOTICE 'Trigger par ligne en cours';
END IF;
```

## Bonnes pratiques et recommandations

### 1. Garder les triggers simples et rapides

‚ùå **√Ä √©viter :**
```sql
CREATE OR REPLACE FUNCTION trigger_lourd()
RETURNS TRIGGER AS $$
BEGIN
  -- Calculs complexes et longs
  PERFORM calcul_tres_long();

  -- Appels externes
  PERFORM appel_api_externe();

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

‚úÖ **Pr√©f√©rer :**
```sql
CREATE OR REPLACE FUNCTION trigger_leger()
RETURNS TRIGGER AS $$
BEGIN
  -- Op√©rations simples et rapides
  NEW.derniere_modif := now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

**Raison :** Les triggers sont ex√©cut√©s dans la transaction, donc des triggers lents ralentissent toutes les op√©rations.

### 2. √âviter les modifications en cascade incontr√¥l√©es

‚ö†Ô∏è **Attention aux boucles infinies :**
```sql
-- DANGER : Risque de boucle infinie si mal g√©r√©
CREATE TRIGGER trigger_A
  AFTER UPDATE ON table_A
  FOR EACH ROW
  EXECUTE FUNCTION modifier_table_B();

CREATE TRIGGER trigger_B
  AFTER UPDATE ON table_B
  FOR EACH ROW
  EXECUTE FUNCTION modifier_table_A();
```

**Solution :** Utiliser des conditions ou d√©sactiver temporairement les triggers.

### 3. Utiliser BEFORE pour la validation

```sql
-- ‚úÖ Bon usage de BEFORE pour validation
CREATE OR REPLACE FUNCTION valider_email()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.email !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' THEN
    RAISE EXCEPTION 'Email invalide : %', NEW.email;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### 4. Documenter les triggers

```sql
-- ‚úÖ Toujours commenter l'objectif du trigger
CREATE OR REPLACE FUNCTION mettre_a_jour_stock()
RETURNS TRIGGER AS $$
/**
 * Trigger : Mise √† jour automatique du stock
 * D√©clench√© par : INSERT, UPDATE sur commandes
 * Action : D√©cr√©mente le stock du produit command√©
 * Auteur : Jean Dupont
 * Date : 2025-11-22
 */
BEGIN
  UPDATE produits
  SET stock = stock - NEW.quantite
  WHERE id = NEW.produit_id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### 5. G√©rer les erreurs proprement

```sql
CREATE OR REPLACE FUNCTION trigger_avec_gestion_erreur()
RETURNS TRIGGER AS $$
BEGIN
  -- Validation avec message clair
  IF NEW.age < 0 THEN
    RAISE EXCEPTION 'L''√¢ge ne peut pas √™tre n√©gatif : %', NEW.age
      USING HINT = 'V√©rifiez la saisie des donn√©es';
  END IF;

  IF NEW.age > 150 THEN
    RAISE WARNING '√Çge suspect : %', NEW.age;
  END IF;

  RETURN NEW;
EXCEPTION
  WHEN OTHERS THEN
    RAISE NOTICE 'Erreur dans le trigger : %', SQLERRM;
    RETURN NULL;  -- Annuler l'op√©ration en cas d'erreur
END;
$$ LANGUAGE plpgsql;
```

## Impact sur les performances

### Consid√©rations importantes

1. **Triggers par ligne et volume**
   - Un trigger `FOR EACH ROW` sur un `UPDATE` de 10 000 lignes s'ex√©cute **10 000 fois**
   - Peut ralentir consid√©rablement les op√©rations en masse

2. **Accumulation de triggers**
   - Plusieurs triggers sur la m√™me table s'ex√©cutent s√©quentiellement
   - Ordre d'ex√©cution : alphab√©tique par nom de trigger (si m√™me timing)

3. **Alternative pour le volume : Statement triggers**
   - Pour des op√©rations en masse, envisager `FOR EACH STATEMENT`
   - S'ex√©cute une seule fois pour toute l'op√©ration

### Exemple de monitoring

```sql
-- Mesurer l'impact d'un trigger
\timing on

-- Insertion sans trigger
INSERT INTO table_test SELECT generate_series(1, 10000);
-- Temps : 150ms

-- M√™me insertion avec trigger simple
-- Temps : 450ms  (3√ó plus lent)

-- Avec trigger complexe
-- Temps : 2500ms  (16√ó plus lent)
```

## D√©sactivation temporaire de triggers

Dans certains cas (imports massifs, migrations), il peut √™tre utile de d√©sactiver temporairement les triggers :

```sql
-- D√©sactiver tous les triggers d'une table
ALTER TABLE ma_table DISABLE TRIGGER ALL;

-- Import massif de donn√©es
COPY ma_table FROM '/chemin/vers/fichier.csv';

-- R√©activer les triggers
ALTER TABLE ma_table ENABLE TRIGGER ALL;
```

‚ö†Ô∏è **Attention :** N√©cessite des privil√®ges superutilisateur dans la plupart des cas.

## Debugging et troubleshooting

### Afficher des messages de debug

```sql
CREATE OR REPLACE FUNCTION trigger_debug()
RETURNS TRIGGER AS $$
BEGIN
  RAISE NOTICE 'Trigger d√©clench√© : %', TG_OP;
  RAISE NOTICE 'Table : %', TG_TABLE_NAME;
  RAISE NOTICE 'OLD : %', OLD;
  RAISE NOTICE 'NEW : %', NEW;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### Lister les triggers d'une table

```sql
SELECT
  tgname AS nom_trigger,
  pg_get_triggerdef(oid) AS definition
FROM pg_trigger
WHERE tgrelid = 'ma_table'::regclass
AND tgisinternal = false;
```

### D√©sactiver un trigger sp√©cifique

```sql
-- D√©sactiver temporairement
ALTER TABLE ma_table DISABLE TRIGGER nom_du_trigger;

-- Supprimer d√©finitivement
DROP TRIGGER nom_du_trigger ON ma_table;
```

## Cas d'usage avanc√©s

### 1. Soft Delete (suppression logique)

Au lieu de supprimer physiquement, marquer comme supprim√© :

```sql
CREATE OR REPLACE FUNCTION soft_delete()
RETURNS TRIGGER AS $$
BEGIN
  -- Au lieu de supprimer, marquer comme supprim√©
  IF TG_OP = 'DELETE' THEN
    UPDATE employes
    SET
      supprime = true,
      supprime_le = now(),
      supprime_par = current_user
    WHERE id = OLD.id;

    -- Emp√™cher la suppression r√©elle
    RETURN NULL;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_soft_delete
  BEFORE DELETE ON employes
  FOR EACH ROW
  EXECUTE FUNCTION soft_delete();
```

### 2. Versionning optimiste

D√©tecter les modifications concurrentes :

```sql
CREATE OR REPLACE FUNCTION gerer_version()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'UPDATE' THEN
    -- V√©rifier que la version n'a pas chang√©
    IF OLD.version != NEW.version THEN
      RAISE EXCEPTION 'Conflit de version d√©tect√©';
    END IF;

    -- Incr√©menter la version
    NEW.version := OLD.version + 1;
  ELSIF TG_OP = 'INSERT' THEN
    NEW.version := 1;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### 3. Mise √† jour de d√©normalisation

Maintenir des donn√©es d√©normalis√©es √† jour :

```sql
-- Mettre √† jour le nombre de commandes d'un client
CREATE OR REPLACE FUNCTION maj_nb_commandes()
RETURNS TRIGGER AS $$
DECLARE
  client_id_cible INTEGER;
BEGIN
  -- D√©terminer quel client est affect√©
  IF TG_OP = 'DELETE' THEN
    client_id_cible := OLD.client_id;
  ELSE
    client_id_cible := NEW.client_id;
  END IF;

  -- Recalculer le compteur
  UPDATE clients
  SET nb_commandes = (
    SELECT COUNT(*)
    FROM commandes
    WHERE client_id = client_id_cible
  )
  WHERE id = client_id_cible;

  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  ELSE
    RETURN NEW;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_maj_compteur
  AFTER INSERT OR UPDATE OR DELETE ON commandes
  FOR EACH ROW
  EXECUTE FUNCTION maj_nb_commandes();
```

## R√©sum√© des points cl√©s

### Caract√©ristiques essentielles

‚úÖ **FOR EACH ROW** s'ex√©cute **une fois par ligne affect√©e**

‚úÖ **BEFORE** permet de **modifier ou bloquer** l'op√©ration

‚úÖ **AFTER** est id√©al pour **l'audit et les effets de bord**

‚úÖ **NEW** contient les nouvelles valeurs (INSERT, UPDATE)

‚úÖ **OLD** contient les anciennes valeurs (UPDATE, DELETE)

‚úÖ La **valeur de retour** est importante dans les BEFORE triggers

### Quand utiliser les triggers par ligne ?

| Cas d'usage | Recommandation |
|-------------|----------------|
| Validation m√©tier complexe | ‚úÖ BEFORE trigger |
| Calculs automatiques | ‚úÖ BEFORE trigger |
| Audit/historisation | ‚úÖ AFTER trigger |
| Synchronisation de tables | ‚úÖ AFTER trigger |
| Traitement en masse | ‚ö†Ô∏è Envisager FOR EACH STATEMENT |
| Op√©rations lourdes | ‚ùå √âviter, privil√©gier des jobs asynchrones |

### Pi√®ges √† √©viter

‚ùå Triggers trop complexes ou lents

‚ùå Modifications en cascade cr√©ant des boucles

‚ùå Manque de gestion d'erreurs

‚ùå Absence de documentation

‚ùå Oublier l'impact sur les performances

## Conclusion

Les triggers par ligne (`FOR EACH ROW`) sont un outil puissant pour automatiser la logique m√©tier au niveau de la base de donn√©es. Leur granularit√© permet un contr√¥le pr√©cis sur chaque modification, mais n√©cessite une attention particuli√®re aux performances et √† la complexit√©.

**Principe directeur :** Un bon trigger est simple, rapide, document√© et r√©pond √† un besoin m√©tier clairement identifi√©.

Dans la prochaine section, nous verrons les **triggers par instruction (FOR EACH STATEMENT)**, qui s'ex√©cutent une seule fois par op√©ration, quel que soit le nombre de lignes affect√©es.

---

**üìö Pour aller plus loin :**
- Section 15.4.2 : Triggers par instruction (FOR EACH STATEMENT)
- Section 15.5 : Event Triggers
- Documentation officielle PostgreSQL sur les triggers

‚è≠Ô∏è [Triggers par instruction (FOR EACH STATEMENT)](/15-programmation-serveur/04.2-triggers-par-instruction.md)
