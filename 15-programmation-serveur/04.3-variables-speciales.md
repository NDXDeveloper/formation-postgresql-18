üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.4.3. Variables sp√©ciales (NEW, OLD, TG_OP)

## Introduction

Lorsqu'un trigger s'ex√©cute dans PostgreSQL, le syst√®me met automatiquement √† disposition un ensemble de **variables sp√©ciales** qui fournissent des informations contextuelles sur l'√©v√©nement en cours. Ces variables sont essentielles pour √©crire des triggers intelligents et r√©actifs.

### Analogie pour comprendre

Imaginez que vous √™tes un gardien de mus√©e (le trigger) :
- **NEW** : La nouvelle ≈ìuvre qui arrive dans la salle
- **OLD** : L'ancienne ≈ìuvre qui √©tait l√† avant
- **TG_OP** : Le type d'op√©ration (ajout, remplacement, retrait)
- **TG_TABLE_NAME** : Le nom de la salle concern√©e
- **TG_WHEN** : Le moment o√π vous intervenez (avant ou apr√®s l'op√©ration)

Ces informations vous permettent de r√©agir de mani√®re appropri√©e selon le contexte.

## Les deux grandes cat√©gories de variables

PostgreSQL fournit deux types de variables sp√©ciales :

### 1. Variables de donn√©es (NEW et OLD)
Contiennent les **valeurs des lignes** affect√©es par l'op√©ration.

### 2. Variables contextuelles (TG_*)
Fournissent des **m√©tadonn√©es** sur le trigger et l'op√©ration en cours.

---

## Variables de donn√©es : NEW et OLD

### NEW : Les nouvelles valeurs

**D√©finition :** NEW est une variable de type RECORD qui contient les **nouvelles valeurs** d'une ligne.

#### Disponibilit√© de NEW

| Op√©ration | NEW disponible ? | Contenu de NEW |
|-----------|------------------|----------------|
| INSERT | ‚úÖ Oui | La ligne √† ins√©rer |
| UPDATE | ‚úÖ Oui | La ligne apr√®s modification |
| DELETE | ‚ùå Non | N/A |

#### Utilisation de NEW

NEW s'utilise comme un enregistrement avec des champs accessibles par notation point√©e :

```sql
-- Acc√©der aux champs de NEW
NEW.nom_colonne
NEW.id
NEW.email
NEW.prix
```

### OLD : Les anciennes valeurs

**D√©finition :** OLD est une variable de type RECORD qui contient les **anciennes valeurs** d'une ligne (avant modification).

#### Disponibilit√© de OLD

| Op√©ration | OLD disponible ? | Contenu de OLD |
|-----------|------------------|----------------|
| INSERT | ‚ùå Non | N/A |
| UPDATE | ‚úÖ Oui | La ligne avant modification |
| DELETE | ‚úÖ Oui | La ligne √† supprimer |

#### Utilisation de OLD

```sql
-- Acc√©der aux champs de OLD
OLD.nom_colonne
OLD.id
OLD.prix
OLD.statut
```

### Tableau r√©capitulatif NEW vs OLD

| Op√©ration | NEW | OLD | Cas d'usage typique |
|-----------|-----|-----|---------------------|
| **INSERT** | ‚úÖ Nouvelles donn√©es | ‚ùå N/A | Valider/transformer avant insertion |
| **UPDATE** | ‚úÖ Valeurs apr√®s modif | ‚úÖ Valeurs avant modif | Comparer ancien/nouveau, historiser |
| **DELETE** | ‚ùå N/A | ‚úÖ Donn√©es supprim√©es | Archiver avant suppression |

### Exemples pratiques avec NEW et OLD

#### Exemple 1 : Modifier NEW dans un trigger BEFORE INSERT

```sql
CREATE TABLE utilisateurs (
  id SERIAL PRIMARY KEY,
  nom TEXT,
  email TEXT,
  date_inscription TIMESTAMP
);

CREATE OR REPLACE FUNCTION normaliser_utilisateur()
RETURNS TRIGGER AS $$
BEGIN
  -- Acc√©der et modifier NEW
  NEW.email := LOWER(TRIM(NEW.email));  -- Email en minuscules sans espaces
  NEW.nom := INITCAP(TRIM(NEW.nom));     -- Premi√®re lettre en majuscule
  NEW.date_inscription := now();         -- Date automatique

  -- Retourner NEW modifi√©
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_normalisation
  BEFORE INSERT ON utilisateurs
  FOR EACH ROW
  EXECUTE FUNCTION normaliser_utilisateur();
```

**Test :**
```sql
INSERT INTO utilisateurs (nom, email)
VALUES ('  jean DUPONT  ', '  JEAN.DUPONT@Example.COM  ');

-- R√©sultat dans la table :
-- nom: 'Jean Dupont'
-- email: 'jean.dupont@example.com'
-- date_inscription: 2025-11-22 14:30:00
```

#### Exemple 2 : Comparer OLD et NEW dans un UPDATE

```sql
CREATE TABLE produits (
  id SERIAL PRIMARY KEY,
  nom TEXT,
  prix NUMERIC(10,2),
  derniere_modif TIMESTAMP
);

CREATE OR REPLACE FUNCTION detecter_changement_prix()
RETURNS TRIGGER AS $$
BEGIN
  -- Comparer l'ancien et le nouveau prix
  IF OLD.prix != NEW.prix THEN
    RAISE NOTICE 'Prix modifi√© pour % : % ‚Üí %',
      NEW.nom, OLD.prix, NEW.prix;

    -- Calculer la variation
    DECLARE
      variation_pct NUMERIC;
    BEGIN
      variation_pct := ((NEW.prix - OLD.prix) / OLD.prix) * 100;

      -- Alerter si variation importante
      IF ABS(variation_pct) > 20 THEN
        RAISE WARNING 'Variation importante de prix : %% pour %',
          ROUND(variation_pct, 2), NEW.nom;
      END IF;
    END;
  END IF;

  -- Mettre √† jour la date de modification
  NEW.derniere_modif := now();

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_prix
  BEFORE UPDATE ON produits
  FOR EACH ROW
  EXECUTE FUNCTION detecter_changement_prix();
```

**Test :**
```sql
-- Prix initial
INSERT INTO produits (nom, prix) VALUES ('Laptop', 1000.00);

-- Petite modification
UPDATE produits SET prix = 1050.00 WHERE nom = 'Laptop';
-- NOTICE: Prix modifi√© pour Laptop : 1000.00 ‚Üí 1050.00

-- Grande modification
UPDATE produits SET prix = 1300.00 WHERE nom = 'Laptop';
-- NOTICE: Prix modifi√© pour Laptop : 1050.00 ‚Üí 1300.00
-- WARNING: Variation importante de prix : 23.81% pour Laptop
```

#### Exemple 3 : Archiver OLD lors d'un DELETE

```sql
CREATE TABLE employes (
  id SERIAL PRIMARY KEY,
  nom TEXT,
  departement TEXT,
  salaire NUMERIC(10,2)
);

CREATE TABLE employes_archives (
  id SERIAL PRIMARY KEY,
  employe_id INTEGER,
  nom TEXT,
  departement TEXT,
  salaire NUMERIC(10,2),
  supprime_le TIMESTAMP DEFAULT now(),
  supprime_par TEXT DEFAULT current_user
);

CREATE OR REPLACE FUNCTION archiver_employe()
RETURNS TRIGGER AS $$
BEGIN
  -- Utiliser OLD pour archiver les donn√©es supprim√©es
  INSERT INTO employes_archives (
    employe_id,
    nom,
    departement,
    salaire
  ) VALUES (
    OLD.id,
    OLD.nom,
    OLD.departement,
    OLD.salaire
  );

  RAISE NOTICE 'Employ√© % archiv√©', OLD.nom;

  -- Retourner OLD pour confirmer la suppression
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_archivage
  BEFORE DELETE ON employes
  FOR EACH ROW
  EXECUTE FUNCTION archiver_employe();
```

**Test :**
```sql
DELETE FROM employes WHERE id = 42;
-- NOTICE: Employ√© Jean Dupont archiv√©
-- L'enregistrement est copi√© dans employes_archives avant suppression
```

---

## Variables contextuelles : TG_*

PostgreSQL fournit plusieurs variables pr√©fix√©es par `TG_` qui donnent des informations sur le contexte du trigger.

### TG_OP : Type d'op√©ration

**Type :** TEXT

**Valeurs possibles :**
- `'INSERT'` : Insertion de donn√©es
- `'UPDATE'` : Mise √† jour de donn√©es
- `'DELETE'` : Suppression de donn√©es
- `'TRUNCATE'` : Vidage de table (triggers STATEMENT uniquement)

#### Utilisation de TG_OP

```sql
CREATE OR REPLACE FUNCTION logger_operation()
RETURNS TRIGGER AS $$
BEGIN
  -- Adapter le comportement selon l'op√©ration
  IF TG_OP = 'INSERT' THEN
    INSERT INTO log_operations (operation, donnees)
    VALUES ('INSERT', row_to_json(NEW));
    RETURN NEW;

  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO log_operations (operation, anciennes_donnees, nouvelles_donnees)
    VALUES ('UPDATE', row_to_json(OLD), row_to_json(NEW));
    RETURN NEW;

  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO log_operations (operation, donnees)
    VALUES ('DELETE', row_to_json(OLD));
    RETURN OLD;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_log
  AFTER INSERT OR UPDATE OR DELETE ON ma_table
  FOR EACH ROW
  EXECUTE FUNCTION logger_operation();
```

#### Pattern : Switch sur TG_OP

```sql
-- Pattern classique avec CASE
CASE TG_OP
  WHEN 'INSERT' THEN
    -- Logique pour INSERT
  WHEN 'UPDATE' THEN
    -- Logique pour UPDATE
  WHEN 'DELETE' THEN
    -- Logique pour DELETE
  ELSE
    RAISE EXCEPTION 'Op√©ration inconnue: %', TG_OP;
END CASE;
```

### TG_WHEN : Moment du trigger

**Type :** TEXT

**Valeurs possibles :**
- `'BEFORE'` : Trigger BEFORE
- `'AFTER'` : Trigger AFTER
- `'INSTEAD OF'` : Trigger INSTEAD OF (vues uniquement)

#### Utilisation de TG_WHEN

```sql
CREATE OR REPLACE FUNCTION fonction_universelle()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_WHEN = 'BEFORE' THEN
    RAISE NOTICE 'Trigger BEFORE : je peux modifier les donn√©es';
    -- Modifier NEW si n√©cessaire
    RETURN NEW;

  ELSIF TG_WHEN = 'AFTER' THEN
    RAISE NOTICE 'Trigger AFTER : les donn√©es sont d√©j√† enregistr√©es';
    -- Uniquement des actions sur d'autres tables
    RETURN NULL;
  END IF;
END;
$$ LANGUAGE plpgsql;
```

### TG_LEVEL : Niveau du trigger

**Type :** TEXT

**Valeurs possibles :**
- `'ROW'` : Trigger FOR EACH ROW
- `'STATEMENT'` : Trigger FOR EACH STATEMENT

#### Utilisation de TG_LEVEL

```sql
CREATE OR REPLACE FUNCTION fonction_adaptative()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_LEVEL = 'ROW' THEN
    RAISE NOTICE 'Traitement ligne par ligne';
    -- NEW et OLD sont disponibles
    RETURN NEW;

  ELSIF TG_LEVEL = 'STATEMENT' THEN
    RAISE NOTICE 'Traitement par instruction';
    -- NEW et OLD ne sont PAS disponibles
    RETURN NULL;
  END IF;
END;
$$ LANGUAGE plpgsql;
```

### TG_TABLE_NAME : Nom de la table

**Type :** NAME (ou TEXT)

**Contenu :** Le nom de la table qui a d√©clench√© le trigger

#### Utilisation de TG_TABLE_NAME

```sql
CREATE OR REPLACE FUNCTION logger_generique()
RETURNS TRIGGER AS $$
BEGIN
  -- Utiliser le nom de la table dans les logs
  INSERT INTO audit_log (table_name, operation, timestamp)
  VALUES (TG_TABLE_NAME, TG_OP, now());

  RAISE NOTICE 'Op√©ration % sur la table %', TG_OP, TG_TABLE_NAME;

  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  ELSE
    RETURN NEW;
  END IF;
END;
$$ LANGUAGE plpgsql;

-- R√©utiliser la m√™me fonction sur plusieurs tables
CREATE TRIGGER trigger_audit_produits
  AFTER INSERT OR UPDATE OR DELETE ON produits
  FOR EACH ROW
  EXECUTE FUNCTION logger_generique();

CREATE TRIGGER trigger_audit_clients
  AFTER INSERT OR UPDATE OR DELETE ON clients
  FOR EACH ROW
  EXECUTE FUNCTION logger_generique();
```

### TG_TABLE_SCHEMA : Sch√©ma de la table

**Type :** NAME (ou TEXT)

**Contenu :** Le sch√©ma (namespace) contenant la table

#### Utilisation de TG_TABLE_SCHEMA

```sql
CREATE OR REPLACE FUNCTION verifier_schema()
RETURNS TRIGGER AS $$
BEGIN
  -- Comportement diff√©rent selon le sch√©ma
  IF TG_TABLE_SCHEMA = 'production' THEN
    RAISE NOTICE 'Attention : modification en production !';
    -- Validations suppl√©mentaires

  ELSIF TG_TABLE_SCHEMA = 'test' THEN
    RAISE NOTICE 'Environnement de test';
    -- Moins de contraintes
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### TG_RELID : OID de la table

**Type :** OID

**Contenu :** L'identifiant interne (Object ID) de la table

#### Utilisation de TG_RELID

```sql
CREATE OR REPLACE FUNCTION obtenir_info_table()
RETURNS TRIGGER AS $$
DECLARE
  nom_complet TEXT;
  taille_table TEXT;
BEGIN
  -- Obtenir le nom complet (sch√©ma.table)
  SELECT schemaname || '.' || tablename INTO nom_complet
  FROM pg_tables
  WHERE schemaname = TG_TABLE_SCHEMA
    AND tablename = TG_TABLE_NAME;

  -- Obtenir la taille de la table
  SELECT pg_size_pretty(pg_total_relation_size(TG_RELID)) INTO taille_table;

  RAISE NOTICE 'Table: %, Taille: %', nom_complet, taille_table;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### TG_NAME : Nom du trigger

**Type :** NAME (ou TEXT)

**Contenu :** Le nom du trigger en cours d'ex√©cution

#### Utilisation de TG_NAME

```sql
CREATE OR REPLACE FUNCTION fonction_tracee()
RETURNS TRIGGER AS $$
BEGIN
  RAISE NOTICE 'Trigger % d√©clench√©', TG_NAME;

  -- Utile pour le debugging de triggers multiples
  INSERT INTO debug_log (trigger_name, timestamp)
  VALUES (TG_NAME, now());

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### TG_ARGV : Arguments du trigger

**Type :** ARRAY de TEXT

**Contenu :** Arguments pass√©s au trigger lors de sa cr√©ation

#### D√©claration avec arguments

```sql
CREATE TRIGGER trigger_avec_args
  BEFORE INSERT ON ma_table
  FOR EACH ROW
  EXECUTE FUNCTION ma_fonction('arg1', 'arg2', '42');
```

#### Acc√®s aux arguments

```sql
CREATE OR REPLACE FUNCTION fonction_parametree()
RETURNS TRIGGER AS $$
BEGIN
  -- Nombre d'arguments
  RAISE NOTICE 'Nombre d''arguments : %', TG_NARGS;

  -- Acc√©der aux arguments (index√©s √† partir de 0)
  IF TG_NARGS > 0 THEN
    RAISE NOTICE 'Argument 0 : %', TG_ARGV[0];
    RAISE NOTICE 'Argument 1 : %', TG_ARGV[1];
    RAISE NOTICE 'Argument 2 : %', TG_ARGV[2];
  END IF;

  -- Utiliser les arguments dans la logique
  IF TG_ARGV[0] = 'strict' THEN
    -- Validation stricte
    IF NEW.valeur < 0 THEN
      RAISE EXCEPTION 'Valeur n√©gative interdite en mode strict';
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

**Exemple pratique :**
```sql
-- Trigger configurable pour diff√©rentes tables
CREATE OR REPLACE FUNCTION valider_seuil()
RETURNS TRIGGER AS $$
DECLARE
  seuil_min NUMERIC;
  seuil_max NUMERIC;
  colonne TEXT;
BEGIN
  -- Arguments : nom_colonne, min, max
  colonne := TG_ARGV[0];
  seuil_min := TG_ARGV[1]::NUMERIC;
  seuil_max := TG_ARGV[2]::NUMERIC;

  -- Validation dynamique
  EXECUTE format('
    SELECT CASE
      WHEN $1.%I < $2 THEN
        RAISE EXCEPTION ''Valeur trop faible: %% < %%'', $1.%I, $2
      WHEN $1.%I > $3 THEN
        RAISE EXCEPTION ''Valeur trop √©lev√©e: %% > %%'', $1.%I, $3
      ELSE NULL
    END',
    colonne, colonne, colonne, colonne
  ) USING NEW, seuil_min, seuil_max;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Utilisation sur diff√©rentes tables avec diff√©rents seuils
CREATE TRIGGER trigger_prix
  BEFORE INSERT OR UPDATE ON produits
  FOR EACH ROW
  EXECUTE FUNCTION valider_seuil('prix', '0', '10000');

CREATE TRIGGER trigger_age
  BEFORE INSERT OR UPDATE ON employes
  FOR EACH ROW
  EXECUTE FUNCTION valider_seuil('age', '18', '70');
```

### TG_NARGS : Nombre d'arguments

**Type :** INTEGER

**Contenu :** Le nombre d'arguments pass√©s au trigger

```sql
IF TG_NARGS != 3 THEN
  RAISE EXCEPTION 'Ce trigger attend exactement 3 arguments, re√ßu %', TG_NARGS;
END IF;
```

---

## Tableau r√©capitulatif complet des variables

| Variable | Type | Disponibilit√© | Description |
|----------|------|---------------|-------------|
| **NEW** | RECORD | INSERT, UPDATE (ROW) | Nouvelles valeurs de la ligne |
| **OLD** | RECORD | UPDATE, DELETE (ROW) | Anciennes valeurs de la ligne |
| **TG_OP** | TEXT | Toujours | Type d'op√©ration : 'INSERT', 'UPDATE', 'DELETE', 'TRUNCATE' |
| **TG_WHEN** | TEXT | Toujours | Moment : 'BEFORE', 'AFTER', 'INSTEAD OF' |
| **TG_LEVEL** | TEXT | Toujours | Niveau : 'ROW' ou 'STATEMENT' |
| **TG_TABLE_NAME** | NAME | Toujours | Nom de la table |
| **TG_TABLE_SCHEMA** | NAME | Toujours | Sch√©ma de la table |
| **TG_RELID** | OID | Toujours | OID de la table |
| **TG_NAME** | NAME | Toujours | Nom du trigger |
| **TG_ARGV** | TEXT[] | Toujours | Tableau d'arguments |
| **TG_NARGS** | INTEGER | Toujours | Nombre d'arguments |

---

## Exemples pratiques combinant plusieurs variables

### Exemple 1 : Logger universel avec toutes les informations

```sql
CREATE TABLE audit_complet (
  id SERIAL PRIMARY KEY,
  timestamp TIMESTAMP DEFAULT now(),
  utilisateur TEXT DEFAULT current_user,
  schema_name TEXT,
  table_name TEXT,
  operation TEXT,
  trigger_name TEXT,
  trigger_level TEXT,
  trigger_when TEXT,
  old_data JSONB,
  new_data JSONB
);

CREATE OR REPLACE FUNCTION audit_complet()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO audit_complet (
    schema_name,
    table_name,
    operation,
    trigger_name,
    trigger_level,
    trigger_when,
    old_data,
    new_data
  ) VALUES (
    TG_TABLE_SCHEMA,
    TG_TABLE_NAME,
    TG_OP,
    TG_NAME,
    TG_LEVEL,
    TG_WHEN,
    CASE WHEN TG_OP IN ('UPDATE', 'DELETE') THEN row_to_json(OLD) ELSE NULL END,
    CASE WHEN TG_OP IN ('INSERT', 'UPDATE') THEN row_to_json(NEW) ELSE NULL END
  );

  -- Retourner la bonne valeur selon l'op√©ration
  CASE TG_OP
    WHEN 'DELETE' THEN RETURN OLD;
    ELSE RETURN NEW;
  END CASE;
END;
$$ LANGUAGE plpgsql;

-- Appliquer sur n'importe quelle table
CREATE TRIGGER audit_produits
  AFTER INSERT OR UPDATE OR DELETE ON produits
  FOR EACH ROW
  EXECUTE FUNCTION audit_complet();
```

### Exemple 2 : Fonction trigger r√©utilisable avec configuration

```sql
CREATE OR REPLACE FUNCTION soft_delete_generique()
RETURNS TRIGGER AS $$
DECLARE
  colonne_suppression TEXT;
  colonne_timestamp TEXT;
BEGIN
  -- Configuration via arguments
  -- TG_ARGV[0] : nom colonne bool√©enne (ex: 'deleted')
  -- TG_ARGV[1] : nom colonne timestamp (ex: 'deleted_at')

  IF TG_NARGS != 2 THEN
    RAISE EXCEPTION 'Usage: EXECUTE FUNCTION soft_delete_generique(''col_bool'', ''col_timestamp'')';
  END IF;

  colonne_suppression := TG_ARGV[0];
  colonne_timestamp := TG_ARGV[1];

  IF TG_OP = 'DELETE' THEN
    -- Au lieu de supprimer, mettre √† jour les colonnes
    EXECUTE format('
      UPDATE %I.%I
      SET %I = true, %I = now()
      WHERE id = $1.id',
      TG_TABLE_SCHEMA,
      TG_TABLE_NAME,
      colonne_suppression,
      colonne_timestamp
    ) USING OLD;

    -- Emp√™cher la vraie suppression
    RETURN NULL;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Utilisation sur diff√©rentes tables
CREATE TRIGGER soft_delete_employes
  BEFORE DELETE ON employes
  FOR EACH ROW
  EXECUTE FUNCTION soft_delete_generique('supprime', 'supprime_le');

CREATE TRIGGER soft_delete_produits
  BEFORE DELETE ON produits
  FOR EACH ROW
  EXECUTE FUNCTION soft_delete_generique('archived', 'archived_at');
```

### Exemple 3 : Validation conditionnelle selon la table et l'op√©ration

```sql
CREATE OR REPLACE FUNCTION validation_intelligente()
RETURNS TRIGGER AS $$
BEGIN
  -- Comportement adaptatif selon table et op√©ration
  CASE TG_TABLE_NAME
    WHEN 'employes' THEN
      IF TG_OP = 'UPDATE' AND OLD.salaire > NEW.salaire THEN
        -- Emp√™cher diminution de salaire
        RAISE EXCEPTION 'Diminution de salaire interdite pour %', OLD.nom;
      END IF;

    WHEN 'produits' THEN
      IF TG_OP IN ('INSERT', 'UPDATE') AND NEW.prix < 0 THEN
        RAISE EXCEPTION 'Prix n√©gatif interdit';
      END IF;

    WHEN 'commandes' THEN
      IF TG_OP = 'DELETE' AND OLD.statut = 'livree' THEN
        RAISE EXCEPTION 'Impossible de supprimer une commande livr√©e';
      END IF;
  END CASE;

  -- Log de toutes les op√©rations
  INSERT INTO operations_log (table_name, operation, when_triggered)
  VALUES (TG_TABLE_NAME, TG_OP, TG_WHEN);

  CASE TG_OP
    WHEN 'DELETE' THEN RETURN OLD;
    ELSE RETURN NEW;
  END CASE;
END;
$$ LANGUAGE plpgsql;
```

---

## Manipulation avanc√©e de NEW et OLD

### Modification dynamique de colonnes

```sql
CREATE OR REPLACE FUNCTION maj_timestamp_dynamique()
RETURNS TRIGGER AS $$
DECLARE
  colonnes_timestamp TEXT[] := ARRAY['created_at', 'updated_at', 'modified_at'];
  col TEXT;
BEGIN
  -- Chercher et mettre √† jour automatiquement les colonnes de timestamp
  FOREACH col IN ARRAY colonnes_timestamp
  LOOP
    -- V√©rifier si la colonne existe dans la table
    IF EXISTS (
      SELECT 1
      FROM information_schema.columns
      WHERE table_schema = TG_TABLE_SCHEMA
        AND table_name = TG_TABLE_NAME
        AND column_name = col
    ) THEN
      -- Mettre √† jour la colonne
      IF TG_OP = 'INSERT' AND col = 'created_at' THEN
        EXECUTE format('SELECT ($1).%I := now()', col) INTO NEW;
      ELSIF TG_OP = 'UPDATE' AND col IN ('updated_at', 'modified_at') THEN
        EXECUTE format('SELECT ($1).%I := now()', col) INTO NEW;
      END IF;
    END IF;
  END LOOP;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### Comparaison intelligente de OLD et NEW

```sql
CREATE OR REPLACE FUNCTION detecter_changements()
RETURNS TRIGGER AS $$
DECLARE
  colonne RECORD;
  valeur_old TEXT;
  valeur_new TEXT;
  changements INTEGER := 0;
BEGIN
  IF TG_OP = 'UPDATE' THEN
    -- Parcourir toutes les colonnes
    FOR colonne IN
      SELECT column_name
      FROM information_schema.columns
      WHERE table_schema = TG_TABLE_SCHEMA
        AND table_name = TG_TABLE_NAME
        AND column_name NOT IN ('updated_at', 'modified_at')  -- Exclure les timestamps auto
    LOOP
      -- R√©cup√©rer les valeurs
      EXECUTE format('SELECT ($1).%I::TEXT', colonne.column_name)
        INTO valeur_old USING OLD;
      EXECUTE format('SELECT ($1).%I::TEXT', colonne.column_name)
        INTO valeur_new USING NEW;

      -- Comparer
      IF valeur_old IS DISTINCT FROM valeur_new THEN
        changements := changements + 1;
        RAISE NOTICE 'Colonne % modifi√©e : % ‚Üí %',
          colonne.column_name, valeur_old, valeur_new;
      END IF;
    END LOOP;

    IF changements = 0 THEN
      RAISE NOTICE 'UPDATE sans changement r√©el d√©tect√©';
    ELSE
      RAISE NOTICE '% colonne(s) modifi√©e(s)', changements;
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### Conversion de NEW/OLD en JSON

```sql
CREATE OR REPLACE FUNCTION serialiser_changements()
RETURNS TRIGGER AS $$
DECLARE
  diff JSONB;
BEGIN
  IF TG_OP = 'UPDATE' THEN
    -- Cr√©er un JSON avec les diff√©rences
    diff := jsonb_build_object(
      'table', TG_TABLE_NAME,
      'operation', TG_OP,
      'timestamp', now(),
      'user', current_user,
      'old_values', row_to_json(OLD)::jsonb,
      'new_values', row_to_json(NEW)::jsonb
    );

    -- Stocker ou envoyer
    PERFORM pg_notify('changements', diff::text);
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

---

## Gestion des NULL avec NEW et OLD

### Comportement avec NULL

Les valeurs NULL dans NEW et OLD se comportent comme des NULL SQL standard :

```sql
CREATE OR REPLACE FUNCTION gerer_null()
RETURNS TRIGGER AS $$
BEGIN
  -- ‚ùå Mauvais : ne fonctionne pas avec NULL
  IF NEW.colonne = NULL THEN  -- Toujours FALSE
    -- Ce code ne s'ex√©cutera JAMAIS
  END IF;

  -- ‚úÖ Bon : utiliser IS NULL
  IF NEW.colonne IS NULL THEN
    -- Code qui s'ex√©cute si colonne est NULL
    NEW.colonne := 'valeur_par_defaut';
  END IF;

  -- ‚úÖ Utiliser COALESCE pour valeur par d√©faut
  NEW.colonne := COALESCE(NEW.colonne, 'defaut');

  -- ‚úÖ IS DISTINCT FROM pour comparaison avec gestion de NULL
  IF OLD.colonne IS DISTINCT FROM NEW.colonne THEN
    -- D√©tecte les changements m√™me si l'une des valeurs est NULL
    RAISE NOTICE 'Colonne modifi√©e';
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### Exemple pratique : Valeurs par d√©faut intelligentes

```sql
CREATE OR REPLACE FUNCTION valeurs_defaut_intelligentes()
RETURNS TRIGGER AS $$
BEGIN
  -- Remplir automatiquement les champs NULL
  NEW.created_at := COALESCE(NEW.created_at, now());
  NEW.updated_at := COALESCE(NEW.updated_at, now());
  NEW.status := COALESCE(NEW.status, 'pending');
  NEW.priority := COALESCE(NEW.priority, 'medium');

  -- Valeur par d√©faut bas√©e sur autre colonne
  IF NEW.nom_complet IS NULL AND NEW.prenom IS NOT NULL AND NEW.nom IS NOT NULL THEN
    NEW.nom_complet := NEW.prenom || ' ' || NEW.nom;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

---

## Bonnes pratiques avec les variables sp√©ciales

### 1. Toujours retourner la bonne valeur

```sql
-- ‚úÖ Bon
CREATE OR REPLACE FUNCTION bon_retour()
RETURNS TRIGGER AS $$
BEGIN
  -- Logique m√©tier...

  -- Retourner selon l'op√©ration
  IF TG_OP = 'DELETE' THEN
    RETURN OLD;  -- OLD pour DELETE
  ELSE
    RETURN NEW;  -- NEW pour INSERT/UPDATE
  END IF;
END;
$$ LANGUAGE plpgsql;

-- ‚ùå Mauvais
CREATE OR REPLACE FUNCTION mauvais_retour()
RETURNS TRIGGER AS $$
BEGIN
  -- Toujours retourner NEW, m√™me pour DELETE
  RETURN NEW;  -- ‚ùå Cause une erreur pour DELETE
END;
$$ LANGUAGE plpgsql;
```

### 2. V√©rifier la disponibilit√© avant utilisation

```sql
-- ‚úÖ Bon : v√©rifier TG_OP avant d'utiliser NEW/OLD
CREATE OR REPLACE FUNCTION verification_securisee()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP IN ('INSERT', 'UPDATE') THEN
    -- S√ªr d'utiliser NEW ici
    NEW.updated_at := now();
  END IF;

  IF TG_OP IN ('UPDATE', 'DELETE') THEN
    -- S√ªr d'utiliser OLD ici
    RAISE NOTICE 'Ancienne valeur : %', OLD.id;
  END IF;

  CASE TG_OP
    WHEN 'DELETE' THEN RETURN OLD;
    ELSE RETURN NEW;
  END CASE;
END;
$$ LANGUAGE plpgsql;
```

### 3. Utiliser TG_TABLE_NAME pour des fonctions r√©utilisables

```sql
-- ‚úÖ Fonction g√©n√©rique r√©utilisable
CREATE OR REPLACE FUNCTION logger_universel()
RETURNS TRIGGER AS $$
BEGIN
  -- Utiliser TG_TABLE_NAME au lieu de hardcoder
  INSERT INTO audit_log (table_name, operation, timestamp)
  VALUES (TG_TABLE_NAME, TG_OP, now());

  CASE TG_OP
    WHEN 'DELETE' THEN RETURN OLD;
    ELSE RETURN NEW;
  END CASE;
END;
$$ LANGUAGE plpgsql;

-- R√©utiliser sur plusieurs tables
CREATE TRIGGER log_produits AFTER INSERT OR UPDATE OR DELETE ON produits
  FOR EACH ROW EXECUTE FUNCTION logger_universel();

CREATE TRIGGER log_clients AFTER INSERT OR UPDATE OR DELETE ON clients
  FOR EACH ROW EXECUTE FUNCTION logger_universel();
```

### 4. Documenter l'utilisation des variables

```sql
CREATE OR REPLACE FUNCTION ma_fonction()
RETURNS TRIGGER AS $$
/**
 * Variables utilis√©es :
 * - NEW : Valeurs apr√®s modification (INSERT, UPDATE)
 * - OLD : Valeurs avant modification (UPDATE, DELETE)
 * - TG_OP : Type d'op√©ration
 * - TG_TABLE_NAME : Nom de la table
 * - TG_WHEN : BEFORE ou AFTER
 */
BEGIN
  -- Code...
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

---

## Debugging et introspection

### Afficher toutes les variables contextuelles

```sql
CREATE OR REPLACE FUNCTION debug_complet()
RETURNS TRIGGER AS $$
BEGIN
  RAISE NOTICE '========== DEBUG TRIGGER ==========';
  RAISE NOTICE 'TG_NAME: %', TG_NAME;
  RAISE NOTICE 'TG_WHEN: %', TG_WHEN;
  RAISE NOTICE 'TG_LEVEL: %', TG_LEVEL;
  RAISE NOTICE 'TG_OP: %', TG_OP;
  RAISE NOTICE 'TG_TABLE_NAME: %', TG_TABLE_NAME;
  RAISE NOTICE 'TG_TABLE_SCHEMA: %', TG_TABLE_SCHEMA;
  RAISE NOTICE 'TG_RELID: %', TG_RELID;
  RAISE NOTICE 'TG_NARGS: %', TG_NARGS;

  IF TG_NARGS > 0 THEN
    FOR i IN 0..TG_NARGS-1 LOOP
      RAISE NOTICE 'TG_ARGV[%]: %', i, TG_ARGV[i];
    END LOOP;
  END IF;

  IF TG_LEVEL = 'ROW' THEN
    IF TG_OP IN ('INSERT', 'UPDATE') THEN
      RAISE NOTICE 'NEW: %', NEW;
    END IF;
    IF TG_OP IN ('UPDATE', 'DELETE') THEN
      RAISE NOTICE 'OLD: %', OLD;
    END IF;
  END IF;

  RAISE NOTICE '===================================';

  CASE TG_OP
    WHEN 'DELETE' THEN RETURN OLD;
    ELSE RETURN NEW;
  END CASE;
END;
$$ LANGUAGE plpgsql;
```

### Fonction d'introspection de NEW/OLD

```sql
CREATE OR REPLACE FUNCTION inspecter_record(rec RECORD)
RETURNS TEXT AS $$
DECLARE
  col RECORD;
  result TEXT := '';
BEGIN
  FOR col IN
    SELECT column_name
    FROM information_schema.columns
    WHERE table_name = TG_TABLE_NAME
  LOOP
    result := result || col.column_name || ': ' ||
              EXECUTE format('SELECT ($1).%I::TEXT', col.column_name) USING rec;
    result := result || E'\n';
  END LOOP;

  RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Utilisation
CREATE OR REPLACE FUNCTION debug_new_old()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP IN ('INSERT', 'UPDATE') THEN
    RAISE NOTICE 'NEW:%', inspecter_record(NEW);
  END IF;
  IF TG_OP IN ('UPDATE', 'DELETE') THEN
    RAISE NOTICE 'OLD:%', inspecter_record(OLD);
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

---

## R√©sum√© des points cl√©s

### Variables de donn√©es

‚úÖ **NEW** : Nouvelles valeurs (INSERT, UPDATE)

‚úÖ **OLD** : Anciennes valeurs (UPDATE, DELETE)

‚úÖ Accessibles uniquement dans les triggers **FOR EACH ROW**

‚úÖ Peuvent √™tre **modifi√©es** dans les triggers **BEFORE**

### Variables contextuelles principales

‚úÖ **TG_OP** : Type d'op√©ration ('INSERT', 'UPDATE', 'DELETE', 'TRUNCATE')

‚úÖ **TG_WHEN** : Moment ('BEFORE', 'AFTER', 'INSTEAD OF')

‚úÖ **TG_LEVEL** : Niveau ('ROW', 'STATEMENT')

‚úÖ **TG_TABLE_NAME** : Nom de la table

‚úÖ **TG_TABLE_SCHEMA** : Sch√©ma de la table

### R√®gles de retour

| Op√©ration | Valeur √† retourner |
|-----------|-------------------|
| INSERT (BEFORE) | NEW (modifiable) |
| UPDATE (BEFORE) | NEW (modifiable) |
| DELETE (BEFORE) | OLD ou NULL pour annuler |
| INSERT/UPDATE/DELETE (AFTER) | NEW ou OLD (ignor√©) |

### Bonnes pratiques

1. Toujours v√©rifier **TG_OP** avant d'utiliser NEW/OLD
2. Utiliser **IS NULL** et **IS DISTINCT FROM** pour les comparaisons avec NULL
3. Retourner la **bonne valeur** selon l'op√©ration
4. Utiliser **TG_TABLE_NAME** pour des fonctions r√©utilisables
5. **Documenter** quelles variables sont utilis√©es

---

## Conclusion

Les variables sp√©ciales sont le **c≈ìur fonctionnel des triggers** PostgreSQL. Leur ma√Ætrise permet de :

- üìù **Acc√©der aux donn√©es** modifi√©es (NEW/OLD)
- üîç **Comprendre le contexte** de l'op√©ration (TG_*)
- ‚ôªÔ∏è **Cr√©er des fonctions r√©utilisables** sur plusieurs tables
- ‚öôÔ∏è **Adapter le comportement** dynamiquement
- üêõ **D√©bugger efficacement** les triggers

**Principe directeur :** Les variables sp√©ciales transforment un trigger d'un simple d√©clencheur en un outil intelligent capable de r√©agir de mani√®re contextuelle et appropri√©e √† chaque situation.

---

**üìö Pour aller plus loin :**
- Section 15.4.1 : Triggers par ligne (FOR EACH ROW)
- Section 15.4.2 : Triggers par instruction (FOR EACH STATEMENT)
- Section 15.5 : Event Triggers
- Section 15.6 : Gestion des exceptions
- Documentation officielle PostgreSQL sur les variables trigger

‚è≠Ô∏è [Event Triggers : Surveillance DDL](/15-programmation-serveur/05-event-triggers.md)
