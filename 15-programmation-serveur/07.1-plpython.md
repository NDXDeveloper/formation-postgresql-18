üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.7.1. PL/Python (plpython3u)

## Introduction √† PL/Python

PL/Python est un langage proc√©dural pour PostgreSQL qui permet d'√©crire des fonctions et des proc√©dures stock√©es en Python. C'est une extension puissante qui combine la flexibilit√© et la richesse de l'√©cosyst√®me Python avec la robustesse de PostgreSQL.

### Pourquoi utiliser PL/Python ?

- **Familiarit√©** : Si vous connaissez d√©j√† Python, vous pouvez r√©utiliser vos connaissances
- **√âcosyst√®me riche** : Acc√®s aux biblioth√®ques Python (NumPy, pandas, requests, etc.)
- **Logique complexe** : Facilite l'impl√©mentation d'algorithmes complexes
- **Traitement de donn√©es** : Id√©al pour les transformations, analyses et calculs avanc√©s
- **Int√©gration** : Permet d'appeler des APIs externes, manipuler des fichiers JSON, etc.

### PL/Python vs PL/pgSQL

| Aspect | PL/pgSQL | PL/Python |
|--------|----------|-----------|
| **Syntaxe** | Sp√©cifique PostgreSQL | Python standard |
| **Performance** | Tr√®s rapide | Moins rapide (interpr√©t√©) |
| **Biblioth√®ques** | Limit√©es | √âcosyst√®me Python complet |
| **Courbe d'apprentissage** | Moyenne | Facile si Python connu |
| **Cas d'usage** | Logique SQL pure | Logique complexe, APIs, ML |

---

## Installation et Configuration

### Les variantes de PL/Python

PostgreSQL propose deux variantes de PL/Python :

1. **plpython3u** (Untrusted) : Version "non s√©curis√©e"
   - Acc√®s complet au syst√®me de fichiers
   - Peut importer n'importe quelle biblioth√®que Python
   - N√©cessite les privil√®ges superutilisateur pour cr√©er des fonctions
   - Recommand√© pour la plupart des usages modernes

2. **plpythonu** (legacy, Python 2) : Obsol√®te, ne plus utiliser

### Installation de l'extension

```sql
-- N√©cessite les privil√®ges superutilisateur
CREATE EXTENSION plpython3u;
```

**Note importante** : PL/Python utilise la version de Python install√©e sur le syst√®me. Sur la plupart des distributions modernes, il s'agit de Python 3.x.

### V√©rification de la version Python

```sql
CREATE OR REPLACE FUNCTION python_version()
RETURNS text AS $$
    import sys
    return sys.version
$$ LANGUAGE plpython3u;

SELECT python_version();
-- R√©sultat : "3.11.5 (main, Sep 11 2023, ...) ..."
```

---

## Anatomie d'une Fonction PL/Python

### Structure de base

```sql
CREATE OR REPLACE FUNCTION nom_fonction(param1 type1, param2 type2)
RETURNS type_retour AS $$
    # Code Python ici
    # Les param√®tres sont directement accessibles
    result = param1 + param2
    return result
$$ LANGUAGE plpython3u;
```

### √âl√©ments cl√©s

1. **D√©limiteurs `$$`** : Encadrent le code Python (alternative aux guillemets simples)
2. **Indentation Python** : Respecter l'indentation Python standard
3. **Variables automatiques** : Les param√®tres de la fonction sont des variables Python
4. **Instruction `return`** : Retourne la valeur √† PostgreSQL
5. **Clause `LANGUAGE plpython3u`** : Indique le langage utilis√©

---

## Types de Donn√©es : PostgreSQL ‚Üî Python

### Conversion automatique

PostgreSQL convertit automatiquement les types entre SQL et Python :

| Type PostgreSQL | Type Python | Exemple |
|----------------|-------------|---------|
| `INTEGER`, `BIGINT` | `int` | `42` |
| `NUMERIC`, `DECIMAL` | `Decimal` | `Decimal('123.45')` |
| `REAL`, `DOUBLE PRECISION` | `float` | `3.14` |
| `TEXT`, `VARCHAR` | `str` | `"Hello"` |
| `BOOLEAN` | `bool` | `True`, `False` |
| `DATE` | `datetime.date` | `date(2025, 11, 22)` |
| `TIMESTAMP` | `datetime.datetime` | `datetime(2025, 11, 22, 14, 30)` |
| `ARRAY` | `list` | `[1, 2, 3]` |
| `JSON`, `JSONB` | `dict` ou `list` | `{"key": "value"}` |
| `NULL` | `None` | `None` |

### Exemple de conversion

```sql
CREATE OR REPLACE FUNCTION demo_types(
    un_entier INTEGER,
    un_texte TEXT,
    une_date DATE,
    un_tableau INTEGER[]
)
RETURNS TEXT AS $$
    # Les types sont automatiquement convertis
    import datetime

    # un_entier est un int Python
    double = un_entier * 2

    # un_texte est un str Python
    majuscules = un_texte.upper()

    # une_date est un datetime.date
    dans_un_an = une_date + datetime.timedelta(days=365)

    # un_tableau est une list Python
    somme = sum(un_tableau)

    return f"Double: {double}, Texte: {majuscules}, Date+1an: {dans_un_an}, Somme: {somme}"
$$ LANGUAGE plpython3u;

-- Utilisation
SELECT demo_types(10, 'postgresql', '2025-11-22', ARRAY[1,2,3,4,5]);
-- R√©sultat : "Double: 20, Texte: POSTGRESQL, Date+1an: 2026-11-22, Somme: 15"
```

---

## Fonctions Simples : Exemples Pratiques

### Exemple 1 : Calcul math√©matique

```sql
CREATE OR REPLACE FUNCTION calculer_tva(prix_ht NUMERIC, taux_tva NUMERIC)
RETURNS NUMERIC AS $$
    # Calcul simple
    tva = prix_ht * (taux_tva / 100)
    prix_ttc = prix_ht + tva
    return prix_ttc
$$ LANGUAGE plpython3u;

SELECT calculer_tva(100.00, 20.0);
-- R√©sultat : 120.00
```

### Exemple 2 : Manipulation de texte

```sql
CREATE OR REPLACE FUNCTION formater_nom_complet(prenom TEXT, nom TEXT)
RETURNS TEXT AS $$
    # Utilisation des m√©thodes Python sur les cha√Ænes
    prenom_format = prenom.strip().capitalize()
    nom_format = nom.strip().upper()
    return f"{prenom_format} {nom_format}"
$$ LANGUAGE plpython3u;

SELECT formater_nom_complet('  jean  ', '  dupont  ');
-- R√©sultat : "Jean DUPONT"
```

### Exemple 3 : Validation complexe

```sql
CREATE OR REPLACE FUNCTION valider_email(email TEXT)
RETURNS BOOLEAN AS $$
    import re

    # Expression r√©guli√®re pour valider un email (simplifi√©e)
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'

    if email is None:
        return False

    return bool(re.match(pattern, email))
$$ LANGUAGE plpython3u;

SELECT valider_email('user@example.com');  -- TRUE
SELECT valider_email('invalid.email');      -- FALSE
```

---

## Manipulation de Donn√©es JSON

L'un des cas d'usage les plus puissants de PL/Python est la manipulation de donn√©es JSON/JSONB.

### Exemple : Extraction et transformation JSON

```sql
CREATE OR REPLACE FUNCTION extraire_infos_json(data JSONB)
RETURNS TABLE(nom TEXT, age INTEGER, ville TEXT) AS $$
    # data est automatiquement converti en dict Python

    # Extraction simple
    nom = data.get('nom', 'Inconnu')
    age = data.get('age', 0)

    # Navigation dans des structures imbriqu√©es
    adresse = data.get('adresse', {})
    ville = adresse.get('ville', 'Non sp√©cifi√©e')

    return [(nom, age, ville)]
$$ LANGUAGE plpython3u;

-- Utilisation
SELECT * FROM extraire_infos_json('
{
    "nom": "Alice Dubois",
    "age": 30,
    "adresse": {
        "ville": "Paris",
        "code_postal": "75001"
    }
}'::JSONB);

-- R√©sultat :
-- nom          | age | ville
-- Alice Dubois | 30  | Paris
```

### Exemple : Construction JSON dynamique

```sql
CREATE OR REPLACE FUNCTION creer_profil_json(
    nom TEXT,
    prenom TEXT,
    age INTEGER
)
RETURNS JSONB AS $$
    import json
    from datetime import datetime

    # Cr√©ation d'un dictionnaire Python
    profil = {
        "nom_complet": f"{prenom} {nom}",
        "age": age,
        "categorie": "majeur" if age >= 18 else "mineur",
        "timestamp": datetime.now().isoformat(),
        "metadata": {
            "version": "1.0",
            "source": "plpython"
        }
    }

    # Retour automatiquement converti en JSONB
    return profil
$$ LANGUAGE plpython3u;

SELECT creer_profil_json('Durand', 'Sophie', 25);
-- R√©sultat : JSON structur√© avec toutes les informations
```

---

## Acc√®s aux Biblioth√®ques Python

L'un des avantages majeurs de PL/Python est l'acc√®s √† l'√©cosyst√®me Python.

### Biblioth√®ques standard

```sql
CREATE OR REPLACE FUNCTION analyser_url(url TEXT)
RETURNS TABLE(schema TEXT, domaine TEXT, chemin TEXT) AS $$
    from urllib.parse import urlparse

    # Analyse de l'URL
    parsed = urlparse(url)

    return [(parsed.scheme, parsed.netloc, parsed.path)]
$$ LANGUAGE plpython3u;

SELECT * FROM analyser_url('https://www.postgresql.org/docs/current/plpython.html');
-- R√©sultat :
-- schema | domaine              | chemin
-- https  | www.postgresql.org   | /docs/current/plpython.html
```

### Biblioth√®ques tierces (si install√©es)

```sql
CREATE OR REPLACE FUNCTION calculer_hash_sha256(texte TEXT)
RETURNS TEXT AS $$
    import hashlib

    # Calcul du hash SHA-256
    hash_obj = hashlib.sha256(texte.encode('utf-8'))
    return hash_obj.hexdigest()
$$ LANGUAGE plpython3u;

SELECT calculer_hash_sha256('PostgreSQL');
-- R√©sultat : "8f3f8e8f8e8f..." (hash SHA-256)
```

**Attention** : Les biblioth√®ques tierces (NumPy, pandas, requests, etc.) doivent √™tre install√©es sur le syst√®me o√π PostgreSQL s'ex√©cute :

```bash
# Sur le serveur PostgreSQL
pip3 install numpy pandas requests
```

---

## Fonctions Retournant Plusieurs Lignes

PL/Python peut retourner des ensembles de r√©sultats (SETOF, TABLE).

### M√©thode 1 : yield (g√©n√©rateur Python)

```sql
CREATE OR REPLACE FUNCTION generer_serie(debut INTEGER, fin INTEGER)
RETURNS SETOF INTEGER AS $$
    # Utilisation d'un g√©n√©rateur Python
    for i in range(debut, fin + 1):
        yield i
$$ LANGUAGE plpython3u;

SELECT * FROM generer_serie(1, 5);
-- R√©sultat :
-- 1
-- 2
-- 3
-- 4
-- 5
```

### M√©thode 2 : return (liste de tuples)

```sql
CREATE OR REPLACE FUNCTION decomposer_texte(texte TEXT)
RETURNS TABLE(mot TEXT, longueur INTEGER) AS $$
    # Split du texte en mots
    mots = texte.split()

    # Cr√©ation d'une liste de tuples
    resultats = [(mot, len(mot)) for mot in mots]

    return resultats
$$ LANGUAGE plpython3u;

SELECT * FROM decomposer_texte('PostgreSQL est une base de donn√©es relationnelle');
-- R√©sultat :
-- mot          | longueur
-- PostgreSQL   | 10
-- est          | 3
-- une          | 3
-- base         | 4
-- de           | 2
-- donn√©es      | 7
-- relationnelle| 13
```

---

## Gestion des Erreurs

### Lever des exceptions

```sql
CREATE OR REPLACE FUNCTION diviser(a NUMERIC, b NUMERIC)
RETURNS NUMERIC AS $$
    if b == 0:
        # Lever une exception PostgreSQL
        plpy.error("Division par z√©ro interdite")

    return a / b
$$ LANGUAGE plpython3u;

SELECT diviser(10, 0);
-- ERROR:  plpy.Error: Division par z√©ro interdite
```

### Niveaux de messages

PL/Python fournit plusieurs fonctions pour communiquer avec PostgreSQL :

```sql
CREATE OR REPLACE FUNCTION demo_messages(valeur INTEGER)
RETURNS TEXT AS $$
    # DEBUG : Message de d√©bogage (non affich√© par d√©faut)
    plpy.debug(f"Valeur re√ßue: {valeur}")

    # INFO : Message informatif
    plpy.info("Traitement en cours...")

    # NOTICE : Notification (affich√© par d√©faut)
    plpy.notice("Valeur valid√©e")

    # WARNING : Avertissement
    if valeur > 100:
        plpy.warning("Valeur √©lev√©e d√©tect√©e")

    # ERROR : Erreur (arr√™te l'ex√©cution)
    if valeur < 0:
        plpy.error("Valeur n√©gative non autoris√©e")

    return "Traitement r√©ussi"
$$ LANGUAGE plpython3u;
```

---

## Ex√©cution de Requ√™tes SQL depuis Python

Le module `plpy` permet d'ex√©cuter des requ√™tes SQL depuis le code Python.

### Ex√©cution simple

```sql
CREATE OR REPLACE FUNCTION compter_utilisateurs()
RETURNS INTEGER AS $$
    # Ex√©cution d'une requ√™te SQL
    result = plpy.execute("SELECT COUNT(*) as total FROM utilisateurs")

    # Acc√®s au r√©sultat (liste de dictionnaires)
    return result[0]["total"]
$$ LANGUAGE plpython3u;
```

### Requ√™tes pr√©par√©es (s√©curis√©es)

```sql
CREATE OR REPLACE FUNCTION obtenir_utilisateur_par_email(email_recherche TEXT)
RETURNS TABLE(id INTEGER, nom TEXT, email TEXT) AS $$
    # Utilisation de requ√™tes pr√©par√©es (protection contre SQL injection)
    plan = plpy.prepare(
        "SELECT id, nom, email FROM utilisateurs WHERE email = $1",
        ["TEXT"]
    )

    # Ex√©cution avec param√®tre
    result = plpy.execute(plan, [email_recherche])

    # Retour des r√©sultats
    return [(row["id"], row["nom"], row["email"]) for row in result]
$$ LANGUAGE plpython3u;
```

### Manipulation de donn√©es

```sql
CREATE OR REPLACE FUNCTION archiver_anciens_logs(jours INTEGER)
RETURNS INTEGER AS $$
    from datetime import datetime, timedelta

    # Calcul de la date limite
    date_limite = datetime.now() - timedelta(days=jours)

    # Insertion dans table d'archive
    plan_insert = plpy.prepare(
        "INSERT INTO logs_archive SELECT * FROM logs WHERE created_at < $1",
        ["TIMESTAMP"]
    )
    result_insert = plpy.execute(plan_insert, [date_limite])

    # Suppression des logs archiv√©s
    plan_delete = plpy.prepare(
        "DELETE FROM logs WHERE created_at < $1",
        ["TIMESTAMP"]
    )
    result_delete = plpy.execute(plan_delete, [date_limite])

    # Retour du nombre d'enregistrements archiv√©s
    return result_delete.nrows()
$$ LANGUAGE plpython3u;
```

---

## Fonctions avec √âtat (Variables Globales)

PL/Python maintient un dictionnaire global `GD` qui persiste entre les appels de fonction dans la m√™me session.

### Exemple : Cache simple

```sql
CREATE OR REPLACE FUNCTION obtenir_config(cle TEXT)
RETURNS TEXT AS $$
    # GD persiste entre les appels
    if "cache" not in GD:
        GD["cache"] = {}
        plpy.notice("Cache initialis√©")

    # V√©rifier le cache
    if cle in GD["cache"]:
        plpy.notice(f"Valeur trouv√©e en cache pour: {cle}")
        return GD["cache"][cle]

    # Sinon, requ√™te en base
    plan = plpy.prepare("SELECT valeur FROM config WHERE cle = $1", ["TEXT"])
    result = plpy.execute(plan, [cle])

    if result:
        valeur = result[0]["valeur"]
        GD["cache"][cle] = valeur  # Mise en cache
        return valeur

    return None
$$ LANGUAGE plpython3u;
```

**Attention** : `GD` est sp√©cifique √† chaque session/connexion PostgreSQL.

---

## Cas d'Usage Avanc√©s

### 1. Appel d'API externe

```sql
CREATE OR REPLACE FUNCTION obtenir_meteo(ville TEXT)
RETURNS JSONB AS $$
    import urllib.request
    import json

    # Attention : ceci est un exemple simplifi√©
    # En production, g√©rer les erreurs, timeouts, etc.
    try:
        url = f"https://api.meteo.fr/v1/{ville}"
        with urllib.request.urlopen(url, timeout=5) as response:
            data = json.loads(response.read().decode())
            return data
    except Exception as e:
        plpy.warning(f"Erreur API: {str(e)}")
        return {"error": str(e)}
$$ LANGUAGE plpython3u;
```

### 2. Analyse statistique

```sql
CREATE OR REPLACE FUNCTION calculer_statistiques(valeurs NUMERIC[])
RETURNS TABLE(
    moyenne NUMERIC,
    mediane NUMERIC,
    ecart_type NUMERIC,
    min_val NUMERIC,
    max_val NUMERIC
) AS $$
    if not valeurs:
        return [(None, None, None, None, None)]

    # Conversion en liste Python
    data = list(valeurs)
    data_sorted = sorted(data)

    # Calculs statistiques
    n = len(data)
    moyenne = sum(data) / n

    # M√©diane
    if n % 2 == 0:
        mediane = (data_sorted[n//2 - 1] + data_sorted[n//2]) / 2
    else:
        mediane = data_sorted[n//2]

    # √âcart-type
    variance = sum((x - moyenne) ** 2 for x in data) / n
    ecart_type = variance ** 0.5

    min_val = min(data)
    max_val = max(data)

    return [(moyenne, mediane, ecart_type, min_val, max_val)]
$$ LANGUAGE plpython3u;

-- Utilisation
SELECT * FROM calculer_statistiques(ARRAY[10, 20, 30, 40, 50]::NUMERIC[]);
```

### 3. G√©n√©ration de donn√©es pour tests

```sql
CREATE OR REPLACE FUNCTION generer_donnees_test(nb_lignes INTEGER)
RETURNS TABLE(
    id INTEGER,
    nom TEXT,
    email TEXT,
    age INTEGER,
    date_inscription DATE
) AS $$
    import random
    import string
    from datetime import date, timedelta

    prenoms = ['Alice', 'Bob', 'Charlie', 'Diana', 'Ethan', 'Fiona']
    noms = ['Martin', 'Bernard', 'Dubois', 'Thomas', 'Robert', 'Petit']

    for i in range(1, nb_lignes + 1):
        prenom = random.choice(prenoms)
        nom_famille = random.choice(noms)
        nom_complet = f"{prenom} {nom_famille}"

        # Email g√©n√©r√©
        email = f"{prenom.lower()}.{nom_famille.lower()}@example.com"

        # √Çge al√©atoire
        age = random.randint(18, 65)

        # Date d'inscription al√©atoire (derni√®re ann√©e)
        jours_arriere = random.randint(0, 365)
        date_inscr = date.today() - timedelta(days=jours_arriere)

        yield (i, nom_complet, email, age, date_inscr)
$$ LANGUAGE plpython3u;

-- G√©n√©ration de 10 enregistrements de test
SELECT * FROM generer_donnees_test(10);
```

---

## Bonnes Pratiques

### 1. S√©curit√©

**Toujours utiliser des requ√™tes pr√©par√©es** pour √©viter les injections SQL :

```sql
-- ‚ùå DANGEREUX - Vuln√©rable aux injections SQL
CREATE OR REPLACE FUNCTION recherche_danger(nom TEXT)
RETURNS INTEGER AS $$
    query = f"SELECT COUNT(*) FROM users WHERE nom = '{nom}'"
    result = plpy.execute(query)
    return result[0]["count"]
$$ LANGUAGE plpython3u;

-- ‚úÖ S√âCURIS√â - Requ√™te pr√©par√©e
CREATE OR REPLACE FUNCTION recherche_securisee(nom TEXT)
RETURNS INTEGER AS $$
    plan = plpy.prepare("SELECT COUNT(*) FROM users WHERE nom = $1", ["TEXT"])
    result = plpy.execute(plan, [nom])
    return result[0]["count"]
$$ LANGUAGE plpython3u;
```

### 2. Performance

- **Limiter l'utilisation** : PL/Python est plus lent que PL/pgSQL pour la logique SQL pure
- **Privil√©gier PL/pgSQL** pour les op√©rations intensives en SQL
- **Utiliser PL/Python** pour :
  - Logique m√©tier complexe
  - Traitement de donn√©es non relationnelles
  - Int√©gration avec des biblioth√®ques externes
  - Appels d'API

### 3. Gestion des transactions

```sql
CREATE OR REPLACE FUNCTION operation_transactionnelle()
RETURNS TEXT AS $$
    # PL/Python s'ex√©cute dans le contexte transactionnel de PostgreSQL
    # Pas de BEGIN/COMMIT explicite n√©cessaire

    try:
        plpy.execute("INSERT INTO logs (message) VALUES ('D√©but op√©ration')")

        # Op√©ration principale
        plpy.execute("UPDATE comptes SET solde = solde + 100 WHERE id = 1")

        plpy.execute("INSERT INTO logs (message) VALUES ('Op√©ration r√©ussie')")

        return "Succ√®s"
    except Exception as e:
        # En cas d'erreur, PostgreSQL rollback automatiquement
        plpy.error(f"Erreur: {str(e)}")
$$ LANGUAGE plpython3u;
```

### 4. Documentation

Toujours documenter vos fonctions :

```sql
CREATE OR REPLACE FUNCTION fonction_documentee(param TEXT)
RETURNS TEXT AS $$
    """
    Description : Cette fonction fait XYZ

    Arguments :
        param (TEXT) : Description du param√®tre

    Retourne :
        TEXT : Description du retour

    Exemple :
        SELECT fonction_documentee('test');

    Notes :
        - Point important 1
        - Point important 2
    """

    # Code ici
    return param.upper()
$$ LANGUAGE plpython3u;

-- Ajouter un commentaire PostgreSQL
COMMENT ON FUNCTION fonction_documentee(TEXT) IS
'Convertit le texte en majuscules avec validation';
```

---

## Limitations et Consid√©rations

### 1. Limitations techniques

- **Performance** : Plus lent que PL/pgSQL pour les op√©rations SQL simples
- **Pas de parall√©lisation native** : Les fonctions PL/Python ne sont pas parall√©lisables
- **Interpr√©teur unique** : Un seul interpr√©teur Python par backend PostgreSQL
- **M√©moire** : Charge m√©moire plus importante que PL/pgSQL

### 2. S√©curit√©

- **plpython3u est "untrusted"** : Acc√®s complet au syst√®me
- **R√©server aux superutilisateurs** : Seuls les superusers peuvent cr√©er des fonctions
- **Isolation limit√©e** : Pas de sandbox pour le code Python
- **Biblioth√®ques** : Attention aux biblioth√®ques tierces et d√©pendances

### 3. Maintenance

- **D√©pendances syst√®me** : Version Python et biblioth√®ques install√©es
- **Portabilit√©** : Code d√©pendant de l'environnement syst√®me
- **Tests** : Plus difficile √† tester que du SQL pur
- **D√©bogage** : Moins d'outils natifs que pour PL/pgSQL

---

## Quand Utiliser PL/Python ?

### ‚úÖ Cas d'usage recommand√©s

1. **Traitement de donn√©es complexe**
   - Parsing de formats non standards
   - Algorithmes math√©matiques avanc√©s
   - Machine Learning / IA (avec scikit-learn, TensorFlow)

2. **Int√©grations externes**
   - Appels d'APIs REST
   - Connexion √† des services tiers
   - Envoi d'emails, SMS

3. **Manipulation de donn√©es non relationnelles**
   - JSON/XML complexe
   - Fichiers binaires
   - Formats propri√©taires

4. **Prototypage rapide**
   - Tests de concepts
   - Scripts de migration
   - Transformations de donn√©es ponctuelles

### ‚ùå Cas d'usage d√©conseill√©s

1. **Op√©rations SQL intensives**
   - Privil√©gier PL/pgSQL
   - Meilleure performance native

2. **Haute fr√©quence d'appel**
   - Overhead d'interpr√©tation Python
   - Latence accrue

3. **Op√©rations transactionnelles critiques**
   - Pr√©f√©rer la logique SQL pure
   - Meilleure int√©gration ACID

---

## Exemple Complet : Syst√®me de Recommandation Simple

Voici un exemple complet illustrant plusieurs concepts :

```sql
-- Table de produits
CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    nom TEXT NOT NULL,
    categorie TEXT,
    tags TEXT[]
);

-- Table d'achats
CREATE TABLE achats (
    id SERIAL PRIMARY KEY,
    utilisateur_id INTEGER,
    produit_id INTEGER REFERENCES produits(id),
    date_achat TIMESTAMP DEFAULT NOW()
);

-- Fonction de recommandation
CREATE OR REPLACE FUNCTION recommander_produits(
    user_id INTEGER,
    limite INTEGER DEFAULT 5
)
RETURNS TABLE(
    produit_id INTEGER,
    nom TEXT,
    score NUMERIC,
    raison TEXT
) AS $$
    from collections import Counter

    # 1. R√©cup√©rer l'historique d'achat de l'utilisateur
    plan_historique = plpy.prepare("""
        SELECT p.categorie, p.tags
        FROM achats a
        JOIN produits p ON p.id = a.produit_id
        WHERE a.utilisateur_id = $1
    """, ["INTEGER"])

    historique = plpy.execute(plan_historique, [user_id])

    if not historique:
        plpy.notice("Aucun historique d'achat trouv√©")
        return []

    # 2. Analyser les pr√©f√©rences
    categories = [row["categorie"] for row in historique if row["categorie"]]
    tous_tags = []
    for row in historique:
        if row["tags"]:
            tous_tags.extend(row["tags"])

    # Compter les occurrences
    categories_freq = Counter(categories)
    tags_freq = Counter(tous_tags)

    # Cat√©gorie pr√©f√©r√©e
    categorie_pref = categories_freq.most_common(1)[0][0] if categories_freq else None
    tags_prefs = [tag for tag, _ in tags_freq.most_common(3)]

    plpy.info(f"Pr√©f√©rences: cat√©gorie={categorie_pref}, tags={tags_prefs}")

    # 3. Trouver des produits similaires non encore achet√©s
    plan_reco = plpy.prepare("""
        SELECT DISTINCT p.id, p.nom, p.categorie, p.tags
        FROM produits p
        WHERE p.id NOT IN (
            SELECT produit_id FROM achats WHERE utilisateur_id = $1
        )
        AND (p.categorie = $2 OR p.tags && $3)
        LIMIT $4
    """, ["INTEGER", "TEXT", "TEXT[]", "INTEGER"])

    recommandations = plpy.execute(
        plan_reco,
        [user_id, categorie_pref, tags_prefs, limite * 2]
    )

    # 4. Calculer un score de pertinence
    resultats = []
    for prod in recommandations:
        score = 0.0
        raisons = []

        # Bonus pour la cat√©gorie
        if prod["categorie"] == categorie_pref:
            score += 10
            raisons.append(f"Cat√©gorie '{categorie_pref}'")

        # Bonus pour les tags
        if prod["tags"]:
            tags_communs = set(prod["tags"]) & set(tags_prefs)
            score += len(tags_communs) * 5
            if tags_communs:
                raisons.append(f"Tags: {', '.join(tags_communs)}")

        if score > 0:
            raison_complete = " | ".join(raisons)
            resultats.append((prod["id"], prod["nom"], score, raison_complete))

    # 5. Trier par score et limiter
    resultats.sort(key=lambda x: x[2], reverse=True)
    return resultats[:limite]

$$ LANGUAGE plpython3u;

-- Utilisation
SELECT * FROM recommander_produits(123, 5);
```

---

## Ressources et Documentation

### Documentation officielle

- **PostgreSQL PL/Python** : https://www.postgresql.org/docs/current/plpython.html
- **Python 3 Documentation** : https://docs.python.org/3/

### Conseils pour aller plus loin

1. **Ma√Ætriser Python** : Plus vous connaissez Python, plus PL/Python est puissant
2. **Comprendre l'√©cosyst√®me PostgreSQL** : PL/Python compl√®te PL/pgSQL, ne le remplace pas
3. **Exp√©rimenter** : Tester diff√©rents cas d'usage pour identifier les meilleurs patterns
4. **Benchmarker** : Toujours comparer les performances avec PL/pgSQL
5. **S√©curiser** : Attention aux privil√®ges et √† l'exposition des fonctions

---

## R√©sum√©

**PL/Python (plpython3u)** est un outil puissant qui :

‚úÖ **Avantages** :
- Syntaxe Python famili√®re et accessible
- Acc√®s √† l'√©cosyst√®me Python complet
- Id√©al pour la logique complexe et les int√©grations
- Manipulation facilit√©e de JSON, APIs, algorithmes

‚ùå **Limitations** :
- Performance inf√©rieure √† PL/pgSQL pour le SQL pur
- N√©cessite des privil√®ges superutilisateur
- D√©pendances syst√®me et maintenance
- Moins bien int√©gr√© dans les transactions PostgreSQL

**Recommandation** : Utilisez PL/Python quand vous avez besoin de la puissance de Python, mais privil√©giez PL/pgSQL pour les op√©rations SQL standards. Les deux langages sont compl√©mentaires dans l'√©cosyst√®me PostgreSQL.

---

**Prochaines √©tapes** :
- 15.7.2. PL/Perl (plperlu)
- 15.7.3. PL/v8 (JavaScript)

‚è≠Ô∏è [PL/Perl (plperlu)](/15-programmation-serveur/07.2-plperl.md)
