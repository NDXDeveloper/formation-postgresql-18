üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.7.2. PL/Perl (plperlu)

## Introduction √† PL/Perl

PL/Perl est un langage proc√©dural pour PostgreSQL qui permet d'√©crire des fonctions et des proc√©dures stock√©es en Perl. Perl, connu pour ses capacit√©s exceptionnelles en manipulation de texte et d'expressions r√©guli√®res, apporte sa puissance au sein de PostgreSQL.

### Qu'est-ce que Perl ?

**Perl** (Practical Extraction and Report Language) est un langage de programmation cr√©√© en 1987 par Larry Wall. Il est particuli√®rement r√©put√© pour :

- **Traitement de texte** : Parsing, recherche, remplacement
- **Expressions r√©guli√®res** : Les plus puissantes parmi les langages mainstream
- **Flexibilit√©** : "There's more than one way to do it" (TMTOWTDI)
- **CPAN** : Comprehensive Perl Archive Network - des milliers de modules

### Pourquoi utiliser PL/Perl ?

- **Manipulation de texte** : Parsing, extraction, transformation de cha√Ænes complexes
- **Expressions r√©guli√®res avanc√©es** : Recherche de patterns sophistiqu√©s
- **√âcosyst√®me CPAN** : Acc√®s √† des milliers de modules Perl
- **Traitement de logs** : Analyse et extraction d'informations
- **Formats de donn√©es** : CSV, XML, formats propri√©taires
- **Int√©gration legacy** : R√©utilisation de code Perl existant

### PL/Perl vs PL/pgSQL vs PL/Python

| Aspect | PL/pgSQL | PL/Perl | PL/Python |
|--------|----------|---------|-----------|
| **Point fort** | SQL natif | Regex/Texte | √âcosyst√®me moderne |
| **Performance SQL** | Excellent | Bon | Bon |
| **Regex** | Basique | **Excellent** | Bon |
| **Manipulation texte** | Basique | **Excellent** | Bon |
| **Courbe apprentissage** | Moyenne | Moyenne-√âlev√©e | Facile |
| **Syntaxe** | SQL-like | Perl | Python |
| **Modules externes** | Non | CPAN | pip/PyPI |

---

## Installation et Configuration

### Les variantes de PL/Perl

PostgreSQL propose deux variantes de PL/Perl :

1. **plperl** (Trusted) : Version "s√©curis√©e"
   - Pas d'acc√®s aux fichiers syst√®me
   - Op√©rations limit√©es
   - Utilisateurs normaux peuvent cr√©er des fonctions
   - Modules CPAN restreints

2. **plperlu** (Untrusted) : Version "non s√©curis√©e"
   - Acc√®s complet au syst√®me de fichiers
   - Peut ex√©cuter des commandes syst√®me
   - N√©cessite les privil√®ges superutilisateur
   - Acc√®s complet aux modules CPAN
   - **Recommand√© pour les cas d'usage avanc√©s**

### Installation de l'extension

```sql
-- Version trusted (pour utilisateurs standards)
CREATE EXTENSION plperl;

-- Version untrusted (pour superutilisateurs, plus de libert√©)
CREATE EXTENSION plperlu;
```

**Note importante** :
- `plperl` et `plperlu` peuvent coexister
- Les fonctions doivent sp√©cifier le langage utilis√©
- PL/Perl utilise la version de Perl install√©e sur le syst√®me

### V√©rification de la version Perl

```sql
CREATE OR REPLACE FUNCTION perl_version()
RETURNS text AS $$
    return $^V;  # Variable sp√©ciale Perl contenant la version
$$ LANGUAGE plperlu;

SELECT perl_version();
-- R√©sultat : "v5.36.0" (par exemple)
```

### V√©rification des modules disponibles

```sql
CREATE OR REPLACE FUNCTION perl_modules_info()
RETURNS text AS $$
    my $info = "Perl version: $^V\n";
    $info .= "INC paths:\n";
    foreach my $path (@INC) {
        $info .= "  - $path\n";
    }
    return $info;
$$ LANGUAGE plperlu;

SELECT perl_modules_info();
```

---

## Anatomie d'une Fonction PL/Perl

### Structure de base

```sql
CREATE OR REPLACE FUNCTION nom_fonction(param1 type1, param2 type2)
RETURNS type_retour AS $$
    # Code Perl ici
    # Les param√®tres sont dans @_
    my ($arg1, $arg2) = @_;

    my $result = $arg1 + $arg2;
    return $result;
$$ LANGUAGE plperlu;
```

### √âl√©ments cl√©s

1. **D√©limiteurs `$$`** : Encadrent le code Perl
2. **Tableau `@_`** : Contient les arguments de la fonction
3. **Variables `my`** : D√©claration de variables locales (bonne pratique)
4. **Instruction `return`** : Retourne la valeur √† PostgreSQL
5. **Clause `LANGUAGE plperlu`** : Sp√©cifie le langage

### Acc√®s aux param√®tres

Il existe plusieurs fa√ßons d'acc√©der aux param√®tres :

```sql
-- M√©thode 1 : D√©composition du tableau @_
CREATE OR REPLACE FUNCTION methode1(a INTEGER, b INTEGER)
RETURNS INTEGER AS $$
    my ($x, $y) = @_;  # D√©composition
    return $x + $y;
$$ LANGUAGE plperlu;

-- M√©thode 2 : Acc√®s direct par index
CREATE OR REPLACE FUNCTION methode2(a INTEGER, b INTEGER)
RETURNS INTEGER AS $$
    return $_[0] + $_[1];  # Acc√®s direct
$$ LANGUAGE plperlu;

-- M√©thode 3 : Variables nomm√©es (le plus lisible)
CREATE OR REPLACE FUNCTION methode3(a INTEGER, b INTEGER)
RETURNS INTEGER AS $$
    my $premier = shift;   # R√©cup√®re $_[0]
    my $second = shift;    # R√©cup√®re $_[1]
    return $premier + $second;
$$ LANGUAGE plperlu;
```

---

## Types de Donn√©es : PostgreSQL ‚Üî Perl

### Conversion automatique

PostgreSQL convertit automatiquement les types entre SQL et Perl :

| Type PostgreSQL | Type Perl | Exemple | Note |
|----------------|-----------|---------|------|
| `INTEGER`, `BIGINT` | Scalaire num√©rique | `42` | Conversion automatique |
| `NUMERIC`, `DECIMAL` | Scalaire cha√Æne | `"123.45"` | Pr√©cision pr√©serv√©e |
| `REAL`, `DOUBLE` | Scalaire num√©rique | `3.14` | Float Perl |
| `TEXT`, `VARCHAR` | Scalaire cha√Æne | `"Hello"` | Encodage UTF-8 |
| `BOOLEAN` | Scalaire | `1` ou `0` ou `undef` | `t`/`f` en base |
| `DATE` | Scalaire cha√Æne | `"2025-11-22"` | Format ISO |
| `TIMESTAMP` | Scalaire cha√Æne | `"2025-11-22 14:30:00"` | Format ISO |
| `ARRAY` | R√©f√©rence tableau | `[1, 2, 3]` | Entre accolades en SQL |
| `NULL` | `undef` | `undef` | Valeur non d√©finie |

### Exemple de conversion

```sql
CREATE OR REPLACE FUNCTION demo_types(
    un_entier INTEGER,
    un_texte TEXT,
    une_date DATE,
    un_tableau INTEGER[]
)
RETURNS TEXT AS $$
    my ($entier, $texte, $date, $tableau) = @_;

    # $entier est un nombre Perl
    my $double = $entier * 2;

    # $texte est une cha√Æne Perl
    my $majuscules = uc($texte);  # uc = uppercase

    # $date est une cha√Æne au format ISO
    my $annee = substr($date, 0, 4);

    # $tableau est une r√©f√©rence √† un tableau Perl
    my $somme = 0;
    foreach my $val (@$tableau) {
        $somme += $val;
    }

    return "Double: $double, Texte: $majuscules, Ann√©e: $annee, Somme: $somme";
$$ LANGUAGE plperlu;

-- Utilisation
SELECT demo_types(10, 'postgresql', '2025-11-22', ARRAY[1,2,3,4,5]);
-- R√©sultat : "Double: 20, Texte: POSTGRESQL, Ann√©e: 2025, Somme: 15"
```

---

## Fonctions Simples : Exemples Pratiques

### Exemple 1 : Calcul math√©matique

```sql
CREATE OR REPLACE FUNCTION calculer_tva(prix_ht NUMERIC, taux_tva NUMERIC)
RETURNS NUMERIC AS $$
    my ($ht, $taux) = @_;

    # Calcul de la TVA
    my $tva = $ht * ($taux / 100);
    my $ttc = $ht + $tva;

    return $ttc;
$$ LANGUAGE plperlu;

SELECT calculer_tva(100.00, 20.0);
-- R√©sultat : 120.00
```

### Exemple 2 : Manipulation de texte

```sql
CREATE OR REPLACE FUNCTION formater_nom_complet(prenom TEXT, nom TEXT)
RETURNS TEXT AS $$
    my ($prenom, $nom) = @_;

    # Nettoyage et formatage
    $prenom =~ s/^\s+|\s+$//g;  # Trim
    $nom =~ s/^\s+|\s+$//g;

    $prenom = ucfirst(lc($prenom));  # Premi√®re lettre majuscule
    $nom = uc($nom);                 # Tout en majuscules

    return "$prenom $nom";
$$ LANGUAGE plperlu;

SELECT formater_nom_complet('  jean  ', '  dupont  ');
-- R√©sultat : "Jean DUPONT"
```

### Exemple 3 : Validation avec regex

```sql
CREATE OR REPLACE FUNCTION valider_email(email TEXT)
RETURNS BOOLEAN AS $$
    my $email = shift;

    return 0 unless defined $email;  # Retour false si undef

    # Regex pour validation email (simplifi√©e)
    if ($email =~ /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/) {
        return 1;  # TRUE
    } else {
        return 0;  # FALSE
    }
$$ LANGUAGE plperlu;

SELECT valider_email('user@example.com');  -- TRUE
SELECT valider_email('invalid.email');      -- FALSE
```

---

## Expressions R√©guli√®res : La Force de Perl

Perl est r√©put√© pour avoir les expressions r√©guli√®res les plus puissantes et flexibles.

### Recherche et matching

```sql
CREATE OR REPLACE FUNCTION extraire_domaine_email(email TEXT)
RETURNS TEXT AS $$
    my $email = shift;

    # Extraction du domaine avec regex
    if ($email =~ /@(.+)$/) {
        return $1;  # $1 contient le premier groupe captur√©
    }

    return undef;  # NULL en SQL
$$ LANGUAGE plperlu;

SELECT extraire_domaine_email('john.doe@example.com');
-- R√©sultat : "example.com"
```

### Remplacement avec regex

```sql
CREATE OR REPLACE FUNCTION anonymiser_texte(texte TEXT)
RETURNS TEXT AS $$
    my $texte = shift;

    # Remplacer tous les emails par [EMAIL]
    $texte =~ s/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/[EMAIL]/g;

    # Remplacer tous les num√©ros de t√©l√©phone (format FR)
    $texte =~ s/\b0[1-9](?:\s?\d{2}){4}\b/[TELEPHONE]/g;

    # Remplacer les num√©ros de carte bancaire (4 groupes de 4 chiffres)
    $texte =~ s/\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/[CARTE]/g;

    return $texte;
$$ LANGUAGE plperlu;

SELECT anonymiser_texte('Contact: john@example.com ou 06 12 34 56 78');
-- R√©sultat : "Contact: [EMAIL] ou [TELEPHONE]"
```

### Extraction de multiples occurrences

```sql
CREATE OR REPLACE FUNCTION extraire_hashtags(texte TEXT)
RETURNS TEXT[] AS $$
    my $texte = shift;

    # Trouver tous les hashtags (#mot)
    my @hashtags = ($texte =~ /#(\w+)/g);

    # Retourner une r√©f√©rence √† un tableau
    return \@hashtags;
$$ LANGUAGE plperlu;

SELECT extraire_hashtags('J''aime #PostgreSQL et #Perl pour le #dev');
-- R√©sultat : {PostgreSQL,Perl,dev}
```

### Validation complexe

```sql
CREATE OR REPLACE FUNCTION valider_mot_de_passe(mdp TEXT)
RETURNS TABLE(valide BOOLEAN, message TEXT) AS $$
    my $mdp = shift;

    # Crit√®res de validation
    my @erreurs;

    push @erreurs, "Minimum 8 caract√®res requis" if length($mdp) < 8;
    push @erreurs, "Au moins une majuscule requise" unless $mdp =~ /[A-Z]/;
    push @erreurs, "Au moins une minuscule requise" unless $mdp =~ /[a-z]/;
    push @erreurs, "Au moins un chiffre requis" unless $mdp =~ /\d/;
    push @erreurs, "Au moins un caract√®re sp√©cial requis" unless $mdp =~ /[!@#$%^&*(),.?":{}|<>]/;

    if (@erreurs) {
        my $msg = join(", ", @erreurs);
        return_next({valide => 0, message => $msg});
    } else {
        return_next({valide => 1, message => "Mot de passe valide"});
    }

    return undef;
$$ LANGUAGE plperlu;

SELECT * FROM valider_mot_de_passe('faible');
-- valide | message
-- FALSE  | Minimum 8 caract√®res requis, Au moins une majuscule requise, ...

SELECT * FROM valider_mot_de_passe('Fort123!Pass');
-- valide | message
-- TRUE   | Mot de passe valide
```

---

## Parsing et Traitement de Texte

### Parsing de logs

```sql
CREATE OR REPLACE FUNCTION parser_log_apache(ligne_log TEXT)
RETURNS TABLE(
    ip TEXT,
    date_acces TEXT,
    methode TEXT,
    url TEXT,
    code_http INTEGER,
    user_agent TEXT
) AS $$
    my $log = shift;

    # Regex pour log Apache format combin√©
    # Format: IP - - [Date] "METHOD URL PROTOCOL" CODE SIZE "REFERER" "USER-AGENT"
    if ($log =~ /^(\S+) \S+ \S+ \[([^\]]+)\] "(\S+) (\S+) \S+" (\d+) \S+ "([^"]*)" "([^"]*)"/) {
        return_next({
            ip => $1,
            date_acces => $2,
            methode => $3,
            url => $4,
            code_http => $5,
            user_agent => $7
        });
    }

    return undef;
$$ LANGUAGE plperlu;

SELECT * FROM parser_log_apache(
    '192.168.1.1 - - [22/Nov/2025:14:30:00 +0100] "GET /index.html HTTP/1.1" 200 1234 "-" "Mozilla/5.0"'
);
```

### Extraction de donn√©es structur√©es

```sql
CREATE OR REPLACE FUNCTION extraire_infos_produit(description TEXT)
RETURNS TABLE(
    reference TEXT,
    prix NUMERIC,
    quantite INTEGER
) AS $$
    my $desc = shift;

    my ($ref, $prix, $qte);

    # Extraction de la r√©f√©rence (format: REF-XXXXX)
    if ($desc =~ /REF-(\w+)/) {
        $ref = $1;
    }

    # Extraction du prix (format: 123.45‚Ç¨ ou 123,45‚Ç¨)
    if ($desc =~ /([\d,\.]+)\s*‚Ç¨/) {
        $prix = $1;
        $prix =~ s/,/./;  # Remplacer virgule par point
    }

    # Extraction de la quantit√© (format: Qt√©: 10 ou x10)
    if ($desc =~ /(?:Qt√©|x)\s*[:=]?\s*(\d+)/i) {
        $qte = $1;
    }

    return_next({
        reference => $ref,
        prix => $prix,
        quantite => $qte
    });

    return undef;
$$ LANGUAGE plperlu;

SELECT * FROM extraire_infos_produit('Produit REF-A1234 √† 49,99‚Ç¨ - Qt√©: 25');
-- reference | prix  | quantite
-- A1234     | 49.99 | 25
```

### Nettoyage de texte

```sql
CREATE OR REPLACE FUNCTION nettoyer_texte(texte TEXT)
RETURNS TEXT AS $$
    my $texte = shift;

    # Supprimer les balises HTML
    $texte =~ s/<[^>]+>//g;

    # Supprimer les espaces multiples
    $texte =~ s/\s+/ /g;

    # Supprimer les espaces en d√©but/fin
    $texte =~ s/^\s+|\s+$//g;

    # Remplacer les entit√©s HTML courantes
    $texte =~ s/&nbsp;/ /g;
    $texte =~ s/&amp;/&/g;
    $texte =~ s/&lt;/</g;
    $texte =~ s/&gt;/>/g;
    $texte =~ s/&quot;/"/g;

    return $texte;
$$ LANGUAGE plperlu;

SELECT nettoyer_texte('<p>Texte   avec   &nbsp;  espaces &amp; balises</p>');
-- R√©sultat : "Texte avec espaces & balises"
```

---

## Manipulation de Tableaux et Structures

### Traitement de tableaux

```sql
CREATE OR REPLACE FUNCTION statistiques_tableau(valeurs INTEGER[])
RETURNS TABLE(
    moyenne NUMERIC,
    mediane NUMERIC,
    minimum INTEGER,
    maximum INTEGER,
    total INTEGER
) AS $$
    my $valeurs = shift;

    # D√©r√©f√©rencement du tableau
    my @array = @$valeurs;

    return_next({
        moyenne => undef,
        mediane => undef,
        minimum => undef,
        maximum => undef,
        total => 0
    }) unless @array;

    # Calculs
    my $somme = 0;
    $somme += $_ for @array;

    my @sorted = sort { $a <=> $b } @array;
    my $n = scalar @sorted;
    my $mediane = $n % 2 ? $sorted[$n/2] : ($sorted[$n/2-1] + $sorted[$n/2]) / 2;

    return_next({
        moyenne => $somme / $n,
        mediane => $mediane,
        minimum => $sorted[0],
        maximum => $sorted[-1],
        total => $somme
    });

    return undef;
$$ LANGUAGE plperlu;

SELECT * FROM statistiques_tableau(ARRAY[10, 20, 30, 40, 50]::INTEGER[]);
```

### Filtrage et transformation

```sql
CREATE OR REPLACE FUNCTION filtrer_pairs(valeurs INTEGER[])
RETURNS INTEGER[] AS $$
    my $valeurs = shift;
    my @array = @$valeurs;

    # Filtrage avec grep (√©quivalent de filter en Python)
    my @pairs = grep { $_ % 2 == 0 } @array;

    return \@pairs;
$$ LANGUAGE plperlu;

SELECT filtrer_pairs(ARRAY[1,2,3,4,5,6,7,8,9,10]);
-- R√©sultat : {2,4,6,8,10}
```

### Construction de hash (dictionnaire)

```sql
CREATE OR REPLACE FUNCTION compter_occurrences(mots TEXT[])
RETURNS TEXT AS $$
    my $mots = shift;
    my @array = @$mots;

    # Hash pour compter les occurrences
    my %compteur;
    $compteur{$_}++ for @array;

    # Construction du r√©sultat
    my @resultats;
    foreach my $mot (sort keys %compteur) {
        push @resultats, "$mot: $compteur{$mot}";
    }

    return join(", ", @resultats);
$$ LANGUAGE plperlu;

SELECT compter_occurrences(ARRAY['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']);
-- R√©sultat : "apple: 3, banana: 2, cherry: 1"
```

---

## Utilisation de Modules CPAN

L'un des avantages majeurs de PL/Perl (plperlu) est l'acc√®s aux modules CPAN.

### Modules pr√©install√©s courants

```sql
-- Test de disponibilit√© d'un module
CREATE OR REPLACE FUNCTION tester_module(nom_module TEXT)
RETURNS BOOLEAN AS $$
    my $module = shift;
    eval "require $module";
    return $@ ? 0 : 1;  # Retourne 0 si erreur, 1 si succ√®s
$$ LANGUAGE plperlu;

SELECT tester_module('DBI');
SELECT tester_module('JSON');
SELECT tester_module('Time::Piece');
```

### Manipulation JSON

```sql
CREATE OR REPLACE FUNCTION parser_json_perl(json_text TEXT)
RETURNS TABLE(cle TEXT, valeur TEXT) AS $$
    use JSON;

    my $json_text = shift;
    my $data = decode_json($json_text);

    # It√©ration sur les cl√©s
    foreach my $key (keys %$data) {
        return_next({
            cle => $key,
            valeur => $data->{$key}
        });
    }

    return undef;
$$ LANGUAGE plperlu;

SELECT * FROM parser_json_perl('{"nom": "Alice", "age": "30", "ville": "Paris"}');
```

### Manipulation de dates

```sql
CREATE OR REPLACE FUNCTION analyser_date(date_str TEXT)
RETURNS TABLE(
    date_formatee TEXT,
    jour_semaine TEXT,
    trimestre INTEGER,
    est_weekend BOOLEAN
) AS $$
    use Time::Piece;

    my $date_str = shift;
    my $t = Time::Piece->strptime($date_str, "%Y-%m-%d");

    # Analyse de la date
    my $jour_semaine = $t->fullday;
    my $trimestre = int(($t->mon - 1) / 3) + 1;
    my $est_weekend = ($t->wday == 0 || $t->wday == 6) ? 1 : 0;

    return_next({
        date_formatee => $t->strftime("%d/%m/%Y"),
        jour_semaine => $jour_semaine,
        trimestre => $trimestre,
        est_weekend => $est_weekend
    });

    return undef;
$$ LANGUAGE plperlu;

SELECT * FROM analyser_date('2025-11-22');
-- date_formatee | jour_semaine | trimestre | est_weekend
-- 22/11/2025    | Saturday     | 4         | TRUE
```

### Encodage/D√©codage Base64

```sql
CREATE OR REPLACE FUNCTION encoder_base64(texte TEXT)
RETURNS TEXT AS $$
    use MIME::Base64;

    my $texte = shift;
    return encode_base64($texte, '');  # '' pour pas de retours √† la ligne
$$ LANGUAGE plperlu;

CREATE OR REPLACE FUNCTION decoder_base64(encoded TEXT)
RETURNS TEXT AS $$
    use MIME::Base64;

    my $encoded = shift;
    return decode_base64($encoded);
$$ LANGUAGE plperlu;

SELECT encoder_base64('PostgreSQL avec Perl');
-- R√©sultat : "UG9zdGdyZVNRTCBhdmVjIFBlcmw="

SELECT decoder_base64('UG9zdGdyZVNRTCBhdmVjIFBlcmw=');
-- R√©sultat : "PostgreSQL avec Perl"
```

### G√©n√©ration UUID

```sql
CREATE OR REPLACE FUNCTION generer_uuid_perl()
RETURNS TEXT AS $$
    use Data::UUID;

    my $ug = Data::UUID->new;
    my $uuid = $ug->create_str();

    return $uuid;
$$ LANGUAGE plperlu;

SELECT generer_uuid_perl();
-- R√©sultat : "550e8400-e29b-41d4-a716-446655440000" (exemple)
```

---

## Ex√©cution de Requ√™tes SQL depuis Perl

Le module `spi_*` permet d'ex√©cuter des requ√™tes SQL depuis le code Perl.

### Ex√©cution simple

```sql
CREATE OR REPLACE FUNCTION compter_utilisateurs_perl()
RETURNS INTEGER AS $$
    # Ex√©cution d'une requ√™te
    my $rv = spi_exec_query("SELECT COUNT(*) as total FROM utilisateurs");

    # Acc√®s au r√©sultat
    return $rv->{rows}[0]->{total};
$$ LANGUAGE plperlu;
```

### Requ√™tes pr√©par√©es

```sql
CREATE OR REPLACE FUNCTION obtenir_utilisateur_par_id(user_id INTEGER)
RETURNS TABLE(id INTEGER, nom TEXT, email TEXT) AS $$
    my $user_id = shift;

    # Utilisation de quote_nullable pour s√©curit√©
    my $quoted_id = quote_nullable($user_id);

    # Meilleure approche : requ√™te pr√©par√©e
    my $plan = spi_prepare(
        'SELECT id, nom, email FROM utilisateurs WHERE id = $1',
        'INTEGER'
    );

    my $rv = spi_exec_prepared($plan, $user_id);

    foreach my $row (@{$rv->{rows}}) {
        return_next({
            id => $row->{id},
            nom => $row->{nom},
            email => $row->{email}
        });
    }

    return undef;
$$ LANGUAGE plperlu;
```

### Modification de donn√©es

```sql
CREATE OR REPLACE FUNCTION incrementer_compteur(cle TEXT)
RETURNS INTEGER AS $$
    my $cle = shift;

    # V√©rifier si la cl√© existe
    my $check_plan = spi_prepare(
        'SELECT valeur FROM compteurs WHERE cle = $1',
        'TEXT'
    );
    my $check_rv = spi_exec_prepared($check_plan, $cle);

    if ($check_rv->{processed} > 0) {
        # Mise √† jour
        my $update_plan = spi_prepare(
            'UPDATE compteurs SET valeur = valeur + 1 WHERE cle = $1 RETURNING valeur',
            'TEXT'
        );
        my $update_rv = spi_exec_prepared($update_plan, $cle);
        return $update_rv->{rows}[0]->{valeur};
    } else {
        # Insertion
        my $insert_plan = spi_prepare(
            'INSERT INTO compteurs (cle, valeur) VALUES ($1, 1) RETURNING valeur',
            'TEXT'
        );
        my $insert_rv = spi_exec_prepared($insert_plan, $cle);
        return $insert_rv->{rows}[0]->{valeur};
    }
$$ LANGUAGE plperlu;
```

---

## Fonctions Retournant Plusieurs Lignes

### M√©thode return_next

```sql
CREATE OR REPLACE FUNCTION generer_serie_perl(debut INTEGER, fin INTEGER)
RETURNS SETOF INTEGER AS $$
    my ($debut, $fin) = @_;

    for (my $i = $debut; $i <= $fin; $i++) {
        return_next($i);
    }

    return undef;
$$ LANGUAGE plperlu;

SELECT * FROM generer_serie_perl(1, 5);
-- 1
-- 2
-- 3
-- 4
-- 5
```

### Table complexe

```sql
CREATE OR REPLACE FUNCTION analyser_texte(texte TEXT)
RETURNS TABLE(
    type_element TEXT,
    valeur TEXT,
    position INTEGER
) AS $$
    my $texte = shift;
    my $pos = 0;

    # Extraction des emails
    while ($texte =~ /([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/g) {
        return_next({
            type_element => 'email',
            valeur => $1,
            position => pos($texte) - length($1)
        });
    }

    # Extraction des URLs
    while ($texte =~ /(https?:\/\/[^\s]+)/g) {
        return_next({
            type_element => 'url',
            valeur => $1,
            position => pos($texte) - length($1)
        });
    }

    # Extraction des hashtags
    while ($texte =~ /#(\w+)/g) {
        return_next({
            type_element => 'hashtag',
            valeur => $1,
            position => pos($texte) - length($1) - 1
        });
    }

    return undef;
$$ LANGUAGE plperlu;

SELECT * FROM analyser_texte('Visitez https://postgresql.org et contactez admin@example.com #PostgreSQL');
```

---

## Gestion des Erreurs

### Lever des exceptions

```sql
CREATE OR REPLACE FUNCTION diviser_perl(a NUMERIC, b NUMERIC)
RETURNS NUMERIC AS $$
    my ($a, $b) = @_;

    if ($b == 0) {
        elog(ERROR, "Division par z√©ro interdite");
    }

    return $a / $b;
$$ LANGUAGE plperlu;
```

### Niveaux de messages

```sql
CREATE OR REPLACE FUNCTION demo_messages_perl(valeur INTEGER)
RETURNS TEXT AS $$
    my $valeur = shift;

    # DEBUG : Message de d√©bogage
    elog(DEBUG, "Valeur re√ßue: $valeur");

    # INFO : Message informatif
    elog(INFO, "Traitement en cours...");

    # NOTICE : Notification
    elog(NOTICE, "Valeur valid√©e");

    # WARNING : Avertissement
    if ($valeur > 100) {
        elog(WARNING, "Valeur √©lev√©e d√©tect√©e: $valeur");
    }

    # ERROR : Erreur (arr√™te l'ex√©cution)
    if ($valeur < 0) {
        elog(ERROR, "Valeur n√©gative non autoris√©e");
    }

    return "Traitement r√©ussi";
$$ LANGUAGE plperlu;
```

### Gestion avec eval

```sql
CREATE OR REPLACE FUNCTION operation_securisee(operation TEXT)
RETURNS TEXT AS $$
    my $operation = shift;

    my $result;
    eval {
        # Code potentiellement dangereux
        $result = eval $operation;
    };

    if ($@) {
        elog(WARNING, "Erreur lors de l'√©valuation: $@");
        return "ERREUR";
    }

    return "R√©sultat: $result";
$$ LANGUAGE plperlu;
```

---

## Variables Globales et √âtat Partag√©

### Variables globales

PL/Perl maintient des variables globales entre les appels de fonction dans la m√™me session.

```sql
CREATE OR REPLACE FUNCTION compteur_appels()
RETURNS INTEGER AS $$
    use vars qw(%_SHARED);

    # Variable globale partag√©e entre les appels
    $_SHARED{compteur} = 0 unless defined $_SHARED{compteur};
    $_SHARED{compteur}++;

    return $_SHARED{compteur};
$$ LANGUAGE plperlu;

-- Premier appel
SELECT compteur_appels();  -- R√©sultat : 1

-- Deuxi√®me appel dans la m√™me session
SELECT compteur_appels();  -- R√©sultat : 2
```

### Cache de donn√©es

```sql
CREATE OR REPLACE FUNCTION cache_config(cle TEXT, valeur TEXT)
RETURNS TEXT AS $$
    use vars qw(%_SHARED);

    my ($cle, $valeur) = @_;

    # Initialisation du cache
    $_SHARED{config_cache} = {} unless defined $_SHARED{config_cache};

    if (defined $valeur) {
        # Stockage dans le cache
        $_SHARED{config_cache}{$cle} = $valeur;
        return "Stock√©: $cle = $valeur";
    } else {
        # Lecture du cache
        if (exists $_SHARED{config_cache}{$cle}) {
            return $_SHARED{config_cache}{$cle};
        } else {
            return undef;
        }
    }
$$ LANGUAGE plperlu;

-- Stockage
SELECT cache_config('app.version', '1.0.0');

-- Lecture
SELECT cache_config('app.version', NULL);
-- R√©sultat : "1.0.0"
```

---

## Cas d'Usage Avanc√©s

### 1. Parsing de fichiers CSV

```sql
CREATE OR REPLACE FUNCTION parser_csv_ligne(ligne TEXT, separateur TEXT DEFAULT ',')
RETURNS TEXT[] AS $$
    use Text::CSV;

    my ($ligne, $sep) = @_;
    $sep = ',' unless defined $sep;

    my $csv = Text::CSV->new({ sep_char => $sep });

    if ($csv->parse($ligne)) {
        my @fields = $csv->fields();
        return \@fields;
    } else {
        elog(ERROR, "Erreur de parsing CSV: " . $csv->error_diag());
    }
$$ LANGUAGE plperlu;

SELECT parser_csv_ligne('John,Doe,30,New York', ',');
-- R√©sultat : {John,Doe,30,"New York"}
```

### 2. G√©n√©ration de slugs URL

```sql
CREATE OR REPLACE FUNCTION generer_slug(titre TEXT)
RETURNS TEXT AS $$
    my $titre = shift;

    # Conversion en minuscules
    $titre = lc($titre);

    # Remplacement des accents
    $titre =~ tr/√†√°√¢√£√§√•√ß√®√©√™√´√¨√≠√Æ√Ø√±√≤√≥√¥√µ√∂√π√∫√ª√º√Ω√ø/aaaaaaceeeeiiiinooooouuuuyy/;

    # Remplacement des caract√®res non alphanum√©riques par des tirets
    $titre =~ s/[^a-z0-9]+/-/g;

    # Suppression des tirets en d√©but/fin
    $titre =~ s/^-+|-+$//g;

    return $titre;
$$ LANGUAGE plperlu;

SELECT generer_slug('Ma√Ætriser PostgreSQL 18 : Guide Complet !');
-- R√©sultat : "maitriser-postgresql-18-guide-complet"
```

### 3. Extraction d'informations de User-Agent

```sql
CREATE OR REPLACE FUNCTION parser_user_agent(ua TEXT)
RETURNS TABLE(
    navigateur TEXT,
    version TEXT,
    os TEXT,
    est_mobile BOOLEAN
) AS $$
    my $ua = shift;

    my ($browser, $version, $os);
    my $mobile = 0;

    # D√©tection du navigateur
    if ($ua =~ /Firefox\/(\S+)/) {
        $browser = "Firefox";
        $version = $1;
    } elsif ($ua =~ /Chrome\/(\S+)/) {
        $browser = "Chrome";
        $version = $1;
    } elsif ($ua =~ /Safari\/(\S+)/) {
        $browser = "Safari";
        $version = $1;
    } elsif ($ua =~ /MSIE (\S+)/) {
        $browser = "Internet Explorer";
        $version = $1;
    }

    # D√©tection de l'OS
    if ($ua =~ /Windows/) {
        $os = "Windows";
    } elsif ($ua =~ /Mac OS X/) {
        $os = "MacOS";
    } elsif ($ua =~ /Linux/) {
        $os = "Linux";
    } elsif ($ua =~ /Android/) {
        $os = "Android";
        $mobile = 1;
    } elsif ($ua =~ /iPhone|iPad/) {
        $os = "iOS";
        $mobile = 1;
    }

    return_next({
        navigateur => $browser,
        version => $version,
        os => $os,
        est_mobile => $mobile
    });

    return undef;
$$ LANGUAGE plperlu;

SELECT * FROM parser_user_agent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0 Safari/537.36');
```

### 4. Validation et nettoyage de donn√©es

```sql
CREATE OR REPLACE FUNCTION nettoyer_numero_telephone(numero TEXT)
RETURNS TEXT AS $$
    my $numero = shift;

    # Suppression de tous les caract√®res non num√©riques
    $numero =~ s/\D//g;

    # Validation longueur (France : 10 chiffres)
    return undef unless length($numero) == 10;

    # V√©rification que √ßa commence par 0
    return undef unless $numero =~ /^0/;

    # Formatage : 01 23 45 67 89
    $numero =~ s/^(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})$/$1 $2 $3 $4 $5/;

    return $numero;
$$ LANGUAGE plperlu;

SELECT nettoyer_numero_telephone('01.23.45.67.89');
-- R√©sultat : "01 23 45 67 89"

SELECT nettoyer_numero_telephone('+33 1 23 45 67 89');
-- R√©sultat : NULL (car > 10 chiffres apr√®s nettoyage)
```

---

## Bonnes Pratiques

### 1. S√©curit√©

**Toujours utiliser spi_prepare pour les requ√™tes SQL** :

```sql
-- ‚ùå DANGEREUX - Injection SQL
CREATE OR REPLACE FUNCTION recherche_danger(nom TEXT)
RETURNS INTEGER AS $$
    my $nom = shift;
    my $query = "SELECT COUNT(*) as cnt FROM users WHERE nom = '$nom'";
    my $rv = spi_exec_query($query);
    return $rv->{rows}[0]->{cnt};
$$ LANGUAGE plperlu;

-- ‚úÖ S√âCURIS√â - Requ√™te pr√©par√©e
CREATE OR REPLACE FUNCTION recherche_securisee(nom TEXT)
RETURNS INTEGER AS $$
    my $nom = shift;
    my $plan = spi_prepare('SELECT COUNT(*) as cnt FROM users WHERE nom = $1', 'TEXT');
    my $rv = spi_exec_prepared($plan, $nom);
    return $rv->{rows}[0]->{cnt};
$$ LANGUAGE plperlu;
```

### 2. Performance

**Optimiser les expressions r√©guli√®res** :

```sql
-- Compiler les regex fr√©quentes
CREATE OR REPLACE FUNCTION valider_format(texte TEXT, pattern TEXT)
RETURNS BOOLEAN AS $$
    use vars qw(%_SHARED);

    my ($texte, $pattern) = @_;

    # Cache des regex compil√©es
    unless (exists $_SHARED{regex_cache}{$pattern}) {
        $_SHARED{regex_cache}{$pattern} = qr/$pattern/;
    }

    my $regex = $_SHARED{regex_cache}{$pattern};
    return $texte =~ $regex ? 1 : 0;
$$ LANGUAGE plperlu;
```

### 3. Code lisible

**Utiliser des variables nomm√©es** :

```sql
-- ‚ùå Moins lisible
CREATE OR REPLACE FUNCTION calcul_remise_mauvais(prix NUMERIC, pct NUMERIC)
RETURNS NUMERIC AS $$
    return $_[0] * (1 - $_[1] / 100);
$$ LANGUAGE plperlu;

-- ‚úÖ Plus lisible
CREATE OR REPLACE FUNCTION calcul_remise_bon(prix NUMERIC, pct NUMERIC)
RETURNS NUMERIC AS $$
    my ($prix, $pourcentage) = @_;
    my $remise = $prix * ($pourcentage / 100);
    my $prix_final = $prix - $remise;
    return $prix_final;
$$ LANGUAGE plperlu;
```

### 4. Gestion d'erreurs

**Toujours valider les entr√©es** :

```sql
CREATE OR REPLACE FUNCTION fonction_robuste(valeur TEXT)
RETURNS TEXT AS $$
    my $valeur = shift;

    # Validation des entr√©es
    return undef unless defined $valeur;
    return undef if $valeur eq '';

    # Traitement avec gestion d'erreur
    my $result;
    eval {
        $result = uc($valeur);
    };

    if ($@) {
        elog(WARNING, "Erreur de traitement: $@");
        return undef;
    }

    return $result;
$$ LANGUAGE plperlu;
```

### 5. Documentation

```sql
CREATE OR REPLACE FUNCTION fonction_documentee(param TEXT)
RETURNS TEXT AS $$
    # Description : Cette fonction fait XYZ
    #
    # Arguments :
    #   param (TEXT) : Description du param√®tre
    #
    # Retourne :
    #   TEXT : Description du retour
    #
    # Exemple :
    #   SELECT fonction_documentee('test');
    #
    # Notes :
    #   - Point important 1
    #   - Point important 2

    my $param = shift;
    return uc($param);
$$ LANGUAGE plperlu;

-- Commentaire PostgreSQL
COMMENT ON FUNCTION fonction_documentee(TEXT) IS
'Convertit le texte en majuscules avec validation';
```

---

## Limitations et Consid√©rations

### 1. Limitations techniques

- **Performance** : Plus lent que PL/pgSQL pour les op√©rations SQL simples
- **M√©moire** : Charge m√©moire plus importante
- **Pas de parall√©lisation** : Les fonctions ne peuvent pas √™tre parall√©lis√©es
- **Interpr√©teur unique** : Un seul par backend PostgreSQL

### 2. S√©curit√©

- **plperlu est "untrusted"** : Acc√®s complet au syst√®me de fichiers
- **Privil√®ges superutilisateur** : N√©cessaires pour cr√©er des fonctions
- **Modules CPAN** : Attention aux d√©pendances et vuln√©rabilit√©s
- **Ex√©cution de code** : Risque si les entr√©es ne sont pas valid√©es

### 3. Maintenance

- **D√©pendances CPAN** : Peuvent n√©cessiter des installations syst√®me
- **Portabilit√©** : D√©pend de la version Perl et des modules install√©s
- **Tests** : Plus complexes que pour du SQL pur
- **D√©bogage** : Moins d'outils natifs

### 4. Perl vs Python

| Crit√®re | Perl | Python |
|---------|------|--------|
| **Regex** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellent | ‚≠ê‚≠ê‚≠ê Bon |
| **Manipulation texte** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellent | ‚≠ê‚≠ê‚≠ê‚≠ê Tr√®s bon |
| **Lisibilit√©** | ‚≠ê‚≠ê‚≠ê Bonne | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellente |
| **√âcosyst√®me moderne** | ‚≠ê‚≠ê‚≠ê CPAN | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê PyPI |
| **Communaut√©** | ‚≠ê‚≠ê‚≠ê Mature | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Tr√®s active |

---

## Quand Utiliser PL/Perl ?

### ‚úÖ Cas d'usage recommand√©s

1. **Traitement de texte complexe**
   - Parsing de logs
   - Extraction de donn√©es non structur√©es
   - Nettoyage et transformation de texte

2. **Expressions r√©guli√®res avanc√©es**
   - Validation de formats complexes
   - Extraction de patterns sophistiqu√©s
   - Recherche et remplacement multiples

3. **Manipulation de formats propri√©taires**
   - CSV, XML personnalis√©s
   - Formats legacy
   - Parsing de fichiers de configuration

4. **Int√©gration de code existant**
   - R√©utilisation de biblioth√®ques Perl
   - Migration de scripts Perl
   - Compatibilit√© avec syst√®mes legacy

5. **Acc√®s CPAN sp√©cifique**
   - Modules Perl uniques
   - Fonctionnalit√©s non disponibles en Python
   - Compatibilit√© avec outils Perl

### ‚ùå Cas d'usage d√©conseill√©s

1. **Op√©rations SQL intensives**
   - Privil√©gier PL/pgSQL
   - Meilleure int√©gration native

2. **Projets n√©cessitant une large √©quipe**
   - Perl moins populaire aujourd'hui
   - Difficult√© de recrutement
   - Courbe d'apprentissage

3. **Applications modernes**
   - Python plus moderne
   - Meilleur support IA/ML
   - √âcosyst√®me plus actif

---

## Comparaison Finale : PL/pgSQL vs PL/Perl vs PL/Python

```sql
-- PL/pgSQL : Le natif
CREATE OR REPLACE FUNCTION exemple_plpgsql(texte TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN upper(texte);
END;
$$ LANGUAGE plpgsql;

-- PL/Perl : Le sp√©cialiste texte/regex
CREATE OR REPLACE FUNCTION exemple_plperl(texte TEXT)
RETURNS TEXT AS $$
    my $texte = shift;
    $texte =~ s/\s+/ /g;  # Nettoyage espaces
    return uc($texte);    # Majuscules
$$ LANGUAGE plperlu;

-- PL/Python : Le moderne
CREATE OR REPLACE FUNCTION exemple_plpython(texte TEXT)
RETURNS TEXT AS $$
    import re
    texte = re.sub(r'\s+', ' ', texte)
    return texte.upper()
$$ LANGUAGE plpython3u;
```

**Recommandations** :
- **PL/pgSQL** : Par d√©faut pour toute logique SQL
- **PL/Perl** : Pour regex complexes et parsing texte intensif
- **PL/Python** : Pour logique m√©tier moderne et int√©grations

---

## Ressources et Documentation

### Documentation officielle

- **PostgreSQL PL/Perl** : https://www.postgresql.org/docs/current/plperl.html
- **Perl 5 Documentation** : https://perldoc.perl.org/
- **CPAN** : https://metacpan.org/

### Modules CPAN utiles

- **Text::CSV** : Manipulation CSV
- **JSON** : Parsing/g√©n√©ration JSON
- **Time::Piece** : Manipulation dates
- **LWP::UserAgent** : Requ√™tes HTTP
- **DBI** : Interface bases de donn√©es
- **XML::Simple** : Parsing XML
- **Digest::SHA** : Hash et cryptographie
- **MIME::Base64** : Encodage/d√©codage

### Livres recommand√©s

- "Programming Perl" (Larry Wall) - La r√©f√©rence
- "Mastering Regular Expressions" (Jeffrey Friedl)
- "Perl Best Practices" (Damian Conway)

---

## R√©sum√©

**PL/Perl (plperlu)** est un langage proc√©dural puissant qui :

‚úÖ **Forces** :
- Expressions r√©guli√®res incomparables
- Manipulation de texte exceptionnelle
- Acc√®s complet √† CPAN
- Excellent pour parsing et transformation
- Code Perl r√©utilisable

‚ùå **Faiblesses** :
- Moins populaire que Python aujourd'hui
- Syntaxe consid√©r√©e comme complexe
- Performance inf√©rieure √† PL/pgSQL pour SQL pur
- Communaut√© plus petite
- Maintenance plus difficile

**Verdict** : Utilisez PL/Perl quand vous avez besoin de ses forces uniques (regex, texte), sinon pr√©f√©rez PL/pgSQL (natif) ou PL/Python (moderne).

---


‚è≠Ô∏è [PL/v8 (JavaScript) - mention](/15-programmation-serveur/07.3-plv8.md)
