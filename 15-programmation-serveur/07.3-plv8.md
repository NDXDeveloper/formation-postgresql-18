üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.7.3. PL/v8 (JavaScript) - Introduction

## Introduction √† PL/v8

**PL/v8** est un langage proc√©dural pour PostgreSQL qui permet d'√©crire des fonctions et des proc√©dures stock√©es en JavaScript. Il utilise le moteur JavaScript V8 de Google (le m√™me qui propulse Chrome et Node.js), offrant ainsi une performance exceptionnelle et un langage moderne tr√®s populaire.

### Qu'est-ce que JavaScript et V8 ?

**JavaScript** est le langage de programmation le plus utilis√© au monde, initialement cr√©√© pour les navigateurs web mais d√©sormais omnipr√©sent (frontend, backend avec Node.js, mobile, desktop).

**V8** est le moteur JavaScript open-source d√©velopp√© par Google, connu pour :
- **Performance exceptionnelle** : Compilation JIT (Just-In-Time)
- **Optimisations avanc√©es** : Garbage collection efficace
- **Standard ECMAScript** : Support des derni√®res fonctionnalit√©s JavaScript
- **√âcosyst√®me npm** : Acc√®s √† des millions de packages

### Pourquoi utiliser PL/v8 ?

‚úÖ **Avantages principaux** :

1. **Langage moderne et populaire**
   - JavaScript est le langage le plus utilis√© au monde
   - Syntaxe claire et accessible
   - Large communaut√© de d√©veloppeurs

2. **Performance excellente**
   - Moteur V8 ultra-optimis√©
   - JIT compilation
   - Meilleure performance que Python ou Perl

3. **Manipulation JSON native**
   - JavaScript et JSON sont naturellement li√©s
   - Manipulation triviale des donn√©es JSONB
   - Parfait pour les APIs REST/GraphQL

4. **√âcosyst√®me npm**
   - Millions de packages disponibles
   - R√©utilisation de code existant
   - Biblioth√®ques modernes

5. **Comp√©tences transf√©rables**
   - M√™me langage que le frontend
   - M√™me langage que Node.js backend
   - Stack JavaScript unifi√©

### PL/v8 vs PL/pgSQL vs PL/Python vs PL/Perl

| Aspect | PL/pgSQL | PL/v8 | PL/Python | PL/Perl |
|--------|----------|-------|-----------|---------|
| **Performance SQL** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **Performance g√©n√©rale** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **Manipulation JSON** | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **Popularit√©** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê |
| **Courbe apprentissage** | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê |
| **√âcosyst√®me** | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê npm | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê pip | ‚≠ê‚≠ê‚≠ê‚≠ê CPAN |

---

## Installation et Configuration

### ‚ö†Ô∏è Important : Extension externe

**PL/v8 n'est PAS inclus par d√©faut dans PostgreSQL**. C'est une extension tierce qui n√©cessite une installation s√©par√©e.

### Installation sur diff√©rents syst√®mes

#### Ubuntu/Debian

```bash
# Installation depuis les d√©p√¥ts
sudo apt-get update
sudo apt-get install postgresql-15-plv8

# V√©rifier l'installation
dpkg -l | grep plv8
```

#### Red Hat/CentOS/Fedora

```bash
# Installation depuis PGDG
sudo yum install plv8_15

# Ou avec dnf
sudo dnf install plv8_15
```

#### macOS avec Homebrew

```bash
# PostgreSQL avec PL/v8
brew install plv8
```

#### Docker

```dockerfile
# Utiliser une image avec PL/v8 pr√©install√©
FROM postgres:15
RUN apt-get update && apt-get install -y postgresql-15-plv8
```

### Activation de l'extension

```sql
-- En tant que superutilisateur
CREATE EXTENSION plv8;

-- V√©rifier la version
SELECT extversion FROM pg_extension WHERE extname = 'plv8';
-- R√©sultat : "3.1.7" (exemple)
```

### V√©rification de l'installation

```sql
CREATE OR REPLACE FUNCTION test_plv8()
RETURNS text AS $$
    return "PL/v8 fonctionne ! Version V8: " + version();
$$ LANGUAGE plv8 IMMUTABLE STRICT;

SELECT test_plv8();
-- R√©sultat : "PL/v8 fonctionne ! Version V8: 11.4.183.11"
```

---

## Anatomie d'une Fonction PL/v8

### Structure de base

```sql
CREATE OR REPLACE FUNCTION nom_fonction(param1 type1, param2 type2)
RETURNS type_retour AS $$
    // Code JavaScript ici
    // Les param√®tres sont directement accessibles comme variables
    let result = param1 + param2;
    return result;
$$ LANGUAGE plv8 IMMUTABLE STRICT;
```

### √âl√©ments cl√©s

1. **D√©limiteurs `$$`** : Encadrent le code JavaScript
2. **Variables directes** : Les param√®tres sont des variables JavaScript
3. **Syntaxe moderne** : Support ES6+ (const, let, arrow functions, etc.)
4. **Instruction `return`** : Retourne la valeur √† PostgreSQL
5. **Clause `LANGUAGE plv8`** : Sp√©cifie le langage
6. **Options** :
   - `IMMUTABLE` : R√©sultat ne change jamais pour les m√™mes entr√©es
   - `STABLE` : R√©sultat constant dans une transaction
   - `VOLATILE` : Peut changer √† chaque appel
   - `STRICT` : Retourne NULL si un param√®tre est NULL

### Syntaxe JavaScript moderne (ES6+)

```sql
CREATE OR REPLACE FUNCTION demo_es6(texte text, multiplicateur int)
RETURNS text AS $$
    // Utilisation de const et let (ES6)
    const prefixe = "R√©sultat: ";
    let resultat = "";

    // Template literals (ES6)
    resultat = `${prefixe}${texte}`;

    // Arrow functions (ES6)
    const repeter = (str, n) => str.repeat(n);

    // M√©thodes modernes
    return repeter(resultat + " ", multiplicateur).trim();
$$ LANGUAGE plv8 IMMUTABLE STRICT;

SELECT demo_es6('Hello', 3);
-- R√©sultat : "R√©sultat: Hello R√©sultat: Hello R√©sultat: Hello"
```

---

## Types de Donn√©es : PostgreSQL ‚Üî JavaScript

### Conversion automatique

PL/v8 convertit automatiquement les types entre PostgreSQL et JavaScript :

| Type PostgreSQL | Type JavaScript | Exemple | Notes |
|----------------|----------------|---------|-------|
| `INTEGER`, `BIGINT` | `number` | `42` | Attention aux limites |
| `NUMERIC`, `DECIMAL` | `string` | `"123.45"` | √âvite perte pr√©cision |
| `REAL`, `DOUBLE` | `number` | `3.14` | Float JavaScript |
| `TEXT`, `VARCHAR` | `string` | `"Hello"` | UTF-8 |
| `BOOLEAN` | `boolean` | `true`, `false` | |
| `DATE` | `Date` | `new Date()` | Objet Date |
| `TIMESTAMP` | `Date` | `new Date()` | Avec temps |
| `JSON`, `JSONB` | `object` ou `array` | `{key: "value"}` | **Natif !** |
| `ARRAY` | `Array` | `[1, 2, 3]` | Tableau JS |
| `NULL` | `null` ou `undefined` | `null` | |

### Exemple de conversion

```sql
CREATE OR REPLACE FUNCTION demo_types(
    un_entier int,
    un_texte text,
    une_date date,
    un_json jsonb,
    un_tableau int[]
)
RETURNS jsonb AS $$
    // Tous les types sont automatiquement convertis

    // un_entier est un number
    const double = un_entier * 2;

    // un_texte est un string
    const majuscules = un_texte.toUpperCase();

    // une_date est un objet Date
    const annee = une_date.getFullYear();

    // un_json est un objet JavaScript natif
    const nom = un_json.nom;

    // un_tableau est un Array
    const somme = un_tableau.reduce((acc, val) => acc + val, 0);

    // Retour d'un objet JavaScript (converti en JSONB)
    return {
        double: double,
        texte: majuscules,
        annee: annee,
        nom_json: nom,
        somme: somme
    };
$$ LANGUAGE plv8 IMMUTABLE STRICT;

-- Utilisation
SELECT demo_types(
    10,
    'postgresql',
    '2025-11-22'::date,
    '{"nom": "Alice", "age": 30}'::jsonb,
    ARRAY[1,2,3,4,5]
);
-- R√©sultat : {"double": 20, "texte": "POSTGRESQL", "annee": 2025, "nom_json": "Alice", "somme": 15}
```

---

## Fonctions Simples : Exemples Pratiques

### Exemple 1 : Calcul math√©matique

```sql
CREATE OR REPLACE FUNCTION calculer_tva(prix_ht numeric, taux_tva numeric)
RETURNS numeric AS $$
    // Conversion string -> number pour calculs
    const ht = parseFloat(prix_ht);
    const taux = parseFloat(taux_tva);

    const tva = ht * (taux / 100);
    const ttc = ht + tva;

    // Arrondir √† 2 d√©cimales
    return Math.round(ttc * 100) / 100;
$$ LANGUAGE plv8 IMMUTABLE STRICT;

SELECT calculer_tva(100.00, 20.0);
-- R√©sultat : 120.00
```

### Exemple 2 : Manipulation de texte

```sql
CREATE OR REPLACE FUNCTION formater_nom_complet(prenom text, nom text)
RETURNS text AS $$
    // M√©thodes JavaScript natives
    const prenomFormat = prenom.trim().charAt(0).toUpperCase() +
                         prenom.trim().slice(1).toLowerCase();
    const nomFormat = nom.trim().toUpperCase();

    return `${prenomFormat} ${nomFormat}`;
$$ LANGUAGE plv8 IMMUTABLE STRICT;

SELECT formater_nom_complet('  jean  ', '  dupont  ');
-- R√©sultat : "Jean DUPONT"
```

### Exemple 3 : Validation avec regex

```sql
CREATE OR REPLACE FUNCTION valider_email(email text)
RETURNS boolean AS $$
    if (!email) return false;

    // Regex JavaScript native
    const pattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    return pattern.test(email);
$$ LANGUAGE plv8 IMMUTABLE STRICT;

SELECT valider_email('user@example.com');  -- TRUE
SELECT valider_email('invalid.email');      -- FALSE
```

---

## Manipulation JSON : Le Point Fort de PL/v8

JavaScript et JSON sont naturellement li√©s, ce qui fait de PL/v8 le choix id√©al pour manipuler des donn√©es JSONB.

### Extraction et navigation

```sql
CREATE OR REPLACE FUNCTION extraire_infos_utilisateur(data jsonb)
RETURNS table(nom text, age int, ville text) AS $$
    // data est un objet JavaScript natif !
    const nom = data.nom || 'Inconnu';
    const age = data.age || 0;

    // Navigation dans des objets imbriqu√©s
    const ville = data.adresse?.ville || 'Non sp√©cifi√©e';  // Optional chaining ES2020

    return [{
        nom: nom,
        age: age,
        ville: ville
    }];
$$ LANGUAGE plv8 IMMUTABLE STRICT;

SELECT * FROM extraire_infos_utilisateur('
{
    "nom": "Alice Dubois",
    "age": 30,
    "adresse": {
        "ville": "Paris",
        "code_postal": "75001"
    }
}'::jsonb);
```

### Transformation JSON

```sql
CREATE OR REPLACE FUNCTION transformer_utilisateur(user_json jsonb)
RETURNS jsonb AS $$
    // Manipulation directe d'objets JavaScript
    const user = JSON.parse(JSON.stringify(user_json)); // Deep copy

    // Ajout de champs calcul√©s
    user.nom_complet = `${user.prenom} ${user.nom}`;
    user.majeur = user.age >= 18;

    // Transformation de date
    if (user.date_naissance) {
        const date = new Date(user.date_naissance);
        user.annee_naissance = date.getFullYear();
    }

    // Filtrage de champs sensibles
    delete user.mot_de_passe;
    delete user.numero_carte;

    return user;
$$ LANGUAGE plv8 IMMUTABLE STRICT;

SELECT transformer_utilisateur('{
    "prenom": "Marie",
    "nom": "Martin",
    "age": 25,
    "date_naissance": "1999-05-15",
    "mot_de_passe": "secret123"
}'::jsonb);
```

### Agr√©gation et filtrage

```sql
CREATE OR REPLACE FUNCTION filtrer_produits_actifs(produits jsonb)
RETURNS jsonb AS $$
    // produits est un array JavaScript
    const actifs = produits.filter(p => p.actif === true);

    // Transformation avec map
    const simplifie = actifs.map(p => ({
        id: p.id,
        nom: p.nom,
        prix: p.prix
    }));

    // Tri
    simplifie.sort((a, b) => a.prix - b.prix);

    return simplifie;
$$ LANGUAGE plv8 IMMUTABLE STRICT;

SELECT filtrer_produits_actifs('[
    {"id": 1, "nom": "Produit A", "prix": 50, "actif": true},
    {"id": 2, "nom": "Produit B", "prix": 30, "actif": false},
    {"id": 3, "nom": "Produit C", "prix": 40, "actif": true}
]'::jsonb);
-- R√©sultat : [{"id":3,"nom":"Produit C","prix":40},{"id":1,"nom":"Produit A","prix":50}]
```

### Validation de sch√©ma JSON

```sql
CREATE OR REPLACE FUNCTION valider_schema_utilisateur(data jsonb)
RETURNS table(valide boolean, erreurs text[]) AS $$
    const erreurs = [];

    // Validation des champs requis
    if (!data.nom || typeof data.nom !== 'string') {
        erreurs.push("Le champ 'nom' est requis et doit √™tre une cha√Æne");
    }

    if (!data.email || typeof data.email !== 'string') {
        erreurs.push("Le champ 'email' est requis");
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(data.email)) {
        erreurs.push("Format d'email invalide");
    }

    if (data.age !== undefined) {
        if (typeof data.age !== 'number' || data.age < 0 || data.age > 150) {
            erreurs.push("L'√¢ge doit √™tre un nombre entre 0 et 150");
        }
    }

    return [{
        valide: erreurs.length === 0,
        erreurs: erreurs
    }];
$$ LANGUAGE plv8 IMMUTABLE STRICT;

SELECT * FROM valider_schema_utilisateur('{"nom": "Jean", "email": "invalide", "age": -5}'::jsonb);
```

---

## Fonctions Avanc√©es JavaScript

### M√©thodes Array modernes

```sql
CREATE OR REPLACE FUNCTION analyser_ventes(ventes jsonb)
RETURNS jsonb AS $$
    // Utilisation des m√©thodes ES6
    const total = ventes.reduce((sum, v) => sum + v.montant, 0);
    const moyenne = total / ventes.length;

    // Filter et map
    const ventesSup100 = ventes
        .filter(v => v.montant > 100)
        .map(v => v.produit);

    // Find
    const maxVente = ventes.reduce((max, v) =>
        v.montant > max.montant ? v : max
    );

    // Some et Every
    const toutesPayees = ventes.every(v => v.payee === true);
    const auMoinsUneRemise = ventes.some(v => v.remise > 0);

    return {
        total: total,
        moyenne: moyenne,
        produits_sup_100: ventesSup100,
        vente_max: maxVente,
        toutes_payees: toutesPayees,
        au_moins_une_remise: auMoinsUneRemise
    };
$$ LANGUAGE plv8 IMMUTABLE STRICT;
```

### Destructuring et spread operator

```sql
CREATE OR REPLACE FUNCTION fusionner_objets(obj1 jsonb, obj2 jsonb)
RETURNS jsonb AS $$
    // Spread operator ES6
    const resultat = {
        ...obj1,
        ...obj2,
        fusionneA: new Date().toISOString()
    };

    return resultat;
$$ LANGUAGE plv8 IMMUTABLE STRICT;

SELECT fusionner_objets(
    '{"nom": "Alice", "age": 30}'::jsonb,
    '{"ville": "Paris", "age": 31}'::jsonb
);
-- R√©sultat : {"nom":"Alice","age":31,"ville":"Paris","fusionneA":"2025-11-22T..."}
```

### Classes ES6

```sql
CREATE OR REPLACE FUNCTION calculer_geometrie(forme text, params jsonb)
RETURNS jsonb AS $$
    class Forme {
        constructor(type) {
            this.type = type;
        }
    }

    class Rectangle extends Forme {
        constructor(largeur, hauteur) {
            super('rectangle');
            this.largeur = largeur;
            this.hauteur = hauteur;
        }

        aire() {
            return this.largeur * this.hauteur;
        }

        perimetre() {
            return 2 * (this.largeur + this.hauteur);
        }
    }

    class Cercle extends Forme {
        constructor(rayon) {
            super('cercle');
            this.rayon = rayon;
        }

        aire() {
            return Math.PI * this.rayon * this.rayon;
        }

        perimetre() {
            return 2 * Math.PI * this.rayon;
        }
    }

    let objet;
    if (forme === 'rectangle') {
        objet = new Rectangle(params.largeur, params.hauteur);
    } else if (forme === 'cercle') {
        objet = new Cercle(params.rayon);
    } else {
        return {erreur: "Forme inconnue"};
    }

    return {
        type: objet.type,
        aire: objet.aire(),
        perimetre: objet.perimetre()
    };
$$ LANGUAGE plv8 IMMUTABLE STRICT;

SELECT calculer_geometrie('rectangle', '{"largeur": 5, "hauteur": 3}'::jsonb);
-- R√©sultat : {"type":"rectangle","aire":15,"perimetre":16}
```

---

## Ex√©cution de Requ√™tes SQL depuis JavaScript

PL/v8 fournit l'objet `plv8` pour interagir avec PostgreSQL.

### Ex√©cution simple

```sql
CREATE OR REPLACE FUNCTION compter_utilisateurs_js()
RETURNS int AS $$
    // Ex√©cution d'une requ√™te
    const result = plv8.execute("SELECT COUNT(*) as total FROM utilisateurs");

    // result est un array de rows
    return result[0].total;
$$ LANGUAGE plv8 VOLATILE;
```

### Requ√™tes pr√©par√©es (s√©curis√©es)

```sql
CREATE OR REPLACE FUNCTION obtenir_utilisateur_par_email_js(email_recherche text)
RETURNS jsonb AS $$
    // Requ√™te pr√©par√©e (protection SQL injection)
    const plan = plv8.prepare(
        "SELECT id, nom, email FROM utilisateurs WHERE email = $1",
        ['text']
    );

    const result = plan.execute([email_recherche]);
    plan.free();  // Lib√©rer les ressources

    return result.length > 0 ? result[0] : null;
$$ LANGUAGE plv8 VOLATILE;
```

### Transactions

```sql
CREATE OR REPLACE FUNCTION transfert_argent(de_compte int, vers_compte int, montant numeric)
RETURNS jsonb AS $$
    try {
        // V√©rifier solde
        const plan_check = plv8.prepare(
            'SELECT solde FROM comptes WHERE id = $1',
            ['int']
        );
        const solde_actuel = plan_check.execute([de_compte]);
        plan_check.free();

        if (solde_actuel.length === 0 || solde_actuel[0].solde < montant) {
            return {success: false, message: "Solde insuffisant"};
        }

        // D√©bit
        const plan_debit = plv8.prepare(
            'UPDATE comptes SET solde = solde - $1 WHERE id = $2',
            ['numeric', 'int']
        );
        plan_debit.execute([montant, de_compte]);
        plan_debit.free();

        // Cr√©dit
        const plan_credit = plv8.prepare(
            'UPDATE comptes SET solde = solde + $1 WHERE id = $2',
            ['numeric', 'int']
        );
        plan_credit.execute([montant, vers_compte]);
        plan_credit.free();

        return {success: true, message: "Transfert r√©ussi"};

    } catch (e) {
        plv8.elog(ERROR, `Erreur de transfert: ${e.message}`);
    }
$$ LANGUAGE plv8 VOLATILE;
```

### Logging et messages

```sql
CREATE OR REPLACE FUNCTION demo_logging(valeur int)
RETURNS text AS $$
    // Diff√©rents niveaux de log
    plv8.elog(DEBUG5, `Valeur re√ßue: ${valeur}`);
    plv8.elog(INFO, "Traitement en cours...");
    plv8.elog(NOTICE, "Valeur valid√©e");

    if (valeur > 100) {
        plv8.elog(WARNING, `Valeur √©lev√©e: ${valeur}`);
    }

    if (valeur < 0) {
        plv8.elog(ERROR, "Valeur n√©gative non autoris√©e");
    }

    return "Traitement r√©ussi";
$$ LANGUAGE plv8 VOLATILE;
```

---

## Fonctions Retournant Plusieurs Lignes

### G√©n√©rateurs et yield

```sql
CREATE OR REPLACE FUNCTION generer_serie_js(debut int, fin int)
RETURNS setof int AS $$
    const results = [];
    for (let i = debut; i <= fin; i++) {
        results.push(i);
    }
    return results;
$$ LANGUAGE plv8 IMMUTABLE STRICT;

SELECT * FROM generer_serie_js(1, 5);
-- 1, 2, 3, 4, 5
```

### Tables complexes

```sql
CREATE OR REPLACE FUNCTION analyser_texte_js(texte text)
RETURNS table(
    type_element text,
    valeur text,
    position int
) AS $$
    const results = [];

    // Extraction des emails
    const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
    let match;
    while ((match = emailRegex.exec(texte)) !== null) {
        results.push({
            type_element: 'email',
            valeur: match[0],
            position: match.index
        });
    }

    // Extraction des URLs
    const urlRegex = /https?:\/\/[^\s]+/g;
    while ((match = urlRegex.exec(texte)) !== null) {
        results.push({
            type_element: 'url',
            valeur: match[0],
            position: match.index
        });
    }

    // Extraction des hashtags
    const hashtagRegex = /#(\w+)/g;
    while ((match = hashtagRegex.exec(texte)) !== null) {
        results.push({
            type_element: 'hashtag',
            valeur: match[1],
            position: match.index
        });
    }

    return results;
$$ LANGUAGE plv8 IMMUTABLE STRICT;

SELECT * FROM analyser_texte_js('Visitez https://postgresql.org et contactez admin@example.com #PostgreSQL');
```

---

## Variables Globales et Cache

### Variables globales partag√©es

```sql
CREATE OR REPLACE FUNCTION compteur_js()
RETURNS int AS $$
    // Variables globales persistent entre les appels
    if (typeof global_counter === 'undefined') {
        global_counter = 0;
        plv8.elog(NOTICE, "Compteur initialis√©");
    }

    global_counter++;
    return global_counter;
$$ LANGUAGE plv8 VOLATILE;

SELECT compteur_js();  -- 1
SELECT compteur_js();  -- 2
```

### Cache de configuration

```sql
CREATE OR REPLACE FUNCTION config_cache_js(cle text, valeur text DEFAULT NULL)
RETURNS text AS $$
    // Cache global
    if (typeof config_store === 'undefined') {
        config_store = {};
    }

    if (valeur !== null) {
        // √âcriture
        config_store[cle] = valeur;
        return `Stock√©: ${cle} = ${valeur}`;
    } else {
        // Lecture
        return config_store[cle] || null;
    }
$$ LANGUAGE plv8 VOLATILE;

SELECT config_cache_js('app.name', 'MonApp');
SELECT config_cache_js('app.name', NULL);  -- Retourne: "MonApp"
```

---

## Cas d'Usage Avanc√©s

### 1. API REST mock

```sql
CREATE OR REPLACE FUNCTION api_mock(endpoint text, params jsonb DEFAULT '{}'::jsonb)
RETURNS jsonb AS $$
    const routes = {
        '/users': () => ({
            users: [
                {id: 1, nom: 'Alice', email: 'alice@example.com'},
                {id: 2, nom: 'Bob', email: 'bob@example.com'}
            ]
        }),

        '/user/:id': () => {
            const id = parseInt(params.id);
            return {
                id: id,
                nom: 'User ' + id,
                email: `user${id}@example.com`
            };
        },

        '/search': () => {
            return {
                query: params.q,
                results: [`R√©sultat 1 pour "${params.q}"`, `R√©sultat 2 pour "${params.q}"`]
            };
        }
    };

    const handler = routes[endpoint];
    if (!handler) {
        return {error: 'Endpoint non trouv√©', status: 404};
    }

    return {
        status: 200,
        data: handler()
    };
$$ LANGUAGE plv8 IMMUTABLE;

SELECT api_mock('/users');
SELECT api_mock('/search', '{"q": "PostgreSQL"}'::jsonb);
```

### 2. G√©n√©ration de slugs

```sql
CREATE OR REPLACE FUNCTION generer_slug_js(titre text)
RETURNS text AS $$
    return titre
        .toLowerCase()
        .normalize('NFD')  // Normalisation Unicode
        .replace(/[\u0300-\u036f]/g, '')  // Supprimer les accents
        .replace(/[^a-z0-9]+/g, '-')      // Remplacer non-alphanum√©riques
        .replace(/^-+|-+$/g, '');         // Trim les tirets
$$ LANGUAGE plv8 IMMUTABLE STRICT;

SELECT generer_slug_js('Ma√Ætriser PostgreSQL 18 : Guide Complet !');
-- R√©sultat : "maitriser-postgresql-18-guide-complet"
```

### 3. Validation de formulaire complexe

```sql
CREATE OR REPLACE FUNCTION valider_formulaire_inscription(data jsonb)
RETURNS jsonb AS $$
    const erreurs = {};
    let valide = true;

    // Validation email
    if (!data.email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(data.email)) {
        erreurs.email = "Email invalide";
        valide = false;
    }

    // Validation mot de passe
    const mdp = data.mot_de_passe || '';
    if (mdp.length < 8) {
        erreurs.mot_de_passe = "Minimum 8 caract√®res";
        valide = false;
    } else if (!/[A-Z]/.test(mdp)) {
        erreurs.mot_de_passe = "Au moins une majuscule requise";
        valide = false;
    } else if (!/[0-9]/.test(mdp)) {
        erreurs.mot_de_passe = "Au moins un chiffre requis";
        valide = false;
    }

    // Validation √¢ge
    if (!data.age || data.age < 18) {
        erreurs.age = "Vous devez avoir au moins 18 ans";
        valide = false;
    }

    // Validation conditions g√©n√©rales
    if (!data.accepte_cgu) {
        erreurs.accepte_cgu = "Vous devez accepter les CGU";
        valide = false;
    }

    return {
        valide: valide,
        erreurs: erreurs
    };
$$ LANGUAGE plv8 IMMUTABLE STRICT;

SELECT valider_formulaire_inscription('{
    "email": "test@example.com",
    "mot_de_passe": "faible",
    "age": 25,
    "accepte_cgu": true
}'::jsonb);
```

### 4. Transformation de donn√©es complexe

```sql
CREATE OR REPLACE FUNCTION normaliser_donnees_client(clients jsonb)
RETURNS jsonb AS $$
    return clients.map(client => {
        // Normalisation du nom
        const nomComplet = `${client.prenom} ${client.nom}`.toUpperCase();

        // Calcul de l'√¢ge
        const dateNaissance = new Date(client.date_naissance);
        const age = new Date().getFullYear() - dateNaissance.getFullYear();

        // Cat√©gorisation
        let categorie;
        if (age < 25) categorie = 'jeune';
        else if (age < 60) categorie = 'actif';
        else categorie = 'senior';

        // Score de fid√©lit√©
        const anciennete = new Date().getFullYear() -
                          new Date(client.date_inscription).getFullYear();
        const score = Math.min(100, anciennete * 10 + (client.commandes || 0) * 2);

        return {
            id: client.id,
            nom_complet: nomComplet,
            email: client.email.toLowerCase(),
            age: age,
            categorie: categorie,
            score_fidelite: score,
            vip: score >= 80
        };
    });
$$ LANGUAGE plv8 IMMUTABLE STRICT;
```

---

## Modules npm et Biblioth√®ques Externes

### ‚ö†Ô∏è Limitation importante

**PL/v8 ne supporte PAS nativement l'import de modules npm**. Le moteur V8 embarqu√© ne contient que le JavaScript standard (ES6+), sans acc√®s au syst√®me de fichiers ou √† `require()`.

### Solutions alternatives

1. **Copier le code directement**
   ```sql
   CREATE OR REPLACE FUNCTION avec_lodash()
   RETURNS text AS $$
       // Coller le code de lodash.min.js ici (d√©conseill√©)
       // ... code lodash ...

       const result = _.capitalize('hello world');
       return result;
   $$ LANGUAGE plv8;
   ```

2. **Utiliser plv8_startup** (approche avanc√©e)
   ```sql
   -- Configuration globale au d√©marrage
   DO $$
       plv8.execute('SELECT plv8_startup()');
   $$ LANGUAGE plv8;
   ```

3. **Rester sur JavaScript standard**
   ```sql
   -- Utiliser uniquement les fonctionnalit√©s natives
   CREATE OR REPLACE FUNCTION sans_dependances(data jsonb)
   RETURNS jsonb AS $$
       // Array.map, filter, reduce, etc. disponibles
       return data.map(item => ({
           ...item,
           processed: true
       }));
   $$ LANGUAGE plv8;
   ```

---

## Bonnes Pratiques

### 1. S√©curit√© SQL

**Toujours utiliser des requ√™tes pr√©par√©es** :

```sql
-- ‚ùå DANGEREUX - Injection SQL
CREATE OR REPLACE FUNCTION recherche_danger(nom text)
RETURNS int AS $$
    const query = `SELECT COUNT(*) as cnt FROM users WHERE nom = '${nom}'`;
    const result = plv8.execute(query);
    return result[0].cnt;
$$ LANGUAGE plv8;

-- ‚úÖ S√âCURIS√â - Requ√™te pr√©par√©e
CREATE OR REPLACE FUNCTION recherche_securisee(nom text)
RETURNS int AS $$
    const plan = plv8.prepare('SELECT COUNT(*) as cnt FROM users WHERE nom = $1', ['text']);
    const result = plan.execute([nom]);
    plan.free();
    return result[0].cnt;
$$ LANGUAGE plv8;
```

### 2. Performance

```sql
-- Pr√©f√©rer le traitement par lot
CREATE OR REPLACE FUNCTION traiter_par_lot(ids int[])
RETURNS jsonb AS $$
    // ‚úÖ Une seule requ√™te pour tous les IDs
    const plan = plv8.prepare(
        'SELECT * FROM users WHERE id = ANY($1)',
        ['int[]']
    );
    const results = plan.execute([ids]);
    plan.free();

    // Traitement en JavaScript
    return results.map(user => ({
        ...user,
        processed: true
    }));
$$ LANGUAGE plv8;
```

### 3. Gestion de m√©moire

```sql
CREATE OR REPLACE FUNCTION liberer_ressources()
RETURNS void AS $$
    // Toujours lib√©rer les plans pr√©par√©s
    const plan = plv8.prepare('SELECT 1', []);
    try {
        plan.execute([]);
    } finally {
        plan.free();  // ‚úÖ Lib√©ration dans finally
    }
$$ LANGUAGE plv8;
```

### 4. Types de retour appropri√©s

```sql
-- Utiliser IMMUTABLE quand possible
CREATE OR REPLACE FUNCTION calcul_pur(a int, b int)
RETURNS int AS $$
    return a + b;
$$ LANGUAGE plv8 IMMUTABLE STRICT;  -- ‚úÖ Performance optimale

-- STABLE pour lectures base de donn√©es
CREATE OR REPLACE FUNCTION lecture_config(cle text)
RETURNS text AS $$
    const result = plv8.execute('SELECT valeur FROM config WHERE cle = $1', [cle]);
    return result[0]?.valeur;
$$ LANGUAGE plv8 STABLE;

-- VOLATILE pour √©critures
CREATE OR REPLACE FUNCTION ecriture(data jsonb)
RETURNS void AS $$
    plv8.execute('INSERT INTO logs (data) VALUES ($1)', [data]);
$$ LANGUAGE plv8 VOLATILE;
```

---

## Limitations et Consid√©rations

### 1. Limitations techniques

- ‚ùå **Pas d'acc√®s npm natif** : Pas de `require()` ou `import`
- ‚ùå **Pas d'I/O fichier** : Pas de `fs`, `path`, etc.
- ‚ùå **Pas de r√©seau** : Pas de `http`, `fetch` natifs
- ‚ùå **Pas de processus** : Pas de `child_process`
- ‚úÖ **JavaScript pur** : ES6+, Array, Object, Date, Math, RegExp, etc.

### 2. Performance

- **Plus rapide** que PL/Python pour logique pure JavaScript
- **Plus lent** que PL/pgSQL pour op√©rations SQL intensives
- **Startup overhead** : Initialisation V8 par session

### 3. Maintenance

- **Extension tierce** : Pas dans PostgreSQL core
- **Version V8** : D√©pend de la version compil√©e
- **Mises √† jour** : N√©cessite recompilation pour nouveau V8

### 4. Disponibilit√©

- ‚ùå Pas dans PostgreSQL par d√©faut
- ‚ö†Ô∏è Peut ne pas √™tre disponible sur certains h√©bergements cloud
- ‚úÖ Disponible sur la plupart des installations on-premise

---

## Comparaison Finale

### PL/pgSQL vs PL/v8 vs PL/Python vs PL/Perl

```sql
-- M√™me fonction dans les 4 langages

-- PL/pgSQL : Le natif
CREATE OR REPLACE FUNCTION exemple_plpgsql(items jsonb)
RETURNS int AS $$
DECLARE
    total int := 0;
    item jsonb;
BEGIN
    FOR item IN SELECT * FROM jsonb_array_elements(items)
    LOOP
        total := total + (item->>'valeur')::int;
    END LOOP;
    RETURN total;
END;
$$ LANGUAGE plpgsql;

-- PL/v8 : JavaScript moderne
CREATE OR REPLACE FUNCTION exemple_plv8(items jsonb)
RETURNS int AS $$
    return items.reduce((sum, item) => sum + item.valeur, 0);
$$ LANGUAGE plv8 IMMUTABLE STRICT;

-- PL/Python : √âcosyst√®me riche
CREATE OR REPLACE FUNCTION exemple_plpython(items jsonb)
RETURNS int AS $$
    return sum(item['valeur'] for item in items)
$$ LANGUAGE plpython3u;

-- PL/Perl : Regex et texte
CREATE OR REPLACE FUNCTION exemple_plperl(items text)  # Limitation : pas de jsonb natif
RETURNS int AS $$
    # Parse JSON manuellement ou avec module
    return 42;  # Simplifi√©
$$ LANGUAGE plperlu;
```

### Recommandations d'utilisation

| Cas d'usage | Langage recommand√© | Raison |
|-------------|-------------------|---------|
| Logique SQL pure | **PL/pgSQL** | Performance native |
| Manipulation JSON | **PL/v8** | JavaScript ‚ù§Ô∏è JSON |
| Regex complexes | **PL/Perl** | Regex imbattables |
| Machine Learning | **PL/Python** | scikit-learn, pandas |
| API REST internes | **PL/v8** | Syntaxe moderne |
| Parsing de logs | **PL/Perl** | Traitement texte |
| Calculs math√©matiques | **PL/Python** | NumPy, SciPy |
| Validation de donn√©es | **PL/v8** | Syntaxe claire |

---

## Quand Utiliser PL/v8 ?

### ‚úÖ Cas d'usage recommand√©s

1. **Manipulation JSON/JSONB intensive**
   - APIs REST
   - Transformation de donn√©es
   - Validation de sch√©mas

2. **Stack JavaScript unifi√©**
   - M√™me langage frontend/backend/database
   - R√©utilisation de code
   - Comp√©tences transf√©rables

3. **Logique m√©tier moderne**
   - Algorithmes complexes
   - Transformation de donn√©es
   - Validation et filtrage

4. **Performance JavaScript**
   - Plus rapide que Python pour calculs purs
   - V8 ultra-optimis√©

### ‚ùå Cas d'usage d√©conseill√©s

1. **Op√©rations SQL intensives**
   - Pr√©f√©rer PL/pgSQL
   - Int√©gration native sup√©rieure

2. **Besoin de biblioth√®ques npm**
   - Limitation majeure de PL/v8
   - Consid√©rer PL/Python avec pip

3. **Regex ultra-complexes**
   - PL/Perl reste sup√©rieur
   - Fonctionnalit√©s regex plus riches

4. **Environnements cloud restrictifs**
   - V√©rifier disponibilit√© PL/v8
   - Peut ne pas √™tre support√©

---

## Installation de PL/v8 : Guide Complet

### V√©rification pr√©-installation

```bash
# V√©rifier si PL/v8 est disponible
pg_config --configure

# Chercher les extensions disponibles
ls -l $(pg_config --sharedir)/extension/ | grep plv8
```

### Compilation depuis les sources (avanc√©)

```bash
# D√©pendances (Ubuntu)
sudo apt-get install build-essential postgresql-server-dev-15 libc++-dev

# Cloner le d√©p√¥t
git clone https://github.com/plv8/plv8.git
cd plv8

# Compiler
make
sudo make install

# Activer l'extension
psql -d votre_base -c "CREATE EXTENSION plv8;"
```

### Docker avec PL/v8

```dockerfile
FROM postgres:15

# Installer PL/v8
RUN apt-get update && \
    apt-get install -y postgresql-15-plv8 && \
    rm -rf /var/lib/apt/lists/*
```

---

## Ressources et Documentation

### Documentation officielle

- **PL/v8 GitHub** : https://github.com/plv8/plv8
- **PostgreSQL PL/v8** : https://plv8.github.io/
- **V8 JavaScript Engine** : https://v8.dev/
- **MDN JavaScript** : https://developer.mozilla.org/

### Exemples de code

```sql
-- Voir les exemples sur le d√©p√¥t GitHub
-- https://github.com/plv8/plv8/tree/master/sql
```

### Communaut√©

- **GitHub Issues** : https://github.com/plv8/plv8/issues
- **Stack Overflow** : Tag `plv8`
- **PostgreSQL Mailing Lists**

---

## R√©sum√©

**PL/v8 (JavaScript)** est un langage proc√©dural puissant qui :

‚úÖ **Avantages** :
- JavaScript moderne (ES6+) dans PostgreSQL
- Performance excellente (moteur V8)
- Manipulation JSON native et triviale
- Syntaxe accessible et populaire
- Stack JavaScript unifi√©
- Comp√©tences transf√©rables

‚ùå **Limitations** :
- Extension tierce (pas dans PostgreSQL core)
- Pas d'acc√®s npm natif
- Disponibilit√© variable selon h√©bergement
- Moins de fonctionnalit√©s que Node.js complet
- Installation plus complexe

**Verdict** : PL/v8 est excellent pour la manipulation JSON et la logique m√©tier moderne, surtout dans un √©cosyst√®me JavaScript. C'est le meilleur choix si vous travaillez d√©j√† avec JavaScript et avez besoin de coh√©rence technologique. Toutefois, v√©rifiez sa disponibilit√© dans votre environnement et privil√©giez PL/pgSQL pour les op√©rations SQL intensives.

---


‚è≠Ô∏è [Administration, Configuration et S√©curit√©](/16-administration-configuration-securite/README.md)
