üîù Retour au [Sommaire](/SOMMAIRE.md)

# 17.3.1. Publications et Subscriptions - R√©plication Logique PostgreSQL 18

## Introduction

La r√©plication logique dans PostgreSQL repose sur deux concepts fondamentaux : les **publications** et les **subscriptions**. Contrairement √† la r√©plication physique qui copie les blocs de donn√©es bruts, la r√©plication logique reproduit les changements de donn√©es au niveau logique (lignes, colonnes, tables), offrant ainsi une flexibilit√© bien plus grande.

### Analogie simple

Imaginez deux journaux d'entreprise :
- **La publication** : C'est comme un journal qui d√©cide quels articles publier (quelles tables partager)
- **La subscription** : C'est comme un abonn√© qui re√ßoit ce journal et lit les articles qui l'int√©ressent

## Qu'est-ce qu'une Publication ?

Une **publication** est un objet cr√©√© sur le serveur **source** (appel√© publisher) qui d√©termine **quelles donn√©es** seront r√©pliqu√©es. C'est une sorte de "catalogue" qui dit : "Voici les tables et les changements que je rends disponibles pour la r√©plication".

### Caract√©ristiques d'une Publication

- **S√©lectivit√©** : Vous pouvez publier toutes les tables d'une base ou seulement certaines tables sp√©cifiques
- **Filtrage d'op√©rations** : Vous pouvez choisir de publier uniquement les INSERT, ou les UPDATE, ou les DELETE, ou toute combinaison
- **Granularit√© fine** : Possibilit√© de publier seulement certaines colonnes d'une table (depuis PostgreSQL 15)
- **Multiple publications** : Une m√™me table peut appartenir √† plusieurs publications diff√©rentes

### Syntaxe de base - CREATE PUBLICATION

```sql
-- Publication simple : publier une table
CREATE PUBLICATION ma_publication FOR TABLE utilisateurs;

-- Publication de plusieurs tables
CREATE PUBLICATION ma_publication FOR TABLE utilisateurs, commandes, produits;

-- Publication de toutes les tables de la base
CREATE PUBLICATION ma_publication_complete FOR ALL TABLES;

-- Publication avec filtre d'op√©rations (seulement INSERT et UPDATE)
CREATE PUBLICATION ma_publication
FOR TABLE utilisateurs
WITH (publish = 'insert, update');

-- Publication avec filtrage de colonnes (PostgreSQL 15+)
CREATE PUBLICATION ma_publication
FOR TABLE utilisateurs (id, nom, email);  -- seulement ces colonnes

-- Publication avec clause WHERE (PostgreSQL 15+)
CREATE PUBLICATION ma_publication
FOR TABLE utilisateurs WHERE (pays = 'France');
```

### Options de Publication

| Option | Valeurs possibles | Description |
|--------|-------------------|-------------|
| `publish` | `'insert'`, `'update'`, `'delete'`, `'truncate'` | D√©finit quelles op√©rations sont r√©pliqu√©es (par d√©faut : toutes) |
| `publish_via_partition_root` | `true` / `false` | Pour les tables partitionn√©es : publier via la table parente ou les partitions |

## Qu'est-ce qu'une Subscription ?

Une **subscription** est un objet cr√©√© sur le serveur **destination** (appel√© subscriber) qui se connecte √† une publication et **re√ßoit** les changements de donn√©es. C'est l'abonn√© qui "tire" les donn√©es depuis le publisher.

### Caract√©ristiques d'une Subscription

- **Connexion active** : La subscription √©tablit une connexion permanente vers le publisher
- **R√©plication en temps quasi-r√©el** : Les changements sont transmis au fur et √† mesure
- **Snapshot initial** : Par d√©faut, une copie initiale des donn√©es est effectu√©e
- **Gestion automatique** : PostgreSQL g√®re automatiquement le suivi des changements (via WAL)

### Syntaxe de base - CREATE SUBSCRIPTION

```sql
-- Subscription simple
CREATE SUBSCRIPTION ma_souscription
CONNECTION 'host=serveur-source.example.com port=5432 dbname=production user=replicateur password=secret'
PUBLICATION ma_publication;

-- Subscription sans copie initiale
CREATE SUBSCRIPTION ma_souscription
CONNECTION 'host=serveur-source.example.com port=5432 dbname=production user=replicateur'
PUBLICATION ma_publication
WITH (copy_data = false);

-- Subscription pour plusieurs publications
CREATE SUBSCRIPTION ma_souscription
CONNECTION 'host=serveur-source.example.com port=5432 dbname=production user=replicateur'
PUBLICATION publication1, publication2;

-- Subscription d√©sactiv√©e (√† activer manuellement plus tard)
CREATE SUBSCRIPTION ma_souscription
CONNECTION 'host=serveur-source.example.com port=5432 dbname=production user=replicateur'
PUBLICATION ma_publication
WITH (enabled = false);
```

### Options de Subscription

| Option | Valeurs possibles | Description |
|--------|-------------------|-------------|
| `copy_data` | `true` / `false` | Copier les donn√©es existantes au d√©marrage (d√©faut : `true`) |
| `enabled` | `true` / `false` | Activer imm√©diatement la subscription (d√©faut : `true`) |
| `create_slot` | `true` / `false` | Cr√©er automatiquement un slot de r√©plication (d√©faut : `true`) |
| `slot_name` | nom personnalis√© | Nom du slot de r√©plication √† utiliser |
| `synchronous_commit` | `off`, `local`, `remote_write`, `on` | Niveau de commit synchrone |

## Comment √ßa fonctionne : Le Flux de R√©plication

### √âtape par √âtape

1. **Cr√©ation de la publication** (sur le serveur source)
   - L'administrateur d√©cide quelles tables publier
   - PostgreSQL enregistre cette configuration

2. **Cr√©ation de la subscription** (sur le serveur destination)
   - Le serveur destination se connecte au serveur source
   - Un **slot de r√©plication** est cr√©√© sur le source (pour suivre la progression)

3. **Snapshot initial** (si `copy_data = true`)
   - Toutes les donn√©es existantes des tables publi√©es sont copi√©es
   - Cette op√©ration peut prendre du temps pour de grandes tables

4. **R√©plication continue**
   - Le serveur source √©crit tous les changements dans le WAL
   - Le d√©codeur logique (`pgoutput`) lit le WAL et transforme les changements en format logique
   - Ces changements sont envoy√©s au subscriber via le slot de r√©plication
   - Le subscriber applique les changements sur ses tables locales

### Sch√©ma conceptuel

```
[SERVEUR SOURCE - Publisher]
    ‚îÇ
    ‚îú‚îÄ Base de donn√©es : production
    ‚îÇ   ‚îú‚îÄ Table : utilisateurs  ‚îÄ‚îÄ‚îê
    ‚îÇ   ‚îú‚îÄ Table : commandes      ‚îÄ‚î§
    ‚îÇ   ‚îî‚îÄ Table : produits       ‚îÄ‚î§
    ‚îÇ                               ‚îÇ
    ‚îî‚îÄ PUBLICATION "ma_pub" ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îÇ (Connexion r√©seau)
         ‚îÇ
         ‚ñº
    ‚îå‚îÄ SUBSCRIPTION "ma_sub"
    ‚îÇ
[SERVEUR DESTINATION - Subscriber]
    ‚îÇ
    ‚îî‚îÄ Base de donn√©es : replication
        ‚îú‚îÄ Table : utilisateurs   (r√©pliqu√©e)
        ‚îú‚îÄ Table : commandes      (r√©pliqu√©e)
        ‚îî‚îÄ Table : produits       (r√©pliqu√©e)
```

## Slots de R√©plication : Le M√©canisme de Suivi

Un **slot de r√©plication** est un objet sur le serveur source qui :
- **M√©morise** jusqu'o√π le subscriber a lu les changements
- **Pr√©serve** les donn√©es WAL n√©cessaires m√™me si elles devraient √™tre supprim√©es
- **Garantit** qu'aucun changement ne sera perdu si le subscriber est temporairement d√©connect√©

### ‚ö†Ô∏è Attention aux Slots

Si un subscriber est arr√™t√© longtemps et que le slot est actif :
- Le WAL continue de s'accumuler sur le serveur source
- **Risque de saturation disque** sur le publisher
- Solution : surveiller la taille des slots et les supprimer si n√©cessaire

```sql
-- Voir les slots de r√©plication actifs
SELECT * FROM pg_replication_slots;

-- Supprimer un slot manuellement (si n√©cessaire)
SELECT pg_drop_replication_slot('nom_du_slot');
```

## Configuration Requise

### Sur le Serveur Source (Publisher)

1. **Param√®tres PostgreSQL** √† configurer dans `postgresql.conf` :

```ini
# Niveau de WAL requis pour la r√©plication logique
wal_level = logical

# Nombre maximum de workers de r√©plication
max_replication_slots = 10  # Au moins 1 par subscription

# Nombre de processus WAL sender
max_wal_senders = 10        # Au moins 1 par subscription
```

2. **Authentification** dans `pg_hba.conf` :

```
# Autoriser la connexion pour la r√©plication
host    production    replicateur    192.168.1.0/24    scram-sha-256
```

3. **Red√©marrage requis** apr√®s modification de `wal_level`

### Sur le Serveur Destination (Subscriber)

1. **Param√®tres PostgreSQL** :

```ini
# Nombre maximum de workers pour appliquer les changements
max_logical_replication_workers = 4

# Nombre de workers par subscription
max_sync_workers_per_subscription = 2
```

2. **Les tables doivent exister** avant de cr√©er la subscription
   - M√™me structure (colonnes, types)
   - Pas n√©cessairement les m√™mes contraintes ou index

## Gestion des Publications et Subscriptions

### Commandes de Gestion - Publications

```sql
-- Voir toutes les publications
SELECT * FROM pg_publication;

-- Voir les tables d'une publication
SELECT * FROM pg_publication_tables WHERE pubname = 'ma_publication';

-- Ajouter une table √† une publication existante
ALTER PUBLICATION ma_publication ADD TABLE nouvelle_table;

-- Retirer une table d'une publication
ALTER PUBLICATION ma_publication DROP TABLE ancienne_table;

-- Modifier les op√©rations publi√©es
ALTER PUBLICATION ma_publication SET (publish = 'insert, update');

-- Supprimer une publication
DROP PUBLICATION ma_publication;
```

### Commandes de Gestion - Subscriptions

```sql
-- Voir toutes les subscriptions
SELECT * FROM pg_subscription;

-- Voir l'√©tat de r√©plication
SELECT * FROM pg_stat_subscription;

-- D√©sactiver temporairement une subscription
ALTER SUBSCRIPTION ma_souscription DISABLE;

-- R√©activer une subscription
ALTER SUBSCRIPTION ma_souscription ENABLE;

-- Rafra√Æchir la subscription (recharger les changements de publication)
ALTER SUBSCRIPTION ma_souscription REFRESH PUBLICATION;

-- Supprimer une subscription
DROP SUBSCRIPTION ma_souscription;
```

### Surveillance et Monitoring

```sql
-- √âtat global des subscriptions
SELECT
    subname AS subscription_name,
    pid,
    received_lsn,
    latest_end_lsn,
    last_msg_send_time,
    last_msg_receipt_time,
    latest_end_time
FROM pg_stat_subscription;

-- D√©calage de r√©plication (lag)
SELECT
    subname,
    pg_size_pretty(
        pg_wal_lsn_diff(sent_lsn, write_lsn)
    ) AS replication_lag
FROM pg_stat_subscription;

-- Slots de r√©plication actifs et leur consommation
SELECT
    slot_name,
    database,
    active,
    pg_size_pretty(
        pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)
    ) AS retained_wal
FROM pg_replication_slots
WHERE slot_type = 'logical';
```

## Cas d'Usage Typiques

### 1. Migration de Base de Donn√©es en Douceur

**Sc√©nario** : Vous devez migrer votre base de production vers un nouveau serveur sans interruption de service.

**Solution** :
- Cr√©er une publication sur l'ancien serveur
- Cr√©er une subscription sur le nouveau serveur
- Laisser la r√©plication se synchroniser
- Basculer les applications vers le nouveau serveur
- Supprimer la r√©plication une fois la migration valid√©e

**Avantage** : Z√©ro downtime, possibilit√© de tester le nouveau serveur avant la bascule compl√®te.

### 2. R√©plication S√©lective entre Environnements

**Sc√©nario** : Vous voulez r√©pliquer uniquement les donn√©es de r√©f√©rence (produits, cat√©gories) de production vers d√©veloppement, mais pas les donn√©es sensibles (utilisateurs, commandes).

**Solution** :
```sql
-- Sur production
CREATE PUBLICATION pub_referentiel
FOR TABLE produits, categories, fournisseurs;

-- Sur d√©veloppement
CREATE SUBSCRIPTION sub_referentiel
CONNECTION 'host=prod.example.com dbname=production user=repl'
PUBLICATION pub_referentiel;
```

**Avantage** : Les d√©veloppeurs ont des donn√©es r√©alistes sans acc√®s aux donn√©es sensibles.

### 3. Agr√©gation Multi-Sources

**Sc√©nario** : Vous avez plusieurs bases PostgreSQL r√©gionales et vous voulez agr√©ger certaines donn√©es dans une base centrale pour l'analytics.

**Solution** :
- Chaque r√©gion a une publication pour les donn√©es √† partager
- Le serveur central a une subscription pour chaque r√©gion
- Les tables destinations peuvent avoir des noms diff√©rents

**Avantage** : Centralisation des donn√©es pour reporting sans impacter les bases r√©gionales.

### 4. R√©plication G√©ographique Partielle

**Sc√©nario** : Vous avez des bureaux dans plusieurs pays, chaque pays doit avoir une copie locale des donn√©es qui le concernent.

**Solution** :
```sql
-- Sur le serveur central
CREATE PUBLICATION pub_france
FOR TABLE commandes
WHERE (pays = 'France');

CREATE PUBLICATION pub_allemagne
FOR TABLE commandes
WHERE (pays = 'Allemagne');

-- Sur chaque serveur r√©gional
CREATE SUBSCRIPTION sub_local
CONNECTION 'host=central.example.com ...'
PUBLICATION pub_france;  -- ou pub_allemagne selon la r√©gion
```

**Avantage** : R√©duit la latence et am√©liore la performance locale.

## Diff√©rences avec la R√©plication Physique

| Aspect | R√©plication Logique | R√©plication Physique |
|--------|---------------------|----------------------|
| **Granularit√©** | Table par table, colonnes filtrables | Instance compl√®te |
| **Versions PostgreSQL** | Peut r√©pliquer entre versions diff√©rentes | M√™me version majeure requise |
| **Direction** | Unidirectionnelle, mais multi-sources possibles | Unidirectionnelle stricte |
| **√âcriture sur replica** | ‚úÖ Possible sur les tables non r√©pliqu√©es | ‚ùå Lecture seule stricte |
| **Sch√©ma** | Doit √™tre cr√©√© manuellement | Copi√© automatiquement |
| **DDL** | ‚ùå Non r√©pliqu√© | ‚úÖ R√©pliqu√© automatiquement |
| **Overhead** | Plus √©lev√© (d√©codage logique) | Plus faible |
| **Flexibilit√©** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê |

## Limitations et Consid√©rations

### Ce qui N'est PAS R√©pliqu√©

‚ùå **Les modifications de sch√©ma (DDL)** :
- `ALTER TABLE`, `CREATE INDEX`, etc. ne sont pas r√©pliqu√©s
- Vous devez les appliquer manuellement sur le subscriber

‚ùå **Les s√©quences** :
- Les valeurs de s√©quences ne sont pas synchronis√©es automatiquement
- Risque de conflits si le subscriber g√©n√®re aussi des ID

‚ùå **Les Large Objects** :
- Les BLOB stock√©s via `pg_largeobject` ne sont pas support√©s

‚ùå **TRUNCATE** :
- Par d√©faut non r√©pliqu√© (sauf si `publish = 'truncate'`)

### Gestion des Conflits

Si une m√™me ligne est modifi√©e sur les deux serveurs (dans des subscriptions bidirectionnelles), PostgreSQL applique la **derni√®re √©criture gagne** par d√©faut, mais :
- Pas de r√©solution automatique de conflits sophistiqu√©e
- Il faut concevoir l'architecture pour √©viter les √©critures concurrentes
- Utiliser des triggers ou logique applicative si n√©cessaire

### Contraintes d'Int√©grit√©

- Les **cl√©s primaires sont obligatoires** sur les tables r√©pliqu√©es
- Sans PK, PostgreSQL ne peut pas identifier de mani√®re unique les lignes √† mettre √† jour ou supprimer
- Les contraintes de cl√©s √©trang√®res peuvent causer des erreurs si l'ordre d'application n'est pas respect√©

### Performance

- Le d√©codage logique consomme du **CPU** sur le publisher
- La taille du **WAL** augmente avec le volume de r√©plication
- Le d√©lai de r√©plication d√©pend de la bande passante r√©seau et du volume de transactions

## Bonnes Pratiques

### ‚úÖ DO (√Ä Faire)

1. **Toujours avoir une cl√© primaire** sur les tables r√©pliqu√©es
2. **Surveiller les slots de r√©plication** pour √©viter la saturation disque
3. **Tester la r√©plication** en environnement de staging avant production
4. **Documenter** quelles tables sont r√©pliqu√©es et pourquoi
5. **Utiliser `copy_data = false`** si les donn√©es existent d√©j√† c√¥t√© subscriber
6. **Monitorer le lag de r√©plication** avec `pg_stat_subscription`
7. **Planifier les changements de sch√©ma** et les appliquer manuellement des deux c√¥t√©s

### ‚ùå DON'T (√Ä √âviter)

1. **Ne pas oublier de supprimer** les subscriptions et slots inutilis√©s
2. **Ne pas r√©pliquer** les tables syst√®me ou temporaires
3. **Ne pas compter** sur la r√©plication des s√©quences
4. **Ne pas ignorer** les erreurs dans les logs de r√©plication
5. **Ne pas d√©passer** la capacit√© r√©seau avec trop de publications volumineuses
6. **Ne pas cr√©er** de boucles de r√©plication (A ‚Üí B ‚Üí A)

## Exemple Complet : Mise en Place √âtape par √âtape

### Contexte
- **Serveur source** : `prod.example.com` (base : `ecommerce`)
- **Serveur destination** : `analytics.example.com` (base : `reporting`)
- **Objectif** : R√©pliquer les tables `commandes` et `produits`

### √âtape 1 : Configuration du Serveur Source

```sql
-- 1.1. Se connecter au serveur source
psql -h prod.example.com -U postgres -d ecommerce

-- 1.2. V√©rifier la configuration WAL
SHOW wal_level;  -- Doit √™tre 'logical'

-- Si ce n'est pas le cas, √©diter postgresql.conf et red√©marrer
-- wal_level = logical
-- max_replication_slots = 10
-- max_wal_senders = 10

-- 1.3. Cr√©er un utilisateur pour la r√©plication
CREATE ROLE replicateur WITH LOGIN PASSWORD 'motdepasse_securise' REPLICATION;

-- 1.4. Donner les permissions n√©cessaires
GRANT SELECT ON commandes TO replicateur;
GRANT SELECT ON produits TO replicateur;

-- 1.5. Cr√©er la publication
CREATE PUBLICATION pub_ecommerce
FOR TABLE commandes, produits;

-- 1.6. V√©rifier la cr√©ation
SELECT * FROM pg_publication WHERE pubname = 'pub_ecommerce';
SELECT * FROM pg_publication_tables WHERE pubname = 'pub_ecommerce';
```

### √âtape 2 : Configuration du Serveur Destination

```sql
-- 2.1. Se connecter au serveur destination
psql -h analytics.example.com -U postgres -d reporting

-- 2.2. Cr√©er les tables avec la m√™me structure
CREATE TABLE commandes (
    id SERIAL PRIMARY KEY,
    client_id INT NOT NULL,
    date_commande TIMESTAMP NOT NULL,
    montant NUMERIC(10,2) NOT NULL
);

CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200) NOT NULL,
    prix NUMERIC(10,2) NOT NULL,
    stock INT DEFAULT 0
);

-- 2.3. Cr√©er la subscription
CREATE SUBSCRIPTION sub_ecommerce
CONNECTION 'host=prod.example.com port=5432 dbname=ecommerce user=replicateur password=motdepasse_securise'
PUBLICATION pub_ecommerce;

-- 2.4. V√©rifier la cr√©ation et l'√©tat
SELECT * FROM pg_subscription WHERE subname = 'sub_ecommerce';
SELECT * FROM pg_stat_subscription WHERE subname = 'sub_ecommerce';
```

### √âtape 3 : V√©rification et Monitoring

```sql
-- 3.1. Sur le serveur source : v√©rifier le slot de r√©plication
SELECT * FROM pg_replication_slots;

-- 3.2. Sur le serveur destination : v√©rifier l'√©tat de r√©plication
SELECT
    subname,
    received_lsn,
    last_msg_receipt_time,
    latest_end_time
FROM pg_stat_subscription;

-- 3.3. Tester : ins√©rer des donn√©es sur le source
INSERT INTO commandes (client_id, date_commande, montant)
VALUES (123, NOW(), 99.99);

-- 3.4. V√©rifier sur la destination (apr√®s quelques secondes)
SELECT * FROM commandes ORDER BY id DESC LIMIT 5;
```

## Nouveaut√©s PostgreSQL 18 pour la R√©plication Logique

PostgreSQL 18 (septembre 2025) apporte quelques am√©liorations notables :

### 1. Meilleure Performance du D√©codeur Logique
- Optimisation du processus de d√©codage WAL
- R√©duction de la latence de r√©plication

### 2. Support Am√©lior√© des Op√©rations DDL
- Bien que toujours non automatique, PostgreSQL 18 facilite la synchronisation des sch√©mas
- Nouvelles fonctions syst√®me pour comparer les structures

### 3. Statistiques √âtendues
- Nouvelles colonnes dans `pg_stat_subscription` pour un monitoring plus fin
- Meilleure visibilit√© sur les erreurs et retards

### 4. Gestion Am√©lior√©e des Conflits
- Nouvelles options pour g√©rer les conflits de mani√®re plus granulaire
- Logs plus d√©taill√©s en cas d'erreur de r√©plication

## Ressources et Documentation

- **Documentation officielle PostgreSQL** : [Logical Replication](https://www.postgresql.org/docs/18/logical-replication.html)
- **pg_stat_subscription** : Pour le monitoring en temps r√©el
- **pg_publication_tables** : Pour lister les tables publi√©es
- **Logs PostgreSQL** : Toujours consulter les logs en cas de probl√®me

## R√©sum√© des Points Cl√©s

- üìå **Publications** = Quelles donn√©es partager (c√¥t√© source)
- üìå **Subscriptions** = Recevoir ces donn√©es (c√¥t√© destination)
- üìå **Flexibilit√©** = R√©plication s√©lective, filtrage, multi-versions
- üìå **Asynchrone** = L√©ger d√©lai de r√©plication (quasi temps-r√©el)
- üìå **PK obligatoires** = Identifiant unique n√©cessaire
- üìå **DDL manuel** = Les changements de sch√©ma ne sont pas automatiques
- üìå **Monitoring** = Surveiller les slots et le lag de r√©plication

## Conclusion

La r√©plication logique via Publications et Subscriptions est un outil puissant et flexible pour :
- Migrer des bases de donn√©es sans downtime
- R√©pliquer s√©lectivement des donn√©es
- Agr√©ger des informations depuis plusieurs sources
- Cr√©er des architectures distribu√©es sophistiqu√©es

Contrairement √† la r√©plication physique "tout ou rien", la r√©plication logique vous donne un contr√¥le fin sur **quoi**, **comment** et **o√π** vos donn√©es sont r√©pliqu√©es. C'est un choix id√©al pour les architectures modernes n√©cessitant de la flexibilit√©.

---


‚è≠Ô∏è [Cas d'usage : Migrations, Selective replication](/17-haute-disponibilite-et-replication/03.2-cas-usage-migrations.md)
