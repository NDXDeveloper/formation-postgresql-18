üîù Retour au [Sommaire](/SOMMAIRE.md)

# 17.2.2. Synchronous vs Asynchronous - Modes de R√©plication PostgreSQL 18

## Introduction

Lorsque vous configurez une r√©plication Primary/Standby dans PostgreSQL, vous devez faire un choix crucial : utiliser une r√©plication **synchrone** ou **asynchrone**. Ce choix impacte directement la coh√©rence des donn√©es, la performance, et la disponibilit√© de votre syst√®me.

Ce chapitre explique en profondeur ces deux modes de r√©plication, leurs diff√©rences, leurs avantages et inconv√©nients, et comment choisir le mode le plus adapt√© √† votre cas d'usage.

---

## Concepts Fondamentaux

### Qu'est-ce que la r√©plication synchrone ?

Dans une **r√©plication synchrone**, le serveur primary attend la confirmation du (ou des) standby avant de consid√©rer une transaction comme valid√©e (committed).

**Le processus :**
1. L'application envoie une commande COMMIT au primary
2. Le primary √©crit les WAL sur son disque local
3. Le primary **attend** que le standby confirme avoir re√ßu et √©crit les WAL
4. Une fois la confirmation re√ßue, le primary r√©pond √† l'application que la transaction est valid√©e
5. L'application peut continuer

**Analogie du monde r√©el :**
Imaginez que vous envoyez une lettre recommand√©e avec accus√© de r√©ception. Vous attendez la confirmation que le destinataire a bien re√ßu la lettre avant de consid√©rer votre envoi comme r√©ussi.

### Qu'est-ce que la r√©plication asynchrone ?

Dans une **r√©plication asynchrone**, le serveur primary valide la transaction imm√©diatement apr√®s l'avoir √©crite sur son propre disque, **sans attendre** la confirmation du standby.

**Le processus :**
1. L'application envoie une commande COMMIT au primary
2. Le primary √©crit les WAL sur son disque local
3. Le primary r√©pond **imm√©diatement** √† l'application que la transaction est valid√©e
4. L'application peut continuer
5. En arri√®re-plan, les WAL sont envoy√©s au standby qui les applique

**Analogie du monde r√©el :**
C'est comme envoyer une lettre normale par la poste. Vous la d√©posez dans la bo√Æte et vous continuez votre journ√©e sans attendre la confirmation qu'elle est arriv√©e.

---

## Comparaison Visuelle

### R√©plication Asynchrone (par d√©faut)

```
Application                Primary                 Standby
    ‚îÇ                         ‚îÇ                       ‚îÇ
    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ COMMIT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                       ‚îÇ
    ‚îÇ                         ‚îÇ                       ‚îÇ
    ‚îÇ                    [√âcrit WAL]                  ‚îÇ
    ‚îÇ                         ‚îÇ                       ‚îÇ
    ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ SUCCESS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                       ‚îÇ
    ‚îÇ                         ‚îÇ                       ‚îÇ
    ‚îÇ   (continue)            ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ WAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
    ‚îÇ                         ‚îÇ                       ‚îÇ
    ‚îÇ                         ‚îÇ                  [Re√ßoit WAL]
    ‚îÇ                         ‚îÇ                       ‚îÇ
    ‚îÇ                         ‚îÇ                  [Applique WAL]
    ‚îÇ                         ‚îÇ                       ‚îÇ

Temps √©coul√© : ~1-2 ms
```

**Caract√©ristiques :**
- ‚úÖ Tr√®s rapide (latence faible)
- ‚úÖ Le primary n'est pas affect√© par les performances du standby
- ‚ö†Ô∏è Risque de perte de donn√©es si le primary tombe avant l'envoi des WAL

### R√©plication Synchrone

```
Application                Primary                 Standby
    ‚îÇ                         ‚îÇ                       ‚îÇ
    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ COMMIT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                       ‚îÇ
    ‚îÇ                         ‚îÇ                       ‚îÇ
    ‚îÇ                    [√âcrit WAL]                  ‚îÇ
    ‚îÇ                         ‚îÇ                       ‚îÇ
    ‚îÇ                         ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ WAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
    ‚îÇ                         ‚îÇ                       ‚îÇ
    ‚îÇ       ATTEND            ‚îÇ                  [Re√ßoit WAL]
    ‚îÇ                         ‚îÇ                       ‚îÇ
    ‚îÇ                         ‚îÇ                  [√âcrit WAL]
    ‚îÇ                         ‚îÇ                       ‚îÇ
    ‚îÇ                         ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ ACK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
    ‚îÇ                         ‚îÇ                       ‚îÇ
    ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ SUCCESS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                       ‚îÇ
    ‚îÇ                         ‚îÇ                       ‚îÇ
    ‚îÇ   (continue)            ‚îÇ                  [Applique WAL]
    ‚îÇ                         ‚îÇ                       ‚îÇ

Temps √©coul√© : ~5-50 ms (d√©pend du r√©seau)
```

**Caract√©ristiques :**
- ‚úÖ Garantie de durabilit√© des donn√©es
- ‚úÖ Aucune perte de donn√©es en cas de panne du primary
- ‚ö†Ô∏è Latence plus √©lev√©e (d√©pend du r√©seau)
- ‚ö†Ô∏è Le primary peut √™tre bloqu√© si le standby est lent ou indisponible

---

## Avantages et Inconv√©nients

### R√©plication Asynchrone

#### Avantages ‚úÖ

**1. Performances maximales**
- Latence de commit tr√®s faible (1-2 ms typiquement)
- D√©bit d'√©criture optimal sur le primary
- Pas d'impact des performances r√©seau sur les transactions

**2. R√©silience aux probl√®mes de standby**
- Si le standby tombe en panne, le primary continue √† fonctionner normalement
- Si le r√©seau entre primary et standby est lent, aucun impact sur le primary
- Id√©al pour les r√©plications g√©ographiquement distantes (cross-region)

**3. Simplicit√© op√©rationnelle**
- Configuration par d√©faut de PostgreSQL
- Moins de risques de blocage du primary
- Plus facile √† diagnostiquer

#### Inconv√©nients ‚ö†Ô∏è

**1. Risque de perte de donn√©es**
- Si le primary tombe en panne brutalement (crash serveur, coupure √©lectrique), les transactions valid√©es mais non encore r√©pliqu√©es sont perdues
- Le "window of data loss" peut aller de quelques millisecondes √† plusieurs secondes selon la charge

**2. Inconsistance temporaire**
- Le standby peut √™tre en retard par rapport au primary
- Les lectures sur le standby peuvent retourner des donn√©es l√©g√®rement obsol√®tes

**3. Pas adapt√© aux applications critiques**
- Pour des donn√©es financi√®res, m√©dicales, ou toute donn√©e o√π la perte est inacceptable

### R√©plication Synchrone

#### Avantages ‚úÖ

**1. Garantie de durabilit√© (Zero Data Loss)**
- Aucune transaction valid√©e ne peut √™tre perdue
- Si le primary tombe, le standby poss√®de **toutes** les donn√©es valid√©es
- Conforme aux exigences de haute criticit√© (finance, sant√©, etc.)

**2. Coh√©rence forte**
- Le standby est toujours √† jour (√† quelques microsecondes pr√®s)
- Les lectures sur le standby sont quasi synchronis√©es avec le primary

**3. Conformit√© r√©glementaire**
- R√©pond aux normes de type ACID strict
- Facilite les audits de conformit√© (GDPR, SOC2, PCI-DSS)

#### Inconv√©nients ‚ö†Ô∏è

**1. Impact sur les performances**
- Latence de commit augment√©e (5-50 ms selon le r√©seau)
- Chaque transaction doit attendre l'aller-retour r√©seau
- D√©bit d'√©criture r√©duit de 20-50% par rapport √† l'asynchrone

**2. D√©pendance au standby**
- Si le standby tombe, le primary peut √™tre configur√© pour :
  - **Bloquer** toutes les √©critures (mode strict) ‚Üí Indisponibilit√©
  - **Revenir en mode asynchrone** (mode d√©grad√©) ‚Üí Risque de perte de donn√©es
- Si le r√©seau est lent, les transactions sont impact√©es

**3. Complexit√© op√©rationnelle**
- Monitoring plus complexe (surveillance du lag synchrone)
- N√©cessite une planification r√©seau rigoureuse
- Gestion des scenarios de failover plus d√©licate

---

## Tableau Comparatif R√©capitulatif

| Crit√®re | Asynchrone | Synchrone |
|---------|------------|-----------|
| **Latence de commit** | 1-2 ms | 5-50 ms |
| **D√©bit d'√©criture** | Maximum | R√©duit (20-50%) |
| **Risque de perte de donn√©es** | Oui (fen√™tre de quelques ms √† quelques secondes) | Non (zero data loss) |
| **Impact panne standby** | Aucun sur le primary | Peut bloquer le primary |
| **Impact r√©seau lent** | Aucun | Ralentit les transactions |
| **Coh√©rence primary/standby** | Quelques secondes de retard possible | Quasi temps r√©el |
| **Complexit√© op√©rationnelle** | Faible | Moyenne √† √©lev√©e |
| **Cas d'usage typique** | Blogs, applications web, r√©plication cross-region | Finance, sant√©, donn√©es critiques |
| **Co√ªt d'infrastructure** | Standard | N√©cessite r√©seau de qualit√© |

---

## Configuration de la R√©plication Synchrone

### √âtape 1 : Configurer postgresql.conf sur le Primary

La r√©plication synchrone se configure principalement sur le serveur primary via le param√®tre `synchronous_standby_names`.

**√âditer le fichier postgresql.conf :**

```ini
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Configuration de la r√©plication synchrone
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

# Liste des standbys consid√©r√©s comme synchrones
# Format : 'FIRST num (standby1, standby2, ...)'
synchronous_standby_names = 'FIRST 1 (standby1, standby2)'

# Ou pour un seul standby :
# synchronous_standby_names = 'standby1'

# Niveau de synchronisation (√† partir de PG 18)
# Options : off, local, remote_write, remote_apply, on (d√©faut)
synchronous_commit = on
```

**Explications d√©taill√©es :**

#### synchronous_standby_names

Ce param√®tre d√©finit quels standbys doivent confirmer les transactions pour qu'elles soient consid√©r√©es comme valid√©es.

**Syntaxe g√©n√©rale :**
```ini
synchronous_standby_names = 'FIRST num (standby1, standby2, ...)'
```

**Exemples de configuration :**

**Exemple 1 : Un seul standby synchrone**
```ini
synchronous_standby_names = 'standby1'
```
- Le primary attend la confirmation de `standby1` pour chaque commit
- Si `standby1` est indisponible, le primary **bloque** (ou bascule en async selon `synchronous_commit`)

**Exemple 2 : Plusieurs standbys, 1 suffit (FIRST 1)**
```ini
synchronous_standby_names = 'FIRST 1 (standby1, standby2)'
```
- Le primary attend la confirmation d'**au moins 1** standby parmi `standby1` et `standby2`
- Si `standby1` r√©pond en premier, la transaction est valid√©e imm√©diatement
- Si `standby1` est en panne, `standby2` prend le relais automatiquement
- ‚úÖ **Configuration recommand√©e** pour allier performance et r√©silience

**Exemple 3 : Plusieurs standbys, tous doivent confirmer (ANY)**
```ini
synchronous_standby_names = 'ANY 2 (standby1, standby2, standby3)'
```
- Le primary attend la confirmation d'**au moins 2** standbys parmi les 3
- Plus r√©silient mais plus lent
- Utilis√© pour des donn√©es ultra-critiques

**Exemple 4 : Plusieurs standbys, ordre de priorit√©**
```ini
synchronous_standby_names = 'standby1, standby2'
```
- Le primary essaie d'abord `standby1`
- Si `standby1` est indisponible, bascule automatiquement sur `standby2`
- Syntaxe sans `FIRST` (√©quivalent √† `FIRST 1`)

**Note importante :** Le nom doit correspondre exactement √† l'`application_name` configur√© dans le `primary_conninfo` du standby.

#### synchronous_commit

Ce param√®tre contr√¥le le **niveau de garantie** de synchronisation.

**Valeurs possibles :**

| Valeur | Description | Garantie | Performance |
|--------|-------------|----------|-------------|
| `off` | Asynchrone total (pas d'attente) | ‚ùå Aucune | ‚ö° Maximale |
| `local` | Attend √©criture locale (sur le primary) | ‚ö†Ô∏è Locale uniquement | ‚ö° √âlev√©e |
| `remote_write` | Attend √©criture sur le standby (OS cache) | ‚ö†Ô∏è Partielle | üî∂ Moyenne |
| `on` (d√©faut) | Attend flush disque sur le standby | ‚úÖ Forte | üî∂ Moyenne |
| `remote_apply` | Attend application des WAL sur le standby | ‚úÖ Maximale | üêå Faible |

**Explications d√©taill√©es :**

**`off` - Asynchrone complet**
- Aucune attente de confirmation
- Le primary valide d√®s l'√©criture en m√©moire
- ‚ö†Ô∏è Risque de perte m√™me en cas de crash du primary seul

**`local` - Garantie locale**
- Le primary attend que les WAL soient √©crits sur son propre disque
- Pas d'attente du standby
- Protection contre un crash du processus PostgreSQL, mais pas contre une panne disque

**`remote_write` - √âcriture distante**
- Le standby confirme avoir re√ßu les WAL et les avoir √©crits en m√©moire (cache OS)
- Pas encore flush√©s sur disque
- ‚ö†Ô∏è Risque de perte si le standby crash imm√©diatement apr√®s (donn√©es en cache non persist√©es)
- **Usage :** Bon compromis performance/s√©curit√© si le standby a un syst√®me de cache s√©curis√© (battery-backed)

**`on` - Flush disque distant (par d√©faut)**
- Le standby confirme avoir √©crit les WAL sur disque physique (fsync)
- ‚úÖ **Configuration recommand√©e** pour la r√©plication synchrone
- Garantie de durabilit√© m√™me en cas de crash du standby

**`remote_apply` - Application distante**
- Le standby confirme avoir non seulement √©crit les WAL sur disque, mais aussi les avoir **appliqu√©s** √† la base de donn√©es
- Garantie la plus forte : les donn√©es sont disponibles imm√©diatement sur le standby
- **Usage :** Lecture sur le standby avec garantie de coh√©rence absolue (read-after-write)
- ‚ö†Ô∏è Plus lent car n√©cessite le temps d'application des WAL

**Comparaison des temps de latence (approximatifs) :**
- `off` : 0.5-1 ms
- `local` : 1-2 ms
- `remote_write` : 3-10 ms (latence r√©seau)
- `on` : 5-20 ms (latence r√©seau + fsync)
- `remote_apply` : 10-50 ms (latence r√©seau + fsync + application)

### √âtape 2 : Configurer l'application_name sur le Standby

Le standby doit s'identifier avec un nom que le primary pourra reconna√Ætre.

**√âditer postgresql.conf sur le Standby :**

```ini
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Configuration de connexion au Primary
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

primary_conninfo = 'host=192.168.1.10 port=5432 user=replicator password=*** application_name=standby1'
```

**Le param√®tre `application_name=standby1` est crucial :** c'est ce nom qui sera r√©f√©renc√© dans `synchronous_standby_names` sur le primary.

### √âtape 3 : Recharger la configuration

**Sur le Primary :**
```bash
# Recharger la configuration sans red√©marrage
pg_ctl reload -D /var/lib/postgresql/18/main

# Ou avec systemd
sudo systemctl reload postgresql
```

**V√©rification :**
```sql
-- Sur le primary
SHOW synchronous_standby_names;
SHOW synchronous_commit;
```

### √âtape 4 : V√©rifier l'√©tat de synchronisation

**Sur le Primary :**
```sql
SELECT
    application_name,
    client_addr,
    state,
    sync_state,          -- 'sync' = synchrone, 'async' = asynchrone, 'potential' = peut devenir sync
    sync_priority,       -- Priorit√© (1 = le plus prioritaire)
    replay_lag
FROM pg_stat_replication
ORDER BY sync_priority;
```

**R√©sultat attendu pour une r√©plication synchrone :**
```
 application_name | client_addr   | state     | sync_state | sync_priority | replay_lag
------------------+---------------+-----------+------------+---------------+------------
 standby1         | 192.168.1.20  | streaming | sync       | 1             | 00:00:00.05
 standby2         | 192.168.1.21  | streaming | potential  | 2             | 00:00:00.08
```

**Interpr√©tation :**
- **sync_state = 'sync'** : Ce standby est actuellement utilis√© pour la r√©plication synchrone
- **sync_state = 'potential'** : Ce standby peut devenir synchrone si le standby sync actuel tombe
- **sync_state = 'async'** : Ce standby est en mode asynchrone
- **sync_priority** : Ordre de priorit√© (1 = plus haute priorit√©)

---

## Modes Hybrides et Strat√©gies Avanc√©es

### Mode FIRST N : Quorum de Synchronisation

Le mode `FIRST N` permet d'attendre la confirmation de N standbys parmi une liste.

**Configuration :**
```ini
synchronous_standby_names = 'FIRST 2 (standby1, standby2, standby3)'
```

**Fonctionnement :**
- Le primary attend **au moins 2** confirmations parmi les 3 standbys
- Si `standby1` et `standby2` r√©pondent rapidement, la transaction est valid√©e
- Si `standby1` est en panne, le primary attend `standby2` et `standby3`

**Avantages :**
- ‚úÖ Tol√©rance aux pannes : 1 standby peut tomber sans bloquer le primary
- ‚úÖ Garantie de durabilit√© forte : les donn√©es sont sur 3 serveurs

**Inconv√©nients :**
- ‚ö†Ô∏è Latence augment√©e (attente du 2√®me standby le plus lent)
- ‚ö†Ô∏è Plus complexe √† monitorer

**Cas d'usage :**
- Donn√©es ultra-critiques (finance, sant√©)
- Architectures multi-datacenter
- R√©glementations strictes (ex: 3 copies de donn√©es minimum)

### Mode ANY N : N parmi M

Le mode `ANY N` est similaire √† `FIRST N` mais sans notion de priorit√©.

**Configuration :**
```ini
synchronous_standby_names = 'ANY 2 (standby1, standby2, standby3)'
```

**Diff√©rence avec FIRST :**
- `FIRST 2` : Choisit les 2 premiers qui se connectent (priorit√© implicite)
- `ANY 2` : N'importe quels 2 standbys parmi les 3 (pas de priorit√©)

En pratique, la diff√©rence est minime et `FIRST N` est plus couramment utilis√©.

### R√©plication Synchrone √† Plusieurs Niveaux

Pour des architectures complexes avec plusieurs r√©gions g√©ographiques.

**Architecture :**
```
Primary (Paris)
    ‚îú‚îÄ> Standby1 (Paris) [SYNC]
    ‚îî‚îÄ> Standby2 (Londres) [ASYNC]
            ‚îî‚îÄ> Standby3 (New York) [ASYNC via cascading]
```

**Configuration sur le Primary (Paris) :**
```ini
synchronous_standby_names = 'standby1'  # Uniquement le standby local
```

**Avantages :**
- ‚úÖ Faible latence (standby synchrone dans le m√™me datacenter)
- ‚úÖ Protection g√©ographique (standbys asynchrones √† distance)
- ‚úÖ Bon √©quilibre performance/r√©silience

**Inconv√©nients :**
- ‚ö†Ô∏è Perte de donn√©es possible si le datacenter Paris complet tombe

---

## Gestion des Sc√©narios de Panne

### Sc√©nario 1 : Le standby synchrone tombe

**Configuration :**
```ini
synchronous_standby_names = 'standby1'
```

**Que se passe-t-il ?**
1. Le standby synchrone (`standby1`) devient indisponible (panne serveur, r√©seau)
2. Le primary d√©tecte la perte de connexion (apr√®s `wal_sender_timeout`)
3. **Comportement par d√©faut :** Le primary **bloque** toutes les transactions en attente de commit

**Cons√©quences :**
- ‚ùå Le primary devient **indisponible en √©criture** (les applications re√ßoivent des timeouts)
- ‚úÖ Garantie de zero data loss maintenue

**Solutions :**

**Option 1 : Configuration FIRST 1 avec fallback**
```ini
synchronous_standby_names = 'FIRST 1 (standby1, standby2)'
```
- Si `standby1` tombe, le primary bascule automatiquement sur `standby2`
- ‚úÖ **Recommand√©** pour la production

**Option 2 : D√©sactiver temporairement la r√©plication synchrone**
```sql
-- En urgence, pour d√©bloquer le primary
ALTER SYSTEM SET synchronous_standby_names = '';
SELECT pg_reload_conf();
```
- ‚ö†Ô∏è Le primary rebascule en mode asynchrone
- ‚ö†Ô∏è Risque de perte de donn√©es pendant cette p√©riode

**Option 3 : Timeout de synchronisation (PostgreSQL 18+)**
PostgreSQL 18 n'a pas de timeout natif, mais on peut simuler avec des param√®tres de connexion :
```ini
# Sur le primary
wal_sender_timeout = 60s  # Timeout apr√®s 60 secondes
```

### Sc√©nario 2 : R√©seau lent entre Primary et Standby

**Sympt√¥me :** Les transactions sont lentes (plusieurs secondes de latence).

**Diagnostic :**
```sql
SELECT
    application_name,
    write_lag,
    flush_lag,
    replay_lag
FROM pg_stat_replication;
```

Si `flush_lag` > 100ms, le r√©seau est probablement satur√© ou lent.

**Solutions :**

**Solution 1 : Passer temporairement en asynchrone**
```sql
ALTER SYSTEM SET synchronous_commit = 'local';
SELECT pg_reload_conf();
```

**Solution 2 : Augmenter la bande passante r√©seau**
- Upgrade du lien r√©seau (1 Gbps ‚Üí 10 Gbps)
- Utiliser un r√©seau d√©di√© √† la r√©plication

**Solution 3 : Changer de mode de synchronisation**
```sql
-- Passer de 'on' √† 'remote_write' pour r√©duire la latence
ALTER SYSTEM SET synchronous_commit = 'remote_write';
SELECT pg_reload_conf();
```

### Sc√©nario 3 : Failover avec r√©plication synchrone

**Situation :** Le primary tombe et on doit promouvoir le standby.

**Avantages de la r√©plication synchrone :**
- ‚úÖ Le standby poss√®de **toutes** les donn√©es valid√©es
- ‚úÖ Aucune perte de donn√©es
- ‚úÖ RTO (Recovery Time Objective) rapide

**Proc√©dure de promotion :**
```bash
# Sur le standby
pg_ctl promote -D /var/lib/postgresql/18/main

# Ou cr√©er un trigger file (si configur√©)
touch /tmp/postgresql.trigger.5432
```

**Apr√®s la promotion :**
1. Le standby devient le nouveau primary
2. V√©rifier que les applications se reconnectent au nouveau primary
3. Reconfigurer l'ancien primary en standby (quand il revient)

---

## Monitoring et Observabilit√©

### M√©triques cl√©s pour la r√©plication synchrone

**1. √âtat de synchronisation**
```sql
SELECT
    application_name,
    sync_state,
    sync_priority
FROM pg_stat_replication;
```

**Alertes √† configurer :**
- ‚ö†Ô∏è Aucun standby en mode 'sync'
- ‚ö†Ô∏è Changement inattendu de sync_state (sync ‚Üí potential)

**2. Latence de r√©plication**
```sql
SELECT
    application_name,
    extract(epoch from write_lag) * 1000 AS write_lag_ms,
    extract(epoch from flush_lag) * 1000 AS flush_lag_ms,
    extract(epoch from replay_lag) * 1000 AS replay_lag_ms
FROM pg_stat_replication;
```

**Seuils recommand√©s :**
- `flush_lag_ms < 10ms` : Excellent
- `flush_lag_ms < 50ms` : Acceptable
- `flush_lag_ms > 100ms` : Probl√®me (r√©seau lent, standby surcharg√©)

**3. Transactions en attente**
```sql
SELECT count(*)
FROM pg_stat_activity
WHERE wait_event_type = 'IPC'
AND wait_event = 'SyncRep';
```

Si ce nombre est > 0 de mani√®re prolong√©e, cela signifie que des transactions attendent la confirmation du standby.

**4. Impact sur le d√©bit**

Comparer le d√©bit d'√©criture avant/apr√®s activation de la r√©plication synchrone :

```sql
-- Transactions par seconde
SELECT
    datname,
    xact_commit + xact_rollback AS tps
FROM pg_stat_database
WHERE datname = 'ma_base';
```

Ex√©cuter cette requ√™te r√©guli√®rement et comparer. Une baisse de 20-50% est normale.

### Dashboard Grafana recommand√©

**M√©triques essentielles √† afficher :**
- √âtat de synchronisation (sync/async/potential)
- Latence de r√©plication (write_lag, flush_lag, replay_lag)
- Nombre de standbys actifs
- D√©bit de transactions (TPS)
- Temps de commit moyen
- Lag bytes (octets de retard)

---

## Choix du Mode : Arbre de D√©cision

### Questions √† se poser

**1. Quelle est la criticit√© des donn√©es ?**

| Criticit√© | Mode recommand√© |
|-----------|-----------------|
| ‚≠ê Faible (blogs, logs, cache) | Asynchrone |
| ‚≠ê‚≠ê Moyenne (e-commerce, CRM) | Asynchrone avec backup r√©gulier |
| ‚≠ê‚≠ê‚≠ê √âlev√©e (finance, sant√©, inventaire) | Synchrone (FIRST 1) |
| ‚≠ê‚≠ê‚≠ê‚≠ê Critique (banking, donn√©es m√©dicales) | Synchrone (FIRST 2 ou ANY 2) |

**2. Quelle est la tol√©rance √† la latence ?**

| Latence acceptable | Mode recommand√© |
|--------------------|-----------------|
| < 5 ms | Asynchrone |
| < 20 ms | Synchrone (local datacenter) |
| < 100 ms | Asynchrone ou remote_write |
| > 100 ms | Asynchrone uniquement |

**3. Quelle est l'architecture r√©seau ?**

| Configuration r√©seau | Mode recommand√© |
|----------------------|-----------------|
| Primary et Standby dans le m√™me datacenter (< 1ms latence) | Synchrone (on) |
| Primary et Standby dans la m√™me r√©gion (< 5ms latence) | Synchrone (on ou remote_write) |
| Primary et Standby dans des r√©gions diff√©rentes (> 10ms latence) | Asynchrone |
| Multi-datacenter avec plusieurs standbys | Synchrone local + Asynchrone distant |

**4. Quel est le volume d'√©critures ?**

| Volume d'√©critures | Mode recommand√© |
|--------------------|-----------------|
| < 1000 TPS | Synchrone ou Asynchrone |
| 1000-10000 TPS | Asynchrone ou Synchrone avec r√©seau rapide |
| > 10000 TPS | Asynchrone (r√©plication synchrone difficile √† maintenir) |

### Arbre de d√©cision visuel

```
Est-ce que la perte de donn√©es est acceptable ?
‚îú‚îÄ OUI ‚Üí Asynchrone
‚îî‚îÄ NON ‚Üí
    ‚îÇ
    Le standby est dans le m√™me datacenter ?
    ‚îú‚îÄ OUI ‚Üí Synchrone (FIRST 1 avec fallback)
    ‚îî‚îÄ NON ‚Üí
        ‚îÇ
        Latence r√©seau < 20ms ?
        ‚îú‚îÄ OUI ‚Üí Synchrone (consid√©rer remote_write)
        ‚îî‚îÄ NON ‚Üí Asynchrone (+ PITR pour r√©cup√©ration)
```

---

## Exemples de Configuration par Cas d'Usage

### Cas 1 : Application Web E-commerce

**Contexte :**
- Donn√©es importantes mais perte tol√©rable de quelques transactions
- Priorit√© : Performance et disponibilit√©
- Volume : 5000 TPS
- Architecture : 1 primary + 2 standbys (m√™me datacenter)

**Configuration recommand√©e :**
```ini
# Sur le primary
synchronous_commit = local           # Garantie locale uniquement
synchronous_standby_names = ''       # Asynchrone
max_wal_senders = 5
```

**Strat√©gie de backup :**
- Sauvegardes quotidiennes (pg_dump)
- Archivage WAL activ√©
- Tests de restauration mensuels

### Cas 2 : Application Financi√®re (Banque)

**Contexte :**
- Zero data loss imp√©ratif
- Conformit√© r√©glementaire stricte
- Volume : 2000 TPS
- Architecture : 1 primary + 3 standbys (2 locaux, 1 distant)

**Configuration recommand√©e :**
```ini
# Sur le primary
synchronous_commit = on                                    # Garantie forte
synchronous_standby_names = 'FIRST 2 (standby1, standby2, standby3)'  # Quorum de 2
```

**Architecture :**
- Primary (Paris)
- Standby1 (Paris datacenter A) [SYNC]
- Standby2 (Paris datacenter B) [SYNC]
- Standby3 (Londres) [ASYNC via cascading depuis Standby1]

**Avantages :**
- ‚úÖ Protection contre la panne de 1 datacenter complet
- ‚úÖ Zero data loss garanti (2 copies synchrones)
- ‚úÖ R√©plication g√©ographique pour disaster recovery

### Cas 3 : Plateforme Analytics (Data Warehouse)

**Contexte :**
- Charges de lecture intensives
- √âcritures batch (nuit)
- Priorit√© : S√©paration lecture/√©criture
- Volume : 500 TPS

**Configuration recommand√©e :**
```ini
# Sur le primary
synchronous_commit = remote_apply                # Garantie forte + application
synchronous_standby_names = 'standby_analytics'  # 1 standby d√©di√© lectures
```

**Architecture :**
- Primary : √âcritures uniquement
- Standby analytics : Lectures (reporting, BI)
- `remote_apply` garantit que les donn√©es sont imm√©diatement visibles sur le standby

**Avantages :**
- ‚úÖ Z√©ro d√©lai entre √©criture et lecture (remote_apply)
- ‚úÖ Isolation des charges (OLTP vs OLAP)

### Cas 4 : Application SaaS Multi-tenant

**Contexte :**
- Plusieurs clients avec criticit√©s diff√©rentes
- N√©cessit√© de flexibilit√©
- Volume : Variable (100-5000 TPS par tenant)

**Configuration recommand√©e :**
```ini
# Sur le primary
synchronous_commit = local                        # Par d√©faut : asynchrone
synchronous_standby_names = 'FIRST 1 (standby1, standby2)'
```

**Strat√©gie applicative :**
Utiliser `synchronous_commit` au niveau de la session pour les clients critiques :

```sql
-- Pour un client premium n√©cessitant zero data loss
SET SESSION synchronous_commit = on;

-- Pour un client standard
SET SESSION synchronous_commit = local;
```

**Avantages :**
- ‚úÖ Flexibilit√© par client
- ‚úÖ Performance optimale pour la majorit√©
- ‚úÖ Garantie forte pour les clients critiques

---

## Nouveaut√©s PostgreSQL 18

PostgreSQL 18 apporte quelques am√©liorations √† la r√©plication synchrone :

### 1. M√©triques de r√©plication am√©lior√©es

Nouvelles colonnes dans `pg_stat_replication` :
```sql
SELECT
    application_name,
    sync_state,
    -- Nouvelles m√©triques PG 18
    wal_sender_pid,
    wal_sender_state,
    last_msg_send_time,
    last_msg_receipt_time
FROM pg_stat_replication;
```

### 2. Observabilit√© du lag am√©lior√©e

PostgreSQL 18 affiche automatiquement les buffers dans EXPLAIN, facilitant le diagnostic des probl√®mes de r√©plication :

```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM ma_table WHERE id = 123;
```

### 3. Optimisations du planificateur

Les am√©liorations du planificateur (auto-√©limination des self-joins, optimisation des OR-clauses) r√©duisent la charge sur le primary, ce qui am√©liore indirectement les performances de r√©plication.

---

## Bonnes Pratiques de Production

### 1. Toujours avoir un fallback

**‚ùå Mauvais :**
```ini
synchronous_standby_names = 'standby1'
```
Si `standby1` tombe, le primary bloque.

**‚úÖ Bon :**
```ini
synchronous_standby_names = 'FIRST 1 (standby1, standby2)'
```
Si `standby1` tombe, `standby2` prend le relais automatiquement.

### 2. Monitorer en continu

**Alertes essentielles :**
- Aucun standby en mode sync pendant > 5 minutes
- flush_lag > 50ms pendant > 10 minutes
- Changement de sync_state (sync ‚Üí potential)
- Augmentation soudaine du temps de commit

### 3. Tester les sc√©narios de panne

**Tests r√©guliers (trimestriels) :**
- Arr√™ter le standby sync et v√©rifier le failover vers le standby potential
- Simuler une latence r√©seau √©lev√©e (avec `tc` sur Linux)
- Promouvoir un standby et v√©rifier l'int√©grit√© des donn√©es

### 4. Documenter la configuration

**Documentation minimale :**
- Diagramme d'architecture (primary, standbys, r√©seau)
- Configuration de `synchronous_standby_names` et justification
- Proc√©dures de failover et rollback
- Contacts et escalade en cas d'incident
- RPO (Recovery Point Objective) et RTO (Recovery Time Objective) cibles

### 5. √âquilibrer performance et durabilit√©

**Ne pas tomber dans les extr√™mes :**
- Trop asynchrone ‚Üí Risque de perte de donn√©es
- Trop synchrone ‚Üí Performances d√©grad√©es, complexit√© accrue

**Approche pragmatique :**
1. Commencer en asynchrone
2. Mesurer le volume d'√©critures et la latence acceptable
3. Activer la r√©plication synchrone de mani√®re progressive
4. Monitorer l'impact et ajuster

### 6. Pr√©voir la croissance

**Questions √† anticiper :**
- Comment la configuration √©voluera avec 10√ó le volume d'√©critures actuel ?
- Est-ce que la bande passante r√©seau est suffisante pour 5 ans ?
- Peut-on ajouter un 3√®me standby sans refonte compl√®te ?

---

## R√©sum√© et Recommandations

### Quand utiliser l'Asynchrone ?

‚úÖ **Utilisez l'asynchrone si :**
- Les performances sont la priorit√© absolue
- La perte de quelques transactions est acceptable
- Le standby est g√©ographiquement distant (latence > 20ms)
- Vous avez une strat√©gie de backup robuste (PITR)
- Le volume d'√©critures est tr√®s √©lev√© (> 10 000 TPS)

**Cas d'usage typiques :**
- Applications web grand public
- Syst√®mes de logs et d'analytics
- R√©plication cross-region pour disaster recovery
- Caches distribu√©s

### Quand utiliser le Synchrone ?

‚úÖ **Utilisez le synchrone si :**
- Zero data loss est requis (finance, sant√©, donn√©es l√©gales)
- Les standbys sont dans le m√™me datacenter (latence < 5ms)
- Le volume d'√©critures est mod√©r√© (< 5000 TPS)
- Vous √™tes soumis √† des r√©glementations strictes (GDPR, SOC2, PCI-DSS)

**Cas d'usage typiques :**
- Applications bancaires et financi√®res
- Syst√®mes de sant√© (dossiers m√©dicaux)
- E-commerce avec transactions critiques
- Gestion d'inventaire en temps r√©el

### Configuration recommand√©e par d√©faut

**Pour la plupart des applications de production :**

```ini
# Sur le primary
synchronous_commit = on
synchronous_standby_names = 'FIRST 1 (standby1, standby2)'
wal_keep_size = 2GB
max_wal_senders = 5
```

**Cette configuration offre :**
- ‚úÖ Protection contre la perte de donn√©es (synchrone)
- ‚úÖ R√©silience aux pannes (FIRST 1 avec fallback)
- ‚úÖ Performance acceptable (< 20ms de latence si r√©seau local)

---

## Conclusion

Le choix entre r√©plication synchrone et asynchrone est un **trade-off fondamental** entre :
- **Durabilit√© des donn√©es** ‚Üî **Performance**
- **Garanties fortes** ‚Üî **Simplicit√© op√©rationnelle**
- **Zero data loss** ‚Üî **Haute disponibilit√©**

**Points cl√©s √† retenir :**

1. **L'asynchrone est le mode par d√©faut** et convient √† la majorit√© des cas d'usage
2. **Le synchrone est indispensable** pour les donn√©es critiques o√π la perte est inacceptable
3. **La configuration `FIRST 1` avec fallback** est le meilleur compromis pour la production
4. **Le monitoring est crucial** pour d√©tecter les d√©gradations de performance
5. **Il n'y a pas de solution universelle** : adaptez votre configuration √† vos besoins r√©els

**Prochaines √©tapes :**
- Mettre en place un monitoring de la r√©plication (Prometheus, Grafana)
- Tester les sc√©narios de failover en environnement de staging
- Mesurer l'impact r√©el sur les performances de votre application
- Explorer la r√©plication en cascade (17.2.3) pour les architectures multi-r√©gions

La r√©plication synchrone est un outil puissant, mais elle doit √™tre utilis√©e avec discernement. Une configuration bien pens√©e et adapt√©e √† votre contexte vous permettra d'atteindre le juste √©quilibre entre fiabilit√© et performance.

---

**Ressources compl√©mentaires :**
- Documentation officielle : [PostgreSQL Replication](https://www.postgresql.org/docs/18/high-availability.html)
- Blog 2ndQuadrant : [Understanding sync_state in pg_stat_replication](https://www.2ndquadrant.com/en/blog/)
- Percona Blog : [Synchronous Replication Best Practices](https://www.percona.com/blog/)

---


‚è≠Ô∏è [Cascading Replication](/17-haute-disponibilite-et-replication/02.3-cascading-replication.md)
