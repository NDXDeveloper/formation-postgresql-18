üîù Retour au [Sommaire](/SOMMAIRE.md)

# 17.6.3. Load Balancing avec HAProxy ou PgPool-II

## Introduction

Vous avez maintenant une infrastructure PostgreSQL hautement disponible avec un serveur Primary et plusieurs Standby en r√©plication. Vos donn√©es sont prot√©g√©es, mais un nouveau d√©fi appara√Æt : **comment distribuer intelligemment les requ√™tes entre vos diff√©rents serveurs ?**

Le **load balancing** (r√©partition de charge) est la solution. C'est un composant qui se place entre vos applications et vos serveurs PostgreSQL pour :
- Diriger les √©critures vers le Primary
- Distribuer les lectures entre les Standby
- D√©tecter les pannes et rediriger le trafic automatiquement
- Am√©liorer les performances globales de votre infrastructure

Dans ce chapitre, nous allons explorer les deux solutions les plus populaires pour PostgreSQL : **HAProxy** et **PgPool-II**.

---

## Comprendre le Load Balancing : Analogie Simple

### Le probl√®me sans load balancing

Imaginez un restaurant avec :
- **Une cuisine principale** (le Primary) qui prend les commandes ET pr√©pare les plats
- **Deux cuisines auxiliaires** (les Standby) qui peuvent lire les recettes mais ne peuvent que pr√©parer les plats d√©j√† command√©s

Sans load balancer, chaque client doit savoir :
- Quelle cuisine peut prendre sa commande (√©criture)
- Quelle cuisine consulter pour voir le menu (lecture)
- Si une cuisine ferme, il doit manuellement chercher une autre cuisine

**Chaos total !** üòµ

### Avec un load balancer

Maintenant, imaginez un **ma√Ætre d'h√¥tel** (le load balancer) :
- Les clients parlent uniquement au ma√Ætre d'h√¥tel
- Le ma√Ætre d'h√¥tel conna√Æt l'√©tat de chaque cuisine
- Il envoie les commandes √† la cuisine principale
- Il dirige les consultations de menu vers les cuisines les moins occup√©es
- Si une cuisine ferme, il redirige automatiquement vers une autre

**Organisation parfaite !** ‚úÖ

---

## Pourquoi le Load Balancing pour PostgreSQL ?

### 1. Simplification applicative

**Sans load balancer :**
```
Application
  ‚îú‚îÄ‚îÄ Connexion Primary (√©critures)
  ‚îú‚îÄ‚îÄ Connexion Standby1 (lectures)
  ‚îú‚îÄ‚îÄ Connexion Standby2 (lectures)
  ‚îî‚îÄ‚îÄ Logique de failover dans chaque application
```

Chaque application doit g√©rer :
- Les diff√©rentes adresses des serveurs
- La d√©tection de panne
- Le basculement automatique
- L'√©quilibrage des lectures

**Avec load balancer :**
```
Application
  ‚îî‚îÄ‚îÄ Connexion unique au load balancer
        ‚îú‚îÄ‚îÄ Port 5432 (√©critures) ‚Üí Primary
        ‚îî‚îÄ‚îÄ Port 5433 (lectures) ‚Üí Standby1, Standby2 (rotation)
```

L'application voit **un seul point d'acc√®s**. Toute la complexit√© est g√©r√©e par le load balancer.

### 2. Distribution optimale des lectures

Avec plusieurs Standby, le load balancer peut :
- **Round-robin** : Distribuer les lectures √©quitablement
- **Least connections** : Envoyer vers le serveur le moins charg√©
- **Weighted** : Favoriser les serveurs plus puissants

### 3. Haute disponibilit√© automatique

Le load balancer surveille en permanence la sant√© des serveurs :
- D√©tection de panne (health checks)
- Retrait automatique des serveurs d√©faillants
- R√©int√©gration automatique apr√®s r√©cup√©ration
- Pas d'intervention manuelle n√©cessaire

### 4. Am√©lioration des performances

En distribuant les lectures sur plusieurs serveurs :
- R√©duction de la charge CPU sur le Primary
- Meilleure utilisation des ressources
- Temps de r√©ponse am√©lior√©s
- Capacit√© de traiter plus de requ√™tes simultan√©es

---

## HAProxy : Le Couteau Suisse du Load Balancing

### Pr√©sentation

**HAProxy** (High Availability Proxy) est un load balancer g√©n√©raliste, extr√™mement populaire et mature :

**Caract√©ristiques :**
- ‚úÖ Open-source (GPLv2)
- ‚úÖ Tr√®s performant (dizaines de milliers de connexions)
- ‚úÖ L√©ger et rapide (√©crit en C)
- ‚úÖ Protocole agnostique (HTTP, TCP, PostgreSQL, etc.)
- ‚úÖ Monitoring int√©gr√© (interface web)
- ‚úÖ Large communaut√© et documentation

**Philosophie :** HAProxy est un **proxy TCP/HTTP g√©n√©rique**. Il ne comprend pas le protocole PostgreSQL en profondeur, mais c'est aussi sa force : simplicit√© et performance.

### Architecture avec HAProxy

```
                     HAProxy
                        |
        +---------------+---------------+
        |                               |
    Port 5432                       Port 5433
  (Write - Primary)              (Read - Standby)
        |                               |
        |                      +--------+--------+
        |                      |                 |
    PostgreSQL             PostgreSQL       PostgreSQL
     Primary               Standby1          Standby2
   (√©critures)            (lectures)        (lectures)
```

**Principe :**
- HAProxy √©coute sur deux ports (ou deux IP)
- **Port 5432** : Toutes les connexions vont au Primary
- **Port 5433** : Les connexions sont distribu√©es entre les Standby

### Configuration de Base

#### √âtape 1 : Installation

```bash
# Ubuntu/Debian
sudo apt update
sudo apt install haproxy

# CentOS/RHEL
sudo yum install haproxy

# V√©rifier la version
haproxy -v
```

#### √âtape 2 : Configuration (`/etc/haproxy/haproxy.cfg`)

```conf
#---------------------------------------------------------------------
# Configuration globale
#---------------------------------------------------------------------
global
    log /dev/log local0
    maxconn 10000
    user haproxy
    group haproxy
    daemon

#---------------------------------------------------------------------
# Configuration par d√©faut
#---------------------------------------------------------------------
defaults
    mode tcp
    log global
    option tcplog
    option dontlognull
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

#---------------------------------------------------------------------
# Interface de monitoring (optionnel)
#---------------------------------------------------------------------
listen stats
    mode http
    bind *:8404
    stats enable
    stats uri /stats
    stats refresh 30s
    stats admin if TRUE

#---------------------------------------------------------------------
# Frontend pour les √âCRITURES (Primary)
#---------------------------------------------------------------------
frontend postgres_write
    bind *:5432
    default_backend postgres_primary

backend postgres_primary
    option pgsql-check user haproxy_check
    server primary1 192.168.1.10:5432 check port 5432 inter 2000 rise 2 fall 3

#---------------------------------------------------------------------
# Frontend pour les LECTURES (Standby)
#---------------------------------------------------------------------
frontend postgres_read
    bind *:5433
    default_backend postgres_replicas

backend postgres_replicas
    balance roundrobin
    option pgsql-check user haproxy_check
    server replica1 192.168.1.11:5432 check port 5432 inter 2000 rise 2 fall 3
    server replica2 192.168.1.12:5432 check port 5432 inter 2000 rise 2 fall 3
    server replica3 192.168.1.13:5432 check port 5432 inter 2000 rise 2 fall 3 backup
```

**Explications des param√®tres :**

| Param√®tre | Signification |
|-----------|---------------|
| `mode tcp` | Mode TCP transparent (pas de parsing HTTP) |
| `bind *:5432` | √âcouter sur toutes les interfaces, port 5432 |
| `balance roundrobin` | Distribution √©quitable des connexions |
| `option pgsql-check` | Health check sp√©cifique PostgreSQL |
| `check port 5432` | Port √† v√©rifier pour le health check |
| `inter 2000` | Intervalle entre les checks (2 secondes) |
| `rise 2` | Nombre de checks r√©ussis avant marquage "UP" |
| `fall 3` | Nombre de checks √©chou√©s avant marquage "DOWN" |
| `backup` | Serveur de secours (utilis√© si les autres tombent) |

#### √âtape 3 : Cr√©er l'utilisateur de health check

Sur **chaque serveur PostgreSQL** :

```sql
-- Cr√©er un utilisateur d√©di√© au health check (sans droits particuliers)
CREATE USER haproxy_check;

-- Ou avec mot de passe si n√©cessaire
CREATE USER haproxy_check WITH PASSWORD 'check_password';
```

Configurez `pg_hba.conf` pour autoriser cet utilisateur :

```conf
# TYPE  DATABASE    USER            ADDRESS         METHOD
host    postgres    haproxy_check   192.168.1.0/24  trust
```

#### √âtape 4 : D√©marrer HAProxy

```bash
# Tester la configuration
sudo haproxy -c -f /etc/haproxy/haproxy.cfg

# D√©marrer le service
sudo systemctl start haproxy
sudo systemctl enable haproxy

# V√©rifier le statut
sudo systemctl status haproxy
```

#### √âtape 5 : V√©rifier le monitoring

Ouvrez votre navigateur : `http://your-haproxy-ip:8404/stats`

Vous verrez l'√©tat en temps r√©el de tous vos serveurs PostgreSQL.

### Utilisation depuis l'application

```python
# Python avec psycopg2
import psycopg2

# Connexion pour √âCRITURES (port 5432 = Primary)
conn_write = psycopg2.connect(
    host="haproxy-ip",
    port=5432,
    database="mydb",
    user="app_user",
    password="password"
)

# Connexion pour LECTURES (port 5433 = Standby)
conn_read = psycopg2.connect(
    host="haproxy-ip",
    port=5433,
    database="mydb",
    user="app_user",
    password="password"
)

# √âcriture
cursor_write = conn_write.cursor()
cursor_write.execute("INSERT INTO users (name) VALUES ('Alice')")
conn_write.commit()

# Lecture
cursor_read = conn_read.cursor()
cursor_read.execute("SELECT * FROM users")
users = cursor_read.fetchall()
```

**Important :** L'application doit g√©rer **deux connexions** (une pour √©crire, une pour lire).

### Configuration Avanc√©e : D√©tection Automatique du Primary

Pour d√©tecter automatiquement quel serveur est le Primary (en cas de failover) :

```conf
backend postgres_primary
    option pgsql-check user haproxy_check

    # Script de v√©rification personnalis√©
    option httpchk
    http-check send meth GET uri /primary

    server pg1 192.168.1.10:5432 check port 8008
    server pg2 192.168.1.11:5432 check port 8008 backup
    server pg3 192.168.1.12:5432 check port 8008 backup
```

Sur chaque serveur PostgreSQL, cr√©ez un endpoint HTTP (port 8008) qui retourne :
- **HTTP 200** si le serveur est Primary
- **HTTP 503** si le serveur est Standby

Exemple avec Python :

```python
# health_check.py
from http.server import BaseHTTPRequestHandler, HTTPServer
import psycopg2

class HealthCheck(BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/primary':
            # V√©rifier si c'est le Primary
            conn = psycopg2.connect("dbname=postgres user=postgres")
            cur = conn.cursor()
            cur.execute("SELECT pg_is_in_recovery()")
            is_standby = cur.fetchone()[0]

            if not is_standby:  # C'est le Primary
                self.send_response(200)
            else:  # C'est un Standby
                self.send_response(503)

            self.end_headers()

HTTPServer(('', 8008), HealthCheck).serve_forever()
```

### Avantages de HAProxy

| Avantage | Description |
|----------|-------------|
| üöÄ **Performance** | Extr√™mement rapide, optimis√© pour le TCP |
| üí™ **Fiabilit√©** | Utilis√© en production par des millions de sites |
| üìä **Monitoring** | Interface web int√©gr√©e tr√®s compl√®te |
| üîß **Flexibilit√©** | Configuration simple et puissante |
| üåê **Polyvalence** | Fonctionne pour tout protocole TCP (pas que PostgreSQL) |
| üí∞ **Gratuit** | Open-source sans limitations |
| üìö **Communaut√©** | Documentation extensive et large adoption |

### Inconv√©nients de HAProxy

| Inconv√©nient | Description |
|--------------|-------------|
| ‚öôÔ∏è **Pas de connection pooling** | HAProxy ne fait que du routage, pas de gestion de pool |
| üîå **Deux connexions n√©cessaires** | L'app doit g√©rer read vs write manuellement |
| üß© **Pas de split automatique** | HAProxy ne parse pas le SQL (SELECT vs INSERT) |
| üîç **Pas de query routing** | Pas d'analyse des requ√™tes pour routage intelligent |
| ‚ö†Ô∏è **Point de d√©faillance** | Si HAProxy tombe, tout est inaccessible (sauf HA HAProxy) |

---

## PgPool-II : Le Middleware PostgreSQL Sp√©cialis√©

### Pr√©sentation

**PgPool-II** est un middleware **sp√©cialement con√ßu pour PostgreSQL** :

**Caract√©ristiques :**
- ‚úÖ Connection pooling int√©gr√©
- ‚úÖ Query routing automatique (SELECT ‚Üí Standby, INSERT/UPDATE ‚Üí Primary)
- ‚úÖ Load balancing intelligent
- ‚úÖ Failover automatique
- ‚úÖ Cache de requ√™tes
- ‚úÖ R√©√©criture de requ√™tes (query rewrite)
- ‚úÖ Parallel query execution

**Philosophie :** PgPool-II est un **middleware PostgreSQL aware**. Il comprend le protocole et peut analyser les requ√™tes SQL pour des fonctionnalit√©s avanc√©es.

### Architecture avec PgPool-II

```
    Applications
         |
    PgPool-II (port 9999)
         |
    +----+----+----+
    |    |    |    |
   PG1  PG2  PG3  PG4
(Primary)(Standby)(Standby)(Standby)
```

**Principe :**
- Les applications se connectent √† PgPool-II (un seul endpoint)
- PgPool-II analyse **chaque requ√™te SQL**
- Il route automatiquement :
  - **SELECT** ‚Üí Standby (load balanced)
  - **INSERT/UPDATE/DELETE** ‚Üí Primary
  - **Transactions** ‚Üí Primary (coh√©rence)
- Il g√®re un **pool de connexions** vers chaque serveur

### Configuration de Base

#### √âtape 1 : Installation

```bash
# Ubuntu/Debian
sudo apt install pgpool2

# CentOS/RHEL
sudo yum install pgpool-II

# V√©rifier la version
pgpool -v
```

#### √âtape 2 : Configuration (`/etc/pgpool2/pgpool.conf`)

Fichier de configuration principal (version simplifi√©e) :

```conf
#---------------------------------------------------------------------
# Configuration r√©seau
#---------------------------------------------------------------------
listen_addresses = '*'
port = 9999
socket_dir = '/var/run/postgresql'

#---------------------------------------------------------------------
# Connection pooling
#---------------------------------------------------------------------
num_init_children = 32                    # Nombre de processus enfants
max_pool = 4                              # Connexions par enfant vers chaque backend
child_life_time = 300                     # Dur√©e de vie d'un enfant (secondes)
child_max_connections = 0                 # 0 = illimit√©
connection_life_time = 0                  # 0 = connexions persistantes
client_idle_limit = 0                     # 0 = pas de timeout

#---------------------------------------------------------------------
# Load balancing
#---------------------------------------------------------------------
load_balance_mode = on                    # Activer le load balancing
ignore_leading_white_space = on           # Ignorer espaces en d√©but de requ√™te
white_function_list = ''                  # Fonctions consid√©r√©es comme read-only
black_function_list = 'nextval,setval'    # Fonctions consid√©r√©es comme write

#---------------------------------------------------------------------
# Configuration des backends (serveurs PostgreSQL)
#---------------------------------------------------------------------
# Backend 0 (Primary)
backend_hostname0 = '192.168.1.10'
backend_port0 = 5432
backend_weight0 = 0                       # Poids 0 = pas de lectures
backend_data_directory0 = '/var/lib/postgresql/14/main'
backend_flag0 = 'ALWAYS_PRIMARY'

# Backend 1 (Standby)
backend_hostname1 = '192.168.1.11'
backend_port1 = 5432
backend_weight1 = 1                       # Poids pour load balancing
backend_data_directory1 = '/var/lib/postgresql/14/main'
backend_flag1 = 'DISALLOW_TO_FAILOVER'

# Backend 2 (Standby)
backend_hostname2 = '192.168.1.12'
backend_port2 = 5432
backend_weight2 = 1
backend_data_directory2 = '/var/lib/postgresql/14/main'
backend_flag2 = 'DISALLOW_TO_FAILOVER'

#---------------------------------------------------------------------
# Health check
#---------------------------------------------------------------------
health_check_period = 10                  # Intervalle (secondes)
health_check_timeout = 20                 # Timeout
health_check_user = 'pgpool_check'        # Utilisateur pour health check
health_check_password = ''                # Mot de passe (ou utiliser pool_passwd)
health_check_database = 'postgres'
health_check_max_retries = 3
health_check_retry_delay = 1

#---------------------------------------------------------------------
# Failover
#---------------------------------------------------------------------
failover_on_backend_error = off           # off pour √©viter failover auto sur erreur simple
failover_command = ''                     # Script personnalis√© de failover
failback_command = ''                     # Script de r√©int√©gration

#---------------------------------------------------------------------
# Authentification
#---------------------------------------------------------------------
enable_pool_hba = on
pool_passwd = 'pool_passwd'               # Fichier de mots de passe

#---------------------------------------------------------------------
# Logging
#---------------------------------------------------------------------
log_destination = 'stderr'
log_line_prefix = '%t: pid %p: '
log_connections = on
log_hostname = on
log_statement = off                       # off pour √©viter de logger toutes les requ√™tes
log_per_node_statement = off
log_client_messages = off
```

**Explications des param√®tres cl√©s :**

| Param√®tre | Signification |
|-----------|---------------|
| `num_init_children` | Nombre de processus enfants PgPool |
| `max_pool` | Connexions maintenues vers chaque backend par enfant |
| `backend_weight0 = 0` | Primary ne re√ßoit pas de lectures |
| `backend_weight1 = 1` | Standby re√ßoit des lectures (poids √©gal) |
| `ALWAYS_PRIMARY` | Ce backend est toujours consid√©r√© comme Primary |
| `load_balance_mode = on` | Activer la r√©partition des lectures |

#### √âtape 3 : Configuration de pool_hba

Fichier `/etc/pgpool2/pool_hba.conf` (similaire √† pg_hba.conf) :

```conf
# TYPE  DATABASE    USER        ADDRESS         METHOD
host    all         all         0.0.0.0/0       scram-sha-256
host    all         all         ::/0            scram-sha-256
```

#### √âtape 4 : Configuration des mots de passe

```bash
# Cr√©er le fichier pool_passwd
sudo pg_md5 --md5auth --username=app_user app_password

# Le fichier /etc/pgpool2/pool_passwd sera cr√©√©
# Format : username:md5hash
```

#### √âtape 5 : Cr√©er l'utilisateur de health check

Sur **chaque serveur PostgreSQL** :

```sql
CREATE USER pgpool_check;
-- Configurer pg_hba.conf pour autoriser cet utilisateur
```

#### √âtape 6 : D√©marrer PgPool-II

```bash
# Tester la configuration
sudo pgpool -n -d -f /etc/pgpool2/pgpool.conf

# Si OK, d√©marrer le service
sudo systemctl start pgpool2
sudo systemctl enable pgpool2

# V√©rifier le statut
sudo systemctl status pgpool2
```

### Utilisation depuis l'application

```python
# Python avec psycopg2
import psycopg2

# UNE SEULE connexion vers PgPool-II
conn = psycopg2.connect(
    host="pgpool-ip",
    port=9999,
    database="mydb",
    user="app_user",
    password="password"
)

cursor = conn.cursor()

# √âcriture (automatiquement rout√©e vers le Primary)
cursor.execute("INSERT INTO users (name) VALUES ('Alice')")
conn.commit()

# Lecture (automatiquement rout√©e vers un Standby)
cursor.execute("SELECT * FROM users")
users = cursor.fetchall()
```

**Avantage majeur :** L'application n'a qu'**une seule connexion** et ne se pr√©occupe pas du routage !

### Monitoring de PgPool-II

#### Commandes CLI

```bash
# Voir l'√©tat des backends
psql -h pgpool-ip -p 9999 -U app_user -c "SHOW POOL_NODES"

# R√©sultat :
# node_id | hostname      | port | status | lb_weight | role    | select_cnt | load_balance_node | replication_delay
# --------|---------------|------|--------|-----------|---------|------------|-------------------|------------------
# 0       | 192.168.1.10  | 5432 | up     | 0.000000  | primary | 0          | false             | 0
# 1       | 192.168.1.11  | 5432 | up     | 0.500000  | standby | 523        | true              | 0
# 2       | 192.168.1.12  | 5432 | up     | 0.500000  | standby | 489        | false             | 0
```

```bash
# Statistiques de pool
psql -h pgpool-ip -p 9999 -U app_user -c "SHOW POOL_PROCESSES"

# Statistiques de cache (si activ√©)
psql -h pgpool-ip -p 9999 -U app_user -c "SHOW POOL_CACHE"
```

### Fonctionnalit√©s Avanc√©es

#### 1. Query Routing Intelligent

PgPool-II analyse chaque requ√™te :

```sql
-- Rout√©e vers un Standby (lecture)
SELECT * FROM users WHERE id = 1;

-- Rout√©e vers le Primary (√©criture)
INSERT INTO users (name) VALUES ('Bob');

-- Rout√©e vers le Primary (transaction)
BEGIN;
SELECT * FROM users WHERE id = 1 FOR UPDATE;
UPDATE users SET name = 'Robert' WHERE id = 1;
COMMIT;
```

**R√®gles de routage :**
- **SELECT sans transaction** ‚Üí Standby (load balanced)
- **INSERT/UPDATE/DELETE** ‚Üí Primary
- **Toute requ√™te dans une transaction** ‚Üí Primary (coh√©rence)
- **SELECT ... FOR UPDATE** ‚Üí Primary
- **Appel de fonctions "write"** (nextval, setval) ‚Üí Primary

#### 2. Connection Pooling

PgPool-II maintient un pool de connexions persistantes :

```
Application (100 clients) ‚Üí PgPool-II ‚Üí PostgreSQL (10 connexions max par backend)
```

**Avantages :**
- R√©duction de la latence (pas de reconnexion)
- √âconomie de ressources sur PostgreSQL
- Support de plus de clients que de connexions backend

#### 3. Failover Automatique

Si PgPool-II d√©tecte qu'un backend est down :
- Il le marque comme "down" automatiquement
- Il redirige le trafic vers les autres backends
- Il peut ex√©cuter un script personnalis√© (promotion d'un Standby)

Configuration du failover :

```conf
failover_on_backend_error = on
failover_command = '/usr/local/bin/failover.sh %d %h %p %D %m %H %M %P %r %R'
```

Exemple de script `/usr/local/bin/failover.sh` :

```bash
#!/bin/bash
# Param√®tres pass√©s par PgPool-II
NODE_ID=$1
NODE_HOST=$2
NODE_PORT=$3
# ... autres param√®tres

# Logger l'√©v√©nement
echo "$(date): Failover triggered for node $NODE_ID ($NODE_HOST:$NODE_PORT)" >> /var/log/pgpool_failover.log

# Promouvoir un Standby (exemple simplifi√©)
if [ $NODE_ID -eq 0 ]; then
    # Le Primary est tomb√©, promouvoir Standby1
    ssh standby1.domain.com "pg_ctl promote -D /var/lib/postgresql/14/main"
fi
```

#### 4. Online Recovery

PgPool-II peut r√©int√©grer automatiquement un serveur apr√®s r√©paration sans interruption de service.

### Avantages de PgPool-II

| Avantage | Description |
|----------|-------------|
| üéØ **Query routing automatique** | Analyse SQL et route intelligemment |
| üîå **Connexion unique** | L'app n'a qu'un seul endpoint √† g√©rer |
| üíº **Connection pooling** | Int√©gr√©, √©conomise les ressources |
| üöÄ **Failover automatique** | D√©tection et bascule sans intervention |
| üìä **Monitoring riche** | Statistiques d√©taill√©es via SQL |
| üß© **Cache de requ√™tes** | Acc√©l√®re les requ√™tes fr√©quentes |
| üîß **PostgreSQL aware** | Comprend le protocole en profondeur |

### Inconv√©nients de PgPool-II

| Inconv√©nient | Description |
|--------------|-------------|
| üêå **Overhead de parsing** | Analyse chaque requ√™te (latence ~1-2ms) |
| üîß **Configuration complexe** | Beaucoup de param√®tres √† ma√Ætriser |
| ‚ö†Ô∏è **Point de d√©faillance** | Si PgPool-II tombe, tout est inaccessible |
| üß† **Limites du routing** | Parfois trop "intelligent" (cas edge) |
| üìö **Documentation** | Moins extensive que HAProxy |
| üîÑ **Moins polyvalent** | Sp√©cifique √† PostgreSQL |

---

## HAProxy vs PgPool-II : Tableau Comparatif

| Crit√®re | HAProxy | PgPool-II |
|---------|---------|-----------|
| **Type** | Proxy TCP g√©n√©rique | Middleware PostgreSQL |
| **Performance** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellent | ‚≠ê‚≠ê‚≠ê‚≠ê Tr√®s bon |
| **Simplicit√©** | ‚≠ê‚≠ê‚≠ê‚≠ê Simple | ‚≠ê‚≠ê‚≠ê Moyen |
| **Query routing** | ‚ùå Manuel (2 ports) | ‚úÖ Automatique |
| **Connection pooling** | ‚ùå Non | ‚úÖ Int√©gr√© |
| **Monitoring** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Interface web | ‚≠ê‚≠ê‚≠ê‚≠ê Via SQL |
| **Polyvalence** | ‚úÖ Tout protocole TCP | ‚ùå PostgreSQL uniquement |
| **Failover auto** | ‚ö†Ô∏è Basique | ‚úÖ Avanc√© |
| **Courbe d'apprentissage** | ‚≠ê‚≠ê‚≠ê‚≠ê Facile | ‚≠ê‚≠ê‚≠ê Mod√©r√©e |
| **Overhead** | ~0.1ms | ~1-2ms |
| **Communaut√©** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Tr√®s large | ‚≠ê‚≠ê‚≠ê PostgreSQL |

---

## Architectures Recommand√©es

### Architecture 1 : HAProxy pour la Simplicit√©

```
          Applications
               |
           HAProxy
        /            \
   Port 5432      Port 5433
   (Write)         (Read)
       |              |
   Primary    +-------+-------+
             Standby1      Standby2
```

**Cas d'usage :**
- Application capable de g√©rer 2 connexions (read/write)
- Performance critique (latence minimale)
- Infrastructure d√©j√† famili√®re avec HAProxy
- Besoin de monitoring HTTP

**Avantages :**
- ‚úÖ Performance maximale
- ‚úÖ Configuration simple
- ‚úÖ Stable et √©prouv√©

**Inconv√©nients :**
- ‚ö†Ô∏è L'app doit g√©rer read vs write
- ‚ö†Ô∏è Pas de connection pooling

---

### Architecture 2 : PgPool-II pour l'Intelligence

```
       Applications
            |
       PgPool-II
            |
    +-------+-------+
    |       |       |
 Primary Standby1 Standby2
```

**Cas d'usage :**
- Application avec connexion unique souhait√©e
- Besoin de routing automatique
- Besoin de connection pooling
- √âquipe famili√®re avec PostgreSQL

**Avantages :**
- ‚úÖ Transparence pour l'application
- ‚úÖ Routing intelligent
- ‚úÖ Connection pooling int√©gr√©

**Inconv√©nients :**
- ‚ö†Ô∏è Overhead de latence (~1-2ms)
- ‚ö†Ô∏è Configuration plus complexe

---

### Architecture 3 : Hybride (Best of Both Worlds)

```
       Applications
            |
       PgPool-II (connection pooling + routing)
            |
         HAProxy (failover + monitoring)
            |
    +-------+-------+
    |       |       |
 Primary Standby1 Standby2
```

**Cas d'usage :**
- Infrastructure critique
- Besoin de toutes les fonctionnalit√©s
- Budget disponible pour la complexit√©

**Avantages :**
- ‚úÖ Connection pooling (PgPool-II)
- ‚úÖ Routing intelligent (PgPool-II)
- ‚úÖ Monitoring avanc√© (HAProxy)
- ‚úÖ D√©tection de panne robuste (HAProxy)

**Inconv√©nients :**
- ‚ö†Ô∏è Complexit√© op√©rationnelle √©lev√©e
- ‚ö†Ô∏è Deux couches = deux points de d√©faillance
- ‚ö†Ô∏è Overhead cumul√©

**Note :** Cette architecture est rarement n√©cessaire. Pr√©f√©rez HAProxy OU PgPool-II.

---

### Architecture 4 : HAProxy en Haute Disponibilit√©

```
           Applications
                |
         Virtual IP (keepalived)
           /         \
    HAProxy-1      HAProxy-2
    (Primary)      (Backup)
         |             |
    +----+----+--------+
    |         |        |
 Primary  Standby1  Standby2
```

**Cas d'usage :**
- HAProxy ne doit pas √™tre un SPOF
- Infrastructure critique
- Besoin de 99.99% de disponibilit√©

**Configuration :**
- **Keepalived** : G√®re une IP virtuelle (VIP)
- Si HAProxy-1 tombe, la VIP bascule vers HAProxy-2
- Les applications pointent toujours vers la VIP

---

## Bonnes Pratiques

### üéØ Choix de la Solution

**Choisissez HAProxy si :**
- ‚úÖ Votre application peut g√©rer 2 connexions (read/write)
- ‚úÖ Vous privil√©giez la performance pure
- ‚úÖ Vous avez d√©j√† une expertise HAProxy
- ‚úÖ Vous voulez une solution simple et √©prouv√©e

**Choisissez PgPool-II si :**
- ‚úÖ Vous voulez une connexion unique depuis l'application
- ‚úÖ Vous avez besoin de connection pooling
- ‚úÖ Le routing automatique est important
- ‚úÖ Vous √™tes pr√™t √† investir dans la configuration

**Ne choisissez pas les deux en m√™me temps** (sauf cas tr√®s sp√©cifiques).

### üéØ Dimensionnement

**HAProxy :**
```conf
# Configuration minimaliste
maxconn 10000                  # Adapt√© √† la plupart des cas
timeout connect 5s
timeout client 50s
timeout server 50s
```

**PgPool-II :**
```conf
# R√®gle empirique
num_init_children = (Nombre de connexions clients max) / max_pool
max_pool = 4                   # 4 connexions persistantes par backend par processus

# Exemple : 1000 clients, 4 connexions par backend
# num_init_children = 1000 / 4 = 250
```

### üéØ Health Checks

**Fr√©quence :**
- HAProxy : `inter 2000` (toutes les 2 secondes)
- PgPool-II : `health_check_period = 10` (toutes les 10 secondes)

**Tol√©rance :**
- HAProxy : `rise 2 fall 3` (2 succ√®s pour UP, 3 √©checs pour DOWN)
- PgPool-II : `health_check_max_retries = 3`

**Principe :** Trouver le bon √©quilibre entre r√©activit√© et faux positifs.

### üéØ Monitoring

**HAProxy :**
```bash
# Stats interface
curl http://haproxy-ip:8404/stats

# Via socket (plus d√©taill√©)
echo "show stat" | sudo socat stdio /var/lib/haproxy/stats
```

**PgPool-II :**
```sql
-- √âtat des backends
SHOW POOL_NODES;

-- Processus actifs
SHOW POOL_PROCESSES;

-- Statistiques
SHOW POOL_VERSION;
```

### üéØ S√©curit√©

**HAProxy :**
- Utiliser `bind` avec des IP sp√©cifiques (pas `*`)
- Activer `stats auth` pour l'interface de monitoring
- Limiter les connexions par IP (`tcp-request connection reject if { src_conn_rate gt 100 }`)

**PgPool-II :**
- Configurer `pool_hba.conf` de mani√®re restrictive
- Utiliser `enable_pool_hba = on`
- Chiffrer les mots de passe dans `pool_passwd`
- Activer SSL entre PgPool et PostgreSQL

### üéØ Tests de Charge

Avant la mise en production, testez :

```bash
# pgbench via HAProxy ou PgPool-II
pgbench -h load-balancer-ip -p 5432 -U test_user -d testdb -c 50 -j 4 -T 60

# Mesurer les performances
# - Transactions per second (TPS)
# - Latence moyenne et P99
# - Taux d'erreur
```

---

## Troubleshooting

### Probl√®me 1 : "Connection refused" sur HAProxy

**Sympt√¥mes :**
```
psql: error: connection to server at "haproxy-ip", port 5432 failed: Connection refused
```

**Causes possibles :**
1. HAProxy n'est pas d√©marr√©
2. HAProxy n'√©coute pas sur `*` ou la bonne IP
3. Firewall bloque le port

**Solutions :**
```bash
# V√©rifier le statut
sudo systemctl status haproxy

# V√©rifier les ports
sudo netstat -tlnp | grep haproxy

# V√©rifier les logs
sudo journalctl -u haproxy -f
```

---

### Probl√®me 2 : Tous les serveurs sont "DOWN" dans HAProxy

**Sympt√¥mes :**
```
# Dans les stats HAProxy
Backend: postgres_replicas
All servers DOWN
```

**Causes possibles :**
1. L'utilisateur `haproxy_check` n'existe pas sur PostgreSQL
2. `pg_hba.conf` n'autorise pas `haproxy_check`
3. Les serveurs PostgreSQL sont r√©ellement down

**Solutions :**
```sql
-- Sur chaque serveur PostgreSQL
CREATE USER haproxy_check;

-- Dans pg_hba.conf
host postgres haproxy_check haproxy-ip/32 trust

-- Recharger la configuration
SELECT pg_reload_conf();
```

---

### Probl√®me 3 : PgPool-II ne route pas vers les Standby

**Sympt√¥mes :**
```sql
-- Toutes les requ√™tes vont au Primary
SHOW POOL_NODES;
-- select_cnt √©lev√© sur Primary, 0 sur Standby
```

**Causes possibles :**
1. `load_balance_mode = off`
2. `backend_weight` des Standby est 0
3. Les requ√™tes sont dans une transaction

**Solutions :**
```conf
# Dans pgpool.conf
load_balance_mode = on
backend_weight1 = 1    # Standby 1
backend_weight2 = 1    # Standby 2

# Red√©marrer PgPool-II
sudo systemctl restart pgpool2
```

**Note :** Les requ√™tes dans une transaction vont TOUJOURS au Primary (c'est normal).

---

### Probl√®me 4 : Latence √©lev√©e avec PgPool-II

**Sympt√¥mes :**
```
Requ√™tes 2-3ms plus lentes qu'en direct
```

**Causes :**
- Overhead normal de parsing SQL par PgPool-II

**Solutions :**
1. **Connection pooling optimis√© :**
   ```conf
   max_pool = 4              # Plus de connexions persistantes
   child_life_time = 0       # Pas de rotation
   ```

2. **Cache de requ√™tes** (pour SELECT r√©p√©titifs) :
   ```conf
   memory_cache_enabled = on
   memqcache_method = 'memcached'
   ```

3. **Si performance critique :** Envisager HAProxy √† la place

---

## Cas Pratiques

### Cas 1 : Startup avec Budget Limit√©

**Besoin :** Simple, performant, peu co√ªteux

**Recommandation :** **HAProxy**

```
    App
     |
  HAProxy
  /     \
Write  Read
  |      |
Primary Standby
```

**Justification :**
- 2 serveurs seulement (Primary + 1 Standby)
- HAProxy l√©ger et rapide
- L'app g√®re read/write (acceptable pour une petite √©quipe)

---

### Cas 2 : SaaS Multi-Tenant

**Besoin :** Scaling, pooling, routing automatique

**Recommandation :** **PgPool-II**

```
   Applications (100-1000 clients)
              |
         PgPool-II (pooling)
              |
      +-------+-------+
      |       |       |
   Primary Standby1 Standby2
```

**Justification :**
- Connection pooling essentiel (√©conomie de connexions)
- Routing automatique simplifie le code applicatif
- Nombreux tenants = nombreuses connexions

---

### Cas 3 : E-Commerce avec Pics de Trafic

**Besoin :** Haute disponibilit√©, monitoring, performance

**Recommandation :** **HAProxy + HA HAProxy**

```
      Applications
           |
    Virtual IP (keepalived)
       /        \
  HAProxy-1  HAProxy-2
       |        |
   +---+---+----+
   |       |    |
Primary Standby1 Standby2
```

**Justification :**
- Performance maximale (HAProxy)
- R√©silience (HA HAProxy)
- Monitoring temps r√©el essentiel (interface web)
- Pics de Black Friday support√©s

---

## Conclusion

Le load balancing est un composant **essentiel** d'une architecture PostgreSQL hautement disponible. Le choix entre HAProxy et PgPool-II d√©pend de vos priorit√©s :

**HAProxy : Performance et Simplicit√©**
- ‚úÖ Si vous privil√©giez la vitesse pure
- ‚úÖ Si votre application peut g√©rer 2 connexions
- ‚úÖ Si vous voulez une solution √©prouv√©e et stable
- ‚úÖ Si vous avez d√©j√† l'expertise HAProxy

**PgPool-II : Intelligence et Int√©gration**
- ‚úÖ Si vous voulez une connexion unique
- ‚úÖ Si le connection pooling est important
- ‚úÖ Si le routing automatique simplifie votre architecture
- ‚úÖ Si vous acceptez un overhead de 1-2ms

**Points cl√©s √† retenir :**

1. üéØ **Le load balancer n'est pas optionnel** en production
2. üéØ **Testez avant de choisir** : Vos besoins sont uniques
3. üéØ **Monitoring essentiel** : Surveillez la sant√© des backends
4. üéØ **HA du load balancer** : Ne cr√©ez pas un nouveau SPOF
5. üéØ **Documentation** : Documentez votre configuration

Quelle que soit votre choix, un load balancer bien configur√© transforme votre infrastructure PostgreSQL en un syst√®me v√©ritablement r√©silient et performant.

---

**Prochaine section :** 18. Extensions et Int√©grations

**Ressources compl√©mentaires :**
- Documentation HAProxy : [https://www.haproxy.org/](https://www.haproxy.org/)
- Documentation PgPool-II : [https://www.pgpool.net/](https://www.pgpool.net/)
- Article : "Choosing a PostgreSQL Load Balancer"
- Section 16.13.6 : Connection Pooling avec PgBouncer

‚è≠Ô∏è [Extensions et Int√©grations](/18-extensions-et-integrations/README.md)
