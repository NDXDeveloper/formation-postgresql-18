üîù Retour au [Sommaire](/SOMMAIRE.md)

# 17.3.3. Limitations et Consid√©rations de la R√©plication Logique

## Introduction

La r√©plication logique PostgreSQL est un outil puissant et flexible, mais comme toute technologie, elle a ses **limitations** et n√©cessite certaines **consid√©rations** importantes. Comprendre ces contraintes est essentiel pour :

- **√âviter les surprises** en production
- **Concevoir une architecture** adapt√©e √† vos besoins
- **Prendre des d√©cisions √©clair√©es** entre r√©plication logique et physique
- **Anticiper les probl√®mes** avant qu'ils ne surviennent

Cette section est cruciale car elle vous permettra d'identifier si la r√©plication logique est la bonne solution pour votre cas d'usage, et comment contourner ses limitations quand c'est possible.

---

## Partie 1 : Ce Qui N'est PAS R√©pliqu√© (Limitations Techniques)

### 1.1. Les Modifications de Sch√©ma (DDL)

#### Le Probl√®me

**Les op√©rations DDL (Data Definition Language) ne sont PAS r√©pliqu√©es automatiquement** par la r√©plication logique.

Cela inclut :
- `CREATE TABLE`, `ALTER TABLE`, `DROP TABLE`
- `CREATE INDEX`, `DROP INDEX`
- `ALTER COLUMN` (ajout, suppression, modification de type)
- `ADD CONSTRAINT`, `DROP CONSTRAINT`
- `CREATE SEQUENCE`, `ALTER SEQUENCE`
- `CREATE FUNCTION`, `CREATE TRIGGER`
- `GRANT`, `REVOKE` (permissions)

**Exemple de sc√©nario probl√©matique** :

```sql
-- ===== SUR LE SERVEUR SOURCE =====
-- Jour 1 : Tout fonctionne
CREATE PUBLICATION pub_prod FOR ALL TABLES;

-- Jour 30 : Ajout d'une colonne
ALTER TABLE commandes ADD COLUMN tracking_number VARCHAR(50);

-- Insertion avec la nouvelle colonne
INSERT INTO commandes (client_id, montant, tracking_number)
VALUES (123, 99.99, 'TRACK123456');


-- ===== SUR LE SERVEUR DESTINATION =====
-- La table n'a toujours que les anciennes colonnes !
-- L'ALTER TABLE n'a pas √©t√© r√©pliqu√©

-- R√©sultat : ERREUR DE R√âPLICATION
-- ERROR: logical replication target relation "commandes" is missing column "tracking_number"
```

#### Solutions et Contournements

**Solution 1 : Gestion Manuelle (Recommand√©e)**

```sql
-- Proc√©dure s√©curis√©e pour ajouter une colonne :

-- √âTAPE 1 : Sur le serveur DESTINATION d'abord
ALTER TABLE commandes ADD COLUMN tracking_number VARCHAR(50);

-- √âTAPE 2 : Sur le serveur SOURCE
ALTER TABLE commandes ADD COLUMN tracking_number VARCHAR(50);

-- √âTAPE 3 : V√©rifier que la r√©plication fonctionne toujours
SELECT * FROM pg_stat_subscription;
```

**Solution 2 : Scripts de Synchronisation**

```bash
#!/bin/bash
# sync_ddl.sh - Appliquer un changement DDL sur tous les serveurs

DDL_SCRIPT=$1

# Liste des serveurs
SERVERS=("prod-source.example.com" "replica1.example.com" "replica2.example.com")

for server in "${SERVERS[@]}"; do
    echo "Applying DDL on $server..."
    psql -h $server -U admin -d production -f $DDL_SCRIPT

    if [ $? -eq 0 ]; then
        echo "‚úì Success on $server"
    else
        echo "‚úó FAILED on $server"
        exit 1
    fi
done

echo "DDL synchronized on all servers"
```

**Solution 3 : Outils de Migration de Sch√©ma**

Utiliser des outils comme :
- **Flyway** : Gestion de versions de sch√©ma SQL
- **Liquibase** : Suivi des changements de base de donn√©es
- **Alembic** : Migration pour Python/SQLAlchemy

```sql
-- Exemple Flyway : V1__add_tracking_column.sql
-- Ce script sera appliqu√© sur tous les serveurs de mani√®re contr√¥l√©e

ALTER TABLE commandes ADD COLUMN tracking_number VARCHAR(50);

-- Flyway garantit que le script est ex√©cut√© une seule fois
-- et sur tous les environnements de mani√®re coh√©rente
```

**‚ö†Ô∏è Implications Importantes**

```
‚ñ° Documenter TOUS les changements de sch√©ma
‚ñ° Tester les changements DDL en staging d'abord
‚ñ° Avoir une proc√©dure claire pour appliquer les DDL en production
‚ñ° Utiliser un syst√®me de gestion de versions de sch√©ma
‚ñ° Former les √©quipes sur cette limitation
```

### 1.2. Les S√©quences (SEQUENCE)

#### Le Probl√®me

**Les valeurs de s√©quences ne sont PAS synchronis√©es** entre le serveur source et destination.

```sql
-- ===== SUR LE SERVEUR SOURCE =====
SELECT currval('commandes_id_seq');  -- Valeur : 1000

-- ===== SUR LE SERVEUR DESTINATION =====
SELECT currval('commandes_id_seq');  -- Valeur : 1 (valeur initiale!)

-- Si le serveur destination g√©n√®re aussi des IDs :
INSERT INTO commandes (...) VALUES (...);  -- G√©n√®re id = 1
-- CONFLIT avec les donn√©es r√©pliqu√©es qui ont d√©j√† id = 1 !
```

**Sc√©nario de Conflit** :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Serveur SOURCE                                          ‚îÇ
‚îÇ S√©quence commandes_id_seq : current value = 5000        ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ INSERT INTO commandes ‚Üí id = 5001 ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                 ‚îÇ
‚îÇ                              (nouveau) ‚îÇ                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                         ‚îÇ
                                         ‚îÇ R√©plication
                                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Serveur DESTINATION                                     ‚îÇ
‚îÇ S√©quence commandes_id_seq : current value = 1 (initial) ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ Re√ßoit : id = 5001 ‚Üí OK (insertion r√©ussie)             ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ Si application g√©n√®re un ID localement :                ‚îÇ
‚îÇ INSERT INTO commandes ‚Üí id = 1 ‚îÄ‚îÄ‚îÄ‚îÄ> ERREUR !           ‚îÇ
‚îÇ                              (conflit avec donn√©es      ‚îÇ
‚îÇ                               r√©pliqu√©es pr√©c√©demment)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### Solutions et Contournements

**Solution 1 : Synchronisation Manuelle Apr√®s Migration**

```sql
-- Apr√®s avoir bascul√© vers le serveur destination,
-- synchroniser toutes les s√©quences :

-- M√©thode automatique pour toutes les s√©quences
DO $$
DECLARE
    seq_record RECORD;
    max_val BIGINT;
BEGIN
    FOR seq_record IN
        SELECT
            sequence_schema,
            sequence_name,
            -- Extraire le nom de la table et colonne depuis la s√©quence
            REPLACE(sequence_name, '_id_seq', '') AS table_name
        FROM information_schema.sequences
        WHERE sequence_schema = 'public'
    LOOP
        -- R√©cup√©rer la valeur maximale dans la table
        EXECUTE format(
            'SELECT COALESCE(MAX(id), 0) FROM %I.%I',
            seq_record.sequence_schema,
            seq_record.table_name
        ) INTO max_val;

        -- Ajuster la s√©quence
        EXECUTE format(
            'SELECT setval(%L, %s)',
            seq_record.sequence_schema || '.' || seq_record.sequence_name,
            max_val
        );

        RAISE NOTICE 'S√©quence % ajust√©e √† %',
            seq_record.sequence_name, max_val;
    END LOOP;
END $$;
```

**Solution 2 : Utiliser UUID au Lieu d'ID S√©quentiels**

```sql
-- Remplacer les SERIAL par UUID
-- Avantage : Pas de conflit possible entre serveurs

-- Ancienne m√©thode (avec conflit potentiel)
CREATE TABLE commandes (
    id SERIAL PRIMARY KEY,  -- Peut causer des conflits
    ...
);

-- Nouvelle m√©thode (sans conflit)
CREATE TABLE commandes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ...
);

-- PostgreSQL 18 : UUIDv7 (tri√© temporellement, meilleur pour les index)
CREATE TABLE commandes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v7(),
    ...
);
```

**Comparaison UUID vs SERIAL** :

| Aspect | SERIAL/BIGSERIAL | UUID | UUIDv7 (PG18) |
|--------|------------------|------|---------------|
| Taille | 4 ou 8 bytes | 16 bytes | 16 bytes |
| Lisibilit√© | ‚úÖ Facile (1, 2, 3...) | ‚ùå Difficile | ‚ùå Difficile |
| Tri naturel | ‚úÖ Oui | ‚ùå Non | ‚úÖ Oui (temps) |
| Conflits multi-serveurs | ‚ùå Risque √©lev√© | ‚úÖ Quasi impossible | ‚úÖ Quasi impossible |
| Performance index | ‚úÖ Excellent | ‚ö†Ô∏è Moyen (al√©atoire) | ‚úÖ Tr√®s bon |
| Recommand√© pour | Single-master | Multi-master | Multi-master (PG18+) |

**Solution 3 : Plages d'ID Distinctes (Si SERIAL Requis)**

```sql
-- Serveur SOURCE : IDs impairs
ALTER SEQUENCE commandes_id_seq RESTART WITH 1 INCREMENT BY 2;

-- Serveur DESTINATION : IDs pairs
ALTER SEQUENCE commandes_id_seq RESTART WITH 2 INCREMENT BY 2;

-- R√©sultat :
-- Source g√©n√®re : 1, 3, 5, 7, 9, 11...
-- Destination g√©n√®re : 2, 4, 6, 8, 10, 12...
-- ‚úÖ Aucun conflit possible
```

### 1.3. Les Large Objects (BLOB)

#### Le Probl√®me

**Les Large Objects (LO) stock√©s via l'interface `pg_largeobject` ne sont PAS r√©pliqu√©s.**

```sql
-- Cette approche NE FONCTIONNE PAS avec la r√©plication logique
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    fichier_oid OID  -- Large Object ID ‚Üí NON r√©pliqu√© !
);

-- Insertion d'un fichier
SELECT lo_import('/path/to/file.pdf');  -- Retourne OID : 16385

INSERT INTO documents (nom, fichier_oid) VALUES ('contrat.pdf', 16385);

-- Sur le serveur destination :
-- L'ID 16385 est r√©pliqu√© dans la table
-- MAIS le contenu du fichier (pg_largeobject) n'est PAS r√©pliqu√© !
-- R√©sultat : OID invalide sur le replica
```

#### Solutions et Contournements

**Solution 1 : Utiliser BYTEA (Recommand√©e)**

```sql
-- Stocker les fichiers en BYTEA (byte array)
-- ‚úÖ R√©pliqu√© automatiquement

CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    mime_type VARCHAR(100),
    contenu BYTEA  -- Fichier stock√© directement
);

-- Insertion d'un fichier
INSERT INTO documents (nom, mime_type, contenu)
VALUES (
    'contrat.pdf',
    'application/pdf',
    pg_read_binary_file('/path/to/file.pdf')
);

-- Ou depuis une application (Python exemple)
-- import psycopg2
-- with open('file.pdf', 'rb') as f:
--     data = f.read()
--     cursor.execute(
--         "INSERT INTO documents (nom, contenu) VALUES (%s, %s)",
--         ('contrat.pdf', data)
--     )
```

**Limitations de BYTEA** :
- ‚ö†Ô∏è Limite : 1 GB par champ (mais suffisant pour la plupart des fichiers)
- ‚ö†Ô∏è Les fichiers sont charg√©s en m√©moire lors de la r√©cup√©ration
- ‚úÖ Avantage : Sauvegarde/r√©plication automatique

**Solution 2 : Stockage Externe (S3, Object Storage)**

```sql
-- Stocker seulement les m√©tadonn√©es et un pointeur vers le stockage externe
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    nom VARCHAR(200),
    mime_type VARCHAR(100),
    s3_bucket VARCHAR(100),
    s3_key VARCHAR(500),  -- Chemin du fichier dans S3
    taille_bytes BIGINT,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Insertion
INSERT INTO documents (nom, mime_type, s3_bucket, s3_key, taille_bytes)
VALUES (
    'contrat.pdf',
    'application/pdf',
    'mon-bucket-prod',
    'documents/2025/11/contrat-123.pdf',
    524288
);

-- ‚úÖ Les m√©tadonn√©es sont r√©pliqu√©es
-- ‚úÖ Le fichier est accessible depuis tous les serveurs via S3
-- ‚úÖ Pas de limite de taille
-- ‚úÖ Architecture cloud-native
```

### 1.4. Les Tables Syst√®me et Temporaires

#### Le Probl√®me

**Certaines tables ne peuvent pas √™tre r√©pliqu√©es** :

- ‚ùå **Tables syst√®me** (`pg_catalog.*`, `information_schema.*`)
- ‚ùå **Tables temporaires** (`CREATE TEMP TABLE`)
- ‚ùå **Tables non journalis√©es** (`CREATE UNLOGGED TABLE`)
- ‚ùå **Tables sans cl√© primaire** (limitation importante)

```sql
-- Ces tables NE PEUVENT PAS √™tre publi√©es :

-- Table temporaire
CREATE TEMP TABLE session_data (
    session_id VARCHAR(50),
    data JSONB
);
-- ‚ùå Non r√©plicable par nature

-- Table non journalis√©e (pour performance)
CREATE UNLOGGED TABLE cache_applicatif (
    key VARCHAR(100) PRIMARY KEY,
    value TEXT,
    expires_at TIMESTAMP
);
-- ‚ùå Non r√©plicable (pas de WAL)

-- Table sans cl√© primaire
CREATE TABLE logs_bruts (
    timestamp TIMESTAMP,
    message TEXT,
    level VARCHAR(10)
);
-- ‚ùå Non r√©plicable sans PK
```

#### Solutions et Contournements

**Pour les Tables Sans Cl√© Primaire** :

```sql
-- Solution 1 : Ajouter une cl√© primaire
ALTER TABLE logs_bruts ADD COLUMN id BIGSERIAL PRIMARY KEY;

-- Solution 2 : Utiliser REPLICA IDENTITY FULL (attention aux performances)
ALTER TABLE logs_bruts REPLICA IDENTITY FULL;

-- Avec REPLICA IDENTITY FULL :
-- - Toute la ligne est compar√©e pour les UPDATE/DELETE
-- - Impact performance important
-- - √Ä utiliser seulement si ajout de PK impossible
```

**Pour les Tables Non Journalis√©es** :

```sql
-- Si la table DOIT √™tre r√©pliqu√©e, la convertir en table normale
ALTER TABLE cache_applicatif SET LOGGED;

-- Ou recr√©er la table :
CREATE TABLE cache_applicatif_logged (LIKE cache_applicatif INCLUDING ALL);
INSERT INTO cache_applicatif_logged SELECT * FROM cache_applicatif;
DROP TABLE cache_applicatif;
ALTER TABLE cache_applicatif_logged RENAME TO cache_applicatif;
```

### 1.5. TRUNCATE (Par D√©faut)

#### Le Probl√®me

**Par d√©faut, `TRUNCATE` n'est pas r√©pliqu√©.**

```sql
-- ===== SUR LE SERVEUR SOURCE =====
TRUNCATE TABLE logs_anciens;

-- ===== SUR LE SERVEUR DESTINATION =====
-- La table logs_anciens contient toujours toutes les donn√©es !
-- Incoh√©rence entre source et destination
```

#### Solution

```sql
-- Cr√©er la publication avec l'option 'truncate'
CREATE PUBLICATION pub_with_truncate
FOR ALL TABLES
WITH (publish = 'insert, update, delete, truncate');

-- Ou modifier une publication existante
ALTER PUBLICATION pub_prod SET (publish = 'insert, update, delete, truncate');

-- V√©rifier
SELECT pubname, pubtruncate FROM pg_publication;
```

---

## Partie 2 : Limitations de Performance et Scalabilit√©

### 2.1. Overhead du D√©codage Logique

#### Le Probl√®me

Le d√©codage logique du WAL consomme des ressources significatives sur le serveur source :

**Impact CPU** :
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Sans R√©plication Logique                    ‚îÇ
‚îÇ CPU: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë (40%)             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Avec R√©plication Logique (3 subscriptions)  ‚îÇ
‚îÇ CPU: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë (70%)             ‚îÇ
‚îÇ                ‚ñ≤                            ‚îÇ
‚îÇ                ‚îÇ                            ‚îÇ
‚îÇ           +30% pour le d√©codage logique     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Co√ªt par Op√©ration** :

| Op√©ration | Overhead R√©plication Physique | Overhead R√©plication Logique |
|-----------|-------------------------------|------------------------------|
| INSERT | ~1-2% | ~5-10% |
| UPDATE | ~1-2% | ~10-20% |
| DELETE | ~1-2% | ~5-15% |
| Bulk INSERT | ~1% | ~3-5% |

#### Solutions et Consid√©rations

**1. Dimensionnement Appropri√©**

```sql
-- Surveiller l'utilisation CPU li√©e √† la r√©plication
SELECT
    pid,
    usename,
    application_name,
    state,
    query
FROM pg_stat_activity
WHERE application_name LIKE 'walreceiver%'
   OR backend_type = 'walsender';

-- M√©triques syst√®me (n√©cessite pg_stat_kcache)
SELECT
    queryid,
    query,
    user_time,  -- Temps CPU utilisateur
    system_time  -- Temps CPU syst√®me
FROM pg_stat_kcache
ORDER BY (user_time + system_time) DESC
LIMIT 10;
```

**2. Limiter le Nombre de Publications**

```sql
-- ‚ùå Mauvais : Beaucoup de publications redondantes
CREATE PUBLICATION pub1 FOR TABLE table1;
CREATE PUBLICATION pub2 FOR TABLE table2;
CREATE PUBLICATION pub3 FOR TABLE table3;
-- ... 50 publications

-- ‚úÖ Bon : Une publication consolid√©e
CREATE PUBLICATION pub_all FOR TABLE table1, table2, table3, ...;

-- Ou grouper par th√©matique
CREATE PUBLICATION pub_metier FOR TABLE commandes, clients, produits;
CREATE PUBLICATION pub_analytics FOR TABLE stats, logs, events;
```

### 2.2. Consommation de WAL et Stockage

#### Le Probl√®me

Les slots de r√©plication **conservent le WAL** jusqu'√† ce que le subscriber l'ait consomm√©.

**Sc√©nario Probl√©matique** :

```
T+0h : Slot cr√©√©, WAL = 1 GB
T+2h : Subscriber arr√™t√© pour maintenance
T+6h : WAL accumul√© = 50 GB (haute activit√©)
T+10h : WAL accumul√© = 120 GB
T+12h : ALERTE : Disque √† 95% !
```

#### Solutions et Pr√©vention

**1. Monitoring des Slots de R√©plication**

```sql
-- Surveiller la taille du WAL retenu par slot
SELECT
    slot_name,
    slot_type,
    database,
    active,
    restart_lsn,
    confirmed_flush_lsn,
    pg_size_pretty(
        pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)
    ) AS wal_retained,
    pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) AS wal_retained_bytes
FROM pg_replication_slots
WHERE slot_type = 'logical'
ORDER BY wal_retained_bytes DESC;

-- Alerter si WAL > 10 GB
CREATE OR REPLACE FUNCTION check_wal_retention()
RETURNS TABLE(slot_name TEXT, wal_gb NUMERIC, alert TEXT) AS $$
BEGIN
    RETURN QUERY
    SELECT
        rs.slot_name::TEXT,
        ROUND(
            pg_wal_lsn_diff(pg_current_wal_lsn(), rs.restart_lsn)
            / 1024.0 / 1024.0 / 1024.0,
            2
        ) AS wal_gb,
        CASE
            WHEN pg_wal_lsn_diff(pg_current_wal_lsn(), rs.restart_lsn) > 10737418240
            THEN '‚ö†Ô∏è CRITICAL: WAL > 10 GB'
            WHEN pg_wal_lsn_diff(pg_current_wal_lsn(), rs.restart_lsn) > 5368709120
            THEN '‚ö†Ô∏è WARNING: WAL > 5 GB'
            ELSE '‚úÖ OK'
        END AS alert
    FROM pg_replication_slots rs
    WHERE rs.slot_type = 'logical';
END;
$$ LANGUAGE plpgsql;

-- Ex√©cuter r√©guli√®rement
SELECT * FROM check_wal_retention();
```

**2. Configuration de Limites**

```sql
-- Dans postgresql.conf

-- Limite de taille des slots (PostgreSQL 13+)
max_slot_wal_keep_size = '50GB'  -- Limite la r√©tention WAL

-- Si cette limite est atteinte, le slot devient "invalidated"
-- et la r√©plication doit √™tre recr√©√©e (resync complet)

-- Param√®tres WAL recommand√©s
wal_keep_size = '10GB'  -- WAL minimum √† garder
max_wal_size = '5GB'    -- D√©clenche checkpoint

-- V√©rifier les slots invalid√©s
SELECT slot_name, slot_type, active, invalidation_reason
FROM pg_replication_slots
WHERE slot_type = 'logical' AND invalidation_reason IS NOT NULL;
```

**3. Proc√©dure d'Urgence (Disque Satur√©)**

```sql
-- ATTENTION : √Ä utiliser seulement en cas d'urgence

-- 1. Identifier le slot probl√©matique
SELECT slot_name, pg_size_pretty(
    pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)
) AS wal_retained
FROM pg_replication_slots
ORDER BY pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) DESC;

-- 2. Option A : Supprimer le slot (la r√©plication devra √™tre recr√©√©e)
SELECT pg_drop_replication_slot('slot_problematique');

-- 3. Option B : D√©sactiver temporairement la subscription (c√¥t√© subscriber)
-- puis supprimer le slot
ALTER SUBSCRIPTION sub_problematique DISABLE;
ALTER SUBSCRIPTION sub_problematique SET (slot_name = NONE);
-- Sur le publisher :
SELECT pg_drop_replication_slot('slot_problematique');
```

### 2.3. Latence de R√©plication

#### Le Probl√®me

La r√©plication logique introduit une **latence** (lag) entre source et destination.

**Facteurs influen√ßant la latence** :
- Volume de transactions
- Bande passante r√©seau
- Charge du serveur source (d√©codage)
- Charge du serveur destination (application)
- Distance g√©ographique

**Mesure de la Latence** :

```sql
-- Sur le serveur destination
SELECT
    subname,
    received_lsn,
    latest_end_lsn,
    -- Diff√©rence en bytes
    pg_wal_lsn_diff(latest_end_lsn, received_lsn) AS lag_bytes,
    pg_size_pretty(pg_wal_lsn_diff(latest_end_lsn, received_lsn)) AS lag_pretty,
    -- Diff√©rence temporelle
    EXTRACT(EPOCH FROM (now() - last_msg_receipt_time)) AS lag_seconds
FROM pg_stat_subscription;

-- R√©sultat type :
--  subname  | lag_pretty | lag_seconds
-- ----------+------------+-------------
--  sub_prod | 2567 kB    | 3.45
```

**Latences Typiques** :

| Configuration | Latence Attendue | Usage |
|---------------|------------------|-------|
| LAN, charges faibles | < 1 seconde | ‚úÖ Acceptable pour la plupart des cas |
| LAN, charges √©lev√©es | 1-5 secondes | ‚ö†Ô∏è √Ä surveiller |
| WAN, inter-continents | 5-30 secondes | ‚ö†Ô∏è Selon le cas d'usage |
| Probl√®me de r√©seau | > 1 minute | ‚ùå Investigation requise |

#### Am√©liorer les Performances

**1. Optimisation R√©seau**

```sql
-- Utiliser la compression (PostgreSQL 14+)
ALTER SUBSCRIPTION sub_prod SET (streaming = 'parallel');

-- D√©sactiver le commit synchrone c√¥t√© subscriber
ALTER SUBSCRIPTION sub_prod SET (synchronous_commit = 'off');
```

**2. Parall√©lisation (PostgreSQL 16+)**

```sql
-- Dans postgresql.conf (subscriber)
max_parallel_apply_workers_per_subscription = 4

-- Permet d'appliquer les changements en parall√®le
-- Am√©lioration possible : 2-4x plus rapide
```

**3. Tuning des Param√®tres**

```sql
-- C√¥t√© publisher (dans postgresql.conf)
wal_sender_timeout = 60s  -- Augmenter si r√©seau instable
max_wal_senders = 10      -- Suffisant pour plusieurs subscribers

-- C√¥t√© subscriber
wal_receiver_timeout = 60s
max_logical_replication_workers = 8
```

---

## Partie 3 : Gestion des Conflits

### 3.1. Types de Conflits

#### Conflit d'INSERT (Violation de Cl√© Primaire)

```sql
-- SC√âNARIO :
-- Serveur SOURCE : INSERT INTO clients VALUES (1, 'Alice');
-- Serveur DESTINATION : INSERT INTO clients VALUES (1, 'Bob');
-- ‚Üí CONFLIT : La cl√© primaire 1 existe d√©j√†

-- Erreur dans les logs :
-- ERROR: duplicate key value violates unique constraint "clients_pkey"
-- DETAIL: Key (id)=(1) already exists.
```

**R√©sultat** : La r√©plication s'**arr√™te** jusqu'√† r√©solution manuelle.

#### Conflit d'UPDATE (Ligne Modifi√©e ou Absente)

```sql
-- SC√âNARIO 1 : Ligne modifi√©e diff√©remment
-- SOURCE : UPDATE clients SET solde = 100 WHERE id = 1;
-- DESTINATION a d√©j√† fait : UPDATE clients SET solde = 200 WHERE id = 1;
-- ‚Üí Quelle valeur doit pr√©valoir ?

-- SC√âNARIO 2 : Ligne supprim√©e
-- SOURCE : UPDATE clients SET email = 'new@example.com' WHERE id = 1;
-- DESTINATION a d√©j√† fait : DELETE FROM clients WHERE id = 1;
-- ‚Üí Impossible de mettre √† jour une ligne inexistante
```

#### Conflit de DELETE

```sql
-- SC√âNARIO :
-- SOURCE : DELETE FROM clients WHERE id = 1;
-- DESTINATION a d√©j√† fait : DELETE FROM clients WHERE id = 1;
-- ‚Üí DELETE d'une ligne d√©j√† supprim√©e (g√©n√©ralement b√©nin)
```

### 3.2. Strat√©gies de R√©solution de Conflits

#### Strat√©gie Par D√©faut : "Last Write Wins"

Par d√©faut, PostgreSQL applique le **dernier changement re√ßu** :

```sql
-- Pas de gestion automatique sophistiqu√©e
-- Si un conflit survient, la r√©plication s'arr√™te avec une erreur

-- V√©rifier l'√©tat
SELECT
    subname,
    pid,
    relid::regclass AS table_name,
    received_lsn,
    last_msg_receipt_time
FROM pg_stat_subscription;

-- En cas d'erreur, le pid sera NULL
```

#### R√©solution Manuelle des Conflits

**√âtape 1 : Identifier le Conflit**

```sql
-- Consulter les logs PostgreSQL
-- Chercher les erreurs de type :
-- ERROR: duplicate key value violates unique constraint
-- ERROR: could not find row to be updated
-- ERROR: could not find row to be deleted

-- Identifier la transaction probl√©matique
SELECT * FROM pg_stat_subscription WHERE pid IS NULL;
```

**√âtape 2 : R√©soudre le Conflit**

```sql
-- Option A : Supprimer la ligne en conflit sur le subscriber
DELETE FROM clients WHERE id = 1;

-- Option B : Modifier la donn√©e conflictuelle
UPDATE clients SET id = 999999 WHERE id = 1;  -- Temporairement

-- Option C : Autoriser le conflit pour cette transaction
-- (Avancer manuellement le slot de r√©plication)
-- ‚ö†Ô∏è DANGEREUX : Peut cr√©er des incoh√©rences

-- Red√©marrer la subscription
ALTER SUBSCRIPTION sub_prod ENABLE;
```

**√âtape 3 : Pr√©vention Future**

```sql
-- Mettre en place des contraintes pour √©viter les conflits

-- 1. Utiliser UUID au lieu de SERIAL
ALTER TABLE clients ADD COLUMN uuid UUID DEFAULT gen_random_uuid();
ALTER TABLE clients DROP CONSTRAINT clients_pkey;
ALTER TABLE clients ADD PRIMARY KEY (uuid);

-- 2. D√©signer clairement un "master" pour chaque table
-- Ne permettre les √©critures QUE sur le master

-- 3. Utiliser des triggers pour d√©tecter les √©critures non autoris√©es
CREATE OR REPLACE FUNCTION prevent_writes_on_replica()
RETURNS TRIGGER AS $$
BEGIN
    RAISE EXCEPTION '√âcritures non autoris√©es sur ce serveur';
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER no_writes_clients
BEFORE INSERT OR UPDATE OR DELETE ON clients
FOR EACH ROW
EXECUTE FUNCTION prevent_writes_on_replica();

-- D√©sactiver sur le master, activer sur les replicas
```

### 3.3. Architecture pour √âviter les Conflits

#### Architecture "Master-Replica" (Recommand√©e)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         SERVEUR MASTER (Source)          ‚îÇ
‚îÇ  ‚úÖ √âcritures autoris√©es                 ‚îÇ
‚îÇ  ‚úÖ Lectures autoris√©es                  ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ  Application ‚Üí Toutes op√©rations         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ
                    ‚îÇ R√©plication unidirectionnelle
                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        SERVEUR REPLICA (Destination)     ‚îÇ
‚îÇ  ‚ùå √âcritures INTERDITES                 ‚îÇ
‚îÇ  ‚úÖ Lectures autoris√©es                  ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ  Analytics, Reporting ‚Üí SELECT only      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚úÖ Aucun conflit possible
```

#### Architecture "Multi-Master" (Complexe, D√©conseill√©e)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚Üê‚îÄ‚îÄ‚îÄ R√©plication ‚îÄ‚îÄ‚îÄ‚Üí ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  SERVEUR A  ‚îÇ                        ‚îÇ  SERVEUR B  ‚îÇ
‚îÇ  √âcritures  ‚îÇ ‚Üê‚îÄ‚îÄ‚îÄ bidirectionnelle  ‚îÇ  √âcritures  ‚îÇ
‚îÇ  autoris√©es ‚îÇ                        ‚îÇ  autoris√©es ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚ö†Ô∏è Risques de conflits √©lev√©s
‚ö†Ô∏è Complexit√© de gestion
‚ö†Ô∏è N√©cessite une logique m√©tier pour √©viter les conflits
```

**Si Multi-Master N√©cessaire** :

```sql
-- Utiliser des strat√©gies de partitionnement des donn√©es

-- Exemple : Chaque serveur g√®re une r√©gion
-- Serveur A : region = 'EU'
-- Serveur B : region = 'US'

CREATE PUBLICATION pub_to_b
FOR TABLE commandes WHERE (region = 'US'),  -- Envoie US vers B
         produits;  -- Produits partag√©s

-- Sur B :
CREATE PUBLICATION pub_to_a
FOR TABLE commandes WHERE (region = 'EU'),  -- Envoie EU vers A
         produits;  -- Produits partag√©s

-- R√®gle m√©tier : Chaque serveur √©crit SEULEMENT dans sa r√©gion
-- ‚Üí Pas de conflit possible
```

---

## Partie 4 : Consid√©rations Op√©rationnelles

### 4.1. Impact sur les Sauvegardes

#### Le Probl√®me

Les slots de r√©plication peuvent **interf√©rer avec les sauvegardes** :

```sql
-- Sc√©nario probl√©matique :
-- 1. Une subscription est cr√©√©e
-- 2. Le subscriber est arr√™t√©
-- 3. Le slot conserve le WAL
-- 4. Tentative de VACUUM sur de grandes tables ‚Üí Bloqu√©
-- 5. pg_dump prend beaucoup plus de temps (donn√©es + WAL)
```

#### Solutions

**1. Surveillance des Slots Avant Sauvegarde**

```bash
#!/bin/bash
# pre_backup_check.sh

# V√©rifier que tous les slots sont actifs et √† jour
psql -U postgres -d production -t -c "
SELECT
    slot_name,
    active,
    pg_size_pretty(
        pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)
    ) AS lag
FROM pg_replication_slots
WHERE slot_type = 'logical'
  AND (NOT active OR pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) > 1073741824);
" | while read slot active lag; do
    if [ ! -z "$slot" ]; then
        echo "‚ö†Ô∏è WARNING: Slot $slot is problematic (active=$active, lag=$lag)"
        # Envoyer une alerte
    fi
done
```

**2. Strat√©gie de Sauvegarde Adapt√©e**

```sql
-- Option 1 : Sauvegardes physiques (pg_basebackup)
-- Non affect√©es par les slots logiques
pg_basebackup -h localhost -U replication -D /backup/physical -Fp -Xs -P

-- Option 2 : Exclure les slots logiques des sauvegardes
-- (ils seront recr√©√©s lors de la restauration)
pg_dump --exclude-table=pg_replication_slots ...

-- Option 3 : Pause temporaire de la r√©plication pendant la sauvegarde
-- (si possible)
```

### 4.2. Maintenance (VACUUM, ANALYZE)

#### Le Probl√®me

Les **transactions longues** li√©es √† la r√©plication peuvent bloquer VACUUM.

```sql
-- VACUUM ne peut pas nettoyer les lignes mortes
-- tant qu'elles pourraient √™tre lues par une transaction active

-- V√©rifier les transactions longues
SELECT
    pid,
    usename,
    application_name,
    state,
    now() - xact_start AS duration,
    query
FROM pg_stat_activity
WHERE state = 'active'
  AND now() - xact_start > interval '1 hour'
ORDER BY xact_start;
```

#### Solutions

**1. Configurer un Timeout**

```sql
-- Dans postgresql.conf
idle_in_transaction_session_timeout = '1h'  -- Tuer les transactions idle
statement_timeout = '2h'  -- Timeout global des requ√™tes

-- Pour la r√©plication sp√©cifiquement
wal_sender_timeout = 60s
wal_receiver_timeout = 60s
```

**2. VACUUM Agressif en Dehors des Heures de Pointe**

```sql
-- Script de maintenance nocturne
-- maintenance.sh (via cron : 0 2 * * *)

#!/bin/bash
psql -U postgres -d production <<EOF
-- Tables critiques avec beaucoup de modifications
VACUUM (VERBOSE, ANALYZE) commandes;
VACUUM (VERBOSE, ANALYZE) clients;
VACUUM (VERBOSE, ANALYZE) logs;

-- Analyser les statistiques
ANALYZE;
EOF
```

### 4.3. Versions et Compatibilit√©

#### Compatibilit√© entre Versions PostgreSQL

La r√©plication logique permet de **r√©pliquer entre versions diff√©rentes** (avantage majeur) :

| Source | Destination | Compatible ? | Notes |
|--------|-------------|--------------|-------|
| PG 13 | PG 13 | ‚úÖ | Id√©al |
| PG 13 | PG 14 | ‚úÖ | Recommand√© pour upgrade |
| PG 13 | PG 18 | ‚úÖ | Possible (tester) |
| PG 18 | PG 13 | ‚ö†Ô∏è | Risqu√© (fonctionnalit√©s manquantes) |
| PG 14 | PG 13 | ‚ùå | D√©conseill√© |

#### Points d'Attention

```sql
-- 1. V√©rifier les types de donn√©es
-- PostgreSQL 18 a de nouveaux types (UUIDv7, etc.)

-- 2. V√©rifier les fonctions utilis√©es dans les contraintes
-- Une fonction disponible en PG 18 peut ne pas exister en PG 13

-- 3. Tester la compatibilit√© en staging
-- Cr√©er un environnement de test avec les deux versions

-- 4. Consulter les release notes
-- Chaque version documente les breaking changes
```

### 4.4. S√©curit√© et Contr√¥le d'Acc√®s

#### Permissions Requises

**Sur le Serveur Source (Publisher)** :

```sql
-- L'utilisateur de r√©plication doit avoir :
-- 1. Droit de REPLICATION
CREATE ROLE replicateur WITH LOGIN REPLICATION PASSWORD 'secure_password';

-- 2. SELECT sur toutes les tables publi√©es
GRANT SELECT ON ALL TABLES IN SCHEMA public TO replicateur;
GRANT USAGE ON SCHEMA public TO replicateur;

-- 3. Pour les futures tables
ALTER DEFAULT PRIVILEGES IN SCHEMA public
GRANT SELECT ON TABLES TO replicateur;
```

**Sur le Serveur Destination (Subscriber)** :

```sql
-- L'utilisateur doit pouvoir :
-- 1. Cr√©er la subscription
-- N√©cessite superuser OU r√¥le avec CREATE sur la database

-- 2. √âcrire dans les tables
GRANT INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO replicateur;

-- 3. G√©rer les s√©quences (si applicable)
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO replicateur;
```

#### S√©curit√© des Connexions

```sql
-- pg_hba.conf sur le source
-- Autoriser seulement les IPs des subscribers
hostssl    production    replicateur    10.0.1.0/24    scram-sha-256

-- Utiliser SSL/TLS obligatoirement
-- Dans la connection string de la subscription
CREATE SUBSCRIPTION sub_secure
CONNECTION 'host=prod.example.com port=5432 dbname=production user=replicateur password=xxx sslmode=require'
PUBLICATION pub_prod;

-- PostgreSQL 18 : Authentification OAuth 2.0
-- Nouvelle m√©thode d'authentification plus s√©curis√©e
-- Voir documentation PostgreSQL 18 pour configuration
```

---

## Partie 5 : Comparaison R√©plication Logique vs Physique

### Tableau Comparatif D√©taill√©

| Crit√®re | R√©plication Logique | R√©plication Physique (Streaming) |
|---------|---------------------|----------------------------------|
| **Granularit√©** | ‚úÖ Table par table, colonnes filtrables | ‚ùå Instance compl√®te (tout ou rien) |
| **Versions PostgreSQL** | ‚úÖ Diff√©rentes versions (ex: 13‚Üí18) | ‚ùå M√™me version majeure requise |
| **Sch√©mas diff√©rents** | ‚úÖ Possible (tables peuvent diff√©rer) | ‚ùå Sch√©ma identique obligatoire |
| **√âcriture sur replica** | ‚úÖ Possible (tables non r√©pliqu√©es) | ‚ùå Lecture seule stricte |
| **DDL automatique** | ‚ùå Manuel | ‚úÖ Automatique |
| **S√©quences** | ‚ùå Non synchronis√©es | ‚úÖ Automatique |
| **Large Objects** | ‚ùå Non support√©s | ‚úÖ Support√©s |
| **Overhead CPU** | ‚ö†Ô∏è Moyen-√©lev√© (10-20%) | ‚úÖ Faible (1-2%) |
| **Overhead I/O** | ‚ö†Ô∏è Moyen | ‚úÖ Faible |
| **Latence typique** | ‚ö†Ô∏è Quelques secondes | ‚úÖ < 1 seconde |
| **Complexit√© gestion** | ‚ö†Ô∏è Moyenne | ‚úÖ Simple |
| **Cas d'usage** | Migration, Analytics, Multi-sources | Haute disponibilit√©, Failover |
| **Gestion conflits** | ‚ùå Complexe (si multi-master) | ‚úÖ N/A (read-only replica) |
| **PostgreSQL 18 perf** | ‚ö†Ô∏è Optimisations continues | ‚úÖ Tr√®s performant |

### Quand Utiliser Chaque Type ?

#### ‚úÖ Utiliser la R√©plication Logique Quand :

- Migration entre versions PostgreSQL
- R√©plication s√©lective (certaines tables seulement)
- Filtrage de donn√©es (WHERE clause, colonnes)
- Agr√©gation multi-sources
- N√©cessit√© d'√©crire sur le replica (tables non r√©pliqu√©es)
- Architecture microservices (replication partielle)
- Conformit√© RGPD (filtrage g√©ographique)

#### ‚úÖ Utiliser la R√©plication Physique Quand :

- Haute disponibilit√© (HA) critique
- Failover automatique requis
- Latence minimale exig√©e (< 100ms)
- R√©plication compl√®te n√©cessaire
- Simplicit√© de gestion prioritaire
- Charge √©lev√©e (overhead minimal requis)
- Disaster Recovery (DR)

---

## Partie 6 : Checklist de Validation Avant Production

### Avant de Mettre en Production la R√©plication Logique

```
‚ñ° Validation Technique
  ‚ñ° Toutes les tables ont des cl√©s primaires
  ‚ñ° Aucune table ne contient de Large Objects (LO)
  ‚ñ° Les s√©quences ne causeront pas de conflits
  ‚ñ° Le sch√©ma est identique source/destination
  ‚ñ° Les extensions n√©cessaires sont install√©es
  ‚ñ° wal_level = logical configur√©
  ‚ñ° max_replication_slots suffisant
  ‚ñ° Param√®tres r√©seau optimis√©s

‚ñ° Performance et Dimensionnement
  ‚ñ° Overhead CPU acceptable en charge
  ‚ñ° Bande passante r√©seau suffisante
  ‚ñ° Latence de r√©plication acceptable
  ‚ñ° Espace disque pour WAL retention
  ‚ñ° Tests de charge effectu√©s
  ‚ñ° Benchmarks avant/apr√®s r√©plication

‚ñ° S√©curit√©
  ‚ñ° Utilisateur de r√©plication avec droits minimaux
  ‚ñ° SSL/TLS activ√© (sslmode=require)
  ‚ñ° pg_hba.conf configur√© (IPs restreintes)
  ‚ñ° Mots de passe s√©curis√©s
  ‚ñ° Audit des acc√®s configur√©

‚ñ° Monitoring
  ‚ñ° Alertes sur lag de r√©plication (> 5 secondes)
  ‚ñ° Alertes sur WAL retention (> 10 GB)
  ‚ñ° Alertes sur slots inactifs
  ‚ñ° Dashboard de monitoring (Grafana)
  ‚ñ° Logs centralis√©s
  ‚ñ° Tests de failover effectu√©s

‚ñ° Op√©rationnel
  ‚ñ° Proc√©dure DDL document√©e
  ‚ñ° Runbook de gestion des conflits
  ‚ñ° Plan de rollback pr√©par√©
  ‚ñ° Formation des √©quipes effectu√©e
  ‚ñ° Contacts d'escalade d√©finis
  ‚ñ° Documentation √† jour

‚ñ° Conformit√©
  ‚ñ° Validation RGPD (donn√©es sensibles)
  ‚ñ° Audit de s√©curit√© effectu√©
  ‚ñ° Backup strategy d√©finie
  ‚ñ° Plan de Disaster Recovery
  ‚ñ° Tests de restauration effectu√©s
```

---

## Partie 7 : D√©pannage (Troubleshooting)

### Probl√®mes Courants et Solutions

#### Probl√®me 1 : "could not create replication slot"

**Erreur** :
```
ERROR: could not create replication slot "sub_prod_slot":
ERROR: all replication slots are in use
```

**Cause** : `max_replication_slots` trop faible.

**Solution** :
```sql
-- V√©rifier l'utilisation actuelle
SELECT count(*) FROM pg_replication_slots;

-- Dans postgresql.conf
max_replication_slots = 10  -- Augmenter

-- Red√©marrer PostgreSQL
sudo systemctl restart postgresql
```

#### Probl√®me 2 : Lag de R√©plication √âlev√©

**Sympt√¥me** :
```sql
SELECT
    pg_size_pretty(pg_wal_lsn_diff(latest_end_lsn, received_lsn)) AS lag
FROM pg_stat_subscription;
-- R√©sultat : lag = 500 MB (probl√©matique)
```

**Causes Possibles et Solutions** :

```sql
-- 1. Charge √©lev√©e sur le subscriber
-- Solution : Augmenter max_logical_replication_workers
ALTER SYSTEM SET max_logical_replication_workers = 8;
SELECT pg_reload_conf();

-- 2. R√©seau satur√©
-- Solution : V√©rifier avec iperf, netstat
-- Activer la compression (PG 14+)

-- 3. Tables sans index
-- Solution : Ajouter des index sur les colonnes fr√©quemment filtr√©es
CREATE INDEX idx_commandes_client ON commandes(client_id);

-- 4. Requ√™tes lentes sur le subscriber
-- Solution : Analyser avec pg_stat_statements
SELECT query, mean_exec_time
FROM pg_stat_statements
ORDER BY mean_exec_time DESC LIMIT 10;
```

#### Probl√®me 3 : Slot Invalide (Trop de WAL)

**Erreur** :
```
WARNING: replication slot "sub_prod_slot" has been invalidated
DETAIL: This slot has been invalidated because it exceeded max_slot_wal_keep_size.
```

**Solution** :
```sql
-- La subscription doit √™tre recr√©√©e compl√®tement

-- 1. Sur le subscriber : Supprimer la subscription
DROP SUBSCRIPTION sub_prod;

-- 2. Sur le publisher : Le slot est d√©j√† supprim√©
SELECT * FROM pg_replication_slots;  -- V√©rifier

-- 3. Recr√©er la subscription (copie compl√®te)
CREATE SUBSCRIPTION sub_prod
CONNECTION '...'
PUBLICATION pub_prod
WITH (copy_data = true);  -- Re-copie toutes les donn√©es
```

#### Probl√®me 4 : Conflits de Donn√©es

**Erreur** :
```
ERROR: duplicate key value violates unique constraint "clients_pkey"
```

**Solution** :
```sql
-- 1. Identifier la ligne en conflit (dans les logs)
-- ERROR: Key (id)=(12345) already exists.

-- 2. R√©soudre manuellement
DELETE FROM clients WHERE id = 12345;  -- Ou UPDATE

-- 3. R√©activer la subscription
ALTER SUBSCRIPTION sub_prod ENABLE;

-- 4. Pr√©venir : Utiliser UUID
ALTER TABLE clients ADD COLUMN uuid UUID DEFAULT gen_random_uuid();
-- Puis migrer vers UUID comme PK
```

---

## Conclusion et Recommandations

### R√©sum√© des Limitations Principales

La r√©plication logique PostgreSQL est puissante mais pr√©sente des contraintes qu'il est essentiel de comprendre :

#### ‚ùå Limitations Techniques
- DDL non r√©pliqu√© automatiquement
- S√©quences non synchronis√©es
- Large Objects non support√©s
- Tables sans PK non r√©plicables
- TRUNCATE non r√©pliqu√© par d√©faut

#### ‚ö†Ô∏è Limitations de Performance
- Overhead CPU de 10-20%
- Consommation WAL accrue
- Latence de quelques secondes
- Complexit√© de gestion

#### üîß Limitations Op√©rationnelles
- Gestion manuelle des conflits
- Surveillance active requise
- Formation des √©quipes n√©cessaire
- Complexit√© si multi-master

### Quand la R√©plication Logique Est le Bon Choix

‚úÖ **Cas d'usage id√©aux** :
- Migration entre versions
- R√©plication s√©lective
- Analytics/Reporting
- Multi-sources
- Conformit√© (RGPD)

‚úÖ **Si vous pouvez accepter** :
- Quelques secondes de latence
- Gestion manuelle des DDL
- Overhead mod√©r√©
- Architecture master-replica

### Quand Envisager des Alternatives

‚ùå **R√©plication physique plut√¥t si** :
- HA critique (failover < 1s)
- R√©plication compl√®te requise
- Simplicit√© prioritaire
- Latence minimale exig√©e

‚ùå **Solutions externes plut√¥t si** :
- Multi-master complexe requis
- R√©solution automatique de conflits
- Synchronisation bi-directionnelle
- (Consid√©rer: BDR, Patroni avec Logical, ou solutions comme CockroachDB)

### Recommandations Finales

1. **Toujours tester en staging** avant production
2. **Documenter** la proc√©dure DDL
3. **Monitorer** activement (lag, slots, WAL)
4. **Former** les √©quipes sur les limitations
5. **Pr√©voir** un plan de rollback
6. **Utiliser UUID** pour √©viter conflits de PK
7. **Automatiser** la surveillance avec alertes
8. **Planifier** la maintenance r√©guli√®re

### Ressources Compl√©mentaires

- **Documentation officielle PostgreSQL 18** : Section Logical Replication
- **pg_stat_subscription** : Vue syst√®me essentielle
- **pgBadger** : Analyse des logs
- **Prometheus + Grafana** : Monitoring
- **Communaut√© PostgreSQL** : Forums, Discord, Reddit

---


‚è≠Ô∏è [Slots de r√©plication : Physical vs Logical](/17-haute-disponibilite-et-replication/04-slots-de-replication.md)
