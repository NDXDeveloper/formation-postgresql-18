üîù Retour au [Sommaire](/SOMMAIRE.md)

# 17.5.1. Promotion Manuelle (pg_ctl promote)

## Introduction

Dans une architecture de haute disponibilit√© PostgreSQL, vous disposez g√©n√©ralement d'un serveur **Primary** (principal) qui accepte les lectures et √©critures, et d'un ou plusieurs serveurs **Standby** (secondaires) qui r√©pliquent les donn√©es du Primary en temps r√©el.

La **promotion** est l'op√©ration qui consiste √† transformer un serveur Standby en serveur Primary. Cette op√©ration est n√©cessaire lorsque :

- Le serveur Primary tombe en panne (failover)
- Vous devez effectuer une maintenance planifi√©e sur le Primary
- Vous souhaitez basculer vers un autre datacenter
- Vous effectuez un test de reprise apr√®s sinistre (disaster recovery)

La promotion manuelle avec `pg_ctl promote` est la m√©thode la plus simple et la plus directe pour effectuer cette op√©ration.

---

## Concept de Base : Primary et Standby

### Le Serveur Primary (Principal)

Le serveur Primary est le serveur PostgreSQL qui :
- Accepte les connexions en **lecture ET √©criture**
- G√©n√®re les fichiers WAL (Write-Ahead Logs) contenant toutes les modifications
- Est la source de v√©rit√© de vos donn√©es

### Le Serveur Standby (Secondaire)

Le serveur Standby est un serveur PostgreSQL qui :
- Est en mode **r√©plication** (lecture seule par d√©faut)
- Re√ßoit continuellement les fichiers WAL du Primary
- Rejoue ces WAL pour maintenir une copie √† jour des donn√©es
- Peut accepter des requ√™tes en lecture (Hot Standby)

### La Promotion : Transformation Standby ‚Üí Primary

Lorsque vous **promouvez** un Standby :
1. Le Standby arr√™te de recevoir les WAL du Primary
2. Il termine de rejouer tous les WAL qu'il a en attente
3. Il passe en mode lecture-√©criture
4. Il devient le nouveau Primary et commence √† g√©n√©rer ses propres WAL

---

## La Commande `pg_ctl promote`

### Syntaxe de Base

```bash
pg_ctl promote -D /chemin/vers/data/directory
```

### Param√®tres Principaux

| Param√®tre | Description | Exemple |
|-----------|-------------|---------|
| `-D` ou `--pgdata` | R√©pertoire de donn√©es du Standby | `-D /var/lib/postgresql/data` |
| `-t` ou `--timeout` | Temps d'attente maximal (secondes) | `-t 60` |
| `-w` | Attendre que la promotion soit termin√©e | `-w` |
| `-W` | Ne pas attendre (mode asynchrone) | `-W` |

### Exemple Complet

```bash
# Promotion avec attente de confirmation
pg_ctl promote -D /var/lib/postgresql/14/main -w -t 60

# Message de sortie attendu :
# waiting for server to promote.... done
# server promoted
```

---

## Pr√©requis Avant la Promotion

### 1. V√©rifier l'√âtat du Standby

Avant de promouvoir, assurez-vous que le Standby est :

**a) Bien en mode r√©plication**

Connectez-vous au Standby avec `psql` et ex√©cutez :

```sql
SELECT pg_is_in_recovery();
```

- **R√©sultat attendu** : `t` (true) ‚Üí Le serveur est en mode recovery/standby
- Si `f` (false) ‚Üí Le serveur est d√©j√† un Primary !

**b) √Ä jour avec le Primary**

V√©rifiez le retard de r√©plication :

```sql
SELECT
    pg_last_wal_receive_lsn() AS derniere_reception,
    pg_last_wal_replay_lsn() AS derniere_application,
    pg_last_wal_receive_lsn() = pg_last_wal_replay_lsn() AS est_a_jour;
```

- `est_a_jour = true` ‚Üí Tous les WAL re√ßus ont √©t√© appliqu√©s
- Un petit retard est normal, mais un retard important peut indiquer un probl√®me

### 2. S'Assurer que le Primary est Vraiment Hors Service

‚ö†Ô∏è **ATTENTION** : Ne jamais promouvoir un Standby si le Primary est encore actif !

**Cons√©quence** : Vous auriez alors **deux Primary** (split-brain), ce qui m√®nerait √† une **corruption des donn√©es**.

**V√©rifications √† effectuer** :
- Le Primary ne r√©pond plus aux connexions r√©seau
- Le Primary est physiquement arr√™t√© ou isol√© du r√©seau
- Les applications ne peuvent plus se connecter au Primary

### 3. Pr√©venir les Applications

Avant la promotion :
- Informer les utilisateurs d'une interruption de service imminente
- Mettre les applications en mode maintenance si possible
- Noter les applications qui devront reconfigurer leur connexion apr√®s promotion

---

## Proc√©dure Compl√®te de Promotion Manuelle

### √âtape 1 : V√©rifications Pr√©liminaires

```bash
# 1. Connectez-vous au serveur Standby (SSH)
ssh postgres@serveur-standby

# 2. Devenez l'utilisateur postgres
sudo su - postgres

# 3. V√©rifiez que le serveur est bien en mode standby
psql -c "SELECT pg_is_in_recovery();"
# R√©sultat attendu : t
```

### √âtape 2 : V√©rifier le Retard de R√©plication

```bash
psql -c "
SELECT
    CASE
        WHEN pg_last_wal_receive_lsn() = pg_last_wal_replay_lsn()
        THEN 'Standby √† jour'
        ELSE 'Standby en retard'
    END AS statut,
    pg_wal_lsn_diff(pg_last_wal_receive_lsn(), pg_last_wal_replay_lsn()) AS retard_bytes;
"
```

### √âtape 3 : Lancer la Promotion

```bash
# Promotion avec attente de confirmation (recommand√©)
pg_ctl promote -D /var/lib/postgresql/14/main -w

# OU avec timeout explicite
pg_ctl promote -D /var/lib/postgresql/14/main -w -t 60
```

**Que se passe-t-il pendant la promotion ?**

1. PostgreSQL termine de rejouer tous les WAL en attente
2. PostgreSQL √©crit un fichier sp√©cial signalant la fin du mode recovery
3. PostgreSQL d√©marre en mode lecture-√©criture
4. PostgreSQL est maintenant un Primary capable d'accepter des √©critures

### √âtape 4 : V√©rifier la Promotion

```bash
# V√©rifier que le serveur n'est plus en recovery
psql -c "SELECT pg_is_in_recovery();"
# R√©sultat attendu : f (false)

# V√©rifier que le serveur accepte les √©critures
psql -c "CREATE TABLE test_promotion (id serial primary key, donnee text);"
psql -c "INSERT INTO test_promotion (donnee) VALUES ('Test r√©ussi');"
psql -c "SELECT * FROM test_promotion;"
psql -c "DROP TABLE test_promotion;"
```

### √âtape 5 : Reconfigurer les Applications

Une fois la promotion r√©ussie :
- Mettez √† jour les cha√Ænes de connexion des applications pour pointer vers le nouveau Primary
- Si vous utilisez un syst√®me de basculement (HAProxy, PgBouncer), mettez √† jour la configuration
- Testez la connectivit√© depuis les applications

---

## D√©tails Techniques de la Promotion

### Fichiers Impliqu√©s

Pendant la promotion, PostgreSQL manipule plusieurs fichiers :

**1. Le fichier `standby.signal`**
- **Pr√©sent sur un Standby** : Indique que le serveur est en mode r√©plication
- **Supprim√© lors de la promotion** : PostgreSQL le supprime automatiquement
- Emplacement : `$PGDATA/standby.signal`

**2. Le fichier `recovery.conf` (PostgreSQL < 12)**
- Ancienne m√©thode de configuration de la r√©plication
- Renomm√© en `recovery.done` apr√®s promotion

**3. Le fichier `postgresql.auto.conf`**
- Peut contenir des param√®tres de r√©plication
- Non modifi√© automatiquement lors de la promotion

### Que se Passe-t-il en Arri√®re-Plan ?

```
1. pg_ctl envoie un signal SIGUSR1 au processus postmaster
2. Le postmaster d√©tecte la demande de promotion
3. Le Startup Process termine de rejouer les WAL
4. PostgreSQL supprime standby.signal
5. PostgreSQL d√©marre les processus en mode Primary :
   - WAL Writer (√©criture des WAL)
   - Background Writer
   - Autovacuum
6. Le serveur accepte maintenant les connexions en √©criture
```

### Temps de Promotion

Le temps n√©cessaire pour une promotion d√©pend de :

| Facteur | Impact |
|---------|--------|
| **Retard de r√©plication** | Plus il y a de WAL √† rejouer, plus c'est long |
| **Taille des WAL** | Des transactions volumineuses prennent du temps |
| **Performance disque** | Les I/O influencent la vitesse de replay |
| **Configuration** | `recovery_target_action` peut imposer des pauses |

**Dur√©e typique** : De quelques secondes √† quelques minutes

---

## Sc√©narios d'Usage

### Sc√©nario 1 : Panne du Primary (Failover Non Planifi√©)

**Contexte** : Le serveur Primary est tomb√© en panne (hardware, r√©seau, corruption)

**Proc√©dure** :
1. Confirmer que le Primary est inaccessible
2. V√©rifier l'√©tat du Standby (retard de r√©plication)
3. Promouvoir le Standby avec `pg_ctl promote`
4. Reconfigurer les applications
5. Enqu√™ter sur la cause de la panne du Primary

**Consid√©ration** : Le Primary doit √™tre compl√®tement isol√© pour √©viter un split-brain

---

### Sc√©nario 2 : Maintenance Planifi√©e (Switchover)

**Contexte** : Vous devez effectuer une maintenance sur le Primary (mise √† jour OS, migration)

**Proc√©dure** :
1. Annoncer une fen√™tre de maintenance
2. Passer les applications en lecture seule (optionnel)
3. Attendre que le Standby soit compl√®tement √† jour
4. Arr√™ter proprement le Primary : `pg_ctl stop -m fast`
5. Promouvoir le Standby : `pg_ctl promote`
6. Basculer les applications vers le nouveau Primary
7. (Optionnel) Transformer l'ancien Primary en nouveau Standby

**Avantage** : Contr√¥le total et minimisation de la perte de donn√©es

---

### Sc√©nario 3 : Test de Disaster Recovery

**Contexte** : Vous testez votre plan de reprise apr√®s sinistre

**Proc√©dure** :
1. Isoler un Standby de test du Primary (r√©seau s√©par√©)
2. Promouvoir ce Standby de test
3. V√©rifier l'int√©grit√© des donn√©es
4. Tester la connectivit√© applicative
5. D√©truire le Standby de test apr√®s validation

**Important** : Ne jamais promouvoir un Standby de production pendant un test !

---

## Gestion des Erreurs et Troubleshooting

### Erreur 1 : "server is not in standby mode"

**Message complet** :
```
pg_ctl: cannot promote server; server is not in standby mode
```

**Cause** : Le serveur est d√©j√† un Primary

**Solution** :
```bash
# V√©rifier le mode du serveur
psql -c "SELECT pg_is_in_recovery();"
# Si false (f), c'est d√©j√† un Primary
```

---

### Erreur 2 : "promotion timed out"

**Message** :
```
pg_ctl: promotion timed out
```

**Cause** : La promotion prend plus de temps que le timeout configur√©

**Solution** :
```bash
# Augmenter le timeout
pg_ctl promote -D /var/lib/postgresql/14/main -w -t 300

# V√©rifier les logs pour comprendre le d√©lai
tail -f /var/log/postgresql/postgresql-14-main.log
```

**Raisons possibles** :
- Beaucoup de WAL √† rejouer
- Disque lent ou satur√©
- Corruption de WAL (rare)

---

### Erreur 3 : "could not connect to server"

**Message** :
```
pg_ctl: could not connect to server
```

**Cause** : PostgreSQL n'est pas d√©marr√© ou ne r√©pond pas

**Solution** :
```bash
# V√©rifier si PostgreSQL est en cours d'ex√©cution
pg_ctl status -D /var/lib/postgresql/14/main

# Si arr√™t√©, le d√©marrer d'abord
pg_ctl start -D /var/lib/postgresql/14/main
```

---

### Erreur 4 : Split-Brain (Deux Primary actifs)

**Sympt√¥me** : Apr√®s promotion, l'ancien Primary red√©marre et accepte aussi des √©critures

**Cons√©quence** : **CORRUPTION DE DONN√âES GARANTIE**

**Pr√©vention** :
- Utiliser des m√©canismes de fencing (STONITH, IPMI, watchdogs)
- Arr√™ter physiquement le Primary avant promotion
- Utiliser Patroni ou Repmgr pour g√©rer automatiquement le fencing

**D√©tection** :
```bash
# Sur chaque serveur, v√©rifier le mode
psql -c "SELECT pg_is_in_recovery();"
# Si les deux renvoient 'f' (false), vous avez un split-brain !
```

**R√©solution** :
1. Identifier le serveur avec les donn√©es les plus r√©centes
2. Arr√™ter imm√©diatement l'autre serveur
3. Reconstruire compl√®tement le Standby depuis le Primary valide

---

## Alternatives et Outils Compl√©mentaires

### 1. Utilisation de `pg_ctl` vs Signal Direct

**M√©thode pg_ctl** (recommand√©e) :
```bash
pg_ctl promote -D /var/lib/postgresql/14/main
```

**M√©thode par signal** (niveau expert) :
```bash
# Trouver le PID du postmaster
PID=$(head -1 /var/lib/postgresql/14/main/postmaster.pid)

# Envoyer le signal SIGUSR1
kill -SIGUSR1 $PID
```

Les deux m√©thodes ont le m√™me effet, mais `pg_ctl promote` est plus s√ªr et plus clair.

---

### 2. Fichier `promote` (M√©thode Trigger)

**Alternative historique** : Cr√©er un fichier `promote` dans `$PGDATA`

```bash
# M√©thode par fichier trigger
touch /var/lib/postgresql/14/main/promote

# PostgreSQL d√©tectera ce fichier au prochain cycle et se promouvra
```

**Note** : Cette m√©thode est moins utilis√©e depuis l'existence de `pg_ctl promote`

---

### 3. Fonction SQL `pg_promote()` (PostgreSQL 12+)

**Nouveaut√© PostgreSQL 12** : Vous pouvez promouvoir depuis une connexion SQL

```sql
-- Depuis une session psql connect√©e au Standby
SELECT pg_promote();
```

**Avantage** : Permet d'automatiser la promotion via des scripts SQL

**Cas d'usage** : Int√©gration dans des outils de monitoring ou d'orchestration

---

## Consid√©rations de Haute Disponibilit√©

### 1. Cascade de Standby

Si vous aviez plusieurs Standby en cascade :

```
Primary ‚Üí Standby A ‚Üí Standby B
```

Apr√®s promotion de Standby A :
- Standby B doit √™tre reconfigur√© pour se connecter au nouveau Primary (ancien Standby A)
- Sinon, Standby B restera en √©tat "d√©connect√©"

**Reconfiguration de Standby B** :
```bash
# √âditer postgresql.auto.conf ou primary_conninfo
# Changer l'IP du Primary pour pointer vers Standby A promu

# Red√©marrer Standby B
pg_ctl restart -D /var/lib/postgresql/14/main
```

---

### 2. R√©plication Synchrone

Si le Primary utilisait la r√©plication **synchrone** :

```sql
-- Configuration sur l'ancien Primary
synchronous_standby_names = 'standby1';
```

**Apr√®s promotion**, le nouveau Primary h√©rite de cette configuration, mais :
- Il n'y a plus de Standby synchrone imm√©diatement
- Les transactions vont **attendre** un Standby qui n'existe pas
- **Impact** : Les √©critures seront bloqu√©es !

**Solution** : D√©sactiver temporairement la r√©plication synchrone

```sql
-- Sur le nouveau Primary
ALTER SYSTEM SET synchronous_standby_names = '';
SELECT pg_reload_conf();
```

Vous pourrez r√©activer la r√©plication synchrone une fois qu'un nouveau Standby sera configur√©.

---

### 3. Slots de R√©plication

Si le Primary utilisait des **slots de r√©plication** :

```sql
-- Liste des slots sur le Primary
SELECT slot_name, active FROM pg_replication_slots;
```

Apr√®s promotion :
- Les slots sont pr√©serv√©s, mais ne sont plus actifs
- Si vous reconstruisez l'ancien Primary en Standby, vous devrez recr√©er les slots

---

## Automatisation vs Manuelle

### Quand Utiliser la Promotion Manuelle ?

- ‚úÖ **Environnements de d√©veloppement ou test**
- ‚úÖ **Clusters de petite taille** (1 Primary + 1 Standby)
- ‚úÖ **Maintenance planifi√©e** avec contr√¥le total
- ‚úÖ **Apprentissage et compr√©hension des m√©canismes**

### Quand Utiliser des Outils d'Automatisation ?

- ‚úÖ **Production critique** (99.99% uptime)
- ‚úÖ **Clusters complexes** (plusieurs Standby)
- ‚úÖ **Failover automatique requis** (RTO < 2 minutes)
- ‚úÖ **R√©partition g√©ographique** (multi-datacenter)

**Outils recommand√©s** :
- **Patroni** : HA automatis√© avec consensus (etcd, Consul, ZooKeeper)
- **Repmgr** : Gestion de r√©plication simplifi√©e
- **pg_auto_failover** : Solution simple de Citus Data

---

## Checklist de Promotion Manuelle

Avant de promouvoir un Standby en production, suivez cette checklist :

### Phase de Pr√©paration

- [ ] Le Primary est confirm√© hors service (panne ou arr√™t volontaire)
- [ ] Le Standby est en bonne sant√© (logs, connectivit√©)
- [ ] Le retard de r√©plication est acceptable (<1 minute)
- [ ] Les applications sont pr√©venues d'une indisponibilit√©
- [ ] Un backup r√©cent est disponible (au cas o√π)
- [ ] La proc√©dure de rollback est document√©e

### Phase de Promotion

- [ ] Connexion SSH au serveur Standby √©tablie
- [ ] Utilisateur postgres actif
- [ ] Commande `pg_ctl promote` pr√©par√©e
- [ ] Logs PostgreSQL surveill√©s en temps r√©el
- [ ] Commande ex√©cut√©e : `pg_ctl promote -D /path -w -t 60`

### Phase de V√©rification

- [ ] La promotion a r√©ussi (message "server promoted")
- [ ] `pg_is_in_recovery()` retourne `f` (false)
- [ ] Le serveur accepte les connexions en √©criture
- [ ] Test d'√©criture r√©ussi (INSERT/UPDATE)
- [ ] Les autres Standby sont reconfigur√©s (si applicable)

### Phase de Bascule Applicative

- [ ] Cha√Ænes de connexion applicatives mises √† jour
- [ ] Tests de connectivit√© depuis les applications
- [ ] V√©rification des logs applicatifs (pas d'erreurs)
- [ ] Monitoring activ√© sur le nouveau Primary
- [ ] Communication aux utilisateurs (fin de maintenance)

### Phase Post-Promotion

- [ ] Surveillance intensive du nouveau Primary (24-48h)
- [ ] V√©rification des performances (pas de d√©gradation)
- [ ] Planification de la reconstruction d'un nouveau Standby
- [ ] Documentation de l'incident (si failover non planifi√©)
- [ ] Retour d'exp√©rience (REX) avec l'√©quipe

---

## R√©sum√© des Concepts Cl√©s

### Ce qu'il Faut Retenir

1. **Promotion = Transformation Standby ‚Üí Primary**
   - Le Standby devient autonome et accepte les √©critures

2. **Commande de Base**
   ```bash
   pg_ctl promote -D /chemin/vers/data -w
   ```

3. **Pr√©requis Essentiels**
   - Le Primary doit √™tre hors service (√©viter le split-brain)
   - Le Standby doit √™tre √† jour (retard minimal)
   - Les applications doivent √™tre reconfigur√©es apr√®s promotion

4. **V√©rifications Post-Promotion**
   - `pg_is_in_recovery()` ‚Üí doit retourner `false`
   - Test d'√©criture manuel pour confirmer le mode lecture-√©criture

5. **Risque Principal : Split-Brain**
   - Deux Primary actifs = corruption garantie
   - Toujours s'assurer que l'ancien Primary est isol√©

---

## Pour Aller Plus Loin

Une fois que vous ma√Ætrisez la promotion manuelle, vous pourrez explorer :

- **Patroni** : Automatisation compl√®te du failover avec consensus distribu√©
- **Repmgr** : Gestion simplifi√©e de clusters de r√©plication
- **R√©plication Logique** : Alternative √† la r√©plication physique pour des cas d'usage sp√©cifiques
- **Load Balancing** : R√©partition automatique des requ√™tes (HAProxy, PgBouncer)
- **Monitoring Avanc√©** : Supervision de la sant√© des r√©plicas (pg_stat_replication)

---

## Conclusion

La promotion manuelle avec `pg_ctl promote` est une comp√©tence fondamentale pour tout administrateur PostgreSQL. Bien qu'elle soit remplac√©e par des solutions automatis√©es en production critique, comprendre son fonctionnement vous permet de :

- **Comprendre les m√©canismes** de haute disponibilit√©
- **Intervenir en cas d'urgence** lorsque les outils automatiques √©chouent
- **Tester votre infrastructure** de r√©plication
- **Concevoir des architectures** r√©silientes

La ma√Ætrise de cette technique est une √©tape essentielle vers l'expertise PostgreSQL en production.

---

**Prochaine √©tape recommand√©e** : √âtudier la section 17.5.2 sur Patroni pour comprendre comment automatiser ce processus dans des environnements de production.

‚è≠Ô∏è [Patroni : HA automatis√© avec consensus (etcd, Consul)](/17-haute-disponibilite-et-replication/05.2-patroni-ha-automatise.md)
