üîù Retour au [Sommaire](/SOMMAIRE.md)

# 17.6.1. Synchrone vs Asynchrone : Trade-offs

## Introduction

Dans le contexte de la haute disponibilit√© PostgreSQL, la r√©plication permet de maintenir des copies de vos donn√©es sur plusieurs serveurs. Mais toutes les r√©plications ne fonctionnent pas de la m√™me mani√®re. La principale distinction r√©side dans le **moment** o√π les donn√©es sont consid√©r√©es comme "sauvegard√©es" : imm√©diatement sur tous les serveurs (synchrone) ou d'abord sur le serveur principal puis propag√©es aux autres (asynchrone).

Ce chapitre vous aidera √† comprendre les diff√©rences fondamentales entre ces deux approches et √† choisir celle qui convient le mieux √† vos besoins.

---

## Rappel : Qu'est-ce que la r√©plication ?

Avant d'aborder les diff√©rences, rappelons bri√®vement le principe de la r√©plication dans PostgreSQL :

- **Serveur Primary (Primaire)** : Le serveur principal qui accepte les √©critures
- **Serveur Standby (Secondaire)** : Un ou plusieurs serveurs qui re√ßoivent une copie des donn√©es
- **WAL (Write-Ahead Log)** : Le journal des modifications qui est envoy√© du Primary vers les Standby

La r√©plication permet de :
- Prot√©ger contre la perte de donn√©es (disaster recovery)
- Distribuer la charge de lecture sur plusieurs serveurs
- Assurer la continuit√© de service en cas de panne

---

## R√©plication Asynchrone : La Performance Avant Tout

### Principe de fonctionnement

Dans la r√©plication **asynchrone** (le mode par d√©faut de PostgreSQL) :

1. Une transaction est valid√©e (COMMIT) sur le serveur Primary
2. PostgreSQL **confirme imm√©diatement** au client que la transaction est r√©ussie
3. Les modifications sont ensuite envoy√©es aux serveurs Standby **en arri√®re-plan**
4. Les Standby appliquent les modifications d√®s qu'ils les re√ßoivent

```
Client ‚Üí Primary ‚Üí Confirmation imm√©diate ‚úì
         ‚Üì
         Standby (plus tard)
```

### Avantages

**üöÄ Performance maximale**
- Aucune attente pour les clients
- Les transactions sont aussi rapides que sur un serveur standalone
- Id√©al pour les applications √† fort trafic

**üåç Tol√©rance √† la latence r√©seau**
- Fonctionne bien m√™me avec des Standby g√©ographiquement √©loign√©s
- Pas d'impact si le r√©seau est lent ou instable

**üí™ R√©silience**
- Si un Standby tombe en panne, le Primary continue de fonctionner normalement
- Pas de point de d√©faillance unique (SPOF) li√© √† la r√©plication

### Inconv√©nients

**‚ö†Ô∏è Risque de perte de donn√©es**

C'est le principal compromis : si le serveur Primary tombe en panne **avant** que les modifications n'aient √©t√© envoy√©es aux Standby, ces donn√©es sont perdues.

**Exemple concret :**
```
10:00:00 - Transaction valid√©e sur le Primary
10:00:01 - Confirmation envoy√©e au client ‚úì
10:00:02 - PANNE du Primary avant envoi aux Standby ‚ö°
‚Üí Les donn√©es de cette transaction sont perdues
```

**üìä D√©calage temporel (Replication Lag)**

Les serveurs Standby peuvent √™tre "en retard" par rapport au Primary :
- Quelques millisecondes en conditions normales
- Plusieurs secondes voire minutes en cas de charge √©lev√©e ou probl√®me r√©seau
- Les lectures sur les Standby peuvent retourner des donn√©es obsol√®tes

### Cas d'usage typiques

La r√©plication asynchrone est recommand√©e pour :

- **Applications web grand public** o√π la performance prime
- **Analytics et reporting** o√π un l√©ger d√©calage est acceptable
- **R√©plication g√©ographique** entre datacenters distants
- **Disaster Recovery** o√π l'objectif est surtout la protection contre une panne majeure
- **Budget limit√©** (pas besoin de mat√©riel r√©seau haute performance)

---

## R√©plication Synchrone : La Fiabilit√© Avant Tout

### Principe de fonctionnement

Dans la r√©plication **synchrone** :

1. Une transaction est valid√©e (COMMIT) sur le serveur Primary
2. PostgreSQL **attend** que les modifications soient re√ßues par au moins un serveur Standby
3. **Seulement apr√®s confirmation** du Standby, PostgreSQL confirme au client
4. Les donn√©es sont garanties pr√©sentes sur au moins deux serveurs

```
Client ‚Üí Primary ‚Üí Attente ‚Üí Standby confirme ‚úì
         ‚Üì                   ‚Üë
         ‚îî‚îÄ‚îÄ‚îÄ Envoi WAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì
         Confirmation au client ‚úì
```

### Avantages

**üõ°Ô∏è Protection maximale contre la perte de donn√©es**

Les donn√©es valid√©es sont **garanties** d'exister sur au moins deux serveurs :
- M√™me si le Primary tombe en panne, aucune transaction valid√©e n'est perdue
- Le Standby poss√®de exactement les m√™mes donn√©es que le Primary au moment de la panne

**üìç Coh√©rence stricte**

- Vous savez avec certitude que vos donn√©es sont dupliqu√©es
- RPO (Recovery Point Objective) = 0 : aucune perte de donn√©es

**‚öñÔ∏è Conformit√© r√©glementaire**

Certains secteurs (bancaire, sant√©, industrie) exigent une protection maximale des donn√©es. La r√©plication synchrone peut aider √† r√©pondre √† ces exigences.

### Inconv√©nients

**üêå Impact sur les performances**

Chaque transaction d'√©criture est **plus lente** car elle doit attendre :
- La transmission r√©seau vers le Standby
- La r√©ception et l'accus√© de r√©ception du Standby

**Ordre de grandeur :**
- R√©seau local (LAN) : +1 √† 5 ms par transaction
- R√©seau distant (WAN) : +50 √† 200 ms ou plus

Pour une application qui fait 100 √©critures par seconde, cela peut repr√©senter un impact significatif.

**üåê Sensibilit√© √† la latence r√©seau**

Plus le Standby est √©loign√©, plus l'impact est fort :
- R√©plication entre deux serveurs dans le m√™me datacenter : viable
- R√©plication entre deux continents : tr√®s probl√©matique

**‚ö° Point de d√©faillance**

Si le Standby synchrone tombe en panne :
- Le Primary **attend** qu'il revienne (mode par d√©faut)
- Toutes les √©critures sont **bloqu√©es**
- Il faut reconfigurer manuellement pour continuer

**Mitigation :** PostgreSQL permet de configurer plusieurs Standby synchrones avec des priorit√©s diff√©rentes.

### Cas d'usage typiques

La r√©plication synchrone est recommand√©e pour :

- **Applications financi√®res** (transactions bancaires, paiements)
- **Donn√©es critiques** o√π aucune perte n'est acceptable
- **Syst√®mes de sant√©** (dossiers m√©dicaux)
- **E-commerce** (commandes, paiements)
- **Infrastructure r√©seau fiable** avec faible latence

---

## Tableau Comparatif : Synchrone vs Asynchrone

| Crit√®re | Asynchrone | Synchrone |
|---------|------------|-----------|
| **Performance** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellente | ‚≠ê‚≠ê‚≠ê Bonne (impact latence) |
| **Protection donn√©es** | ‚≠ê‚≠ê‚≠ê Bonne (risque de perte) | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellente (aucune perte) |
| **Latence r√©seau** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Tr√®s tol√©rant | ‚≠ê‚≠ê Sensible |
| **R√©plication distante** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Id√©al | ‚≠ê‚≠ê Difficile |
| **Complexit√©** | ‚≠ê‚≠ê‚≠ê‚≠ê Simple | ‚≠ê‚≠ê‚≠ê Moyenne |
| **Disponibilit√©** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Continue | ‚≠ê‚≠ê‚≠ê D√©pend du Standby |
| **RPO** | Quelques secondes/minutes | 0 (aucune perte) |
| **RTO** | Quelques secondes/minutes | Quelques secondes/minutes |

---

## Les Modes Hybrides : Le Meilleur des Deux Mondes ?

PostgreSQL offre des options interm√©diaires pour √©quilibrer performance et fiabilit√© :

### 1. Synchronous Commit = remote_write

Au lieu d'attendre que le Standby **applique** les modifications, le Primary attend seulement qu'elles soient **√©crites sur disque** par le Standby.

**Trade-off :**
- Protection contre une panne du Primary
- Mais pas contre une panne simultan√©e des deux serveurs
- Performance l√©g√®rement meilleure que `synchronous_commit = on`

### 2. Synchronous Commit = remote_apply

Le Primary attend que le Standby ait **appliqu√©** les modifications et qu'elles soient **visibles** pour les lectures.

**Trade-off :**
- Garantie que les lectures sur le Standby sont √† jour
- Performance encore plus impact√©e (attente suppl√©mentaire)
- Utile pour les architectures de load balancing

### 3. R√©plication avec Quorum

PostgreSQL permet de configurer un **quorum** : attendre la confirmation de N serveurs parmi M Standby.

**Exemple : `synchronous_standby_names = 'ANY 2 (standby1, standby2, standby3)'`**
- Le Primary attend la confirmation de **2 serveurs parmi 3**
- Meilleure tol√©rance aux pannes qu'avec un seul Standby synchrone
- Flexibilit√© accrue

---

## Comment Choisir ? Arbre de D√©cision

### Posez-vous ces questions :

**1. Quelle est la criticit√© de vos donn√©es ?**
- Critique (finance, sant√©) ‚Üí **Synchrone**
- Importante mais r√©cup√©rable ‚Üí **Asynchrone**

**2. Quel est votre RPO (Recovery Point Objective) ?**
- RPO = 0 (aucune perte acceptable) ‚Üí **Synchrone**
- RPO = quelques secondes/minutes ‚Üí **Asynchrone**

**3. Quelle est votre latence r√©seau vers les Standby ?**
- < 5 ms (m√™me datacenter) ‚Üí **Synchrone viable**
- > 50 ms (g√©ographiquement distant) ‚Üí **Asynchrone recommand√©**

**4. Quel est votre volume d'√©critures ?**
- Tr√®s √©lev√© ‚Üí **Asynchrone** (pour pr√©server les performances)
- Mod√©r√© ‚Üí **Synchrone** (impact acceptable)

**5. Avez-vous une infrastructure r√©seau fiable ?**
- Oui (datacenter de qualit√©) ‚Üí **Synchrone possible**
- Non (r√©seau public, instable) ‚Üí **Asynchrone pr√©f√©rable**

### Sc√©nario recommand√© : Architecture hybride

De nombreuses organisations utilisent une **combinaison** des deux :

```
Primary
  ‚îú‚îÄ‚îÄ Standby 1 (Synchrone, m√™me datacenter)
  ‚îî‚îÄ‚îÄ Standby 2 (Asynchrone, datacenter distant)
```

**Avantages :**
- Protection maximale contre la perte de donn√©es (Standby synchrone local)
- Protection g√©ographique contre un d√©sastre (Standby asynchrone distant)
- Performance acceptable (latence locale faible)

---

## Configuration dans PostgreSQL

### R√©plication Asynchrone (par d√©faut)

Sur le serveur **Primary**, aucune configuration sp√©ciale n'est n√©cessaire. La r√©plication est asynchrone par d√©faut.

```sql
-- V√©rifier le mode actuel
SHOW synchronous_commit;
-- R√©sultat : on (mais asynchrone si aucun standby synchrone n'est configur√©)
```

### R√©plication Synchrone

Sur le serveur **Primary**, dans `postgresql.conf` :

```conf
# D√©finir les serveurs Standby synchrones
synchronous_standby_names = 'standby1'

# Ou avec quorum (attendre 1 parmi 2)
synchronous_standby_names = 'ANY 1 (standby1, standby2)'

# Ou attendre tous les serveurs
synchronous_standby_names = 'FIRST 2 (standby1, standby2)'
```

Sur le serveur **Standby**, dans `postgresql.conf` :

```conf
# D√©finir le nom de l'application (doit correspondre √† synchronous_standby_names)
primary_conninfo = 'host=primary_ip port=5432 user=replication application_name=standby1'
```

### V√©rification du mode actif

```sql
-- Voir l'√©tat de la r√©plication
SELECT
    application_name,
    state,
    sync_state,  -- 'sync' ou 'async'
    sync_priority
FROM pg_stat_replication;
```

---

## M√©triques √† Surveiller

Quelle que soit votre configuration, surveillez ces indicateurs :

### Pour la r√©plication asynchrone :

**1. Replication Lag (d√©calage)**
```sql
SELECT
    application_name,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS lag_bytes,
    extract(epoch from (now() - pg_last_xact_replay_timestamp()))::int AS lag_seconds
FROM pg_stat_replication;
```

**Objectif :** Maintenir un lag < 1 seconde en conditions normales

**2. WAL Sender State**
- V√©rifier que le processus `wal sender` est actif
- Surveiller l'utilisation r√©seau

### Pour la r√©plication synchrone :

**1. Dur√©e des commits**
```sql
-- Activer le tracking
ALTER SYSTEM SET track_commit_timestamp = on;
SELECT pg_reload_conf();
```

**Objectif :** Dur√©e acceptable selon vos SLA (< 10 ms id√©alement)

**2. √âtat des Standby synchrones**
```sql
SELECT sync_state, state
FROM pg_stat_replication
WHERE sync_state = 'sync';
```

**Objectif :** Toujours au moins un Standby en √©tat 'sync' et 'streaming'

---

## Erreurs Courantes √† √âviter

### ‚ùå Configurer la r√©plication synchrone sans surveiller les performances

**Probl√®me :** L'impact sur les temps de r√©ponse peut √™tre significatif et d√©grader l'exp√©rience utilisateur.

**Solution :** Testez en environnement de pr√©production et surveillez les m√©triques de latence.

### ‚ùå Utiliser la r√©plication synchrone avec un Standby distant (WAN)

**Probl√®me :** La latence r√©seau √©lev√©e rend toutes les √©critures tr√®s lentes.

**Solution :** Utilisez l'asynchrone pour les Standby distants et le synchrone uniquement pour les Standby locaux.

### ‚ùå Ne pas configurer de Standby de secours pour la r√©plication synchrone

**Probl√®me :** Si le seul Standby synchrone tombe, toutes les √©critures sont bloqu√©es.

**Solution :** Configurez plusieurs Standby avec priorit√©s ou utilisez un quorum.

### ‚ùå Croire que l'asynchrone = pas de protection

**Probl√®me :** Sous-estimer la valeur de la r√©plication asynchrone.

**R√©alit√© :** L'asynchrone offre une excellente protection contre la plupart des pannes. Le lag est g√©n√©ralement de quelques millisecondes en conditions normales.

---

## Cas Pratiques : Quelle Configuration pour Quel Besoin ?

### Cas 1 : Application Web E-Commerce

**Besoins :**
- Performance essentielle (temps de r√©ponse < 100 ms)
- Protection contre les pannes
- Tol√©rance √† la perte de quelques transactions en cas de catastrophe

**Recommandation :** **Asynchrone** avec un Standby local + un Standby distant

**Justification :**
- Les utilisateurs ne doivent pas subir de ralentissement
- La perte de quelques secondes de transactions est acceptable en cas de catastrophe majeure
- Le Standby local permet une promotion rapide en cas de panne

### Cas 2 : Syst√®me Bancaire (Transactions)

**Besoins :**
- Aucune perte de transaction acceptable
- Conformit√© r√©glementaire stricte
- Performance secondaire (mais importante)

**Recommandation :** **Synchrone** avec quorum (2 Standby locaux)

**Justification :**
- RPO = 0 exig√©
- Le quorum √©vite le point de d√©faillance unique
- Infrastructure r√©seau de qualit√© bancaire avec latence < 2 ms

### Cas 3 : Plateforme Analytics / Data Warehouse

**Besoins :**
- Gros volumes de donn√©es
- Tol√©rance au d√©calage (quelques minutes)
- R√©plication vers plusieurs datacenters

**Recommandation :** **Asynchrone** exclusivement

**Justification :**
- La nature analytique tol√®re un d√©calage
- Les performances d'√©criture sont critiques (imports massifs)
- R√©plication g√©ographique impossible en synchrone

### Cas 4 : Plateforme SaaS Multi-Tenant

**Besoins :**
- Balance entre performance et fiabilit√©
- Clients avec diff√©rents SLA
- Architecture multi-r√©gion

**Recommandation :** **Hybride** - Synchrone local + Asynchrone distant

**Justification :**
- Protection maximale avec impact performance minimal (synchrone local)
- Disaster recovery g√©ographique (asynchrone distant)
- Flexibilit√© selon les clients (certains peuvent choisir asynchrone uniquement)

---

## Conclusion : Il n'y a pas de "Meilleur" Choix Universel

Le choix entre r√©plication synchrone et asynchrone n'est pas binaire. Il d√©pend de votre contexte sp√©cifique :

**Choisissez l'asynchrone si :**
- La performance est votre priorit√© num√©ro 1
- Vous avez une infrastructure r√©seau √©tendue
- Vous acceptez un RPO de quelques secondes
- Vous avez un fort volume d'√©critures

**Choisissez la synchrone si :**
- La perte de donn√©es est inacceptable (RPO = 0)
- Vous avez une infrastructure r√©seau fiable et rapide
- Vos contraintes r√©glementaires l'exigent
- Votre volume d'√©critures est mod√©r√©

**Choisissez l'hybride si :**
- Vous voulez le meilleur des deux mondes
- Vous avez plusieurs datacenters
- Vous avez besoin de protection locale ET g√©ographique

**Points cl√©s √† retenir :**

1. **L'asynchrone n'est pas "dangereux"** : Le lag est g√©n√©ralement minimal et offre une excellente protection
2. **La synchrone a un co√ªt** : Impact performance et complexit√© op√©rationnelle
3. **Testez avant de d√©cider** : Mesurez l'impact r√©el dans votre environnement
4. **Surveillez en continu** : Les m√©triques de r√©plication doivent faire partie de votre monitoring
5. **√âvoluez progressivement** : Commencez asynchrone, puis passez au synchrone si n√©cessaire

La r√©plication PostgreSQL est un outil puissant et flexible. Comprendre les trade-offs vous permet de faire le choix optimal pour votre architecture.

---

**Prochaine section :** 17.6.2. Quorum-based commit - Approfondir les configurations de quorum pour la haute disponibilit√©

**Ressources compl√©mentaires :**
- Documentation officielle : [High Availability, Load Balancing, and Replication](https://www.postgresql.org/docs/current/high-availability.html)
- Section 17.2 : R√©plication Physique (Streaming Replication)
- Section 17.3 : R√©plication Logique

‚è≠Ô∏è [Quorum-based commit](/17-haute-disponibilite-et-replication/06.2-quorum-based-commit.md)
