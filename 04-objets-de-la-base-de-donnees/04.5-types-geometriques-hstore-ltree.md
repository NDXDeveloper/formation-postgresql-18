üîù Retour au [Sommaire](/SOMMAIRE.md)

# 4.4.5. Types G√©om√©triques, hstore et ltree

## Introduction

PostgreSQL offre des types de donn√©es sp√©cialis√©s pour g√©rer des cas d'usage avanc√©s : formes g√©om√©triques, paires cl√©-valeur et structures hi√©rarchiques. Ces types sont moins courants dans les applications quotidiennes mais extr√™mement puissants pour des besoins sp√©cifiques.

Dans cette section, nous allons explorer :
- **Types g√©om√©triques** : Stocker et manipuler des formes g√©om√©triques simples
- **hstore** : Stocker des paires cl√©-valeur (alternative l√©g√®re √† JSONB)
- **ltree** : Repr√©senter et requ√™ter des hi√©rarchies et structures arborescentes

**Note importante :** Pour la plupart des applications g√©ospatiales modernes, vous utiliserez l'extension **PostGIS** plut√¥t que les types g√©om√©triques natifs. PostGIS sera couvert dans une section ult√©rieure.

---

## 1. Types G√©om√©triques

### Vue d'Ensemble

PostgreSQL fournit des types natifs pour repr√©senter des objets g√©om√©triques en 2D. Ces types sont simples et int√©gr√©s directement dans le moteur.

| Type | Description | Exemple |
|------|-------------|---------|
| `POINT` | Un point (x, y) | `(1, 2)` |
| `LINE` | Ligne infinie (Ax + By + C = 0) | `{A, B, C}` |
| `LSEG` | Segment de ligne (deux points) | `[(0,0),(1,1)]` |
| `BOX` | Rectangle (deux points oppos√©s) | `(1,1),(3,3)` |
| `PATH` | Chemin (suite de points) | `[(0,0),(1,1),(2,0)]` |
| `POLYGON` | Polygone ferm√© | `((0,0),(1,0),(1,1),(0,1))` |
| `CIRCLE` | Cercle (centre + rayon) | `<(0,0),5>` |

### POINT (Point)

Un **POINT** repr√©sente une position en 2D avec des coordonn√©es (x, y).

```sql
-- Cr√©er une table avec des points
CREATE TABLE lieux (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    position POINT
);

-- Ins√©rer des points (syntaxe : (x, y))
INSERT INTO lieux (nom, position) VALUES
    ('Tour Eiffel', POINT(48.858844, 2.294351)),
    ('Louvre', POINT(48.860611, 2.337644)),
    ('Notre-Dame', POINT(48.852968, 2.349902));

-- Ou avec notation texte
INSERT INTO lieux (nom, position) VALUES
    ('Arc de Triomphe', '(48.873792, 2.295028)');

SELECT * FROM lieux;
```

#### Op√©rations sur les Points

```sql
-- Acc√©der aux coordonn√©es
SELECT
    nom,
    position,
    position[0] AS longitude,  -- x
    position[1] AS latitude    -- y
FROM lieux;

-- Distance entre deux points (distance euclidienne)
SELECT
    l1.nom AS lieu1,
    l2.nom AS lieu2,
    l1.position <-> l2.position AS distance
FROM lieux l1, lieux l2
WHERE l1.id < l2.id;

-- Point le plus proche
SELECT nom, position
FROM lieux
WHERE nom != 'Tour Eiffel'
ORDER BY position <-> POINT(48.858844, 2.294351)
LIMIT 1;
```

### BOX (Rectangle)

Un **BOX** repr√©sente un rectangle d√©fini par deux coins oppos√©s.

```sql
CREATE TABLE zones (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    perimetre BOX
);

-- Ins√©rer des rectangles
-- Syntaxe : (coin_haut_droit, coin_bas_gauche)
INSERT INTO zones (nom, perimetre) VALUES
    ('Zone A', BOX(POINT(0, 0), POINT(10, 10))),
    ('Zone B', '((5, 5), (15, 15))');

SELECT * FROM zones;
```

#### Op√©rations sur les BOX

```sql
-- Aire du rectangle
SELECT
    nom,
    area(perimetre) AS aire
FROM zones;

-- V√©rifier si un point est dans un rectangle
SELECT nom
FROM zones
WHERE perimetre @> POINT(7, 7);  -- Le point (7,7) est-il dans la zone ?

-- V√©rifier si deux rectangles se chevauchent
SELECT z1.nom, z2.nom
FROM zones z1, zones z2
WHERE z1.id < z2.id
  AND z1.perimetre && z2.perimetre;  -- Chevauchement
```

### CIRCLE (Cercle)

Un **CIRCLE** est d√©fini par un centre (point) et un rayon.

```sql
CREATE TABLE zones_circulaires (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    zone CIRCLE
);

-- Ins√©rer des cercles
-- Syntaxe : <(x, y), rayon>
INSERT INTO zones_circulaires (nom, zone) VALUES
    ('Zone Centre', CIRCLE(POINT(0, 0), 5)),
    ('Zone Nord', '<(0, 10), 3>');

SELECT * FROM zones_circulaires;
```

#### Op√©rations sur les CIRCLE

```sql
-- Aire du cercle
SELECT
    nom,
    area(zone) AS aire,
    radius(zone) AS rayon,
    center(zone) AS centre
FROM zones_circulaires;

-- V√©rifier si un point est dans un cercle
SELECT nom
FROM zones_circulaires
WHERE zone @> POINT(2, 2);

-- Distance entre centres de deux cercles
SELECT
    z1.nom,
    z2.nom,
    center(z1.zone) <-> center(z2.zone) AS distance_centres
FROM zones_circulaires z1, zones_circulaires z2
WHERE z1.id < z2.id;
```

### POLYGON (Polygone)

Un **POLYGON** est une forme ferm√©e d√©finie par une suite de points.

```sql
CREATE TABLE parcelles (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    forme POLYGON
);

-- Ins√©rer des polygones
-- Triangle
INSERT INTO parcelles (nom, forme) VALUES
    ('Parcelle Triangle', '((0,0), (4,0), (2,3))');

-- Carr√©
INSERT INTO parcelles (nom, forme) VALUES
    ('Parcelle Carr√©e', '((0,0), (5,0), (5,5), (0,5))');

-- Pentagone irr√©gulier
INSERT INTO parcelles (nom, forme) VALUES
    ('Parcelle Complexe', '((0,0), (5,0), (6,3), (3,6), (-1,3))');

SELECT * FROM parcelles;
```

#### Op√©rations sur les POLYGON

```sql
-- Aire du polygone
SELECT
    nom,
    area(forme) AS aire,
    npoints(forme) AS nombre_points
FROM parcelles;

-- V√©rifier si un point est dans un polygone
SELECT nom
FROM parcelles
WHERE forme @> POINT(2, 2);

-- V√©rifier si deux polygones se chevauchent
SELECT p1.nom, p2.nom
FROM parcelles p1, parcelles p2
WHERE p1.id < p2.id
  AND p1.forme && p2.forme;
```

### PATH (Chemin)

Un **PATH** repr√©sente un chemin (suite de points reli√©s). Il peut √™tre ouvert ou ferm√©.

```sql
CREATE TABLE trajets (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    parcours PATH
);

-- Chemin ouvert : [(x1,y1), (x2,y2), ...]
INSERT INTO trajets (nom, parcours) VALUES
    ('Route A', '[(0,0), (1,1), (2,1), (3,2)]');

-- Chemin ferm√© : ((x1,y1), (x2,y2), ...)
INSERT INTO trajets (nom, parcours) VALUES
    ('Circuit B', '((0,0), (2,0), (2,2), (0,2))');

SELECT * FROM trajets;
```

### Fonctions et Op√©rateurs G√©om√©triques

```sql
-- Distance entre objets
SELECT point1 <-> point2 AS distance;

-- Contient (est √† l'int√©rieur de)
SELECT box @> point;  -- Le point est-il dans le rectangle ?
SELECT circle @> point;  -- Le point est-il dans le cercle ?

-- Chevauche (intersecte)
SELECT box1 && box2;  -- Les rectangles se chevauchent-ils ?

-- √Ä gauche de / √† droite de
SELECT point1 << point2;  -- point1 est strictement √† gauche de point2
SELECT point1 >> point2;  -- point1 est strictement √† droite de point2

-- Au-dessus / en-dessous
SELECT point1 |<< point2;  -- point1 est strictement en dessous de point2
SELECT point1 |>> point2;  -- point1 est strictement au-dessus de point2

-- Centre d'un objet
SELECT center(circle);
SELECT center(box);

-- Aire
SELECT area(circle);
SELECT area(box);
SELECT area(polygon);

-- Rayon
SELECT radius(circle);

-- Nombre de points
SELECT npoints(path);
SELECT npoints(polygon);
```

### Cas d'Usage des Types G√©om√©triques

#### 1. Application de Cartographie Simple

```sql
CREATE TABLE batiments (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    emplacement POINT,
    emprise BOX,  -- Rectangle du b√¢timent
    type VARCHAR(50)
);

INSERT INTO batiments (nom, emplacement, emprise, type) VALUES
    ('Biblioth√®que', POINT(10, 10), BOX(POINT(9, 9), POINT(11, 11)), 'Public'),
    ('√âcole', POINT(20, 20), BOX(POINT(18, 18), POINT(22, 22)), '√âducation');

-- Trouver les b√¢timents dans une zone
SELECT nom
FROM batiments
WHERE emprise && BOX(POINT(0, 0), POINT(15, 15));

-- B√¢timents les plus proches d'un point
SELECT nom, type
FROM batiments
ORDER BY emplacement <-> POINT(12, 12)
LIMIT 3;
```

#### 2. Zones de Livraison

```sql
CREATE TABLE zones_livraison (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    zone CIRCLE,
    frais_livraison NUMERIC(5, 2)
);

INSERT INTO zones_livraison (nom, zone, frais_livraison) VALUES
    ('Centre-ville', CIRCLE(POINT(0, 0), 5), 5.00),
    ('Banlieue proche', CIRCLE(POINT(0, 0), 10), 10.00),
    ('Banlieue √©loign√©e', CIRCLE(POINT(0, 0), 20), 15.00);

-- V√©rifier les frais de livraison pour une adresse
SELECT nom, frais_livraison
FROM zones_livraison
WHERE zone @> POINT(3, 4)
ORDER BY frais_livraison
LIMIT 1;
```

### Limites des Types G√©om√©triques Natifs

**‚ö†Ô∏è Important :** Les types g√©om√©triques natifs de PostgreSQL sont limit√©s :
- ‚ùå Pas de support des projections cartographiques
- ‚ùå Pas de g√©od√©sie (calculs sur sph√®re/ellipso√Øde)
- ‚ùå Fonctionnalit√©s limit√©es compar√© √† PostGIS
- ‚ùå Pas de support des formats standards (WKT, GeoJSON)

**Recommandation :** Pour des applications g√©ospatiales s√©rieuses, utilisez **PostGIS** (extension PostgreSQL d√©di√©e).

---

## 2. hstore (Paires Cl√©-Valeur)

### Qu'est-ce que hstore ?

**hstore** est un type de donn√©es qui stocke des ensembles de paires **cl√©-valeur** (similaire √† un dictionnaire ou un hash). C'est une alternative plus l√©g√®re √† JSONB pour des donn√©es simples.

### Diff√©rences : hstore vs JSONB

| Aspect | hstore | JSONB |
|--------|--------|-------|
| Structure | Plat (cl√©-valeur simple) | Hi√©rarchique (objets imbriqu√©s) |
| Valeurs | Texte uniquement | Tout type JSON (nombres, bool, tableaux, objets) |
| Performance | L√©g√®rement plus rapide | Tr√®s bon |
| Taille | Plus compact | Plus gros |
| **Recommandation moderne** | Legacy (h√©ritage) | **Pr√©f√©rer JSONB** |

**Note :** hstore est historique. Pour les nouveaux projets, **JSONB est g√©n√©ralement pr√©f√©r√©**.

### Activer l'Extension hstore

```sql
-- Activer l'extension hstore
CREATE EXTENSION IF NOT EXISTS hstore;
```

### Cr√©ation et Insertion

```sql
CREATE TABLE produits_hstore (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    attributs hstore  -- Paires cl√©-valeur
);

-- Ins√©rer des donn√©es hstore
INSERT INTO produits_hstore (nom, attributs) VALUES
    ('Ordinateur',
     'marque => "Dell", processeur => "Intel i7", ram => "16GB", couleur => "Noir"'),
    ('T√©l√©phone',
     'marque => "Samsung", stockage => "128GB", couleur => "Bleu", ecran => "6.5 pouces"'),
    ('Tablette',
     'marque => "Apple", stockage => "256GB", couleur => "Argent"');

SELECT * FROM produits_hstore;
```

### Acc√©der aux Donn√©es hstore

```sql
-- Acc√©der √† une valeur par cl√©
SELECT
    nom,
    attributs -> 'marque' AS marque,
    attributs -> 'couleur' AS couleur
FROM produits_hstore;

-- V√©rifier si une cl√© existe
SELECT nom
FROM produits_hstore
WHERE attributs ? 'processeur';  -- Poss√®de la cl√© 'processeur'

-- V√©rifier si contient plusieurs cl√©s
SELECT nom
FROM produits_hstore
WHERE attributs ?& ARRAY['marque', 'couleur'];  -- Poss√®de toutes ces cl√©s

-- V√©rifier si contient au moins une cl√©
SELECT nom
FROM produits_hstore
WHERE attributs ?| ARRAY['processeur', 'stockage'];  -- Poss√®de au moins une

-- Filtrer par valeur
SELECT nom
FROM produits_hstore
WHERE attributs -> 'marque' = 'Dell';

-- Recherche de paire cl√©-valeur
SELECT nom
FROM produits_hstore
WHERE attributs @> 'couleur => "Noir"'::hstore;
```

### Modifier des Donn√©es hstore

```sql
-- Ajouter ou mettre √† jour une paire
UPDATE produits_hstore
SET attributs = attributs || 'garantie => "2 ans"'::hstore
WHERE nom = 'Ordinateur';

-- Supprimer une cl√©
UPDATE produits_hstore
SET attributs = delete(attributs, 'couleur')
WHERE nom = 'T√©l√©phone';

-- Supprimer plusieurs cl√©s
UPDATE produits_hstore
SET attributs = delete(attributs, ARRAY['couleur', 'ecran'])
WHERE nom = 'T√©l√©phone';
```

### Fonctions hstore

```sql
-- akeys : Obtenir toutes les cl√©s
SELECT akeys(attributs) FROM produits_hstore;

-- avals : Obtenir toutes les valeurs
SELECT avals(attributs) FROM produits_hstore;

-- each : D√©composer en lignes (cl√©, valeur)
SELECT nom, (each(attributs)).*
FROM produits_hstore
WHERE nom = 'Ordinateur';

-- hstore_to_json : Convertir en JSON
SELECT
    nom,
    hstore_to_json(attributs) AS attributs_json
FROM produits_hstore;

-- Nombre de paires
SELECT
    nom,
    array_length(akeys(attributs), 1) AS nombre_attributs
FROM produits_hstore;
```

### Indexation hstore

```sql
-- Index GIN pour recherches
CREATE INDEX idx_produits_attributs ON produits_hstore USING GIN (attributs);

-- Requ√™tes optimis√©es
SELECT * FROM produits_hstore
WHERE attributs @> 'marque => "Dell"'::hstore;  -- Utilise l'index
```

### Cas d'Usage de hstore

#### 1. Attributs Produits Variables

```sql
CREATE TABLE catalogue (
    id SERIAL PRIMARY KEY,
    categorie VARCHAR(100),
    nom VARCHAR(200),
    prix NUMERIC(10, 2),
    specifications hstore
);

-- √âlectronique
INSERT INTO catalogue (categorie, nom, prix, specifications) VALUES
    ('√âlectronique', 'Laptop Pro', 1299.99,
     'cpu => "i7", ram => "32GB", ssd => "1TB", gpu => "RTX 3060"');

-- V√™tements
INSERT INTO catalogue (categorie, nom, prix, specifications) VALUES
    ('V√™tements', 'T-Shirt', 29.99,
     'taille => "M", couleur => "Bleu", matiere => "Coton"');

-- Livres
INSERT INTO catalogue (categorie, nom, prix, specifications) VALUES
    ('Livres', 'PostgreSQL Guide', 49.99,
     'auteur => "Expert DB", pages => "500", langue => "FR"');
```

#### 2. Param√®tres Utilisateurs

```sql
CREATE TABLE parametres_utilisateurs (
    user_id INTEGER PRIMARY KEY,
    preferences hstore
);

INSERT INTO parametres_utilisateurs VALUES
    (1, 'theme => "dark", langue => "fr", notifications => "true", timezone => "Europe/Paris"'),
    (2, 'theme => "light", langue => "en", notifications => "false"');

-- R√©cup√©rer les pr√©f√©rences
SELECT
    user_id,
    preferences -> 'theme' AS theme,
    preferences -> 'langue' AS langue
FROM parametres_utilisateurs;
```

### hstore vs JSONB : Quand Utiliser Quoi ?

```sql
-- Exemple identique avec JSONB (RECOMMAND√â)
CREATE TABLE produits_jsonb (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    attributs JSONB
);

INSERT INTO produits_jsonb (nom, attributs) VALUES
    ('Ordinateur',
     '{"marque": "Dell", "processeur": "Intel i7", "ram": "16GB", "prix": 1200}'::JSONB);

-- JSONB supporte des structures complexes
INSERT INTO produits_jsonb (nom, attributs) VALUES
    ('Smartphone',
     '{
         "marque": "Samsung",
         "prix": 799,
         "specifications": {
             "ecran": "6.5 pouces",
             "batterie": 5000
         },
         "couleurs_disponibles": ["Noir", "Bleu", "Blanc"]
     }'::JSONB);
```

**Conclusion :** Pour les nouveaux projets, **utilisez JSONB** au lieu de hstore.

---

## 3. ltree (Structures Hi√©rarchiques)

### Qu'est-ce que ltree ?

**ltree** est un type de donn√©es sp√©cialis√© pour repr√©senter et manipuler des **structures hi√©rarchiques** ou **arborescentes** (comme des cat√©gories, organigrammes, chemins de fichiers, taxonomies).

### Activer l'Extension ltree

```sql
-- Activer l'extension ltree
CREATE EXTENSION IF NOT EXISTS ltree;
```

### Format et Syntaxe

Un **ltree** est un chemin compos√© de labels s√©par√©s par des points (`.`), similaire √† un chemin de fichier.

```
Format : label1.label2.label3.label4
Exemple : France.Ile_de_France.Paris.75001
Exemple : Entreprise.IT.Backend.Database
```

**R√®gles :**
- Labels : lettres, chiffres et underscores (pas d'espaces)
- S√©parateur : point (`.`)
- Maximum : 65 535 caract√®res total

### Cr√©ation et Insertion

```sql
CREATE TABLE categories (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    chemin ltree UNIQUE NOT NULL
);

-- Hi√©rarchie de cat√©gories e-commerce
INSERT INTO categories (nom, chemin) VALUES
    ('√âlectronique', 'Electronique'),
    ('Ordinateurs', 'Electronique.Ordinateurs'),
    ('Laptops', 'Electronique.Ordinateurs.Laptops'),
    ('Gaming', 'Electronique.Ordinateurs.Laptops.Gaming'),
    ('Bureautique', 'Electronique.Ordinateurs.Laptops.Bureautique'),
    ('Composants', 'Electronique.Ordinateurs.Composants'),
    ('T√©l√©phones', 'Electronique.Telephones'),
    ('Smartphones', 'Electronique.Telephones.Smartphones');

-- Hi√©rarchie g√©ographique
INSERT INTO categories (nom, chemin) VALUES
    ('France', 'Monde.Europe.France'),
    ('√éle-de-France', 'Monde.Europe.France.Ile_de_France'),
    ('Paris', 'Monde.Europe.France.Ile_de_France.Paris');

SELECT * FROM categories ORDER BY chemin;
```

### Op√©rateurs ltree

#### Anc√™tre et Descendant

```sql
-- @ : Est un descendant (ou √©gal)
SELECT nom, chemin
FROM categories
WHERE chemin @ 'Electronique.Ordinateurs';
-- Retourne : Ordinateurs, Laptops, Gaming, Bureautique, Composants

-- ~ : Correspond √† un pattern (anc√™tre)
SELECT nom, chemin
FROM categories
WHERE chemin ~ 'Electronique.*';
-- Retourne tous les descendants d'√âlectronique

-- ? : Correspond √† un pattern lquery
SELECT nom, chemin
FROM categories
WHERE chemin ~ 'Electronique.*.Gaming';
-- Retourne les chemins contenant Electronique...Gaming
```

#### Anc√™tre Commun

```sql
-- Trouver l'anc√™tre commun de deux chemins
SELECT
    'Electronique.Ordinateurs.Laptops.Gaming'::ltree <@
    'Electronique.Ordinateurs.Laptops.Bureautique'::ltree AS est_ancetre;

-- LCA : Lowest Common Ancestor (anc√™tre commun le plus proche)
SELECT lca(
    'Electronique.Ordinateurs.Laptops.Gaming'::ltree,
    'Electronique.Ordinateurs.Composants'::ltree
);
-- R√©sultat : Electronique.Ordinateurs
```

#### Sous-arbre et Niveau

```sql
-- Obtenir le premier niveau (enfants directs)
SELECT nom, chemin
FROM categories
WHERE chemin ~ 'Electronique.*{1}';
-- {1} = exactement 1 niveau en dessous

-- Obtenir tous les descendants jusqu'√† 2 niveaux
SELECT nom, chemin
FROM categories
WHERE chemin ~ 'Electronique.*{1,2}';

-- Niveau de profondeur
SELECT
    nom,
    chemin,
    nlevel(chemin) AS profondeur
FROM categories
ORDER BY profondeur;
```

### Fonctions ltree

```sql
-- nlevel : Nombre de niveaux
SELECT
    chemin,
    nlevel(chemin) AS profondeur
FROM categories;

-- subpath : Extraire une partie du chemin
SELECT
    chemin,
    subpath(chemin, 0, 2) AS deux_premiers_niveaux,
    subpath(chemin, 1) AS sans_racine
FROM categories
WHERE chemin ~ 'Electronique.*';

-- subltree : Extraire sous-arbre
SELECT
    chemin,
    subltree(chemin, 0, 2) AS sous_arbre
FROM categories;

-- index : Position d'un sous-chemin
SELECT
    chemin,
    index(chemin, 'Ordinateurs') AS position
FROM categories
WHERE chemin ~ '*.Ordinateurs.*';

-- text2ltree : Convertir texte vers ltree
SELECT text2ltree('France.Paris.75001');

-- ltree2text : Convertir ltree vers texte
SELECT ltree2text('France.Paris.75001'::ltree);
```

### Indexation ltree

```sql
-- Index GiST pour requ√™tes ltree
CREATE INDEX idx_categories_chemin ON categories USING GIST (chemin);

-- Index sur anc√™tres (pour requ√™tes de descendants)
CREATE INDEX idx_categories_chemin_ancetre ON categories USING BTREE (chemin);

-- Requ√™tes optimis√©es
SELECT * FROM categories
WHERE chemin @ 'Electronique.Ordinateurs';  -- Utilise l'index
```

### Cas d'Usage de ltree

#### 1. Cat√©gories de Produits

```sql
CREATE TABLE produits_ltree (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    categorie ltree,
    prix NUMERIC(10, 2)
);

INSERT INTO produits_ltree (nom, categorie, prix) VALUES
    ('Dell XPS 15', 'Electronique.Ordinateurs.Laptops.Bureautique', 1299.99),
    ('ASUS ROG', 'Electronique.Ordinateurs.Laptops.Gaming', 1799.99),
    ('iPhone 15', 'Electronique.Telephones.Smartphones', 999.99),
    ('Processeur i9', 'Electronique.Ordinateurs.Composants', 499.99);

-- Tous les produits dans une cat√©gorie et ses sous-cat√©gories
SELECT nom, prix
FROM produits_ltree
WHERE categorie @ 'Electronique.Ordinateurs';

-- Produits d'une cat√©gorie sp√©cifique uniquement
SELECT nom, prix
FROM produits_ltree
WHERE categorie = 'Electronique.Ordinateurs.Laptops.Gaming';
```

#### 2. Organigramme d'Entreprise

```sql
CREATE TABLE employes_org (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    poste VARCHAR(100),
    chemin_hierarchique ltree
);

INSERT INTO employes_org (nom, poste, chemin_hierarchique) VALUES
    ('Alice CEO', 'CEO', 'Entreprise'),
    ('Bob CTO', 'CTO', 'Entreprise.CTO'),
    ('Charlie Dev Manager', 'Dev Manager', 'Entreprise.CTO.Dev'),
    ('Dave Dev', 'Developer', 'Entreprise.CTO.Dev.Backend'),
    ('Eve Dev', 'Developer', 'Entreprise.CTO.Dev.Frontend'),
    ('Frank CFO', 'CFO', 'Entreprise.CFO'),
    ('Grace Comptable', 'Comptable', 'Entreprise.CFO.Compta');

-- Tous les employ√©s sous le CTO
SELECT nom, poste
FROM employes_org
WHERE chemin_hierarchique @ 'Entreprise.CTO';

-- Manager direct (parent imm√©diat)
SELECT nom, poste
FROM employes_org
WHERE chemin_hierarchique = subpath(
    'Entreprise.CTO.Dev.Backend'::ltree,
    0,
    nlevel('Entreprise.CTO.Dev.Backend'::ltree) - 1
);

-- Nombre de subordonn√©s directs
SELECT
    e.nom,
    e.poste,
    COUNT(sub.id) AS nombre_subordonnes_directs
FROM employes_org e
LEFT JOIN employes_org sub ON sub.chemin_hierarchique ~ (e.chemin_hierarchique::text || '.*{1}')::lquery
GROUP BY e.id, e.nom, e.poste;
```

#### 3. Syst√®me de Fichiers

```sql
CREATE TABLE fichiers (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    chemin ltree,
    type VARCHAR(20),  -- 'dossier' ou 'fichier'
    taille_ko INTEGER
);

INSERT INTO fichiers (nom, chemin, type, taille_ko) VALUES
    ('home', 'home', 'dossier', NULL),
    ('alice', 'home.alice', 'dossier', NULL),
    ('Documents', 'home.alice.Documents', 'dossier', NULL),
    ('rapport.pdf', 'home.alice.Documents.rapport_pdf', 'fichier', 1024),
    ('photos', 'home.alice.photos', 'dossier', NULL),
    ('vacances.jpg', 'home.alice.photos.vacances_jpg', 'fichier', 2048);

-- Lister le contenu d'un dossier (enfants directs)
SELECT nom, type, taille_ko
FROM fichiers
WHERE chemin ~ 'home.alice.*{1}'
ORDER BY type DESC, nom;

-- Taille totale d'un dossier (r√©cursif)
SELECT
    SUM(taille_ko) AS taille_totale_ko
FROM fichiers
WHERE chemin @ 'home.alice'
  AND type = 'fichier';
```

#### 4. Taxonomie Biologique

```sql
CREATE TABLE taxonomie (
    id SERIAL PRIMARY KEY,
    nom_scientifique VARCHAR(200),
    nom_commun VARCHAR(200),
    classification ltree
);

INSERT INTO taxonomie (nom_scientifique, nom_commun, classification) VALUES
    ('Animalia', 'Animaux', 'Vie.Animalia'),
    ('Chordata', 'Cord√©s', 'Vie.Animalia.Chordata'),
    ('Mammalia', 'Mammif√®res', 'Vie.Animalia.Chordata.Mammalia'),
    ('Carnivora', 'Carnivores', 'Vie.Animalia.Chordata.Mammalia.Carnivora'),
    ('Felidae', 'F√©lins', 'Vie.Animalia.Chordata.Mammalia.Carnivora.Felidae'),
    ('Panthera', 'Panth√®res', 'Vie.Animalia.Chordata.Mammalia.Carnivora.Felidae.Panthera'),
    ('Panthera leo', 'Lion', 'Vie.Animalia.Chordata.Mammalia.Carnivora.Felidae.Panthera.leo');

-- Tous les mammif√®res
SELECT nom_scientifique, nom_commun
FROM taxonomie
WHERE classification @ 'Vie.Animalia.Chordata.Mammalia';

-- Classification compl√®te d'un animal
SELECT
    subpath(classification, level) AS rang,
    level + 1 AS niveau
FROM taxonomie,
     LATERAL generate_series(0, nlevel(classification) - 1) AS level
WHERE nom_scientifique = 'Panthera leo'
ORDER BY niveau;
```

### ltree vs Approches Alternatives

#### Alternative 1 : Adjacency List (Parent ID)

```sql
-- Approche classique avec parent_id
CREATE TABLE categories_parent (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    parent_id INTEGER REFERENCES categories_parent(id)
);

-- Probl√®me : Requ√™tes r√©cursives complexes pour obtenir toute la hi√©rarchie
-- N√©cessite des CTEs r√©cursives
```

**Avantages de ltree :**
- ‚úÖ Requ√™tes de hi√©rarchie simples et rapides
- ‚úÖ Pas besoin de r√©cursion
- ‚úÖ Indexation efficace

**Inconv√©nients de ltree :**
- ‚ùå Difficile de d√©placer des sous-arbres entiers
- ‚ùå Changement de parent n√©cessite mise √† jour de tous les descendants

#### Alternative 2 : Nested Sets

```sql
-- Nested Sets (left, right)
CREATE TABLE categories_nested (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    lft INTEGER,
    rgt INTEGER
);
```

**Comparaison :**
- ltree est plus intuitif et lisible
- Nested Sets est complexe √† maintenir
- ltree pr√©f√©r√© dans la plupart des cas

---

## Comparaison et Recommandations

### Quand Utiliser Quoi ?

| Besoin | Type Recommand√© | Alternative |
|--------|----------------|-------------|
| Coordonn√©es g√©ographiques simples | `POINT` | PostGIS (recommand√©) |
| Formes g√©om√©triques 2D basiques | Types g√©om√©triques | PostGIS |
| **G√©olocalisation s√©rieuse** | **PostGIS** | - |
| Attributs cl√©-valeur simples | **JSONB** | hstore (legacy) |
| **Hi√©rarchies et arbres** | **ltree** | CTE r√©cursives |
| Cat√©gories imbriqu√©es | ltree | Parent ID + r√©cursion |
| Organigrammes | ltree | Table de jonction |

### Tableau R√©capitulatif

| Type | Cas d'Usage | Complexit√© | Performance | Recommandation |
|------|-------------|------------|-------------|----------------|
| **G√©om√©triques** | Formes 2D simples | Facile | Bonne | Utilisez PostGIS pour du s√©rieux |
| **hstore** | Cl√©-valeur plat | Facile | Excellente | Pr√©f√©rez JSONB maintenant |
| **ltree** | Hi√©rarchies | Moyenne | Excellente | ‚úÖ Recommand√© pour les arbres |

---

## Bonnes Pratiques

### 1. Types G√©om√©triques : Consid√©rez PostGIS

```sql
-- ‚ùå Pour une vraie application g√©ospatiale
CREATE TABLE lieux (position POINT);

-- ‚úÖ Utilisez PostGIS
CREATE EXTENSION postgis;
CREATE TABLE lieux (position GEOMETRY(Point, 4326));  -- WGS84
```

### 2. hstore : Pr√©f√©rez JSONB pour Nouveaux Projets

```sql
-- ‚ùå Nouveau projet avec hstore
CREATE TABLE produits (attributs hstore);

-- ‚úÖ Nouveau projet avec JSONB
CREATE TABLE produits (attributs JSONB);
```

### 3. ltree : Indexez pour Performance

```sql
-- ‚úÖ Toujours indexer les colonnes ltree
CREATE INDEX idx_categories_chemin ON categories USING GIST (chemin);

-- Pour recherches de descendants
CREATE INDEX idx_categories_ancetre ON categories USING BTREE (chemin);
```

### 4. ltree : Convention de Nommage Claire

```sql
-- ‚úÖ BON : Noms descriptifs et coh√©rents
'Electronique.Ordinateurs.Laptops.Gaming'

-- ‚ùå MAUVAIS : Noms incoh√©rents
'elec.ordi.lap.gam'  -- Trop abr√©g√©
'√âlectronique.Ordi.laptops.GAMING'  -- Incoh√©rent
```

### 5. ltree : Limiter la Profondeur

```sql
-- ‚úÖ BON : Profondeur raisonnable (3-5 niveaux)
'Entreprise.IT.Backend.Database'

-- ‚ùå √âVITER : Hi√©rarchie trop profonde
'A.B.C.D.E.F.G.H.I.J.K'  -- Difficile √† maintenir
```

---

## R√©capitulatif

### Types Sp√©cialis√©s PostgreSQL

1. **Types G√©om√©triques** : Formes 2D basiques
   - POINT, BOX, CIRCLE, POLYGON
   - Op√©rateurs : `<->`, `@>`, `&&`
   - Limit√© : pr√©f√©rer PostGIS pour g√©ospatial

2. **hstore** : Paires cl√©-valeur plates
   - Legacy, remplac√© par JSONB
   - Toujours texte uniquement
   - Extensions n√©cessaire

3. **ltree** : Structures hi√©rarchiques
   - Format : `label.sublabel.subsublabel`
   - Op√©rateurs : `@`, `~`, `?`
   - Excellent pour cat√©gories, organigrammes

### Commandes Essentielles

```sql
-- Types g√©om√©triques
SELECT point1 <-> point2;  -- Distance
SELECT box @> point;  -- Contient

-- hstore
CREATE EXTENSION hstore;
SELECT data -> 'key';  -- Acc√®s
SELECT data ? 'key';  -- Existe

-- ltree
CREATE EXTENSION ltree;
SELECT path @ 'root.child';  -- Descendant
SELECT nlevel(path);  -- Profondeur
```

---

## Conclusion

Ces types sp√©cialis√©s √©tendent PostgreSQL pour des cas d'usage sp√©cifiques :

- **Types g√©om√©triques** : Utiles pour des besoins g√©om√©triques simples, mais PostGIS est recommand√© pour du g√©ospatial s√©rieux
- **hstore** : Type historique pour cl√©-valeur, maintenant supplant√© par JSONB dans la plupart des cas
- **ltree** : Excellent choix pour repr√©senter et requ√™ter des hi√©rarchies, plus simple et performant que les CTEs r√©cursives

**ltree** est le plus utile de ces trois types dans les applications modernes, particuli√®rement pour les cat√©gories, organigrammes et structures arborescentes.

Dans la prochaine section, nous explorerons les s√©quences et la g√©n√©ration automatique de valeurs.

---


‚è≠Ô∏è [Types binaires (BYTEA) et XML](/04-objets-de-la-base-de-donnees/04.6-types-binaires-xml.md)
