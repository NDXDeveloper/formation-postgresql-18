üîù Retour au [Sommaire](/SOMMAIRE.md)

# 4.4.6. Types Binaires (BYTEA) et XML

## Introduction

PostgreSQL offre des types de donn√©es pour stocker des contenus sp√©cialis√©s : les donn√©es binaires brutes et les documents XML. Ces types sont moins courants dans les applications quotidiennes mais essentiels pour certains cas d'usage sp√©cifiques.

Dans cette section, nous allons explorer :
- **BYTEA** : Stockage de donn√©es binaires (images, fichiers, cryptographie)
- **XML** : Stockage et manipulation de documents XML

**Note importante :** Pour la plupart des cas d'usage modernes, d'autres solutions sont souvent pr√©f√©r√©es (stockage de fichiers externe, JSON au lieu de XML). Cependant, ces types restent utiles dans des contextes sp√©cifiques.

---

## 1. BYTEA (Donn√©es Binaires)

### Qu'est-ce que BYTEA ?

**BYTEA** (Binary Data) est un type de donn√©es qui permet de stocker des **s√©quences d'octets bruts** (donn√©es binaires). C'est l'√©quivalent PostgreSQL d'un BLOB (Binary Large Object).

**Utilisation typique :**
- Fichiers binaires (images, PDFs, documents)
- Donn√©es cryptographiques (cl√©s, hashes, signatures)
- Donn√©es s√©rialis√©es
- Donn√©es brutes de capteurs

### Formats d'Encodage

PostgreSQL utilise deux formats pour repr√©senter BYTEA :

| Format | Description | Exemple |
|--------|-------------|---------|
| **hex** | Hexad√©cimal (d√©faut depuis PG 9.0) | `\x48656c6c6f` |
| **escape** | Format d'√©chappement legacy | `Hello` avec √©chappements |

**Format recommand√© :** hex (plus lisible et sans ambigu√Øt√©)

```sql
-- Voir le format d'encodage actuel
SHOW bytea_output;  -- hex ou escape
```

### Cr√©ation et Insertion

```sql
CREATE TABLE fichiers (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(255) NOT NULL,
    type_mime VARCHAR(100),
    contenu BYTEA NOT NULL,
    taille INTEGER,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insertion avec format hexad√©cimal
-- 'Hello' en ASCII/UTF-8
INSERT INTO fichiers (nom, type_mime, contenu, taille) VALUES
    ('hello.txt', 'text/plain', '\x48656c6c6f'::BYTEA, 5);

-- Insertion avec texte (converti automatiquement)
INSERT INTO fichiers (nom, type_mime, contenu, taille) VALUES
    ('test.txt', 'text/plain', 'Contenu texte'::BYTEA, 13);

-- Insertion avec decode depuis base64
INSERT INTO fichiers (nom, type_mime, contenu, taille) VALUES
    ('data.bin', 'application/octet-stream',
     decode('SGVsbG8gV29ybGQ=', 'base64'), 11);

SELECT id, nom, type_mime, taille FROM fichiers;
```

### Lecture et R√©cup√©ration

```sql
-- R√©cup√©rer le contenu brut (format hex)
SELECT contenu FROM fichiers WHERE nom = 'hello.txt';
-- R√©sultat : \x48656c6c6f

-- Convertir en texte (si le contenu est du texte)
SELECT convert_from(contenu, 'UTF8') AS texte
FROM fichiers
WHERE nom = 'hello.txt';
-- R√©sultat : 'Hello'

-- Encoder en base64 pour transmission
SELECT encode(contenu, 'base64') AS base64
FROM fichiers
WHERE nom = 'hello.txt';
-- R√©sultat : 'SGVsbG8='

-- Voir la taille en octets
SELECT
    nom,
    octet_length(contenu) AS taille_octets,
    length(contenu) AS taille_octets_alt
FROM fichiers;
```

### Fonctions de Manipulation BYTEA

#### Encodage et D√©codage

```sql
-- decode : D√©coder depuis diff√©rents formats
SELECT decode('48656c6c6f', 'hex');  -- Depuis hexad√©cimal
SELECT decode('SGVsbG8=', 'base64');  -- Depuis base64
SELECT decode('Hello', 'escape');  -- Depuis format escape

-- encode : Encoder vers diff√©rents formats
SELECT encode('\x48656c6c6f'::BYTEA, 'hex');  -- Vers hexad√©cimal
SELECT encode('\x48656c6c6f'::BYTEA, 'base64');  -- Vers base64
SELECT encode('\x48656c6c6f'::BYTEA, 'escape');  -- Vers escape

-- Exemple pratique : stocker une image base64
CREATE TABLE images (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(255),
    data BYTEA
);

INSERT INTO images (nom, data) VALUES (
    'logo.png',
    decode('iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==', 'base64')
);

-- R√©cup√©rer en base64 pour affichage web
SELECT
    nom,
    'data:image/png;base64,' || encode(data, 'base64') AS data_url
FROM images;
```

#### Conversions Texte-Binaire

```sql
-- convert_to : Texte vers BYTEA
SELECT convert_to('Bonjour', 'UTF8');
SELECT convert_to('Hello', 'LATIN1');

-- convert_from : BYTEA vers texte
SELECT convert_from('\x426f6e6a6f7572'::BYTEA, 'UTF8');  -- 'Bonjour'

-- Exemple : stocker du texte en diff√©rents encodages
CREATE TABLE textes_encodes (
    id SERIAL PRIMARY KEY,
    texte_original TEXT,
    encodage VARCHAR(20),
    donnees BYTEA
);

INSERT INTO textes_encodes (texte_original, encodage, donnees) VALUES
    ('Fran√ßais', 'UTF8', convert_to('Fran√ßais', 'UTF8')),
    ('Fran√ßais', 'LATIN1', convert_to('Fran√ßais', 'LATIN1'));

SELECT
    texte_original,
    encodage,
    donnees,
    convert_from(donnees, encodage) AS texte_decode
FROM textes_encodes;
```

#### Op√©rations sur BYTEA

```sql
-- Concat√©nation
SELECT '\x4865'::BYTEA || '\x6c6c6f'::BYTEA;  -- \x48656c6c6f ('Hello')

-- Longueur
SELECT octet_length('\x48656c6c6f'::BYTEA);  -- 5 octets

-- Extraction de sous-cha√Æne
SELECT substring('\x48656c6c6f'::BYTEA FROM 1 FOR 2);  -- \x4865 ('He')

-- Position
SELECT position('\x6c6c'::BYTEA IN '\x48656c6c6f'::BYTEA);  -- 3 ('ll' commence √† l'octet 3)

-- Comparaison
SELECT '\x48656c6c6f'::BYTEA = '\x48656c6c6f'::BYTEA;  -- true
SELECT '\x48656c6c6f'::BYTEA < '\x48656c6c70'::BYTEA;  -- true (comparaison lexicographique)
```

### Fonctions Cryptographiques (Extension pgcrypto)

```sql
-- Activer l'extension pgcrypto
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Hachage MD5
SELECT md5('password');  -- Retourne texte hexad√©cimal

-- Hachage SHA-256 (retourne BYTEA)
SELECT digest('password', 'sha256');
SELECT encode(digest('password', 'sha256'), 'hex');  -- En hexad√©cimal

-- Hachage SHA-512
SELECT encode(digest('password', 'sha512'), 'hex');

-- HMAC (Hash-based Message Authentication Code)
SELECT encode(
    hmac('message', 'secret_key', 'sha256'),
    'hex'
);

-- G√©n√©ration de nombres al√©atoires
SELECT gen_random_bytes(16);  -- 16 octets al√©atoires
SELECT encode(gen_random_bytes(32), 'hex');  -- 32 octets en hex
```

### Cas d'Usage de BYTEA

#### 1. Stockage de Petits Fichiers

```sql
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(300),
    nom_fichier VARCHAR(255),
    type_mime VARCHAR(100),
    contenu BYTEA,
    taille INTEGER,
    uploaded_by INTEGER,
    uploaded_at TIMESTAMPTZ DEFAULT NOW()
);

-- Fonction pour calculer la taille
CREATE OR REPLACE FUNCTION set_taille()
RETURNS TRIGGER AS $$
BEGIN
    NEW.taille = octet_length(NEW.contenu);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_set_taille
BEFORE INSERT OR UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION set_taille();

-- Insertion d'un document
INSERT INTO documents (titre, nom_fichier, type_mime, contenu, uploaded_by) VALUES (
    'Facture Novembre 2025',
    'facture_nov_2025.pdf',
    'application/pdf',
    decode('JVBERi0xLjQKJeLjz9MK...', 'base64'),  -- Contenu PDF encod√©
    1
);

-- Statistiques de stockage
SELECT
    COUNT(*) AS nombre_fichiers,
    pg_size_pretty(SUM(taille)::BIGINT) AS taille_totale,
    AVG(taille) AS taille_moyenne
FROM documents;
```

**‚ö†Ô∏è Limite importante :** BYTEA peut stocker jusqu'√† 1 Go, mais pour des fichiers volumineux, il est recommand√© d'utiliser un stockage externe (S3, syst√®me de fichiers) et de stocker uniquement le chemin en base.

#### 2. Hachage de Mots de Passe

```sql
CREATE TABLE utilisateurs_secure (
    id SERIAL PRIMARY KEY,
    username VARCHAR(100) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash BYTEA NOT NULL,  -- Hash du mot de passe
    salt BYTEA NOT NULL,  -- Salt unique par utilisateur
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Fonction pour cr√©er un utilisateur avec hash s√©curis√©
CREATE OR REPLACE FUNCTION create_user(
    p_username VARCHAR,
    p_email VARCHAR,
    p_password TEXT
) RETURNS INTEGER AS $$
DECLARE
    v_salt BYTEA;
    v_hash BYTEA;
    v_user_id INTEGER;
BEGIN
    -- G√©n√©rer un salt al√©atoire
    v_salt := gen_random_bytes(32);

    -- Hasher le mot de passe avec le salt
    v_hash := digest(v_salt || convert_to(p_password, 'UTF8'), 'sha256');

    -- Ins√©rer l'utilisateur
    INSERT INTO utilisateurs_secure (username, email, password_hash, salt)
    VALUES (p_username, p_email, v_hash, v_salt)
    RETURNING id INTO v_user_id;

    RETURN v_user_id;
END;
$$ LANGUAGE plpgsql;

-- Fonction pour v√©rifier un mot de passe
CREATE OR REPLACE FUNCTION verify_password(
    p_username VARCHAR,
    p_password TEXT
) RETURNS BOOLEAN AS $$
DECLARE
    v_stored_hash BYTEA;
    v_salt BYTEA;
    v_computed_hash BYTEA;
BEGIN
    -- R√©cup√©rer le hash et le salt
    SELECT password_hash, salt
    INTO v_stored_hash, v_salt
    FROM utilisateurs_secure
    WHERE username = p_username;

    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;

    -- Calculer le hash du mot de passe fourni
    v_computed_hash := digest(v_salt || convert_to(p_password, 'UTF8'), 'sha256');

    -- Comparer
    RETURN v_stored_hash = v_computed_hash;
END;
$$ LANGUAGE plpgsql;

-- Utilisation
SELECT create_user('alice', 'alice@example.com', 'motdepasse123');
SELECT verify_password('alice', 'motdepasse123');  -- true
SELECT verify_password('alice', 'mauvais');  -- false
```

**Note :** Pour du vrai code de production, utilisez des biblioth√®ques sp√©cialis√©es comme bcrypt, scrypt ou Argon2 plut√¥t que SHA-256 simple.

#### 3. Signatures et Certificats

```sql
CREATE TABLE certificats (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    certificat BYTEA,  -- Certificat X.509
    cle_privee BYTEA,  -- Cl√© priv√©e (chiffr√©e!)
    date_expiration DATE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Stocker un certificat
INSERT INTO certificats (nom, certificat, date_expiration) VALUES (
    'SSL Certificate - example.com',
    decode('LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0t...', 'base64'),
    '2026-12-31'
);

-- V√©rifier les certificats arrivant √† expiration
SELECT nom, date_expiration
FROM certificats
WHERE date_expiration < CURRENT_DATE + INTERVAL '30 days'
ORDER BY date_expiration;
```

#### 4. Donn√©es S√©rialis√©es Binaires

```sql
CREATE TABLE donnees_serialisees (
    id SERIAL PRIMARY KEY,
    type VARCHAR(50),
    payload BYTEA,  -- Donn√©es s√©rialis√©es (protobuf, msgpack, etc.)
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Exemple : stocker des donn√©es binaires d'un protocole personnalis√©
INSERT INTO donnees_serialisees (type, payload) VALUES
    ('sensor_data', '\x010203040506070809'::BYTEA);
```

### Limites et Bonnes Pratiques avec BYTEA

#### Limites

- **Taille maximale :** Environ 1 Go (limite pratique)
- **Performance :** Stocker de gros fichiers en base ralentit les sauvegardes et les requ√™tes
- **M√©moire :** Les donn√©es BYTEA sont charg√©es enti√®rement en m√©moire

#### Bonnes Pratiques

```sql
-- ‚úÖ BON : Petits fichiers (< 1 MB)
CREATE TABLE avatars (
    user_id INTEGER PRIMARY KEY,
    image BYTEA CHECK (octet_length(image) <= 1048576)  -- Max 1 MB
);

-- ‚úÖ BON : Donn√©es cryptographiques
CREATE TABLE api_keys (
    key_hash BYTEA,  -- Hash de la cl√© API
    key_encrypted BYTEA  -- Cl√© chiffr√©e
);

-- ‚ùå MAUVAIS : Gros fichiers
-- Ne stockez pas des vid√©os, grandes images, etc. en BYTEA
-- Utilisez un stockage externe (S3, CDN) et stockez l'URL

-- ‚úÖ RECOMMAND√â : R√©f√©rence externe
CREATE TABLE videos (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(300),
    url VARCHAR(500),  -- URL vers S3/CDN
    thumbnail BYTEA  -- Seulement la miniature en base
);
```

#### Quand Utiliser BYTEA

**‚úÖ Utiliser BYTEA pour :**
- Petits fichiers (< 1 MB)
- Hashes cryptographiques
- Cl√©s et certificats
- Donn√©es binaires de petite taille
- Donn√©es n√©cessitant transaction ACID

**‚ùå Ne PAS utiliser BYTEA pour :**
- Fichiers volumineux (> 10 MB)
- Contenus multim√©dias (vid√©os, grandes images)
- Fichiers fr√©quemment t√©l√©charg√©s
- Tr√®s grand nombre de fichiers

**Alternative recommand√©e :** Stockage externe (AWS S3, Azure Blob, Google Cloud Storage) + URL en base.

---

## 2. XML (Extensible Markup Language)

### Qu'est-ce que XML ?

**XML** (Extensible Markup Language) est un format de donn√©es structur√© bas√© sur des balises, similaire √† HTML mais plus strict et extensible.

Exemple de XML :
```xml
<utilisateur>
    <nom>Alice Martin</nom>
    <email>alice@example.com</email>
    <age>30</age>
    <adresse>
        <rue>123 rue de la Paix</rue>
        <ville>Paris</ville>
        <code_postal>75001</code_postal>
    </adresse>
    <hobbies>
        <hobby>Lecture</hobby>
        <hobby>Cyclisme</hobby>
    </hobbies>
</utilisateur>
```

### XML vs JSON

| Aspect | XML | JSON |
|--------|-----|------|
| Syntaxe | Verbose (balises) | Concise |
| Lisibilit√© | Moyenne | Excellente |
| Support PostgreSQL | Type XML natif | **JSONB recommand√©** |
| Cas d'usage moderne | Legacy, √©changes B2B | **Standard moderne** |
| Performance | Plus lent | Plus rapide |

**Note importante :** Pour les nouveaux projets, **JSON/JSONB est g√©n√©ralement pr√©f√©r√©** √† XML. XML reste utile pour :
- Int√©gration avec syst√®mes legacy
- √âchanges standardis√©s (SOAP, RSS, SVG)
- Documents complexes avec sch√©mas

### Type XML dans PostgreSQL

```sql
CREATE TABLE documents_xml (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(300),
    contenu XML,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insertion de XML
INSERT INTO documents_xml (titre, contenu) VALUES (
    'Profil utilisateur',
    '<utilisateur>
        <nom>Alice Martin</nom>
        <email>alice@example.com</email>
        <age>30</age>
    </utilisateur>'
);

-- XML mal form√© (erreur)
INSERT INTO documents_xml (titre, contenu) VALUES (
    'XML invalide',
    '<utilisateur><nom>Bob</utilisateur>'  -- Balise mal ferm√©e
);
-- ERROR: invalid XML content

SELECT * FROM documents_xml;
```

### Validation XML

PostgreSQL v√©rifie que le XML est **well-formed** (bien form√©) :
- Balises correctement ouvertes et ferm√©es
- Hi√©rarchie correcte
- Caract√®res sp√©ciaux √©chapp√©s

```sql
-- XML valide
SELECT '<root><child>Texte</child></root>'::XML;

-- XML avec attributs
SELECT '<user id="123" active="true">Alice</user>'::XML;

-- XML avec espaces de noms
SELECT '<ns:element xmlns:ns="http://example.com">Contenu</ns:element>'::XML;

-- XML avec caract√®res sp√©ciaux √©chapp√©s
SELECT '<message>Price &lt; 100 &amp; Quality &gt; 5</message>'::XML;
-- < = &lt;  (less than)
-- > = &gt;  (greater than)
-- & = &amp; (ampersand)

-- Erreur : XML mal form√©
SELECT '<unclosed>'::XML;  -- ERROR
```

### Fonctions XML

#### Cr√©ation de XML

```sql
-- xmlelement : Cr√©er un √©l√©ment
SELECT xmlelement(
    name "utilisateur",
    xmlelement(name "nom", 'Alice Martin'),
    xmlelement(name "email", 'alice@example.com')
);
-- R√©sultat : <utilisateur><nom>Alice Martin</nom><email>alice@example.com</email></utilisateur>

-- xmlforest : Cr√©er plusieurs √©l√©ments
SELECT xmlforest(
    'Alice' AS prenom,
    'Martin' AS nom,
    30 AS age
);
-- R√©sultat : <prenom>Alice</prenom><nom>Martin</nom><age>30</age>

-- xmlconcat : Concat√©ner des √©l√©ments XML
SELECT xmlconcat(
    '<element1>Valeur1</element1>'::XML,
    '<element2>Valeur2</element2>'::XML
);

-- xmlcomment : Cr√©er un commentaire
SELECT xmlcomment('Ceci est un commentaire');
-- R√©sultat : <!--Ceci est un commentaire-->

-- xmlpi : Cr√©er une instruction de traitement
SELECT xmlpi(name php, 'echo "Hello"; ');
-- R√©sultat : <?php echo "Hello"; ?>
```

#### G√©n√©rer XML depuis Tables

```sql
CREATE TABLE produits_xml (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    prix NUMERIC(10, 2),
    categorie VARCHAR(100)
);

INSERT INTO produits_xml (nom, prix, categorie) VALUES
    ('Ordinateur', 999.99, '√âlectronique'),
    ('Souris', 29.99, 'Accessoires'),
    ('Clavier', 79.99, 'Accessoires');

-- G√©n√©rer XML pour chaque ligne
SELECT xmlelement(
    name "produit",
    xmlattributes(id AS "id"),
    xmlelement(name "nom", nom),
    xmlelement(name "prix", prix),
    xmlelement(name "categorie", categorie)
) AS produit_xml
FROM produits_xml;

-- R√©sultat exemple :
-- <produit id="1"><nom>Ordinateur</nom><prix>999.99</prix><categorie>√âlectronique</categorie></produit>

-- Agr√©ger en un seul document XML
SELECT xmlelement(
    name "catalogue",
    xmlagg(
        xmlelement(
            name "produit",
            xmlattributes(id AS "id"),
            xmlelement(name "nom", nom),
            xmlelement(name "prix", prix)
        )
    )
) AS catalogue_xml
FROM produits_xml;

-- R√©sultat :
-- <catalogue>
--   <produit id="1"><nom>Ordinateur</nom><prix>999.99</prix></produit>
--   <produit id="2"><nom>Souris</nom><prix>29.99</prix></produit>
--   <produit id="3"><nom>Clavier</nom><prix>79.99</prix></produit>
-- </catalogue>
```

### XPath : Requ√™ter du XML

**XPath** est un langage de requ√™te pour naviguer dans des documents XML.

```sql
-- Exemple de document XML
CREATE TABLE livres_xml (
    id SERIAL PRIMARY KEY,
    info XML
);

INSERT INTO livres_xml (info) VALUES (
    '<livre>
        <titre>PostgreSQL: Up and Running</titre>
        <auteurs>
            <auteur>Regina Obe</auteur>
            <auteur>Leo Hsu</auteur>
        </auteurs>
        <prix devise="USD">39.99</prix>
        <pages>428</pages>
    </livre>'
);

-- xpath : Extraire des valeurs avec XPath
SELECT xpath('/livre/titre/text()', info) AS titre
FROM livres_xml;
-- R√©sultat : {PostgreSQL: Up and Running}

-- Extraire plusieurs √©l√©ments
SELECT xpath('/livre/auteurs/auteur/text()', info) AS auteurs
FROM livres_xml;
-- R√©sultat : {Regina Obe, "Leo Hsu"}

-- Extraire un attribut
SELECT xpath('/livre/prix/@devise', info) AS devise
FROM livres_xml;
-- R√©sultat : {USD}

-- Extraire une valeur num√©rique et la convertir
SELECT (xpath('/livre/prix/text()', info))[1]::TEXT::NUMERIC AS prix
FROM livres_xml;
-- R√©sultat : 39.99
```

#### XPath avec Pr√©dicats

```sql
INSERT INTO livres_xml (info) VALUES (
    '<bibliotheque>
        <livre id="1">
            <titre>Livre A</titre>
            <prix>29.99</prix>
        </livre>
        <livre id="2">
            <titre>Livre B</titre>
            <prix>39.99</prix>
        </livre>
        <livre id="3">
            <titre>Livre C</titre>
            <prix>19.99</prix>
        </livre>
    </bibliotheque>'
);

-- S√©lectionner un livre par ID
SELECT xpath('/bibliotheque/livre[@id="2"]/titre/text()', info)
FROM livres_xml
WHERE id = 2;

-- Livres avec prix < 30
SELECT xpath('/bibliotheque/livre[prix < 30]/titre/text()', info)
FROM livres_xml
WHERE id = 2;

-- Premier livre
SELECT xpath('/bibliotheque/livre[1]/titre/text()', info)
FROM livres_xml
WHERE id = 2;
```

### Fonctions de Test XML

```sql
-- xmlexists : V√©rifier si un √©l√©ment existe
SELECT
    id,
    xmlexists('/livre/auteurs' PASSING info) AS a_auteurs
FROM livres_xml;

-- Filtrer avec xmlexists
SELECT * FROM livres_xml
WHERE xmlexists('/livre[prix < 40]' PASSING info);

-- Compter des √©l√©ments
SELECT
    (xpath('count(/livre/auteurs/auteur)', info))[1]::TEXT::INTEGER AS nombre_auteurs
FROM livres_xml
WHERE id = 1;
```

### Modification de XML

```sql
-- Mise √† jour de contenu XML
UPDATE livres_xml
SET info = '<livre>
        <titre>PostgreSQL: The Definitive Guide</titre>
        <auteurs>
            <auteur>Regina Obe</auteur>
        </auteurs>
        <prix devise="EUR">35.00</prix>
        <pages>450</pages>
    </livre>'::XML
WHERE id = 1;

-- Extraction, modification et r√©insertion
-- (XML n'a pas de fonctions de modification in-place comme JSONB)
```

### Cas d'Usage de XML

#### 1. Flux RSS/Atom

```sql
CREATE TABLE flux_rss (
    id SERIAL PRIMARY KEY,
    source VARCHAR(200),
    contenu XML,
    date_recuperation TIMESTAMPTZ DEFAULT NOW()
);

INSERT INTO flux_rss (source, contenu) VALUES (
    'Blog Tech',
    '<?xml version="1.0" encoding="UTF-8"?>
    <rss version="2.0">
        <channel>
            <title>Blog Tech</title>
            <link>https://blog.example.com</link>
            <description>Actualit√©s technologiques</description>
            <item>
                <title>PostgreSQL 18 est sorti</title>
                <link>https://blog.example.com/pg18</link>
                <pubDate>Mon, 19 Nov 2025 10:00:00 GMT</pubDate>
                <description>D√©couvrez les nouveaut√©s de PostgreSQL 18</description>
            </item>
        </channel>
    </rss>'
);

-- Extraire les articles
SELECT
    (xpath('/rss/channel/title/text()', contenu))[1]::TEXT AS flux_titre,
    unnest(xpath('/rss/channel/item/title/text()', contenu))::TEXT AS article_titre,
    unnest(xpath('/rss/channel/item/link/text()', contenu))::TEXT AS article_lien
FROM flux_rss;
```

#### 2. Configuration et Param√®tres

```sql
CREATE TABLE configurations_xml (
    id SERIAL PRIMARY KEY,
    application VARCHAR(100),
    environnement VARCHAR(20),
    config XML
);

INSERT INTO configurations_xml (application, environnement, config) VALUES (
    'web-app',
    'production',
    '<configuration>
        <database>
            <host>db.prod.example.com</host>
            <port>5432</port>
            <name>webapp_prod</name>
        </database>
        <cache>
            <enabled>true</enabled>
            <ttl>3600</ttl>
        </cache>
    </configuration>'
);

-- Lire la configuration
SELECT
    (xpath('/configuration/database/host/text()', config))[1]::TEXT AS db_host,
    (xpath('/configuration/database/port/text()', config))[1]::TEXT::INTEGER AS db_port,
    (xpath('/configuration/cache/enabled/text()', config))[1]::TEXT::BOOLEAN AS cache_enabled
FROM configurations_xml
WHERE application = 'web-app' AND environnement = 'production';
```

#### 3. √âchanges B2B (EDI)

```sql
CREATE TABLE commandes_edi (
    id SERIAL PRIMARY KEY,
    numero_commande VARCHAR(50),
    partenaire VARCHAR(200),
    document XML,
    date_reception TIMESTAMPTZ DEFAULT NOW()
);

-- Commande EDI au format XML
INSERT INTO commandes_edi (numero_commande, partenaire, document) VALUES (
    'PO-2025-001',
    'Fournisseur ABC',
    '<purchaseOrder orderDate="2025-11-19">
        <shipTo>
            <name>Alice Martin</name>
            <street>123 rue de la Paix</street>
            <city>Paris</city>
            <zip>75001</zip>
        </shipTo>
        <items>
            <item partNum="ABC123">
                <productName>Widget</productName>
                <quantity>100</quantity>
                <price>9.99</price>
            </item>
        </items>
    </purchaseOrder>'
);
```

#### 4. Documents SVG

```sql
CREATE TABLE graphiques_svg (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    svg XML
);

INSERT INTO graphiques_svg (nom, svg) VALUES (
    'Cercle rouge',
    '<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">
        <circle cx="50" cy="50" r="40" fill="red"/>
    </svg>'
);
```

### XML vs JSONB : Quand Utiliser Quoi ?

```sql
-- M√™me donn√©es en XML
SELECT '<user>
    <name>Alice</name>
    <email>alice@example.com</email>
    <age>30</age>
</user>'::XML;

-- M√™me donn√©es en JSONB (plus simple et moderne)
SELECT '{
    "name": "Alice",
    "email": "alice@example.com",
    "age": 30
}'::JSONB;

-- Requ√™te XML (verbeux)
SELECT xpath('/user/name/text()', '<user><name>Alice</name></user>'::XML);

-- Requ√™te JSONB (simple)
SELECT '{"name": "Alice"}'::JSONB ->> 'name';
```

**Recommandation moderne :**

| Besoin | Recommandation |
|--------|----------------|
| Nouveau projet | **JSONB** |
| API REST moderne | **JSONB** |
| Int√©gration legacy | XML |
| Standards B2B (EDI, SOAP) | XML |
| Flux RSS/Atom | XML |
| Documents SVG | XML |
| Configuration flexible | **JSONB** |

---

## Comparaison et Recommandations

### Tableau R√©capitulatif

| Type | Taille Max | Cas d'Usage | Performance | Recommandation |
|------|-----------|-------------|-------------|----------------|
| **BYTEA** | ~1 GB | Petits fichiers, crypto | Bonne | ‚úÖ Pour < 1 MB |
| **XML** | Illimit√©e | Legacy, B2B, RSS | Moyenne | ‚ö†Ô∏è Pr√©f√©rer JSONB |

### Quand Utiliser Quoi ?

#### BYTEA

**‚úÖ Utiliser BYTEA pour :**
- Hashes et signatures cryptographiques
- Petits fichiers (< 1 MB)
- Cl√©s et certificats
- Donn√©es binaires n√©cessitant ACID

**‚ùå √âviter BYTEA pour :**
- Fichiers volumineux (> 10 MB)
- Contenus multim√©dias
- Tr√®s grand nombre de fichiers

**Alternative :** Stockage externe (S3, CDN) + r√©f√©rence en base

#### XML

**‚úÖ Utiliser XML pour :**
- Int√©gration avec syst√®mes legacy XML
- Standards B2B (EDI, SOAP)
- Flux RSS/Atom
- Documents SVG
- Conformit√© √† des sch√©mas XML stricts

**‚ùå √âviter XML pour :**
- Nouveaux projets (pr√©f√©rer JSONB)
- API REST modernes
- Applications web contemporaines

**Alternative :** JSONB pour donn√©es semi-structur√©es

---

## Bonnes Pratiques

### 1. BYTEA : Limiter la Taille

```sql
-- ‚úÖ BON : Contrainte de taille
CREATE TABLE avatars (
    user_id INTEGER PRIMARY KEY,
    image BYTEA CHECK (octet_length(image) <= 1048576)  -- Max 1 MB
);

-- ‚ùå MAUVAIS : Pas de limite
CREATE TABLE fichiers (
    contenu BYTEA  -- Peut accepter jusqu'√† 1 GB !
);
```

### 2. BYTEA : Utiliser Stockage Externe pour Gros Fichiers

```sql
-- ‚úÖ RECOMMAND√â : R√©f√©rence externe
CREATE TABLE videos (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(300),
    fichier_url VARCHAR(500),  -- URL S3/CDN
    thumbnail BYTEA,  -- Seulement miniature en base
    duree INTERVAL
);

-- ‚ùå MAUVAIS : Stocker vid√©o en base
CREATE TABLE videos_mauvais (
    contenu BYTEA  -- Vid√©o de plusieurs GB en base !
);
```

### 3. BYTEA : Toujours Encoder pour Transmission

```sql
-- ‚úÖ BON : Encoder en base64 pour API/web
SELECT encode(image, 'base64') FROM avatars;

-- ‚ùå MAUVAIS : Retourner BYTEA brut
SELECT image FROM avatars;  -- Donn√©es binaires brutes
```

### 4. XML : Pr√©f√©rer JSONB pour Nouveaux Projets

```sql
-- ‚ùå Nouveau projet avec XML
CREATE TABLE configurations (
    config XML
);

-- ‚úÖ Nouveau projet avec JSONB
CREATE TABLE configurations (
    config JSONB
);
```

### 5. XML : Valider avec Sch√©mas (XSD)

PostgreSQL ne valide pas les sch√©mas XML (XSD) nativement. Pour validation stricte, validez c√¥t√© application avant insertion.

### 6. Performances : Indexer Intelligemment

```sql
-- BYTEA : Indexer les hashes
CREATE INDEX idx_users_password_hash ON utilisateurs(password_hash);

-- XML : XPath ne peut pas utiliser d'index standard
-- Mieux : extraire et stocker s√©par√©ment les valeurs fr√©quemment recherch√©es
CREATE TABLE documents_optimized (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(300),  -- Extrait du XML
    contenu XML
);

CREATE INDEX idx_documents_titre ON documents_optimized(titre);
```

---

## R√©capitulatif

### Types Sp√©cialis√©s

1. **BYTEA** : Donn√©es binaires
   - Formats : hex (recommand√©), escape
   - Fonctions : `encode()`, `decode()`, `convert_to/from()`
   - Limite pratique : 1 MB
   - Cas d'usage : crypto, petits fichiers

2. **XML** : Documents XML structur√©s
   - Validation : well-formed automatique
   - Requ√™tes : XPath
   - Fonctions : `xmlelement()`, `xpath()`, `xmlagg()`
   - **Alternative moderne : JSONB**

### Commandes Essentielles

```sql
-- BYTEA
SELECT encode(data, 'base64');
SELECT decode('SGVsbG8=', 'base64');
SELECT digest('password', 'sha256');

-- XML
SELECT xpath('/root/element/text()', xml_column);
SELECT xmlelement(name "tag", 'contenu');
SELECT xmlexists('/path' PASSING xml_column);
```

---

## Conclusion

BYTEA et XML sont des types sp√©cialis√©s pour des besoins sp√©cifiques :

- **BYTEA** reste utile pour les donn√©es cryptographiques et les petits fichiers, mais √©vitez de stocker de gros fichiers en base
- **XML** est principalement utilis√© pour l'int√©gration avec des syst√®mes legacy. Pour les nouveaux projets, **JSONB est g√©n√©ralement pr√©f√©r√©**

**Recommandations principales :**
1. Utilisez BYTEA pour crypto et fichiers < 1 MB
2. Stockez les gros fichiers en externe (S3, CDN)
3. Pr√©f√©rez JSONB √† XML pour les nouveaux projets
4. Gardez XML pour les standards B2B et flux RSS

Dans la prochaine section, nous explorerons les s√©quences et la g√©n√©ration automatique de valeurs pour les cl√©s primaires.

---


‚è≠Ô∏è [S√©quences (SEQUENCE) et g√©n√©ration automatique](/04-objets-de-la-base-de-donnees/05-sequences-et-generation-automatique.md)
