üîù Retour au [Sommaire](/SOMMAIRE.md)

# 4.4.3. Types Temporels (DATE, TIMESTAMP, TIMESTAMPTZ, INTERVAL)

## Introduction

La gestion des dates et heures est un aspect crucial de presque toutes les applications. PostgreSQL offre des types de donn√©es temporels puissants et flexibles pour g√©rer les dates, les heures, les fuseaux horaires et les dur√©es.

Dans cette section, nous allons explorer :
- **DATE** : Dates sans heure (2025-11-19)
- **TIMESTAMP** : Date et heure sans fuseau horaire
- **TIMESTAMPTZ** : Date et heure avec fuseau horaire (recommand√©)
- **INTERVAL** : Dur√©es et intervalles de temps
- **TIME** : Heure sans date (moins courant)

---

## Vue d'Ensemble des Types Temporels

| Type | Stockage | Plage | Pr√©cision | Utilisation |
|------|----------|-------|-----------|-------------|
| `DATE` | 4 octets | 4713 BC √† 5874897 AD | Jour | Dates de naissance, √©ch√©ances |
| `TIME` | 8 octets | 00:00:00 √† 24:00:00 | Microseconde | Heures d'ouverture (rare) |
| `TIMESTAMP` | 8 octets | 4713 BC √† 294276 AD | Microseconde | Logs, √©v√©nements (sans TZ) |
| `TIMESTAMPTZ` | 8 octets | 4713 BC √† 294276 AD | Microseconde | **Standard** : √©v√©nements avec TZ |
| `INTERVAL` | 16 octets | -178000000 ans √† +178000000 ans | Microseconde | Dur√©es, d√©lais |

---

## 1. DATE (Date sans Heure)

### D√©finition et Syntaxe

`DATE` stocke une date (ann√©e, mois, jour) **sans** information d'heure ni de fuseau horaire.

```sql
-- Syntaxe
DATE

-- Format standard : YYYY-MM-DD
-- Exemple : 2025-11-19
```

### Cr√©ation et Insertion

```sql
CREATE TABLE evenements (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200) NOT NULL,
    date_evenement DATE NOT NULL,
    date_inscription_debut DATE,
    date_inscription_fin DATE
);

-- Insertion avec diff√©rents formats
INSERT INTO evenements (nom, date_evenement)
VALUES ('Conf√©rence PostgreSQL', '2025-11-19');

INSERT INTO evenements (nom, date_evenement)
VALUES ('Formation SQL', DATE '2025-12-15');  -- Avec cast explicite

-- Date actuelle
INSERT INTO evenements (nom, date_evenement, date_inscription_debut)
VALUES ('Webinaire', CURRENT_DATE, CURRENT_DATE);

SELECT * FROM evenements;
```

R√©sultat :
```
 id |         nom              | date_evenement | date_inscription_debut | date_inscription_fin
----+--------------------------+----------------+------------------------+---------------------
  1 | Conf√©rence PostgreSQL    | 2025-11-19     | null                   | null
  2 | Formation SQL            | 2025-12-15     | null                   | null
  3 | Webinaire                | 2025-11-19     | 2025-11-19             | null
```

### Formats d'Entr√©e Accept√©s

PostgreSQL accepte plusieurs formats de date :

```sql
-- Format ISO 8601 (recommand√©)
SELECT DATE '2025-11-19';

-- Format europ√©en
SELECT DATE '19/11/2025';
SELECT DATE '19-11-2025';

-- Format am√©ricain (selon configuration)
SELECT DATE '11/19/2025';

-- Format texte
SELECT DATE '19 November 2025';
SELECT DATE 'November 19, 2025';

-- Attention : Le format d√©pend de la configuration datestyle
SHOW datestyle;  -- Voir le format actuel
```

**Recommandation :** Utilisez toujours le format ISO (YYYY-MM-DD) pour √©viter les ambigu√Øt√©s.

### Fonctions Utiles avec DATE

#### Obtenir la Date Actuelle

```sql
-- Date actuelle (selon le fuseau horaire du serveur)
SELECT CURRENT_DATE;
SELECT NOW()::DATE;  -- Conversion de timestamp vers date

-- Exemple
INSERT INTO logs (message, date_log)
VALUES ('D√©marrage application', CURRENT_DATE);
```

#### Extraction de Composants

```sql
-- Extraire l'ann√©e, le mois, le jour
SELECT
    EXTRACT(YEAR FROM DATE '2025-11-19') AS annee,    -- 2025
    EXTRACT(MONTH FROM DATE '2025-11-19') AS mois,    -- 11
    EXTRACT(DAY FROM DATE '2025-11-19') AS jour;      -- 19

-- Jour de la semaine (0 = dimanche, 6 = samedi)
SELECT EXTRACT(DOW FROM DATE '2025-11-19');  -- 2 (mardi)

-- Jour de la semaine (1 = lundi, 7 = dimanche) - ISO
SELECT EXTRACT(ISODOW FROM DATE '2025-11-19');  -- 2 (mardi)

-- Jour de l'ann√©e (1 √† 366)
SELECT EXTRACT(DOY FROM DATE '2025-11-19');  -- 323

-- Semaine de l'ann√©e
SELECT EXTRACT(WEEK FROM DATE '2025-11-19');  -- 47

-- Exemple pratique
SELECT
    nom,
    date_evenement,
    EXTRACT(YEAR FROM date_evenement) AS annee,
    EXTRACT(MONTH FROM date_evenement) AS mois,
    TO_CHAR(date_evenement, 'Day') AS jour_semaine
FROM evenements;
```

#### Formatage de Dates

```sql
-- TO_CHAR : Formater une date en texte
SELECT TO_CHAR(DATE '2025-11-19', 'DD/MM/YYYY');  -- '19/11/2025'
SELECT TO_CHAR(DATE '2025-11-19', 'Day, DD Month YYYY');  -- 'Tuesday, 19 November 2025'
SELECT TO_CHAR(DATE '2025-11-19', 'DD-MM-YYYY');  -- '19-11-2025'
SELECT TO_CHAR(DATE '2025-11-19', 'YYYY-MM-DD');  -- '2025-11-19'

-- Formats personnalis√©s
SELECT TO_CHAR(DATE '2025-11-19', 'FMDay FMDDth FMMonth YYYY');
-- 'Tuesday 19th November 2025'

-- Exemple pratique : affichage pour l'utilisateur
SELECT
    nom,
    TO_CHAR(date_evenement, 'DD/MM/YYYY') AS date_francaise,
    TO_CHAR(date_evenement, 'FMDay DD FMMonth YYYY') AS date_lisible
FROM evenements;
```

Codes de format courants :
- `YYYY` : Ann√©e sur 4 chiffres
- `MM` : Mois (01-12)
- `DD` : Jour (01-31)
- `Day` : Nom du jour (Monday, Tuesday...)
- `Month` : Nom du mois (January, February...)
- `FM` : Supprime les z√©ros et espaces de remplissage

#### Arithm√©tique avec DATE

```sql
-- Ajouter des jours
SELECT DATE '2025-11-19' + 7;  -- 2025-11-26 (dans 7 jours)
SELECT DATE '2025-11-19' + INTERVAL '7 days';  -- M√™me r√©sultat

-- Soustraire des jours
SELECT DATE '2025-11-19' - 7;  -- 2025-11-12 (il y a 7 jours)

-- Diff√©rence entre deux dates (en jours)
SELECT DATE '2025-12-25' - DATE '2025-11-19';  -- 36 jours

-- Exemple pratique : calculer une date d'√©ch√©ance
SELECT
    nom,
    date_evenement,
    date_evenement + 30 AS date_limite_inscription,
    date_evenement - 7 AS rappel_7_jours_avant
FROM evenements;

-- Ajouter des mois (attention aux fins de mois)
SELECT DATE '2025-01-31' + INTERVAL '1 month';  -- 2025-02-28
SELECT DATE '2025-01-31' + INTERVAL '2 months';  -- 2025-03-31
```

### Cas d'Usage de DATE

#### 1. Dates de Naissance

```sql
CREATE TABLE personnes (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100) NOT NULL,
    prenom VARCHAR(100) NOT NULL,
    date_naissance DATE NOT NULL,
    age INTEGER GENERATED ALWAYS AS (
        EXTRACT(YEAR FROM AGE(CURRENT_DATE, date_naissance))
    ) STORED
);

INSERT INTO personnes (nom, prenom, date_naissance)
VALUES ('Dupont', 'Alice', '1990-05-15');

-- Calculer l'√¢ge
SELECT
    nom,
    prenom,
    date_naissance,
    AGE(CURRENT_DATE, date_naissance) AS age_complet,
    EXTRACT(YEAR FROM AGE(CURRENT_DATE, date_naissance)) AS age_annees
FROM personnes;
```

#### 2. √âch√©ances et Deadlines

```sql
CREATE TABLE taches (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(200) NOT NULL,
    date_creation DATE DEFAULT CURRENT_DATE,
    date_echeance DATE NOT NULL,
    est_terminee BOOLEAN DEFAULT FALSE,

    -- V√©rifier que l'√©ch√©ance est dans le futur
    CONSTRAINT ck_echeance_future CHECK (date_echeance >= date_creation)
);

-- T√¢ches en retard
SELECT * FROM taches
WHERE date_echeance < CURRENT_DATE
  AND est_terminee = FALSE;

-- T√¢ches √† faire cette semaine
SELECT * FROM taches
WHERE date_echeance BETWEEN CURRENT_DATE AND CURRENT_DATE + 7
  AND est_terminee = FALSE;
```

#### 3. P√©riodes et Plages de Dates

```sql
CREATE TABLE reservations (
    id SERIAL PRIMARY KEY,
    client_nom VARCHAR(100) NOT NULL,
    date_debut DATE NOT NULL,
    date_fin DATE NOT NULL,

    CONSTRAINT ck_dates_coherentes CHECK (date_fin >= date_debut)
);

INSERT INTO reservations (client_nom, date_debut, date_fin)
VALUES ('Dupont', '2025-12-01', '2025-12-07');

-- Calculer le nombre de jours de r√©servation
SELECT
    client_nom,
    date_debut,
    date_fin,
    date_fin - date_debut AS nombre_jours
FROM reservations;

-- V√©rifier les chevauchements de r√©servations
SELECT r1.*, r2.*
FROM reservations r1
JOIN reservations r2 ON r1.id != r2.id
WHERE r1.date_debut <= r2.date_fin
  AND r1.date_fin >= r2.date_debut;
```

---

## 2. TIME (Heure sans Date)

### D√©finition et Syntaxe

`TIME` stocke une heure (heures, minutes, secondes) **sans** date ni fuseau horaire.

```sql
-- Syntaxe
TIME
TIME(precision)  -- 0 √† 6 chiffres de pr√©cision pour les fractions de seconde

-- Format : HH:MI:SS
-- Exemple : 14:30:00
```

### Utilisation de TIME

```sql
CREATE TABLE horaires_magasin (
    id SERIAL PRIMARY KEY,
    jour_semaine VARCHAR(20),
    heure_ouverture TIME NOT NULL,
    heure_fermeture TIME NOT NULL,

    CONSTRAINT ck_heures_coherentes CHECK (heure_fermeture > heure_ouverture)
);

INSERT INTO horaires_magasin (jour_semaine, heure_ouverture, heure_fermeture)
VALUES ('Lundi', '09:00:00', '18:00:00');

INSERT INTO horaires_magasin (jour_semaine, heure_ouverture, heure_fermeture)
VALUES ('Samedi', '10:00:00', '17:30:00');

-- Heure actuelle
SELECT CURRENT_TIME;
SELECT LOCALTIME;

-- V√©rifier si le magasin est ouvert maintenant
SELECT * FROM horaires_magasin
WHERE CURRENT_TIME BETWEEN heure_ouverture AND heure_fermeture;
```

**Note :** TIME est rarement utilis√© seul. La plupart des applications utilisent TIMESTAMP ou TIMESTAMPTZ.

---

## 3. TIMESTAMP (Date et Heure sans Fuseau Horaire)

### D√©finition et Syntaxe

`TIMESTAMP` stocke une date et une heure **sans** information de fuseau horaire.

```sql
-- Syntaxe
TIMESTAMP
TIMESTAMP(precision)  -- 0 √† 6 chiffres de pr√©cision

-- Format : YYYY-MM-DD HH:MI:SS
-- Exemple : 2025-11-19 14:30:00
```

### Cr√©ation et Insertion

```sql
CREATE TABLE logs_application (
    id BIGSERIAL PRIMARY KEY,
    niveau VARCHAR(10),
    message TEXT,
    timestamp_log TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Insertion avec timestamp explicite
INSERT INTO logs_application (niveau, message, timestamp_log)
VALUES ('INFO', 'Application d√©marr√©e', '2025-11-19 14:30:00');

-- Insertion avec timestamp actuel (automatique)
INSERT INTO logs_application (niveau, message)
VALUES ('INFO', 'Connexion √©tablie');

-- Avec pr√©cision de microseconde
INSERT INTO logs_application (niveau, message, timestamp_log)
VALUES ('DEBUG', 'Test', '2025-11-19 14:30:00.123456');

SELECT * FROM logs_application;
```

### Fonctions avec TIMESTAMP

```sql
-- Timestamp actuel
SELECT CURRENT_TIMESTAMP;
SELECT NOW();  -- Identique √† CURRENT_TIMESTAMP
SELECT LOCALTIMESTAMP;  -- Sans fuseau horaire

-- Extraction de composants
SELECT
    EXTRACT(YEAR FROM TIMESTAMP '2025-11-19 14:30:00') AS annee,
    EXTRACT(MONTH FROM TIMESTAMP '2025-11-19 14:30:00') AS mois,
    EXTRACT(DAY FROM TIMESTAMP '2025-11-19 14:30:00') AS jour,
    EXTRACT(HOUR FROM TIMESTAMP '2025-11-19 14:30:00') AS heure,
    EXTRACT(MINUTE FROM TIMESTAMP '2025-11-19 14:30:00') AS minute,
    EXTRACT(SECOND FROM TIMESTAMP '2025-11-19 14:30:00') AS seconde;

-- Convertir en date ou heure
SELECT
    TIMESTAMP '2025-11-19 14:30:00'::DATE AS date_seule,
    TIMESTAMP '2025-11-19 14:30:00'::TIME AS heure_seule;
```

### Arithm√©tique avec TIMESTAMP

```sql
-- Ajouter du temps
SELECT TIMESTAMP '2025-11-19 14:30:00' + INTERVAL '2 hours';  -- 16:30:00
SELECT TIMESTAMP '2025-11-19 14:30:00' + INTERVAL '30 minutes';  -- 15:00:00
SELECT TIMESTAMP '2025-11-19 14:30:00' + INTERVAL '3 days 2 hours';  -- 2025-11-22 16:30:00

-- Diff√©rence entre deux timestamps
SELECT TIMESTAMP '2025-11-19 16:30:00' - TIMESTAMP '2025-11-19 14:30:00';
-- R√©sultat : interval '02:00:00' (2 heures)

-- Exemple pratique : temps √©coul√©
SELECT
    message,
    timestamp_log,
    NOW() - timestamp_log AS temps_ecoule
FROM logs_application;
```

---

## 4. TIMESTAMPTZ (Date et Heure avec Fuseau Horaire) ‚≠ê

### D√©finition et Syntaxe

`TIMESTAMPTZ` (ou `TIMESTAMP WITH TIME ZONE`) stocke une date et une heure **avec** information de fuseau horaire. C'est le type **recommand√©** pour la plupart des applications.

```sql
-- Syntaxe
TIMESTAMPTZ
TIMESTAMP WITH TIME ZONE

-- Format : YYYY-MM-DD HH:MI:SS+TZ
-- Exemple : 2025-11-19 14:30:00+01
```

### Pourquoi TIMESTAMPTZ est Crucial

```sql
-- Probl√®me avec TIMESTAMP (sans timezone)
CREATE TABLE meetings_sans_tz (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(200),
    heure_meeting TIMESTAMP  -- ‚ö†Ô∏è Sans fuseau horaire
);

INSERT INTO meetings_sans_tz (titre, heure_meeting)
VALUES ('R√©union Paris', '2025-11-19 14:00:00');

-- Question : 14:00 dans quel fuseau horaire ?
-- Paris (CET/CEST) ? New York (EST) ? Tokyo (JST) ?
-- Impossible √† savoir ! ‚ùå

-- Solution avec TIMESTAMPTZ
CREATE TABLE meetings_avec_tz (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(200),
    heure_meeting TIMESTAMPTZ  -- ‚úÖ Avec fuseau horaire
);

INSERT INTO meetings_avec_tz (titre, heure_meeting)
VALUES ('R√©union Paris', '2025-11-19 14:00:00+01');  -- 14h heure de Paris (CET)

INSERT INTO meetings_avec_tz (titre, heure_meeting)
VALUES ('R√©union New York', '2025-11-19 14:00:00-05');  -- 14h heure de New York (EST)

-- PostgreSQL convertit et stocke en UTC en interne
SELECT * FROM meetings_avec_tz;
```

### Comment PostgreSQL G√®re TIMESTAMPTZ

```sql
-- PostgreSQL stocke TOUJOURS en UTC en interne
-- et convertit selon le fuseau horaire de la session lors de l'affichage

-- Voir le fuseau horaire actuel
SHOW timezone;

-- Changer le fuseau horaire de la session
SET timezone = 'Europe/Paris';

-- Ins√©rer avec diff√©rents fuseaux horaires
INSERT INTO meetings_avec_tz (titre, heure_meeting) VALUES
    ('Meeting UTC', '2025-11-19 14:00:00+00'),     -- 14h UTC
    ('Meeting Paris', '2025-11-19 14:00:00+01'),   -- 14h Paris (= 13h UTC)
    ('Meeting New York', '2025-11-19 14:00:00-05'); -- 14h New York (= 19h UTC)

-- Tous sont convertis en UTC puis affich√©s selon timezone de session
SELECT titre, heure_meeting FROM meetings_avec_tz;
-- Si timezone='Europe/Paris', tout sera affich√© en heure de Paris

-- Afficher en diff√©rents fuseaux horaires
SELECT
    titre,
    heure_meeting,
    heure_meeting AT TIME ZONE 'UTC' AS heure_utc,
    heure_meeting AT TIME ZONE 'America/New_York' AS heure_ny,
    heure_meeting AT TIME ZONE 'Asia/Tokyo' AS heure_tokyo
FROM meetings_avec_tz;
```

### Fonctions avec TIMESTAMPTZ

```sql
-- Timestamp actuel avec timezone
SELECT NOW();  -- Type : TIMESTAMPTZ
SELECT CURRENT_TIMESTAMP;  -- Type : TIMESTAMPTZ

-- Timestamp actuel en UTC
SELECT NOW() AT TIME ZONE 'UTC';

-- Cr√©er un timestamp avec timezone sp√©cifique
SELECT TIMESTAMPTZ '2025-11-19 14:00:00 Europe/Paris';
SELECT TIMESTAMPTZ '2025-11-19 14:00:00+01';

-- Convertir entre fuseaux horaires
SELECT
    NOW() AS heure_locale,
    NOW() AT TIME ZONE 'UTC' AS heure_utc,
    NOW() AT TIME ZONE 'America/Los_Angeles' AS heure_la,
    NOW() AT TIME ZONE 'Asia/Tokyo' AS heure_tokyo;
```

### Cas d'Usage de TIMESTAMPTZ

#### 1. Application Web Internationale

```sql
CREATE TABLE utilisateurs (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    date_inscription TIMESTAMPTZ DEFAULT NOW(),
    derniere_connexion TIMESTAMPTZ,
    fuseau_horaire VARCHAR(50) DEFAULT 'UTC'
);

-- Enregistrer quand un utilisateur se connecte
UPDATE utilisateurs
SET derniere_connexion = NOW()
WHERE email = 'alice@example.com';

-- Afficher selon le fuseau horaire de l'utilisateur
SELECT
    email,
    derniere_connexion AT TIME ZONE fuseau_horaire AS heure_locale_user
FROM utilisateurs;
```

#### 2. Syst√®me de R√©servation

```sql
CREATE TABLE reservations_hotels (
    id SERIAL PRIMARY KEY,
    client_nom VARCHAR(100),
    hotel_timezone VARCHAR(50),
    checkin TIMESTAMPTZ NOT NULL,
    checkout TIMESTAMPTZ NOT NULL,

    CONSTRAINT ck_dates_coherentes CHECK (checkout > checkin)
);

-- R√©servation pour un h√¥tel √† Paris
INSERT INTO reservations_hotels (client_nom, hotel_timezone, checkin, checkout)
VALUES (
    'Alice Martin',
    'Europe/Paris',
    '2025-12-01 15:00:00+01',  -- 15h heure de Paris
    '2025-12-05 11:00:00+01'   -- 11h heure de Paris
);

-- R√©servation pour un h√¥tel √† Tokyo
INSERT INTO reservations_hotels (client_nom, hotel_timezone, checkin, checkout)
VALUES (
    'Bob Smith',
    'Asia/Tokyo',
    '2025-12-01 15:00:00+09',  -- 15h heure de Tokyo
    '2025-12-05 11:00:00+09'   -- 11h heure de Tokyo
);

-- Voir toutes les r√©servations en heure locale de l'h√¥tel
SELECT
    client_nom,
    checkin AT TIME ZONE hotel_timezone AS checkin_local,
    checkout AT TIME ZONE hotel_timezone AS checkout_local
FROM reservations_hotels;
```

#### 3. Logs et Audit

```sql
CREATE TABLE audit_log (
    id BIGSERIAL PRIMARY KEY,
    user_id INTEGER,
    action VARCHAR(100),
    timestamp TIMESTAMPTZ DEFAULT NOW(),  -- ‚úÖ Toujours avec TZ
    ip_address INET,
    details JSONB
);

-- Insertion automatique du timestamp
INSERT INTO audit_log (user_id, action, ip_address)
VALUES (123, 'LOGIN', '192.168.1.100');

-- Rechercher les actions dans les derni√®res 24h
SELECT * FROM audit_log
WHERE timestamp > NOW() - INTERVAL '24 hours'
ORDER BY timestamp DESC;

-- Actions group√©es par heure (en UTC)
SELECT
    DATE_TRUNC('hour', timestamp AT TIME ZONE 'UTC') AS heure_utc,
    COUNT(*) AS nombre_actions
FROM audit_log
GROUP BY heure_utc
ORDER BY heure_utc;
```

---

## 5. INTERVAL (Dur√©es et Intervalles)

### D√©finition et Syntaxe

`INTERVAL` repr√©sente une dur√©e ou un intervalle de temps (jours, heures, minutes, etc.).

```sql
-- Syntaxe
INTERVAL 'quantit√© unit√©'

-- Exemples
INTERVAL '1 day'
INTERVAL '2 hours 30 minutes'
INTERVAL '3 months'
INTERVAL '1 year 2 months 3 days'
```

### Cr√©ation et Utilisation

```sql
-- Diff√©rentes fa√ßons de cr√©er des intervals
SELECT
    INTERVAL '1 day' AS un_jour,
    INTERVAL '2 hours' AS deux_heures,
    INTERVAL '30 minutes' AS trente_minutes,
    INTERVAL '1 week' AS une_semaine,
    INTERVAL '3 months' AS trois_mois,
    INTERVAL '1 year' AS un_an;

-- Intervals compos√©s
SELECT
    INTERVAL '1 day 2 hours 30 minutes' AS compose1,
    INTERVAL '2 years 3 months 4 days' AS compose2;

-- Avec pr√©cision
SELECT INTERVAL '1.5 hours';  -- 1 heure 30 minutes
SELECT INTERVAL '2.5 days';   -- 2 jours 12 heures
```

### Arithm√©tique avec INTERVAL

```sql
-- Ajouter un interval √† un timestamp
SELECT NOW() + INTERVAL '1 day' AS demain;
SELECT NOW() + INTERVAL '2 hours' AS dans_2_heures;
SELECT NOW() - INTERVAL '1 week' AS il_y_a_une_semaine;

-- Ajouter un interval √† une date
SELECT CURRENT_DATE + INTERVAL '1 month' AS dans_un_mois;
SELECT CURRENT_DATE - INTERVAL '1 year' AS il_y_a_un_an;

-- Multiplier un interval
SELECT INTERVAL '1 hour' * 3;  -- 3 heures
SELECT INTERVAL '1 day' * 7;   -- 7 jours (1 semaine)

-- Diviser un interval
SELECT INTERVAL '1 hour' / 2;  -- 30 minutes
```

### Op√©rations entre Timestamps : R√©sultat INTERVAL

```sql
-- Diff√©rence entre deux timestamps = INTERVAL
SELECT
    TIMESTAMP '2025-11-20 16:30:00' - TIMESTAMP '2025-11-19 14:30:00' AS difference;
-- R√©sultat : 1 day 02:00:00

-- Calcul d'√¢ge
SELECT AGE(TIMESTAMP '2025-11-19', TIMESTAMP '1990-05-15');
-- R√©sultat : 35 years 6 months 4 days

-- Exemple pratique : temps de traitement
CREATE TABLE jobs (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    debut TIMESTAMPTZ,
    fin TIMESTAMPTZ,
    duree INTERVAL GENERATED ALWAYS AS (fin - debut) STORED
);

INSERT INTO jobs (nom, debut, fin) VALUES
    ('Job 1', '2025-11-19 10:00:00+01', '2025-11-19 10:05:30+01');

SELECT
    nom,
    debut,
    fin,
    duree,
    EXTRACT(EPOCH FROM duree) AS duree_secondes  -- Convertir en secondes
FROM jobs;
```

### Extraction de Composants d'INTERVAL

```sql
SELECT
    INTERVAL '2 years 3 months 4 days 5 hours' AS interval_complet,
    EXTRACT(YEAR FROM INTERVAL '2 years 3 months') AS annees,
    EXTRACT(MONTH FROM INTERVAL '2 years 3 months') AS mois,
    EXTRACT(DAY FROM INTERVAL '4 days 5 hours') AS jours,
    EXTRACT(HOUR FROM INTERVAL '5 hours 30 minutes') AS heures,
    EXTRACT(MINUTE FROM INTERVAL '30 minutes') AS minutes;

-- Convertir un interval en secondes totales
SELECT EXTRACT(EPOCH FROM INTERVAL '1 day 2 hours 30 minutes');  -- 95400 secondes
```

### Cas d'Usage d'INTERVAL

#### 1. Calcul de D√©lais et √âch√©ances

```sql
CREATE TABLE commandes (
    id SERIAL PRIMARY KEY,
    numero VARCHAR(50),
    date_commande TIMESTAMPTZ DEFAULT NOW(),
    delai_livraison INTERVAL DEFAULT INTERVAL '5 days',
    date_livraison_estimee TIMESTAMPTZ GENERATED ALWAYS AS
        (date_commande + delai_livraison) STORED
);

INSERT INTO commandes (numero, delai_livraison) VALUES
    ('CMD-001', INTERVAL '3 days'),
    ('CMD-002', INTERVAL '1 week'),
    ('CMD-003', INTERVAL '2 days 6 hours');

SELECT
    numero,
    date_commande,
    delai_livraison,
    date_livraison_estimee
FROM commandes;
```

#### 2. Dur√©es de Sessions

```sql
CREATE TABLE sessions_utilisateur (
    id BIGSERIAL PRIMARY KEY,
    user_id INTEGER,
    debut TIMESTAMPTZ DEFAULT NOW(),
    fin TIMESTAMPTZ,
    duree INTERVAL GENERATED ALWAYS AS (fin - debut) STORED
);

-- D√©marrer une session
INSERT INTO sessions_utilisateur (user_id, debut)
VALUES (123, NOW());

-- Terminer une session
UPDATE sessions_utilisateur
SET fin = NOW()
WHERE id = 1;

-- Sessions longues (plus de 1 heure)
SELECT * FROM sessions_utilisateur
WHERE duree > INTERVAL '1 hour';

-- Dur√©e moyenne des sessions
SELECT AVG(duree) AS duree_moyenne
FROM sessions_utilisateur
WHERE fin IS NOT NULL;
```

#### 3. Planification et Rappels

```sql
CREATE TABLE taches_rappels (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(200),
    date_echeance TIMESTAMPTZ,
    rappel_avant INTERVAL DEFAULT INTERVAL '1 day',
    date_rappel TIMESTAMPTZ GENERATED ALWAYS AS
        (date_echeance - rappel_avant) STORED
);

INSERT INTO taches_rappels (titre, date_echeance, rappel_avant) VALUES
    ('R√©union importante', '2025-12-01 14:00:00+01', INTERVAL '2 days'),
    ('Rendez-vous m√©dical', '2025-11-25 10:00:00+01', INTERVAL '1 week'),
    ('Paiement facture', '2025-12-15 00:00:00+01', INTERVAL '3 days');

-- Rappels √† envoyer aujourd'hui
SELECT * FROM taches_rappels
WHERE date_rappel::DATE = CURRENT_DATE;
```

---

## Fonctions Avanc√©es sur les Types Temporels

### DATE_TRUNC (Tronquer √† une Unit√©)

```sql
-- Tronquer √† diff√©rentes unit√©s
SELECT
    DATE_TRUNC('year', TIMESTAMP '2025-11-19 14:30:00') AS debut_annee,
    DATE_TRUNC('month', TIMESTAMP '2025-11-19 14:30:00') AS debut_mois,
    DATE_TRUNC('week', TIMESTAMP '2025-11-19 14:30:00') AS debut_semaine,
    DATE_TRUNC('day', TIMESTAMP '2025-11-19 14:30:00') AS debut_jour,
    DATE_TRUNC('hour', TIMESTAMP '2025-11-19 14:30:00') AS debut_heure;

-- R√©sultats :
-- debut_annee:   2025-01-01 00:00:00
-- debut_mois:    2025-11-01 00:00:00
-- debut_semaine: 2025-11-17 00:00:00 (lundi)
-- debut_jour:    2025-11-19 00:00:00
-- debut_heure:   2025-11-19 14:00:00

-- Exemple pratique : grouper des logs par heure
SELECT
    DATE_TRUNC('hour', timestamp_log) AS heure,
    COUNT(*) AS nombre_logs
FROM logs_application
GROUP BY heure
ORDER BY heure;
```

### AGE (Calculer un √Çge ou une Diff√©rence)

```sql
-- √Çge entre deux dates
SELECT AGE(TIMESTAMP '2025-11-19', TIMESTAMP '1990-05-15');
-- R√©sultat : 35 years 6 months 4 days

-- √Çge par rapport √† aujourd'hui
SELECT AGE(DATE '1990-05-15');
-- R√©sultat : 35 years 6 months 4 days (variable selon la date actuelle)

-- Exemple pratique : √¢ge des utilisateurs
SELECT
    nom,
    date_naissance,
    AGE(date_naissance) AS age,
    EXTRACT(YEAR FROM AGE(date_naissance)) AS age_annees
FROM personnes;
```

### MAKE_DATE, MAKE_TIME, MAKE_TIMESTAMP

```sql
-- Construire une date √† partir de composants
SELECT MAKE_DATE(2025, 11, 19);  -- 2025-11-19

-- Construire une heure
SELECT MAKE_TIME(14, 30, 0);  -- 14:30:00

-- Construire un timestamp
SELECT MAKE_TIMESTAMP(2025, 11, 19, 14, 30, 0);
-- 2025-11-19 14:30:00

-- Exemple : cr√©er une date √† partir de valeurs s√©par√©es
CREATE TABLE evenements_composants (
    id SERIAL PRIMARY KEY,
    annee INTEGER,
    mois INTEGER,
    jour INTEGER,
    date_calculee DATE GENERATED ALWAYS AS
        (MAKE_DATE(annee, mois, jour)) STORED
);

INSERT INTO evenements_composants (annee, mois, jour)
VALUES (2025, 12, 25);
```

### GENERATE_SERIES (G√©n√©rer des S√©quences Temporelles)

```sql
-- G√©n√©rer une s√©rie de dates
SELECT DATE FROM GENERATE_SERIES(
    '2025-11-01'::DATE,
    '2025-11-30'::DATE,
    '1 day'::INTERVAL
) AS DATE;

-- G√©n√©rer une s√©rie de timestamps par heure
SELECT timestamp FROM GENERATE_SERIES(
    '2025-11-19 00:00:00'::TIMESTAMP,
    '2025-11-19 23:00:00'::TIMESTAMP,
    '1 hour'::INTERVAL
) AS timestamp;

-- Exemple pratique : g√©n√©rer un calendrier
SELECT
    date,
    TO_CHAR(date, 'Day') AS jour_semaine,
    EXTRACT(WEEK FROM date) AS semaine
FROM GENERATE_SERIES(
    '2025-11-01'::DATE,
    '2025-11-30'::DATE,
    '1 day'
) AS date;
```

---

## Comparaison : TIMESTAMP vs TIMESTAMPTZ

### Tableau Comparatif

| Aspect | TIMESTAMP | TIMESTAMPTZ |
|--------|-----------|-------------|
| Fuseau horaire | ‚ùå Non stock√© | ‚úÖ Stock√© (en UTC) |
| Conversion automatique | ‚ùå Non | ‚úÖ Oui |
| Applications internationales | ‚ùå Probl√©matique | ‚úÖ Recommand√© |
| Taille stockage | 8 octets | 8 octets (identique) |
| Performance | Identique | Identique |
| **Recommandation** | √âviter | **Toujours utiliser** |

### Exemple de Probl√®me avec TIMESTAMP

```sql
-- Probl√®me : Une r√©union √† 14h, mais o√π ?
CREATE TABLE meetings_bad (
    titre VARCHAR(200),
    heure TIMESTAMP  -- ‚ö†Ô∏è Sans timezone
);

INSERT INTO meetings_bad VALUES ('R√©union', '2025-12-01 14:00:00');

-- Question : 14h Paris ? New York ? Tokyo ?
-- Impossible √† savoir ! Ambigu pour les utilisateurs internationaux

-- Solution : Toujours utiliser TIMESTAMPTZ
CREATE TABLE meetings_good (
    titre VARCHAR(200),
    heure TIMESTAMPTZ  -- ‚úÖ Avec timezone
);

INSERT INTO meetings_good VALUES ('R√©union', '2025-12-01 14:00:00+01');
-- Maintenant c'est clair : 14h heure de Paris (CET)
```

---

## Bonnes Pratiques avec les Types Temporels

### 1. Toujours Utiliser TIMESTAMPTZ (pas TIMESTAMP)

```sql
-- ‚úÖ BON : Utiliser TIMESTAMPTZ
CREATE TABLE utilisateurs (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255),
    date_inscription TIMESTAMPTZ DEFAULT NOW(),
    derniere_connexion TIMESTAMPTZ
);

-- ‚ùå MAUVAIS : Utiliser TIMESTAMP
CREATE TABLE utilisateurs_mauvais (
    date_inscription TIMESTAMP  -- Ambigu√Øt√© timezone !
);
```

### 2. Stocker les Fuseaux Horaires des Utilisateurs

```sql
CREATE TABLE utilisateurs_tz (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255),
    fuseau_horaire VARCHAR(50) DEFAULT 'UTC',  -- Stocker le TZ de l'utilisateur
    date_inscription TIMESTAMPTZ DEFAULT NOW()
);

-- Afficher selon le fuseau de l'utilisateur
SELECT
    email,
    date_inscription AT TIME ZONE fuseau_horaire AS date_locale
FROM utilisateurs_tz;
```

### 3. Utiliser DEFAULT NOW() ou CURRENT_TIMESTAMP

```sql
-- ‚úÖ BON : Timestamp automatique
CREATE TABLE logs (
    id BIGSERIAL PRIMARY KEY,
    message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insertion automatique du timestamp
INSERT INTO logs (message) VALUES ('Test');
```

### 4. Valider les Dates avec CHECK

```sql
CREATE TABLE reservations_valides (
    id SERIAL PRIMARY KEY,
    date_debut TIMESTAMPTZ NOT NULL,
    date_fin TIMESTAMPTZ NOT NULL,

    -- La fin doit √™tre apr√®s le d√©but
    CONSTRAINT ck_dates_coherentes CHECK (date_fin > date_debut),

    -- La r√©servation ne peut pas √™tre dans le pass√©
    CONSTRAINT ck_futur CHECK (date_debut >= NOW())
);
```

### 5. Utiliser INTERVAL pour les Dur√©es

```sql
-- ‚úÖ BON : Stocker une dur√©e comme INTERVAL
CREATE TABLE videos (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(300),
    duree INTERVAL  -- Dur√©e de la vid√©o
);

INSERT INTO videos (titre, duree)
VALUES ('Tutoriel PostgreSQL', INTERVAL '45 minutes');

-- ‚ùå MOINS BON : Stocker en secondes (moins lisible)
CREATE TABLE videos_secondes (
    duree_secondes INTEGER  -- Difficile √† lire : 2700 = combien ?
);
```

### 6. Indexer les Colonnes Temporelles Recherch√©es

```sql
-- Index pour recherches par date
CREATE INDEX idx_logs_created_at ON logs(created_at);

-- Index pour plages de dates
CREATE INDEX idx_reservations_dates ON reservations(date_debut, date_fin);

-- Requ√™tes optimis√©es
SELECT * FROM logs
WHERE created_at > NOW() - INTERVAL '24 hours';
```

### 7. Utiliser DATE_TRUNC pour Regroupements

```sql
-- Statistiques par jour
SELECT
    DATE_TRUNC('day', created_at) AS jour,
    COUNT(*) AS nombre
FROM logs
GROUP BY jour
ORDER BY jour;

-- Statistiques par heure
SELECT
    DATE_TRUNC('hour', created_at) AS heure,
    COUNT(*) AS nombre
FROM logs
WHERE created_at > NOW() - INTERVAL '24 hours'
GROUP BY heure
ORDER BY heure;
```

---

## Pi√®ges Courants et Solutions

### Pi√®ge 1 : Confusion entre TIMESTAMP et TIMESTAMPTZ

```sql
-- ‚ùå Probl√®me
CREATE TABLE events (
    event_time TIMESTAMP  -- Quelle timezone ?
);

-- ‚úÖ Solution
CREATE TABLE events (
    event_time TIMESTAMPTZ  -- Toujours clair
);
```

### Pi√®ge 2 : Arithm√©tique avec DATE vs TIMESTAMP

```sql
-- Addition avec DATE
SELECT DATE '2025-11-19' + 1;  -- 2025-11-20 (ajoute 1 jour)
SELECT DATE '2025-11-19' + INTERVAL '1 day';  -- 2025-11-20

-- Mais attention avec TIMESTAMP
SELECT TIMESTAMP '2025-11-19 00:00:00' + 1;  -- ERREUR !
SELECT TIMESTAMP '2025-11-19 00:00:00' + INTERVAL '1 day';  -- ‚úÖ OK
```

### Pi√®ge 3 : Comparaison de Dates avec Heures

```sql
-- Comparer une DATE avec un TIMESTAMP
SELECT * FROM events
WHERE event_date = DATE '2025-11-19';  -- OK

-- Mais attention :
SELECT * FROM events
WHERE event_timestamp = DATE '2025-11-19';
-- Compare √† 2025-11-19 00:00:00 exactement !

-- Meilleure approche : plage
SELECT * FROM events
WHERE event_timestamp >= DATE '2025-11-19'
  AND event_timestamp < DATE '2025-11-19' + 1;
-- Ou
WHERE event_timestamp::DATE = DATE '2025-11-19';
```

### Pi√®ge 4 : Fuseaux Horaires et √ât√©/Hiver

```sql
-- L'heure change en √©t√©/hiver
SELECT '2025-03-30 02:30:00'::TIMESTAMPTZ AT TIME ZONE 'Europe/Paris';
-- Attention au changement d'heure !

-- PostgreSQL g√®re automatiquement les changements
-- Mais soyez conscient des ambigu√Øt√©s possibles
```

---

## R√©capitulatif

### Tableau de D√©cision

| Besoin | Type Recommand√© | Exemple |
|--------|----------------|---------|
| Date de naissance | `DATE` | `date_naissance DATE` |
| √âch√©ance sans heure | `DATE` | `date_echeance DATE` |
| Horaires d'ouverture | `TIME` | `heure_ouverture TIME` |
| **√âv√©nement avec heure** | `TIMESTAMPTZ` | `created_at TIMESTAMPTZ` |
| **Log avec horodatage** | `TIMESTAMPTZ` | `timestamp TIMESTAMPTZ` |
| Dur√©e, d√©lai | `INTERVAL` | `delai INTERVAL` |
| Application locale uniquement | `TIMESTAMP` (acceptable) | `log_time TIMESTAMP` |
| **Application internationale** | `TIMESTAMPTZ` (obligatoire) | `event_time TIMESTAMPTZ` |

### R√®gles d'Or

1. **Utilisez TIMESTAMPTZ par d√©faut** (pas TIMESTAMP)
2. **DATE pour les dates sans heure** (anniversaires, √©ch√©ances)
3. **INTERVAL pour les dur√©es** (pas d'entiers en secondes)
4. **Stockez toujours en UTC** (laissez PostgreSQL g√©rer)
5. **Indexez les colonnes temporelles** recherch√©es fr√©quemment
6. **Validez avec CHECK** pour la coh√©rence des dates

### Fonctions Essentielles

```sql
-- Obtenir la date/heure actuelle
NOW(), CURRENT_DATE, CURRENT_TIMESTAMP

-- Extraction
EXTRACT(), DATE_TRUNC()

-- Formatage
TO_CHAR(), TO_TIMESTAMP()

-- Calculs
AGE(), INTERVAL arithm√©tique

-- Conversion timezone
AT TIME ZONE
```

---

## Conclusion

Les types temporels de PostgreSQL sont puissants et flexibles :

- **DATE** : Pour les dates simples sans heure
- **TIMESTAMPTZ** : Le choix par d√©faut pour presque tout (√©v√©nements, logs, audit)
- **INTERVAL** : Pour repr√©senter des dur√©es de mani√®re lisible
- **TIME** : Rarement n√©cessaire (horaires uniquement)

**Point crucial :** Utilisez **TIMESTAMPTZ** (avec timezone) au lieu de TIMESTAMP pour √©viter les ambigu√Øt√©s dans les applications internationales. PostgreSQL stocke en UTC et convertit automatiquement, ce qui rend la gestion des fuseaux horaires transparente.

Dans la prochaine section, nous explorerons les types sp√©cifiques √† PostgreSQL comme JSON/JSONB, les tableaux, UUID, et d'autres types avanc√©s.

---


‚è≠Ô∏è [Sp√©cifiques PostgreSQL (JSON/JSONB, ARRAYS, UUID/UUIDv7, ENUMS)](/04-objets-de-la-base-de-donnees/04.4-types-specifiques-postgresql.md)
