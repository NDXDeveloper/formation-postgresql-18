üîù Retour au [Sommaire](/SOMMAIRE.md)

# 4.4.4. Types Sp√©cifiques PostgreSQL (JSON/JSONB, ARRAYS, UUID/UUIDv7, ENUMS)

## Introduction

PostgreSQL ne se limite pas aux types de donn√©es standards SQL. Il offre des types avanc√©s et sp√©cifiques qui le rendent particuli√®rement puissant et flexible. Ces types permettent de g√©rer des structures de donn√©es complexes directement dans la base de donn√©es.

Dans cette section, nous allons explorer :
- **JSON et JSONB** : Stocker et manipuler des donn√©es JSON
- **ARRAYS** : Tableaux de valeurs
- **UUID et UUIDv7** : Identifiants universels uniques
- **ENUMS** : Types √©num√©r√©s personnalis√©s

Ces types font de PostgreSQL un excellent choix pour des applications modernes qui n√©cessitent flexibilit√© et puissance.

---

## 1. JSON et JSONB (Documents JSON)

### Qu'est-ce que JSON ?

**JSON** (JavaScript Object Notation) est un format de donn√©es textuelles l√©ger et lisible par les humains, tr√®s utilis√© pour √©changer des donn√©es entre applications.

Exemple de JSON :
```json
{
  "nom": "Alice Martin",
  "age": 30,
  "email": "alice@example.com",
  "adresse": {
    "rue": "123 rue de la Paix",
    "ville": "Paris",
    "code_postal": "75001"
  },
  "hobbies": ["lecture", "cyclisme", "programmation"]
}
```

### JSON vs JSONB dans PostgreSQL

PostgreSQL propose **deux types** pour stocker du JSON :

| Aspect | JSON | JSONB |
|--------|------|-------|
| Stockage | Texte brut (copie exacte) | Format binaire (d√©compos√©) |
| Performance lecture | Plus lent | **Plus rapide** |
| Performance √©criture | Plus rapide | L√©g√®rement plus lent |
| Indexation | ‚ùå Non | ‚úÖ Oui (GIN index) |
| Ordre des cl√©s | Pr√©serv√© | Non pr√©serv√© |
| Espaces blancs | Pr√©serv√©s | Supprim√©s |
| Cl√©s dupliqu√©es | Accept√©es | Derni√®re valeur gard√©e |
| **Recommandation** | Rarement | **Toujours utiliser** |

**R√®gle simple :** Utilisez **JSONB** dans 99% des cas.

### Cr√©ation et Insertion

```sql
-- Cr√©er une table avec JSONB
CREATE TABLE utilisateurs (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    email VARCHAR(255),
    profil JSONB,  -- Donn√©es flexibles en JSON
    preferences JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insertion avec JSON
INSERT INTO utilisateurs (nom, email, profil, preferences) VALUES (
    'Alice Martin',
    'alice@example.com',
    '{
        "age": 30,
        "ville": "Paris",
        "bio": "D√©veloppeuse passionn√©e",
        "competences": ["PostgreSQL", "Python", "JavaScript"]
    }'::JSONB,
    '{
        "theme": "dark",
        "langue": "fr",
        "notifications": true
    }'::JSONB
);

-- Insertion avec notation PostgreSQL
INSERT INTO utilisateurs (nom, email, profil) VALUES (
    'Bob Dupont',
    'bob@example.com',
    '{"age": 25, "ville": "Lyon", "bio": "Designer cr√©atif"}'
);

SELECT * FROM utilisateurs;
```

### Acc√©der aux Donn√©es JSON

#### Op√©rateurs de Base

```sql
-- -> : Acc√©der √† un champ (retourne JSON)
SELECT profil -> 'age' FROM utilisateurs WHERE nom = 'Alice Martin';
-- R√©sultat : 30 (type JSON)

-- ->> : Acc√©der √† un champ (retourne TEXT)
SELECT profil ->> 'age' FROM utilisateurs WHERE nom = 'Alice Martin';
-- R√©sultat : '30' (type TEXT)

-- Acc√®s √† un √©l√©ment de tableau par index
SELECT profil -> 'competences' -> 0 FROM utilisateurs WHERE nom = 'Alice Martin';
-- R√©sultat : "PostgreSQL"

SELECT profil -> 'competences' ->> 0 FROM utilisateurs WHERE nom = 'Alice Martin';
-- R√©sultat : PostgreSQL (texte)

-- Chemin profond avec ->
SELECT
    nom,
    profil ->> 'ville' AS ville,
    profil -> 'competences' AS competences
FROM utilisateurs;
```

#### Op√©rateur de Chemin #>

```sql
-- Cr√©er des donn√©es imbriqu√©es
INSERT INTO utilisateurs (nom, email, profil) VALUES (
    'Charlie Bernard',
    'charlie@example.com',
    '{
        "age": 35,
        "adresse": {
            "rue": "10 avenue Victor Hugo",
            "ville": "Marseille",
            "code_postal": "13001"
        }
    }'::JSONB
);

-- Acc√©der avec un chemin
SELECT
    nom,
    profil #> '{adresse, ville}' AS ville_json,
    profil #>> '{adresse, ville}' AS ville_text
FROM utilisateurs
WHERE nom = 'Charlie Bernard';
```

### Requ√™tes et Filtres JSON

```sql
-- Filtrer par valeur JSON
SELECT * FROM utilisateurs
WHERE profil ->> 'ville' = 'Paris';

-- Filtrer par valeur num√©rique
SELECT * FROM utilisateurs
WHERE (profil ->> 'age')::INTEGER > 28;

-- V√©rifier l'existence d'une cl√©
SELECT * FROM utilisateurs
WHERE profil ? 'competences';  -- La cl√© 'competences' existe

-- V√©rifier si contient une valeur
SELECT * FROM utilisateurs
WHERE profil @> '{"ville": "Paris"}';  -- Contient cette paire cl√©-valeur

-- V√©rifier si un tableau contient un √©l√©ment
SELECT * FROM utilisateurs
WHERE profil -> 'competences' ? 'PostgreSQL';  -- Tableau contient 'PostgreSQL'

-- V√©rifier plusieurs cl√©s
SELECT * FROM utilisateurs
WHERE profil ?& ARRAY['age', 'ville'];  -- Contient TOUTES ces cl√©s

SELECT * FROM utilisateurs
WHERE profil ?| ARRAY['age', 'adresse'];  -- Contient AU MOINS UNE de ces cl√©s
```

### Modifier des Donn√©es JSON

```sql
-- Mettre √† jour un champ JSON
UPDATE utilisateurs
SET profil = jsonb_set(profil, '{age}', '31')
WHERE nom = 'Alice Martin';

-- Ajouter un nouveau champ
UPDATE utilisateurs
SET profil = profil || '{"profession": "Ing√©nieure"}'::JSONB
WHERE nom = 'Alice Martin';

-- Supprimer un champ
UPDATE utilisateurs
SET profil = profil - 'bio'
WHERE nom = 'Alice Martin';

-- Mettre √† jour un champ imbriqu√©
UPDATE utilisateurs
SET profil = jsonb_set(
    profil,
    '{adresse, ville}',
    '"Nice"'
)
WHERE nom = 'Charlie Bernard';
```

### Fonctions JSON Utiles

```sql
-- jsonb_build_object : Construire un objet JSON
SELECT jsonb_build_object(
    'nom', nom,
    'email', email,
    'age', profil ->> 'age'
) AS user_json
FROM utilisateurs;

-- jsonb_build_array : Construire un tableau JSON
SELECT jsonb_build_array('PostgreSQL', 'MongoDB', 'Redis');
-- R√©sultat : ["PostgreSQL", "MongoDB", "Redis"]

-- jsonb_array_elements : D√©composer un tableau JSON
SELECT
    nom,
    jsonb_array_elements_text(profil -> 'competences') AS competence
FROM utilisateurs
WHERE profil ? 'competences';

-- jsonb_each : D√©composer en paires cl√©-valeur
SELECT key, value
FROM utilisateurs,
     jsonb_each(profil)
WHERE nom = 'Alice Martin';

-- jsonb_object_keys : Lister les cl√©s
SELECT DISTINCT jsonb_object_keys(profil) AS cles
FROM utilisateurs;

-- jsonb_typeof : Type de la valeur
SELECT
    profil -> 'age' AS valeur,
    jsonb_typeof(profil -> 'age') AS type
FROM utilisateurs;
```

### Indexation JSON (Performance)

```sql
-- Index GIN sur toute la colonne JSONB
CREATE INDEX idx_profil_gin ON utilisateurs USING GIN (profil);

-- Requ√™tes optimis√©es avec l'index
SELECT * FROM utilisateurs
WHERE profil @> '{"ville": "Paris"}';  -- Utilise l'index

-- Index sur un champ sp√©cifique (plus efficace)
CREATE INDEX idx_profil_ville ON utilisateurs ((profil ->> 'ville'));

-- Requ√™te optimis√©e
SELECT * FROM utilisateurs
WHERE profil ->> 'ville' = 'Paris';  -- Utilise l'index

-- Index avec jsonb_path_ops (plus compact)
CREATE INDEX idx_profil_path ON utilisateurs USING GIN (profil jsonb_path_ops);
```

### Cas d'Usage de JSONB

#### 1. Donn√©es Flexibles et √âvolutives

```sql
-- Profils utilisateurs avec champs variables
CREATE TABLE profils_utilisateurs (
    id SERIAL PRIMARY KEY,
    user_id INTEGER UNIQUE NOT NULL,
    donnees JSONB NOT NULL DEFAULT '{}'::JSONB,
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Chaque utilisateur peut avoir des champs diff√©rents
INSERT INTO profils_utilisateurs (user_id, donnees) VALUES
    (1, '{"bio": "D√©veloppeur", "github": "alice123", "langues": ["fr", "en"]}'),
    (2, '{"bio": "Designer", "dribbble": "bob_design", "portfolio": "https://bob.com"}'),
    (3, '{"bio": "Manager", "linkedin": "charlie-bernard", "certifications": ["PMP", "Scrum"]}');
```

#### 2. Logs et √âv√©nements

```sql
CREATE TABLE logs_application (
    id BIGSERIAL PRIMARY KEY,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    niveau VARCHAR(10),
    message TEXT,
    contexte JSONB,  -- Donn√©es contextuelles variables
    stack_trace TEXT
);

INSERT INTO logs_application (niveau, message, contexte) VALUES (
    'ERROR',
    '√âchec de connexion base de donn√©es',
    '{
        "database": "production",
        "host": "db.example.com",
        "tentatives": 3,
        "erreur_code": "28P01"
    }'::JSONB
);

-- Rechercher des erreurs avec un contexte sp√©cifique
SELECT * FROM logs_application
WHERE contexte ->> 'database' = 'production'
  AND niveau = 'ERROR';
```

#### 3. Configuration et Param√®tres

```sql
CREATE TABLE configurations (
    id SERIAL PRIMARY KEY,
    application VARCHAR(100) NOT NULL,
    environnement VARCHAR(20) NOT NULL,  -- dev, staging, prod
    config JSONB NOT NULL,
    version INTEGER DEFAULT 1,
    created_at TIMESTAMPTZ DEFAULT NOW(),

    UNIQUE(application, environnement)
);

INSERT INTO configurations (application, environnement, config) VALUES (
    'api-backend',
    'production',
    '{
        "database": {
            "host": "db.prod.example.com",
            "port": 5432,
            "max_connections": 100
        },
        "cache": {
            "enabled": true,
            "ttl": 3600
        },
        "features": {
            "new_dashboard": true,
            "beta_features": false
        }
    }'::JSONB
);

-- R√©cup√©rer une configuration
SELECT config FROM configurations
WHERE application = 'api-backend'
  AND environnement = 'production';
```

#### 4. Donn√©es E-commerce (Produits Variables)

```sql
CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(300) NOT NULL,
    categorie VARCHAR(100),
    prix NUMERIC(10, 2) NOT NULL,
    attributs JSONB,  -- Attributs variables selon cat√©gorie
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Livre
INSERT INTO produits (nom, categorie, prix, attributs) VALUES (
    'PostgreSQL: Up and Running',
    'Livre',
    39.99,
    '{
        "auteurs": ["Regina Obe", "Leo Hsu"],
        "isbn": "978-1449373191",
        "pages": 428,
        "editeur": "O''Reilly"
    }'
);

-- Ordinateur
INSERT INTO produits (nom, categorie, prix, attributs) VALUES (
    'Laptop Pro 2025',
    '√âlectronique',
    1299.99,
    '{
        "processeur": "Intel i7",
        "ram": "16GB",
        "stockage": "512GB SSD",
        "ecran": "15.6 pouces",
        "garantie": "2 ans"
    }'
);

-- Recherche par attribut
SELECT nom, prix, attributs
FROM produits
WHERE categorie = '√âlectronique'
  AND (attributs ->> 'ram') = '16GB';
```

---

## 2. ARRAYS (Tableaux)

### D√©finition

PostgreSQL permet de stocker des **tableaux** de valeurs dans une seule colonne. Un tableau peut contenir n'importe quel type de donn√©es (integers, text, dates, etc.).

### Syntaxe de D√©claration

```sql
-- Tableau d'entiers
colonne INTEGER[]

-- Tableau de texte
colonne TEXT[]

-- Tableau de dates
colonne DATE[]

-- Tableau multidimensionnel
colonne INTEGER[][]
```

### Cr√©ation et Insertion

```sql
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(300) NOT NULL,
    contenu TEXT,
    tags TEXT[],  -- Tableau de tags
    vues_par_jour INTEGER[],  -- Tableau de statistiques
    auteurs VARCHAR(100)[],  -- Plusieurs auteurs
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insertion avec notation ARRAY
INSERT INTO articles (titre, contenu, tags, auteurs) VALUES (
    'Introduction √† PostgreSQL',
    'PostgreSQL est un syst√®me...',
    ARRAY['PostgreSQL', 'SQL', 'Database', 'Tutorial'],
    ARRAY['Alice Martin', 'Bob Dupont']
);

-- Insertion avec notation {}
INSERT INTO articles (titre, contenu, tags, auteurs) VALUES (
    'Les Arrays dans PostgreSQL',
    'Les tableaux sont puissants...',
    '{"PostgreSQL", "Arrays", "Advanced"}',
    '{"Charlie Bernard"}'
);

-- Tableau vide
INSERT INTO articles (titre, contenu, tags) VALUES (
    'Article sans tags',
    'Contenu...',
    ARRAY[]::TEXT[]  -- Tableau vide
);

SELECT * FROM articles;
```

### Acc√©der aux √âl√©ments

```sql
-- Acc√©der √† un √©l√©ment (index commence √† 1, pas 0 !)
SELECT
    titre,
    tags[1] AS premier_tag,
    tags[2] AS deuxieme_tag
FROM articles;

-- Extraire une portion (slice)
SELECT
    titre,
    tags[1:2] AS deux_premiers_tags
FROM articles;

-- Longueur du tableau
SELECT
    titre,
    array_length(tags, 1) AS nombre_tags
FROM articles;
```

### Op√©rations sur les Tableaux

```sql
-- V√©rifier si contient un √©l√©ment
SELECT * FROM articles
WHERE 'PostgreSQL' = ANY(tags);

-- V√©rifier si contient tous les √©l√©ments
SELECT * FROM articles
WHERE tags @> ARRAY['PostgreSQL', 'Tutorial'];

-- V√©rifier si chevauche (au moins un √©l√©ment commun)
SELECT * FROM articles
WHERE tags && ARRAY['SQL', 'Tutorial'];

-- Concat√©ner des tableaux
SELECT
    titre,
    tags || ARRAY['Nouveau Tag'] AS tags_etendus
FROM articles;

-- Ajouter un √©l√©ment au d√©but
SELECT
    titre,
    ARRAY['Featured'] || tags AS tags_avec_featured
FROM articles;
```

### Fonctions de Manipulation

```sql
-- array_append : Ajouter √† la fin
UPDATE articles
SET tags = array_append(tags, 'Nouveau')
WHERE id = 1;

-- array_prepend : Ajouter au d√©but
UPDATE articles
SET tags = array_prepend('Important', tags)
WHERE id = 1;

-- array_remove : Supprimer une valeur
UPDATE articles
SET tags = array_remove(tags, 'Ancien')
WHERE id = 1;

-- array_cat : Concat√©ner
SELECT array_cat(ARRAY[1,2,3], ARRAY[4,5,6]);  -- {1,2,3,4,5,6}

-- array_position : Position d'un √©l√©ment
SELECT array_position(tags, 'PostgreSQL') FROM articles;

-- unnest : D√©composer en lignes
SELECT
    titre,
    unnest(tags) AS tag
FROM articles;

-- array_agg : Agr√©ger en tableau (inverse de unnest)
SELECT
    auteurs,
    array_agg(titre) AS articles
FROM articles
GROUP BY auteurs;
```

### Indexation des Tableaux

```sql
-- Index GIN pour recherches dans les tableaux
CREATE INDEX idx_articles_tags ON articles USING GIN (tags);

-- Requ√™tes optimis√©es
SELECT * FROM articles WHERE tags @> ARRAY['PostgreSQL'];  -- Utilise l'index
SELECT * FROM articles WHERE 'PostgreSQL' = ANY(tags);  -- Utilise l'index
```

### Cas d'Usage des Arrays

#### 1. Tags et Cat√©gories

```sql
CREATE TABLE produits_tags (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    prix NUMERIC(10, 2),
    tags TEXT[],
    categories TEXT[]
);

INSERT INTO produits_tags (nom, prix, tags, categories) VALUES (
    'Ordinateur Portable',
    999.99,
    ARRAY['laptop', 'gaming', 'portable', 'high-performance'],
    ARRAY['Informatique', 'Gaming']
);

-- Recherche par tag
SELECT * FROM produits_tags
WHERE 'gaming' = ANY(tags);

-- Recherche par plusieurs tags
SELECT * FROM produits_tags
WHERE tags @> ARRAY['laptop', 'gaming'];
```

#### 2. Historique de Valeurs

```sql
CREATE TABLE metriques (
    id SERIAL PRIMARY KEY,
    metrique VARCHAR(100),
    date DATE,
    valeurs_horaires NUMERIC[24]  -- 24 valeurs (une par heure)
);

INSERT INTO metriques (metrique, date, valeurs_horaires) VALUES (
    'temperature_serveur',
    '2025-11-19',
    ARRAY[65.2, 66.1, 65.8, 67.3, 68.1, 69.5, 70.2, 71.1,
          72.4, 73.2, 74.1, 73.8, 72.9, 71.5, 70.8, 69.9,
          68.7, 67.5, 66.8, 66.2, 65.9, 65.4, 65.1, 64.9]
);

-- Temp√©rature maximale
SELECT
    metrique,
    date,
    (SELECT MAX(v) FROM unnest(valeurs_horaires) AS v) AS temp_max
FROM metriques;
```

#### 3. Listes de Relations Simples

```sql
CREATE TABLE utilisateurs_permissions (
    id SERIAL PRIMARY KEY,
    username VARCHAR(100),
    roles TEXT[],
    permissions TEXT[]
);

INSERT INTO utilisateurs_permissions (username, roles, permissions) VALUES (
    'alice',
    ARRAY['admin', 'moderator'],
    ARRAY['read', 'write', 'delete', 'manage_users']
);

-- V√©rifier les permissions
SELECT * FROM utilisateurs_permissions
WHERE 'admin' = ANY(roles);

SELECT * FROM utilisateurs_permissions
WHERE permissions @> ARRAY['write', 'delete'];
```

---

## 3. UUID et UUIDv7 (Identifiants Uniques)

### Qu'est-ce qu'un UUID ?

Un **UUID** (Universally Unique Identifier) est un identifiant de 128 bits garanti unique √† l'√©chelle mondiale. Format : `550e8400-e29b-41d4-a716-446655440000`

### Types d'UUID

PostgreSQL supporte plusieurs versions d'UUID :

| Version | Description | Utilisation |
|---------|-------------|-------------|
| UUID v4 | Al√©atoire | Standard, recommand√© historiquement |
| UUID v7 | Bas√© sur timestamp (nouveau !) | **Recommand√©** pour PostgreSQL 18+ |

### UUIDv7 : Nouveaut√© PostgreSQL 18 üÜï

**UUIDv7** est une nouveaut√© majeure de PostgreSQL 18 (septembre 2025). Il combine :
- Un **timestamp** (millisecondes depuis epoch)
- Des bits **al√©atoires**

**Avantages :**
- ‚úÖ **Triable chronologiquement** (contrairement √† UUIDv4)
- ‚úÖ Meilleure performance d'indexation (index B-Tree)
- ‚úÖ Toujours unique globalement
- ‚úÖ Pas besoin de s√©quence centralis√©e

### Activer l'Extension UUID

```sql
-- Activer l'extension pgcrypto (pour UUID v4)
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- PostgreSQL 18+ : UUIDv7 int√©gr√© nativement (pas d'extension n√©cessaire)
```

### Cr√©ation et Utilisation

```sql
-- Table avec UUID v4 (m√©thode classique)
CREATE TABLE utilisateurs_uuid4 (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),  -- UUID v4
    nom VARCHAR(100),
    email VARCHAR(255)
);

-- Table avec UUID v7 (PostgreSQL 18+)
CREATE TABLE utilisateurs_uuid7 (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid_v7(),  -- UUID v7 üÜï
    nom VARCHAR(100),
    email VARCHAR(255),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insertion automatique d'UUID
INSERT INTO utilisateurs_uuid7 (nom, email) VALUES
    ('Alice Martin', 'alice@example.com');

INSERT INTO utilisateurs_uuid7 (nom, email) VALUES
    ('Bob Dupont', 'bob@example.com');

SELECT * FROM utilisateurs_uuid7;
```

R√©sultat exemple :
```
                  id                  |     nom      |        email        |         created_at
--------------------------------------+--------------+---------------------+----------------------------
 018c8f5e-5a1e-7890-abcd-123456789abc | Alice Martin | alice@example.com   | 2025-11-19 14:30:00+01
 018c8f5e-6234-7123-def0-987654321fed | Bob Dupont   | bob@example.com     | 2025-11-19 14:30:05+01
```

### UUID v4 vs UUID v7

```sql
-- G√©n√©rer plusieurs UUID v4
SELECT gen_random_uuid() FROM generate_series(1, 5);
-- R√©sultats : ordre compl√®tement al√©atoire
-- 7c9e6679-7425-40de-944b-e07fc1f90ae7
-- 3f333df6-90a4-4fda-8dd3-9485d27cef1c
-- ...

-- G√©n√©rer plusieurs UUID v7 (PostgreSQL 18+)
SELECT gen_random_uuid_v7() FROM generate_series(1, 5);
-- R√©sultats : ordre chronologique (pr√©fixe timestamp)
-- 018c8f5e-5a1e-7890-abcd-123456789abc
-- 018c8f5e-5a1f-7123-def0-987654321fed
-- 018c8f5e-5a20-7456-1234-abcdef123456
-- ...
```

**Observation :** Les UUID v7 sont **tri√©s naturellement** par ordre de cr√©ation !

### Extraire le Timestamp d'un UUID v7

```sql
-- PostgreSQL 18+ : Fonction pour extraire le timestamp
CREATE OR REPLACE FUNCTION uuid_v7_to_timestamp(uuid UUID)
RETURNS TIMESTAMPTZ AS $$
    SELECT to_timestamp(
        ('x' || substring(uuid::text, 1, 8) ||
         substring(uuid::text, 10, 4))::bit(48)::bigint / 1000.0
    );
$$ LANGUAGE SQL IMMUTABLE;

-- Utilisation
SELECT
    id,
    nom,
    uuid_v7_to_timestamp(id) AS timestamp_from_uuid,
    created_at
FROM utilisateurs_uuid7;
```

### UUID vs SERIAL/BIGSERIAL

| Aspect | SERIAL | UUID v7 |
|--------|--------|---------|
| Taille | 4 ou 8 octets | 16 octets |
| Unicit√© | Base de donn√©es | **Globale** |
| Pr√©visibilit√© | ‚ùå Pr√©visible | ‚úÖ Impr√©visible |
| Tri chronologique | ‚úÖ Oui | ‚úÖ Oui (v7) |
| Performance | L√©g√®rement meilleur | Tr√®s bon (v7) |
| R√©plication/Merge | ‚ùå Probl√©matique | ‚úÖ Facile |
| S√©curit√© | Exposition info | Aucune exposition |

### Cas d'Usage des UUID

#### 1. API REST et Identifiants Publics

```sql
-- √âviter d'exposer des IDs s√©quentiels
CREATE TABLE commandes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid_v7(),
    numero_commande VARCHAR(50) UNIQUE NOT NULL,
    client_id UUID NOT NULL,
    montant NUMERIC(10, 2),
    statut VARCHAR(20),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- URL de l'API : /api/commandes/018c8f5e-5a1e-7890-abcd-123456789abc
-- Au lieu de : /api/commandes/1234 (pr√©visible)
```

#### 2. Syst√®mes Distribu√©s

```sql
-- Plusieurs serveurs peuvent g√©n√©rer des IDs sans conflit
-- Serveur A en France
INSERT INTO utilisateurs_uuid7 (nom) VALUES ('User A');
-- ID : 018c8f5e-5a1e-7890-abcd-123456789abc

-- Serveur B au Japon (en m√™me temps)
INSERT INTO utilisateurs_uuid7 (nom) VALUES ('User B');
-- ID : 018c8f5e-5a1f-7123-def0-987654321fed

-- Pas de collision possible !
```

#### 3. Import/Export et Migrations

```sql
-- Les UUID facilitent les fusions de donn√©es
-- Base A
INSERT INTO produits (id, nom)
VALUES ('018c8f5e-5a1e-7890-abcd-123456789abc', 'Produit A');

-- Base B
INSERT INTO produits (id, nom)
VALUES ('018c8f5e-6234-7123-def0-987654321fed', 'Produit B');

-- Fusion : aucun conflit d'ID !
```

---

## 4. ENUM (Types √ânum√©r√©s)

### Qu'est-ce qu'un ENUM ?

Un **ENUM** (√©num√©ration) est un type de donn√©es personnalis√© qui ne peut contenir qu'un ensemble **fixe et pr√©d√©fini** de valeurs.

### Cr√©ation d'un ENUM

```sql
-- Cr√©er un type ENUM
CREATE TYPE statut_commande AS ENUM (
    'en_attente',
    'confirmee',
    'en_preparation',
    'expediee',
    'livree',
    'annulee'
);

-- Utiliser l'ENUM dans une table
CREATE TABLE commandes_enum (
    id SERIAL PRIMARY KEY,
    numero VARCHAR(50) UNIQUE NOT NULL,
    statut statut_commande DEFAULT 'en_attente',
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insertion avec valeurs valides
INSERT INTO commandes_enum (numero, statut) VALUES
    ('CMD-001', 'en_attente'),
    ('CMD-002', 'confirmee');

-- Tentative avec valeur invalide
INSERT INTO commandes_enum (numero, statut) VALUES
    ('CMD-003', 'en_cours');  -- ‚ùå ERREUR : valeur invalide
-- ERROR: invalid input value for enum statut_commande: "en_cours"

SELECT * FROM commandes_enum;
```

### Avantages des ENUM

- ‚úÖ **Validation automatique** : Impossible d'ins√©rer une valeur non d√©finie
- ‚úÖ **Lisibilit√©** : Code plus clair que des codes num√©riques
- ‚úÖ **Performance** : Stockage efficace (1 ou 2 octets selon le nombre de valeurs)
- ‚úÖ **Ordre pr√©serv√©** : Les valeurs ont un ordre d√©fini

### Op√©rations avec ENUM

```sql
-- Comparaison
SELECT * FROM commandes_enum
WHERE statut = 'confirmee';

-- Ordre des valeurs (selon ordre de d√©finition)
SELECT * FROM commandes_enum
ORDER BY statut;
-- R√©sultat : en_attente, confirmee, expediee, livree...

-- Comparer avec <, >, etc.
SELECT * FROM commandes_enum
WHERE statut > 'en_preparation';
-- Retourne : expediee, livree, annulee

-- Lister toutes les valeurs possibles
SELECT enum_range(NULL::statut_commande);
-- R√©sultat : {en_attente,confirmee,en_preparation,expediee,livree,annulee}
```

### Modifier un ENUM

```sql
-- Ajouter une nouvelle valeur √† la fin
ALTER TYPE statut_commande ADD VALUE 'retournee';

-- Ajouter avant une valeur existante
ALTER TYPE statut_commande ADD VALUE 'en_cours_de_livraison' BEFORE 'livree';

-- Ajouter apr√®s une valeur existante
ALTER TYPE statut_commande ADD VALUE 'en_attente_paiement' AFTER 'en_attente';

-- ‚ö†Ô∏è IMPOSSIBLE de supprimer ou renommer une valeur !
-- Pour cela, il faut recr√©er l'ENUM et migrer les donn√©es
```

### ENUM vs VARCHAR avec CHECK

```sql
-- M√©thode 1 : ENUM
CREATE TYPE priorite AS ENUM ('basse', 'moyenne', 'haute', 'critique');

CREATE TABLE taches_enum (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(200),
    priorite priorite DEFAULT 'moyenne'
);

-- M√©thode 2 : VARCHAR avec CHECK
CREATE TABLE taches_varchar (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(200),
    priorite VARCHAR(20) DEFAULT 'moyenne'
        CHECK (priorite IN ('basse', 'moyenne', 'haute', 'critique'))
);
```

**Comparaison :**

| Aspect | ENUM | VARCHAR + CHECK |
|--------|------|-----------------|
| Validation | ‚úÖ Type natif | ‚úÖ Contrainte |
| Performance | ‚úÖ Meilleure | L√©g√®rement moins bonne |
| Stockage | ‚úÖ 1-2 octets | 5-20 octets (selon valeur) |
| Modification | ‚ùå Limit√©e | ‚úÖ Facile (ALTER TABLE) |
| Ordre | ‚úÖ D√©fini | ‚ùå Alphab√©tique |
| R√©utilisabilit√© | ‚úÖ Type global | ‚ùå Par table |

**Recommandation :**
- Utilisez **ENUM** pour des valeurs stables et rarement modifi√©es
- Utilisez **VARCHAR + CHECK** si vous pr√©voyez des changements fr√©quents

### Cas d'Usage des ENUM

#### 1. Statuts de Workflow

```sql
CREATE TYPE statut_article AS ENUM (
    'brouillon',
    'en_revision',
    'approuve',
    'publie',
    'archive'
);

CREATE TABLE articles_enum (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(300),
    contenu TEXT,
    statut statut_article DEFAULT 'brouillon',
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Statistiques par statut
SELECT
    statut,
    COUNT(*) AS nombre
FROM articles_enum
GROUP BY statut
ORDER BY statut;
```

#### 2. Priorit√©s et Niveaux

```sql
CREATE TYPE niveau_log AS ENUM ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL');

CREATE TABLE logs_enum (
    id BIGSERIAL PRIMARY KEY,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    niveau niveau_log NOT NULL,
    message TEXT
);

-- Logs d'erreur et critiques
SELECT * FROM logs_enum
WHERE niveau >= 'ERROR'
ORDER BY timestamp DESC;
```

#### 3. Jours de la Semaine

```sql
CREATE TYPE jour_semaine AS ENUM (
    'Lundi',
    'Mardi',
    'Mercredi',
    'Jeudi',
    'Vendredi',
    'Samedi',
    'Dimanche'
);

CREATE TABLE horaires_magasin (
    id SERIAL PRIMARY KEY,
    jour jour_semaine UNIQUE NOT NULL,
    heure_ouverture TIME,
    heure_fermeture TIME
);

INSERT INTO horaires_magasin VALUES
    (1, 'Lundi', '09:00', '18:00'),
    (2, 'Mardi', '09:00', '18:00'),
    (3, 'Mercredi', '09:00', '18:00');

-- Tri automatique selon l'ordre de l'ENUM
SELECT * FROM horaires_magasin ORDER BY jour;
```

### Supprimer un ENUM

```sql
-- Supprimer l'ENUM (seulement si non utilis√©)
DROP TYPE statut_commande;

-- Si utilis√©, d'abord supprimer les r√©f√©rences
DROP TABLE commandes_enum;
DROP TYPE statut_commande;
```

---

## Comparaison et Recommandations

### Tableau R√©capitulatif

| Type | Utilisation | Avantages | Inconv√©nients |
|------|-------------|-----------|---------------|
| **JSONB** | Donn√©es flexibles, API, logs | Flexible, indexable, puissant | Plus lourd qu'une table normalis√©e |
| **ARRAY** | Tags, listes simples | Simple, performant | Difficult√© pour contraintes |
| **UUID v7** | IDs distribu√©s, API publiques | Global, s√©curis√©, triable | Plus gros que SERIAL |
| **ENUM** | Statuts, cat√©gories fixes | Valid√©, performant, lisible | Difficile √† modifier |

### Quand Utiliser Quoi ?

#### Utiliser JSONB quand :
- ‚úÖ Structure de donn√©es variable entre les lignes
- ‚úÖ Donn√©es provenant d'APIs externes (JSON natif)
- ‚úÖ Logs avec contextes variables
- ‚úÖ Configuration ou m√©tadonn√©es flexibles
- ‚ùå Pas pour : Donn√©es relationnelles strictes (utilisez des tables)

#### Utiliser ARRAY quand :
- ‚úÖ Liste simple de valeurs sans relations complexes
- ‚úÖ Tags, cat√©gories multiples
- ‚úÖ Historique de valeurs simples
- ‚ùå Pas pour : Relations many-to-many complexes (utilisez une table de jonction)

#### Utiliser UUID v7 quand :
- ‚úÖ Application distribu√©e (plusieurs serveurs)
- ‚úÖ IDs publics dans une API
- ‚úÖ Besoin de g√©n√©ration c√¥t√© client
- ‚úÖ Import/export et fusions de donn√©es
- ‚ùå Pas pour : Tables internes simples (SERIAL suffit)

#### Utiliser ENUM quand :
- ‚úÖ Ensemble de valeurs fixes et stables
- ‚úÖ Besoin d'ordre sp√©cifique
- ‚úÖ Performance critique
- ‚ùå Pas pour : Valeurs changeant fr√©quemment (utilisez une table de r√©f√©rence)

---

## Bonnes Pratiques

### 1. JSONB : Indexer les Champs Recherch√©s

```sql
-- ‚úÖ BON : Index sur les champs JSONB fr√©quemment recherch√©s
CREATE INDEX idx_profil_gin ON utilisateurs USING GIN (profil);
CREATE INDEX idx_profil_ville ON utilisateurs ((profil ->> 'ville'));

-- ‚ùå MAUVAIS : Recherches sans index sur JSONB
SELECT * FROM utilisateurs WHERE profil ->> 'ville' = 'Paris';
-- Lent sur grande table sans index
```

### 2. ARRAY : Limiter la Taille

```sql
-- ‚úÖ BON : Tableaux de taille raisonnable
CREATE TABLE articles (
    tags TEXT[] CHECK (array_length(tags, 1) <= 20)
);

-- ‚ùå MAUVAIS : Tableaux tr√®s grands
-- Mieux vaut une table de jonction
```

### 3. UUID : Utiliser v7 pour les Nouveaux Projets

```sql
-- ‚úÖ RECOMMAND√â : UUID v7 (PostgreSQL 18+)
id UUID PRIMARY KEY DEFAULT gen_random_uuid_v7()

-- ‚ùì ACCEPTABLE : UUID v4 (versions ant√©rieures)
id UUID PRIMARY KEY DEFAULT gen_random_uuid()

-- ‚úÖ BON : Index B-Tree avec UUID v7 (performant)
CREATE INDEX idx_users_id ON users(id);
```

### 4. ENUM : Utiliser pour Valeurs Stables Uniquement

```sql
-- ‚úÖ BON : Valeurs stables
CREATE TYPE jour_semaine AS ENUM ('Lundi', 'Mardi', ...);

-- ‚ùå MAUVAIS : Valeurs changeantes
-- CREATE TYPE pays AS ENUM ('France', 'Allemagne', ...);
-- Mieux vaut une table de r√©f√©rence
CREATE TABLE pays (
    code CHAR(2) PRIMARY KEY,
    nom VARCHAR(100)
);
```

---

## R√©capitulatif

### Types Sp√©cifiques PostgreSQL

1. **JSONB** : Donn√©es semi-structur√©es, flexibles
   - Stocker, indexer et requ√™ter du JSON
   - Op√©rateurs : `->`, `->>`, `@>`, `?`
   - Index GIN pour performance

2. **ARRAY** : Listes de valeurs
   - Types : `INTEGER[]`, `TEXT[]`, etc.
   - Op√©rateurs : `ANY`, `@>`, `&&`
   - Index GIN pour recherches

3. **UUID v7** : Identifiants uniques globaux (PostgreSQL 18+)
   - `gen_random_uuid_v7()`
   - Triable chronologiquement
   - Parfait pour syst√®mes distribu√©s

4. **ENUM** : Valeurs √©num√©r√©es
   - Validation automatique
   - Performance optimale
   - Pour valeurs stables uniquement

### Commandes Essentielles

```sql
-- JSONB
SELECT data ->> 'key' FROM table;
CREATE INDEX ON table USING GIN (jsonb_column);

-- ARRAY
SELECT * FROM table WHERE 'value' = ANY(array_column);
CREATE INDEX ON table USING GIN (array_column);

-- UUID v7 (PG 18+)
DEFAULT gen_random_uuid_v7()

-- ENUM
CREATE TYPE status AS ENUM ('active', 'inactive');
ALTER TYPE status ADD VALUE 'pending';
```

---

## Conclusion

Les types sp√©cifiques PostgreSQL offrent une flexibilit√© et une puissance extraordinaires :

- **JSONB** permet de stocker des donn√©es flexibles tout en b√©n√©ficiant de la puissance de SQL
- **ARRAY** simplifie le stockage de listes sans tables suppl√©mentaires
- **UUID v7** r√©volutionne les identifiants distribu√©s avec son tri chronologique
- **ENUM** garantit la validit√© des donn√©es avec une excellente performance

Ces types font de PostgreSQL bien plus qu'une simple base de donn√©es relationnelle : c'est une plateforme de donn√©es compl√®te capable de g√©rer des cas d'usage modernes et complexes.

Dans les prochaines sections, nous continuerons √† explorer d'autres types avanc√©s et apprendrons √† cr√©er nos propres types personnalis√©s.

---


‚è≠Ô∏è [Types g√©om√©triques, hstore et ltree](/04-objets-de-la-base-de-donnees/04.5-types-geometriques-hstore-ltree.md)
