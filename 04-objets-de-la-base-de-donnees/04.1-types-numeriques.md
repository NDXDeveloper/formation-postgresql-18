üîù Retour au [Sommaire](/SOMMAIRE.md)

# 4.4.1. Types Num√©riques (INTEGER, SERIAL/IDENTITY, NUMERIC, FLOAT)

## Introduction

Les types num√©riques sont fondamentaux dans toute base de donn√©es. PostgreSQL offre une grande vari√©t√© de types num√©riques adapt√©s √† diff√©rents besoins : nombres entiers, nombres d√©cimaux pr√©cis, nombres √† virgule flottante, et identifiants auto-incr√©ment√©s.

Dans cette section, nous allons explorer en d√©tail :
- Les **nombres entiers** (INTEGER et ses variantes)
- Les **identifiants auto-incr√©ment√©s** (SERIAL et IDENTITY)
- Les **nombres d√©cimaux pr√©cis** (NUMERIC et DECIMAL)
- Les **nombres √† virgule flottante** (REAL et DOUBLE PRECISION)

---

## Vue d'Ensemble des Types Num√©riques

Voici un tableau r√©capitulatif des types num√©riques PostgreSQL :

| Type | Taille | Plage de Valeurs | Utilisation Typique |
|------|--------|------------------|---------------------|
| `SMALLINT` | 2 octets | -32 768 √† +32 767 | Petits entiers |
| `INTEGER` / `INT` | 4 octets | -2 milliards √† +2 milliards | Entiers standards |
| `BIGINT` | 8 octets | -9 √ó 10¬π‚Å∏ √† +9 √ó 10¬π‚Å∏ | Tr√®s grands entiers |
| `SERIAL` | 4 octets | 1 √† 2 milliards | ID auto-incr√©ment√©s |
| `BIGSERIAL` | 8 octets | 1 √† 9 √ó 10¬π‚Å∏ | ID auto-incr√©ment√©s (grande table) |
| `NUMERIC(p,s)` | Variable | Pr√©cision arbitraire | Montants financiers, calculs pr√©cis |
| `DECIMAL(p,s)` | Variable | Identique √† NUMERIC | Alias de NUMERIC |
| `REAL` | 4 octets | 6 d√©cimales de pr√©cision | Nombres flottants simples |
| `DOUBLE PRECISION` | 8 octets | 15 d√©cimales de pr√©cision | Nombres flottants doubles |

---

## 1. Les Nombres Entiers (INTEGER)

### Types d'entiers disponibles

PostgreSQL propose trois types d'entiers de tailles diff√©rentes :

#### SMALLINT (Petit Entier)

```sql
-- D√©finition
SMALLINT

-- Plage : -32 768 √† +32 767
-- Stockage : 2 octets (16 bits)
```

**Utilisation :**
- √Çges, notes, quantit√©s limit√©es
- Lorsque vous √™tes **certain** que les valeurs resteront petites

**Exemple :**

```sql
CREATE TABLE etudiants (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    age SMALLINT,  -- L'√¢ge ne d√©passera jamais 32 767
    note SMALLINT CHECK (note BETWEEN 0 AND 20)
);

INSERT INTO etudiants (nom, age, note) VALUES ('Alice', 22, 18);
INSERT INTO etudiants (nom, age, note) VALUES ('Bob', 19, 15);

-- Tentative de d√©passement (erreur)
INSERT INTO etudiants (nom, age, note) VALUES ('Charlie', 40000, 10);
-- ERROR: smallint out of range
```

#### INTEGER ou INT (Entier Standard)

```sql
-- D√©finition
INTEGER  -- ou INT (alias)

-- Plage : -2 147 483 648 √† +2 147 483 647 (environ -2 milliards √† +2 milliards)
-- Stockage : 4 octets (32 bits)
```

**Utilisation :**
- **Type d'entier par d√©faut** le plus courant
- IDs, compteurs, quantit√©s standards
- Bon √©quilibre entre plage et taille

**Exemple :**

```sql
CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    quantite_stock INTEGER,  -- Stock de produits
    nombre_ventes INTEGER DEFAULT 0
);

INSERT INTO produits (nom, quantite_stock) VALUES ('Ordinateur', 150);
INSERT INTO produits (nom, quantite_stock) VALUES ('Souris', 5000);
INSERT INTO produits (nom, quantite_stock) VALUES ('Clavier', 2500);

SELECT * FROM produits;
```

#### BIGINT (Grand Entier)

```sql
-- D√©finition
BIGINT

-- Plage : -9 223 372 036 854 775 808 √† +9 223 372 036 854 775 807
--         (environ -9 √ó 10^18 √† +9 √ó 10^18)
-- Stockage : 8 octets (64 bits)
```

**Utilisation :**
- Tr√®s grandes quantit√©s (compteurs de vues, transactions bancaires)
- Timestamps en millisecondes
- Identifiants pour tr√®s grandes tables (plusieurs milliards de lignes)

**Exemple :**

```sql
CREATE TABLE statistiques_site (
    id BIGSERIAL PRIMARY KEY,
    page VARCHAR(500),
    nombre_vues BIGINT DEFAULT 0,  -- Peut atteindre des milliards
    timestamp_ms BIGINT  -- Timestamp en millisecondes depuis epoch
);

INSERT INTO statistiques_site (page, nombre_vues, timestamp_ms)
VALUES ('/home', 15000000000, 1700400000000);

-- Afficher les donn√©es
SELECT
    page,
    nombre_vues,
    to_timestamp(timestamp_ms / 1000.0) AS date_heure
FROM statistiques_site;
```

### Comparaison des Types Entiers

| Type | Taille | Plage Approximative | Quand l'Utiliser |
|------|--------|---------------------|------------------|
| `SMALLINT` | 2 octets | -32K √† +32K | Petites valeurs garanties |
| `INTEGER` | 4 octets | -2B √† +2B | **Usage g√©n√©ral** (recommand√©) |
| `BIGINT` | 8 octets | -9 √ó 10¬π‚Å∏ √† +9 √ó 10¬π‚Å∏ | Tr√®s grandes valeurs |

**R√®gle pratique :** Utilisez `INTEGER` par d√©faut, sauf si :
- Vous avez besoin d'√©conomiser de l'espace ‚Üí `SMALLINT`
- Vous pr√©voyez des valeurs > 2 milliards ‚Üí `BIGINT`

### Op√©rations Arithm√©tiques

PostgreSQL supporte toutes les op√©rations arithm√©tiques standards :

```sql
-- Cr√©er une table de d√©monstration
CREATE TABLE calculs (
    a INTEGER,
    b INTEGER
);

INSERT INTO calculs VALUES (10, 3), (100, 25), (7, 2);

-- Addition
SELECT a, b, a + b AS addition FROM calculs;

-- Soustraction
SELECT a, b, a - b AS soustraction FROM calculs;

-- Multiplication
SELECT a, b, a * b AS multiplication FROM calculs;

-- Division enti√®re (tronque les d√©cimales)
SELECT a, b, a / b AS division_entiere FROM calculs;
-- R√©sultat : 10/3 = 3 (pas 3.33)

-- Modulo (reste de la division)
SELECT a, b, a % b AS modulo FROM calculs;
-- R√©sultat : 10 % 3 = 1

-- Puissance
SELECT a, b, a ^ b AS puissance FROM calculs;
-- Ou avec power()
SELECT a, b, power(a, b) AS puissance FROM calculs;
```

**Attention √† la division enti√®re :**

```sql
-- Division entre deux entiers = r√©sultat entier (tronqu√©)
SELECT 10 / 3;  -- R√©sultat : 3 (pas 3.333...)

-- Pour obtenir un r√©sultat d√©cimal, convertir l'un des nombres
SELECT 10.0 / 3;        -- R√©sultat : 3.333...
SELECT 10 / 3.0;        -- R√©sultat : 3.333...
SELECT 10::NUMERIC / 3; -- R√©sultat : 3.333...
SELECT CAST(10 AS NUMERIC) / 3; -- R√©sultat : 3.333...
```

---

## 2. Les Identifiants Auto-Incr√©ment√©s (SERIAL et IDENTITY)

### SERIAL, BIGSERIAL, SMALLSERIAL

Les types `SERIAL` ne sont **pas de vrais types** PostgreSQL. C'est un raccourci qui cr√©e automatiquement :
1. Une s√©quence
2. Une colonne INTEGER avec une valeur par d√©faut provenant de cette s√©quence

#### SERIAL (Auto-Increment Standard)

```sql
-- D√©finition
SERIAL

-- √âquivalent √† :
INTEGER NOT NULL DEFAULT nextval('sequence_name')
```

**Exemple de base :**

```sql
CREATE TABLE utilisateurs (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    email VARCHAR(255)
);

-- Ins√©rer sans sp√©cifier l'ID
INSERT INTO utilisateurs (nom, email) VALUES ('Alice', 'alice@example.com');
INSERT INTO utilisateurs (nom, email) VALUES ('Bob', 'bob@example.com');
INSERT INTO utilisateurs (nom, email) VALUES ('Charlie', 'charlie@example.com');

-- PostgreSQL g√©n√®re automatiquement les IDs : 1, 2, 3
SELECT * FROM utilisateurs;
```

R√©sultat :
```
 id |   nom   |        email
----+---------+---------------------
  1 | Alice   | alice@example.com
  2 | Bob     | bob@example.com
  3 | Charlie | charlie@example.com
```

#### BIGSERIAL (Auto-Increment pour Grandes Tables)

```sql
-- D√©finition
BIGSERIAL

-- √âquivalent √† :
BIGINT NOT NULL DEFAULT nextval('sequence_name')

-- Plage : 1 √† 9 223 372 036 854 775 807
```

**Utilisation :**
- Tables qui auront plus de 2 milliards de lignes
- Logs syst√®me, √©v√©nements, donn√©es de capteurs

**Exemple :**

```sql
CREATE TABLE logs_application (
    id BIGSERIAL PRIMARY KEY,  -- Peut atteindre des milliards
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    niveau VARCHAR(20),
    message TEXT
);

INSERT INTO logs_application (niveau, message)
VALUES ('INFO', 'Application d√©marr√©e');
```

#### SMALLSERIAL (Auto-Increment Limit√©)

```sql
-- D√©finition
SMALLSERIAL

-- √âquivalent √† :
SMALLINT NOT NULL DEFAULT nextval('sequence_name')

-- Plage : 1 √† 32 767
```

**Utilisation :** Rarement utilis√© (32 767 lignes max).

### Comparaison SERIAL vs BIGSERIAL

| Type | Type R√©el | Plage | Utilisation |
|------|-----------|-------|-------------|
| `SMALLSERIAL` | SMALLINT | 1 √† 32K | Tr√®s petites tables |
| `SERIAL` | INTEGER | 1 √† 2 milliards | **Standard** (tables normales) |
| `BIGSERIAL` | BIGINT | 1 √† 9 √ó 10¬π‚Å∏ | Grandes tables (logs, analytics) |

### Comprendre les S√©quences

Sous le capot, `SERIAL` cr√©e une **s√©quence** :

```sql
-- Cr√©er une table avec SERIAL
CREATE TABLE test_serial (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(50)
);

-- PostgreSQL cr√©e automatiquement une s√©quence nomm√©e :
-- test_serial_id_seq

-- Voir la s√©quence
\ds

-- Voir la valeur actuelle de la s√©quence
SELECT currval('test_serial_id_seq');  -- Erreur si jamais utilis√©e

-- Voir la prochaine valeur (et l'incr√©menter)
SELECT nextval('test_serial_id_seq');  -- Retourne 1, puis 2, puis 3...

-- R√©initialiser la s√©quence
ALTER SEQUENCE test_serial_id_seq RESTART WITH 100;

-- Les prochaines insertions commenceront √† 100
INSERT INTO test_serial (nom) VALUES ('Test');  -- id = 100
```

### Comportement Important de SERIAL

#### 1. Les valeurs ne sont PAS r√©utilis√©es

```sql
CREATE TABLE demo_serial (
    id SERIAL PRIMARY KEY,
    valeur VARCHAR(50)
);

INSERT INTO demo_serial (valeur) VALUES ('A');  -- id = 1
INSERT INTO demo_serial (valeur) VALUES ('B');  -- id = 2
INSERT INTO demo_serial (valeur) VALUES ('C');  -- id = 3

-- Supprimer la ligne avec id = 2
DELETE FROM demo_serial WHERE id = 2;

-- Ins√©rer une nouvelle ligne
INSERT INTO demo_serial (valeur) VALUES ('D');  -- id = 4 (pas 2 !)

SELECT * FROM demo_serial;
-- R√©sultat :
-- id | valeur
-- ---+--------
-- 1  | A
-- 3  | C
-- 4  | D
```

**Pourquoi ?** Les s√©quences ne regardent pas les valeurs existantes, elles incr√©mentent toujours.

#### 2. Les trous dans les IDs sont normaux

```sql
-- D√©but de transaction
BEGIN;
INSERT INTO demo_serial (valeur) VALUES ('E');  -- id = 5 (s√©quence incr√©ment√©e)
ROLLBACK;  -- Annulation de la transaction

-- La s√©quence N'EST PAS annul√©e
INSERT INTO demo_serial (valeur) VALUES ('F');  -- id = 6 (pas 5)
```

**R√©sultat :** Il peut y avoir des trous dans la num√©rotation. **C'est normal et acceptable.**

#### 3. On peut sp√©cifier manuellement l'ID

```sql
-- Ins√©rer avec un ID sp√©cifique
INSERT INTO demo_serial (id, valeur) VALUES (100, 'Manuel');

-- La s√©quence n'est PAS mise √† jour automatiquement !
INSERT INTO demo_serial (valeur) VALUES ('Auto');  -- Pourrait cr√©er un conflit

-- Il faut mettre √† jour la s√©quence manuellement
SELECT setval('demo_serial_id_seq', (SELECT MAX(id) FROM demo_serial));
```

### IDENTITY (Standard SQL)

PostgreSQL 10+ supporte le standard SQL `IDENTITY`, une alternative moderne √† `SERIAL` :

```sql
-- Syntaxe IDENTITY
CREATE TABLE produits (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    nom VARCHAR(200)
);

-- Ou avec BY DEFAULT (permet l'insertion manuelle)
CREATE TABLE produits2 (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nom VARCHAR(200)
);
```

#### Diff√©rences entre SERIAL et IDENTITY

| Aspect | SERIAL | IDENTITY |
|--------|--------|----------|
| Standard SQL | Non (sp√©cifique PostgreSQL) | Oui (SQL:2003) |
| Insertion manuelle | Toujours possible | `BY DEFAULT` : oui, `ALWAYS` : non |
| Portabilit√© | Faible | Meilleure |
| Recommandation | Historique, tr√®s utilis√© | **Pr√©f√©r√©** pour nouveau code |

**Exemple avec GENERATED ALWAYS :**

```sql
CREATE TABLE commandes (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    numero VARCHAR(50)
);

-- Insertion normale (OK)
INSERT INTO commandes (numero) VALUES ('CMD-001');  -- id = 1

-- Tentative d'insertion manuelle (ERREUR)
INSERT INTO commandes (id, numero) VALUES (100, 'CMD-002');
-- ERROR: cannot insert into column "id"

-- Pour forcer quand m√™me (rare)
INSERT INTO commandes (id, numero) OVERRIDING SYSTEM VALUE VALUES (100, 'CMD-002');
```

**Exemple avec GENERATED BY DEFAULT :**

```sql
CREATE TABLE articles (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    titre VARCHAR(300)
);

-- Insertion normale
INSERT INTO articles (titre) VALUES ('Article 1');  -- id = 1

-- Insertion manuelle (OK avec BY DEFAULT)
INSERT INTO articles (id, titre) VALUES (100, 'Article 100');

-- Prochaine insertion automatique
INSERT INTO articles (titre) VALUES ('Article 2');  -- id = 2 (pas 101 !)
```

---

## 3. Les Nombres D√©cimaux Pr√©cis (NUMERIC et DECIMAL)

### NUMERIC / DECIMAL (Exactitude Math√©matique)

Les types `NUMERIC` et `DECIMAL` sont **identiques** dans PostgreSQL. Ils stockent les nombres avec une **pr√©cision exacte**, sans erreur d'arrondi.

```sql
-- Syntaxe
NUMERIC(precision, scale)
DECIMAL(precision, scale)

-- O√π :
-- precision = nombre total de chiffres significatifs
-- scale = nombre de chiffres apr√®s la virgule
```

#### Exemples de D√©claration

```sql
-- NUMERIC(10, 2) : 10 chiffres au total, 2 apr√®s la virgule
-- Exemple de valeurs valides : 12345678.90, -1234567.89, 0.50

CREATE TABLE finances (
    id SERIAL PRIMARY KEY,
    montant NUMERIC(10, 2),  -- 99 999 999.99 max
    taux_interet NUMERIC(5, 4)  -- 9.9999 max
);

-- Exemples d'insertions
INSERT INTO finances (montant, taux_interet) VALUES (1500.50, 0.0475);
INSERT INTO finances (montant, taux_interet) VALUES (999999.99, 5.5000);
INSERT INTO finances (montant, taux_interet) VALUES (0.01, 0.0001);

SELECT * FROM finances;
```

#### Pr√©cision et Scale en D√©tail

```sql
-- NUMERIC(5, 2)
-- precision = 5 (total de chiffres)
-- scale = 2 (chiffres apr√®s la virgule)
-- Plage : -999.99 √† 999.99

CREATE TABLE test_numeric (
    valeur NUMERIC(5, 2)
);

-- Insertions valides
INSERT INTO test_numeric VALUES (123.45);   -- OK
INSERT INTO test_numeric VALUES (999.99);   -- OK (valeur max)
INSERT INTO test_numeric VALUES (-999.99);  -- OK
INSERT INTO test_numeric VALUES (0.01);     -- OK

-- Insertions invalides
INSERT INTO test_numeric VALUES (1234.56);  -- ERREUR : trop de chiffres avant la virgule
INSERT INTO test_numeric VALUES (123.456);  -- ERREUR : trop de chiffres apr√®s la virgule
-- ERROR: numeric field overflow
```

#### NUMERIC sans Pr√©cision

Si vous omettez la pr√©cision et le scale, PostgreSQL accepte n'importe quelle pr√©cision :

```sql
CREATE TABLE calculs_precis (
    id SERIAL PRIMARY KEY,
    resultat NUMERIC  -- Pr√©cision arbitraire !
);

-- Peut stocker des nombres tr√®s pr√©cis
INSERT INTO calculs_precis (resultat)
VALUES (123456789012345678901234567890.123456789);

SELECT * FROM calculs_precis;
```

**Attention :** Cela consomme plus d'espace disque. Sp√©cifiez une pr√©cision quand possible.

### Cas d'Usage de NUMERIC

#### 1. Montants Financiers (Le Plus Important)

```sql
-- TOUJOURS utiliser NUMERIC pour l'argent !
CREATE TABLE transactions (
    id SERIAL PRIMARY KEY,
    compte_source VARCHAR(50),
    compte_destination VARCHAR(50),
    montant NUMERIC(15, 2) NOT NULL CHECK (montant > 0),
    devise VARCHAR(3) DEFAULT 'EUR',
    date_transaction TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Insertion
INSERT INTO transactions (compte_source, compte_destination, montant, devise)
VALUES ('FR123', 'FR456', 1250.75, 'EUR');

-- Calculs financiers (sans erreur d'arrondi)
SELECT
    compte_source,
    SUM(montant) AS total_debite,
    AVG(montant) AS montant_moyen
FROM transactions
GROUP BY compte_source;
```

‚ùå **JAMAIS UTILISER FLOAT POUR L'ARGENT !**

```sql
-- MAUVAISE PRATIQUE
CREATE TABLE mauvais_exemple (
    montant FLOAT  -- NON ! Erreurs d'arrondi garanties
);

-- Probl√®me avec FLOAT
SELECT 0.1 + 0.2;  -- R√©sultat en FLOAT : 0.30000000000000004 (!)
SELECT 0.1::NUMERIC + 0.2::NUMERIC;  -- R√©sultat en NUMERIC : 0.3 (exact)
```

#### 2. Pourcentages et Taux

```sql
CREATE TABLE produits_promo (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    prix_original NUMERIC(10, 2),
    taux_remise NUMERIC(5, 2),  -- De 0.00 √† 100.00 (pourcentage)
    prix_final NUMERIC(10, 2) GENERATED ALWAYS AS (
        prix_original * (1 - taux_remise / 100)
    ) STORED
);

INSERT INTO produits_promo (nom, prix_original, taux_remise)
VALUES ('Laptop', 1200.00, 15.50);

SELECT
    nom,
    prix_original,
    taux_remise || '%' AS remise,
    prix_final
FROM produits_promo;
```

#### 3. Mesures Scientifiques Pr√©cises

```sql
CREATE TABLE mesures_laboratoire (
    id SERIAL PRIMARY KEY,
    echantillon VARCHAR(50),
    concentration NUMERIC(12, 8),  -- Tr√®s haute pr√©cision
    temperature NUMERIC(6, 3),
    ph NUMERIC(4, 2) CHECK (ph BETWEEN 0 AND 14)
);

INSERT INTO mesures_laboratoire (echantillon, concentration, temperature, ph)
VALUES ('ECH-001', 0.00000123, 23.456, 7.35);
```

### Op√©rations avec NUMERIC

```sql
-- Cr√©er une table de test
CREATE TABLE operations_numeric (
    a NUMERIC(10, 2),
    b NUMERIC(10, 2)
);

INSERT INTO operations_numeric VALUES (100.50, 25.25);

-- Addition et soustraction (pr√©cision pr√©serv√©e)
SELECT a + b AS addition, a - b AS soustraction
FROM operations_numeric;

-- Multiplication (pr√©cision augmente)
SELECT a * b AS multiplication
FROM operations_numeric;
-- R√©sultat : 2537.6250 (4 d√©cimales)

-- Division (pr√©cision configurable)
SELECT a / b AS division
FROM operations_numeric;
-- R√©sultat : 3.98019801980198... (tr√®s pr√©cis)

-- Arrondir le r√©sultat
SELECT ROUND(a / b, 2) AS division_arrondie
FROM operations_numeric;
-- R√©sultat : 3.98

-- Tronquer (enlever les d√©cimales sans arrondir)
SELECT TRUNC(a / b, 2) AS division_tronquee
FROM operations_numeric;
-- R√©sultat : 3.98

-- Plafond et plancher
SELECT CEIL(a / b) AS ceil, FLOOR(a / b) AS floor
FROM operations_numeric;
-- R√©sultat : ceil = 4, floor = 3
```

### Fonctions Utiles avec NUMERIC

```sql
-- ROUND : Arrondir
SELECT ROUND(123.456, 2);  -- 123.46
SELECT ROUND(123.456, 0);  -- 123
SELECT ROUND(123.456, -1); -- 120

-- TRUNC : Tronquer (pas d'arrondi)
SELECT TRUNC(123.456, 2);  -- 123.45
SELECT TRUNC(123.456, 0);  -- 123

-- CEIL : Arrondir vers le haut
SELECT CEIL(123.1);  -- 124
SELECT CEIL(-123.9); -- -123

-- FLOOR : Arrondir vers le bas
SELECT FLOOR(123.9);  -- 123
SELECT FLOOR(-123.1); -- -124

-- ABS : Valeur absolue
SELECT ABS(-123.45);  -- 123.45

-- SIGN : Signe (-1, 0, 1)
SELECT SIGN(123.45);  -- 1
SELECT SIGN(-123.45); -- -1
SELECT SIGN(0);       -- 0
```

---

## 4. Les Nombres √† Virgule Flottante (REAL et DOUBLE PRECISION)

### Types √† Virgule Flottante

Les types √† virgule flottante stockent des **approximations** de nombres r√©els. Ils sont bas√©s sur le standard IEEE 754.

```sql
-- REAL (simple pr√©cision)
REAL  -- ou FLOAT4
-- Stockage : 4 octets
-- Pr√©cision : 6 chiffres d√©cimaux

-- DOUBLE PRECISION (double pr√©cision)
DOUBLE PRECISION  -- ou FLOAT8 ou FLOAT
-- Stockage : 8 octets
-- Pr√©cision : 15 chiffres d√©cimaux
```

### Quand Utiliser les Flottants ?

‚úÖ **Utiliser FLOAT pour :**
- Calculs scientifiques o√π une approximation est acceptable
- Mesures physiques (temp√©rature, distance)
- Graphiques et visualisations
- Performances critiques avec grandes quantit√©s de donn√©es

‚ùå **NE JAMAIS utiliser FLOAT pour :**
- Montants financiers
- Tout calcul n√©cessitant une exactitude parfaite

### REAL (Simple Pr√©cision)

```sql
CREATE TABLE mesures_temperature (
    id SERIAL PRIMARY KEY,
    capteur VARCHAR(50),
    temperature REAL,  -- Suffisant pour une temp√©rature
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO mesures_temperature (capteur, temperature)
VALUES ('CAPTEUR-01', 23.456);

INSERT INTO mesures_temperature (capteur, temperature)
VALUES ('CAPTEUR-02', -15.789);

SELECT * FROM mesures_temperature;
```

### DOUBLE PRECISION (Double Pr√©cision)

```sql
CREATE TABLE coordonnees_gps (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    latitude DOUBLE PRECISION,  -- Pr√©cision importante pour GPS
    longitude DOUBLE PRECISION,
    altitude REAL  -- Moins critique
);

INSERT INTO coordonnees_gps (nom, latitude, longitude, altitude)
VALUES ('Tour Eiffel', 48.858844, 2.294351, 324.0);

INSERT INTO coordonnees_gps (nom, latitude, longitude, altitude)
VALUES ('Statue de la Libert√©', 40.689247, -74.044502, 93.0);

SELECT * FROM coordonnees_gps;
```

### Le Probl√®me des Erreurs d'Arrondi

Les nombres flottants ne peuvent pas repr√©senter exactement tous les nombres d√©cimaux :

```sql
-- D√©monstration du probl√®me
CREATE TABLE demo_float (
    id SERIAL PRIMARY KEY,
    valeur_float REAL,
    valeur_numeric NUMERIC(10, 2)
);

-- Ins√©rer la m√™me valeur dans les deux colonnes
INSERT INTO demo_float (valeur_float, valeur_numeric)
VALUES (0.1, 0.1);

-- Multiplier par 10
SELECT
    valeur_float * 10 AS resultat_float,
    valeur_numeric * 10 AS resultat_numeric
FROM demo_float;
-- Float : 1.0000001 (impr√©cis)
-- Numeric : 1.00 (exact)

-- Exemple classique
SELECT 0.1::REAL + 0.2::REAL;  -- 0.300000012 (!)
SELECT 0.1::NUMERIC + 0.2::NUMERIC;  -- 0.3 (exact)
```

### Valeurs Sp√©ciales

Les flottants supportent des valeurs sp√©ciales :

```sql
-- Infini positif
SELECT 'Infinity'::REAL;
SELECT 1.0 / 0.0;  -- Infinity

-- Infini n√©gatif
SELECT '-Infinity'::REAL;
SELECT -1.0 / 0.0;  -- -Infinity

-- Not a Number (pas un nombre)
SELECT 'NaN'::REAL;
SELECT 0.0 / 0.0;  -- NaN

-- Tester ces valeurs
SELECT
    'Infinity'::REAL > 999999999 AS inf_est_plus_grand,  -- true
    'NaN'::REAL = 'NaN'::REAL AS nan_egal_nan;  -- false (!)
```

### Fonctions Math√©matiques avec Flottants

PostgreSQL offre de nombreuses fonctions math√©matiques :

```sql
-- Fonctions trigonom√©triques (angles en radians)
SELECT
    SIN(PI() / 2) AS sinus_90_deg,  -- 1
    COS(PI()) AS cosinus_180_deg,   -- -1
    TAN(PI() / 4) AS tangente_45_deg; -- 1

-- Puissances et racines
SELECT
    POWER(2, 10) AS deux_puissance_10,  -- 1024
    SQRT(16) AS racine_16,              -- 4
    CBRT(27) AS racine_cubique_27;      -- 3

-- Exponentielles et logarithmes
SELECT
    EXP(1) AS e,                    -- 2.718...
    LN(2.718281828) AS ln_e,        -- 1
    LOG(100) AS log10_100;          -- 2

-- Arrondir
SELECT
    ROUND(3.14159::NUMERIC, 2) AS pi_arrondi;  -- 3.14
```

---

## Comparaison : NUMERIC vs FLOAT

Voici un tableau comparatif pour vous aider √† choisir :

| Aspect | NUMERIC / DECIMAL | REAL / DOUBLE PRECISION |
|--------|-------------------|-------------------------|
| **Exactitude** | Exacte (pas d'erreur d'arrondi) | Approximative |
| **Pr√©cision** | Arbitraire (d√©finie par vous) | Limit√©e (6 ou 15 chiffres) |
| **Performances** | Plus lent | Plus rapide |
| **Stockage** | Variable (plus d'espace) | Fixe (4 ou 8 octets) |
| **Argent** | ‚úÖ OUI (obligatoire) | ‚ùå NON (jamais) |
| **Calculs scientifiques** | Possible mais lent | ‚úÖ OUI (recommand√©) |
| **Valeurs sp√©ciales** | Non | Infinity, -Infinity, NaN |

### Exemple Comparatif

```sql
CREATE TABLE comparaison_types (
    id SERIAL PRIMARY KEY,
    description VARCHAR(100),
    valeur_numeric NUMERIC(15, 2),
    valeur_float DOUBLE PRECISION
);

-- Ins√©rer la m√™me valeur
INSERT INTO comparaison_types (description, valeur_numeric, valeur_float)
VALUES ('Test 1', 1234567.89, 1234567.89);

-- Calculs
SELECT
    description,
    valeur_numeric * 1.15 AS numeric_avec_tva,
    valeur_float * 1.15 AS float_avec_tva,
    (valeur_numeric * 1.15) = (valeur_float * 1.15) AS sont_egaux
FROM comparaison_types;
-- R√©sultat : sont_egaux = false (√† cause des erreurs d'arrondi en float)
```

---

## Conversions entre Types Num√©riques

### Cast Explicite

```sql
-- Conversion avec ::
SELECT
    123::SMALLINT AS small,
    123::INTEGER AS int,
    123::BIGINT AS big,
    123::NUMERIC(5,2) AS num,
    123::REAL AS real,
    123::DOUBLE PRECISION AS double;

-- Conversion avec CAST()
SELECT
    CAST(123.456 AS INTEGER) AS int_tronque,  -- 123
    CAST('123' AS INTEGER) AS text_to_int,    -- 123
    CAST(123 AS VARCHAR) AS int_to_text;      -- '123'
```

### Pr√©cautions lors des Conversions

```sql
-- Conversion qui tronque
SELECT 123.789::INTEGER;  -- 123 (d√©cimales perdues)

-- Conversion qui peut √©chouer
SELECT 50000::SMALLINT;  -- ERREUR : d√©passement de capacit√©

-- Conversion NUMERIC vers INTEGER (arrondit)
SELECT
    123.4::INTEGER AS arrondi_bas,   -- 123
    123.5::INTEGER AS arrondi_haut,  -- 124
    123.9::INTEGER AS arrondi;       -- 124

-- Conversion texte vers nombre
SELECT '123.45'::NUMERIC;  -- 123.45
SELECT '123abc'::INTEGER;  -- ERREUR : format invalide
```

---

## Bonnes Pratiques avec les Types Num√©riques

### 1. Choisir le Bon Type

```sql
-- ‚úÖ BON : Types appropri√©s
CREATE TABLE commandes (
    id SERIAL PRIMARY KEY,              -- Auto-increment standard
    numero_commande VARCHAR(50),
    quantite INTEGER,                   -- Entier simple
    prix_unitaire NUMERIC(10, 2),      -- Argent : NUMERIC !
    total NUMERIC(12, 2),              -- Argent : NUMERIC !
    taux_tva NUMERIC(4, 2),            -- Pourcentage
    poids_kg REAL                       -- Mesure physique : FLOAT OK
);

-- ‚ùå MAUVAIS : Types inadapt√©s
CREATE TABLE commandes_mal (
    id VARCHAR(50),                     -- ID en texte ? Non !
    quantite NUMERIC(10, 2),           -- Quantit√© avec d√©cimales ? Bizarre
    prix_unitaire REAL,                 -- Argent en FLOAT ? JAMAIS !
    total VARCHAR(20)                   -- Total en texte ? Non !
);
```

### 2. Toujours NUMERIC pour l'Argent

```sql
-- ‚úÖ CORRECT
CREATE TABLE factures (
    id SERIAL PRIMARY KEY,
    montant_ht NUMERIC(12, 2) NOT NULL,
    montant_tva NUMERIC(12, 2) NOT NULL,
    montant_ttc NUMERIC(12, 2) NOT NULL,
    CHECK (montant_ttc = montant_ht + montant_tva)
);

-- ‚ùå INCORRECT
CREATE TABLE factures_mal (
    montant FLOAT  -- NON ! Erreurs d'arrondi sur l'argent
);
```

### 3. Sp√©cifier la Pr√©cision

```sql
-- ‚úÖ BON : Pr√©cision d√©finie
CREATE TABLE produits (
    prix NUMERIC(10, 2),  -- Max 99 999 999.99
    poids NUMERIC(8, 3)   -- Max 99 999.999 kg
);

-- ‚ùì ACCEPTABLE mais moins optimal
CREATE TABLE produits_vague (
    prix NUMERIC,  -- Pr√©cision arbitraire (plus lourd)
    poids NUMERIC
);
```

### 4. Attention aux D√©passements

```sql
-- Utiliser CHECK pour les limites
CREATE TABLE stock (
    id SERIAL PRIMARY KEY,
    quantite INTEGER CHECK (quantite >= 0 AND quantite <= 100000)
);

-- Ou choisir le type appropri√©
CREATE TABLE stock_petit (
    quantite SMALLINT CHECK (quantite >= 0)  -- Si quantit√© < 32K toujours
);
```

### 5. Documenter les Unit√©s

```sql
-- Nommer explicitement avec l'unit√©
CREATE TABLE mesures (
    temperature_celsius REAL,
    distance_metres NUMERIC(10, 2),
    poids_kg NUMERIC(8, 3),
    prix_euros NUMERIC(10, 2)
);

-- Ou utiliser des commentaires
CREATE TABLE produits (
    poids NUMERIC(8, 3)  -- en kilogrammes
);

COMMENT ON COLUMN produits.poids IS 'Poids du produit en kilogrammes';
```

---

## R√©capitulatif

### Tableau de D√©cision Rapide

| Besoin | Type Recommand√© | Exemple |
|--------|----------------|---------|
| ID auto-incr√©ment√© (table normale) | `SERIAL` | `id SERIAL PRIMARY KEY` |
| ID auto-incr√©ment√© (grande table) | `BIGSERIAL` | `id BIGSERIAL PRIMARY KEY` |
| Quantit√©, compteur | `INTEGER` | `quantite INTEGER` |
| √Çge, note | `SMALLINT` | `age SMALLINT` |
| **Prix, argent** | `NUMERIC(p, 2)` | `prix NUMERIC(10, 2)` |
| Pourcentage | `NUMERIC(5, 2)` | `taux NUMERIC(5, 2)` |
| Mesure physique approximative | `REAL` | `temperature REAL` |
| Coordonn√©es GPS | `DOUBLE PRECISION` | `latitude DOUBLE PRECISION` |
| Calculs scientifiques | `DOUBLE PRECISION` | `resultat DOUBLE PRECISION` |

### Commandes SQL Utiles

```sql
-- Voir le type d'une colonne
\d nom_table

-- Conversion de type
SELECT valeur::nouveau_type FROM table;
SELECT CAST(valeur AS nouveau_type) FROM table;

-- Arrondir NUMERIC
SELECT ROUND(valeur, 2) FROM table;

-- V√©rifier le type d'une expression
SELECT pg_typeof(123);        -- integer
SELECT pg_typeof(123.45);     -- numeric
SELECT pg_typeof(123.45::REAL); -- real
```

---

## Conclusion

Les types num√©riques PostgreSQL offrent une grande flexibilit√© pour stocker diff√©rents types de nombres :

- **INTEGER** : Le choix par d√©faut pour les entiers
- **SERIAL** : Pour les identifiants auto-incr√©ment√©s
- **NUMERIC** : **Obligatoire** pour l'argent et les calculs pr√©cis
- **FLOAT** : Pour les mesures physiques et calculs scientifiques

**R√®gle d'or :**
> Utilisez **NUMERIC pour l'argent**, **INTEGER pour les compteurs**, et **FLOAT seulement** pour les calculs scientifiques o√π l'approximation est acceptable.

Dans la prochaine section, nous explorerons les types de donn√©es textuels (VARCHAR, TEXT, CHAR) qui sont tout aussi essentiels pour stocker des informations.

---


‚è≠Ô∏è [Texte (VARCHAR, TEXT, CHAR)](/04-objets-de-la-base-de-donnees/04.2-types-texte.md)
