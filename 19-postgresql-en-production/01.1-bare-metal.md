üîù Retour au [Sommaire](/SOMMAIRE.md)

# 19.1.1. Bare Metal : Configuration Optimale

## Introduction au D√©ploiement Bare Metal

### Qu'est-ce que le Bare Metal ?

Le terme **"Bare Metal"** (litt√©ralement "m√©tal nu") d√©signe l'installation de PostgreSQL directement sur un serveur physique, sans couche de virtualisation interm√©diaire. C'est la m√©thode de d√©ploiement la plus traditionnelle et la plus proche du mat√©riel.

**Analogie simple :** Imaginez que vous poss√©dez une voiture. Le d√©ploiement bare metal, c'est conduire votre propre voiture (contr√¥le total), alors que la virtualisation reviendrait √† louer une voiture ou utiliser un taxi (moins de contr√¥le, mais plus de flexibilit√©).

### Comparaison des M√©thodes de D√©ploiement

| Crit√®re | Bare Metal | VM | Conteneurs | Cloud Manag√© |
|---------|-----------|-----|-----------|--------------|
| **Performance** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Maximale | ‚≠ê‚≠ê‚≠ê‚≠ê Tr√®s bonne | ‚≠ê‚≠ê‚≠ê‚≠ê Tr√®s bonne | ‚≠ê‚≠ê‚≠ê Variable |
| **Contr√¥le** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Total | ‚≠ê‚≠ê‚≠ê‚≠ê √âlev√© | ‚≠ê‚≠ê‚≠ê Moyen | ‚≠ê‚≠ê Limit√© |
| **Co√ªt initial** | ‚≠ê √âlev√© | ‚≠ê‚≠ê‚≠ê Moyen | ‚≠ê‚≠ê‚≠ê‚≠ê Faible | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Tr√®s faible |
| **Scalabilit√©** | ‚≠ê‚≠ê Limit√©e | ‚≠ê‚≠ê‚≠ê‚≠ê Bonne | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellente | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellente |
| **Maintenance** | ‚≠ê‚≠ê Exigeante | ‚≠ê‚≠ê‚≠ê Moyenne | ‚≠ê‚≠ê‚≠ê‚≠ê Facilit√©e | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Minimale |

### Quand Choisir un D√©ploiement Bare Metal ?

**Situations id√©ales pour le bare metal :**

1. **Charges critiques √† haute performance**
   - Applications financi√®res n√©cessitant une latence minimale
   - Syst√®mes transactionnels √† tr√®s haut d√©bit (>10 000 transactions/seconde)
   - Bases de donn√©es volumineuses (plusieurs t√©raoctets)

2. **Besoins de contr√¥le total**
   - Optimisation fine du mat√©riel et du syst√®me
   - Configurations r√©seau complexes
   - Respect de r√©glementations strictes (donn√©es sensibles, souverainet√©)

3. **Pr√©visibilit√© des ressources**
   - Charges de travail stables et pr√©visibles
   - Budget op√©rationnel ma√Ætris√© sur le long terme
   - Absence de besoin d'√©lasticit√© rapide

4. **Contraintes de conformit√©**
   - Interdiction de cloud public (secteur bancaire, sant√©, d√©fense)
   - N√©cessit√© de conserver les donn√©es physiquement sur site
   - Certifications sp√©cifiques (ISO 27001, HDS, PCI-DSS)

**Quand √©viter le bare metal :**
- Startup en phase de croissance rapide
- Charges de travail tr√®s variables
- √âquipe technique limit√©e
- Budget d'investissement initial restreint

---

## Architecture Mat√©rielle Optimale

### Processeur (CPU)

**Recommandations g√©n√©rales :**

PostgreSQL b√©n√©ficie d'une architecture multi-c≈ìurs pour g√©rer plusieurs connexions simultan√©es. Cependant, chaque requ√™te individuelle n'utilise g√©n√©ralement qu'un seul c≈ìur (sauf op√©rations parall√©lis√©es).

**Configuration id√©ale selon le cas d'usage :**

#### Pour OLTP (Transactionnel - Haute Concurrence)
- **CPU recommand√© :** 16 √† 32 c≈ìurs physiques
- **Fr√©quence :** Privil√©gier la fr√©quence √©lev√©e (3.0+ GHz)
- **Architecture :** Intel Xeon Gold ou AMD EPYC
- **Exemple :** Intel Xeon Gold 6348 (28 c≈ìurs @ 2.6 GHz, boost 3.5 GHz)

**Pourquoi ?** De nombreuses petites requ√™tes simultan√©es n√©cessitent beaucoup de c≈ìurs. La fr√©quence haute acc√©l√®re chaque requ√™te individuelle.

#### Pour OLAP (Analytique - Requ√™tes Lourdes)
- **CPU recommand√© :** 32 √† 64 c≈ìurs physiques
- **Fr√©quence :** Acceptable √† 2.5+ GHz
- **Architecture :** AMD EPYC (meilleur rapport c≈ìurs/prix)
- **Exemple :** AMD EPYC 7543 (32 c≈ìurs @ 2.8 GHz)

**Pourquoi ?** Les requ√™tes analytiques peuvent √™tre parall√©lis√©es (PostgreSQL 18 am√©liore cette capacit√©). Plus de c≈ìurs = plus de parall√©lisme.

#### Pour Usage Mixte
- **CPU recommand√© :** 24 √† 48 c≈ìurs physiques
- **Fr√©quence :** 2.8+ GHz
- **√âquilibre :** Intel Xeon Platinum ou AMD EPYC

**Point technique important :** D√©sactiver l'Hyper-Threading peut parfois am√©liorer les performances PostgreSQL, car il pr√©f√®re les c≈ìurs physiques aux threads logiques.

---

### M√©moire (RAM)

La RAM est **cruciale** pour PostgreSQL. Plus vous en avez, meilleures seront vos performances, car PostgreSQL garde en m√©moire :
- Les donn√©es fr√©quemment consult√©es (shared_buffers)
- Les r√©sultats interm√©diaires de requ√™tes (work_mem)
- Les index
- Les statistiques du planificateur

#### R√®gle de Dimensionnement

**Formule de base :**
```
RAM totale = Taille de la base de donn√©es active √ó 0.25 + Overhead PostgreSQL + Overhead OS
```

**Exemple concret :**
- Base de donn√©es : 400 GB
- Donn√©es "chaudes" (fr√©quemment consult√©es) : ~100 GB
- RAM recommand√©e : 64 √† 128 GB

#### Configuration Minimale et Id√©ale

| Usage | RAM Minimale | RAM Id√©ale | Justification |
|-------|-------------|-----------|---------------|
| D√©veloppement/Test | 8 GB | 16 GB | Donn√©es limit√©es |
| OLTP L√©ger | 16 GB | 32 GB | Nombreuses connexions |
| OLTP Production | 64 GB | 128 GB | Hot dataset en m√©moire |
| OLAP/Data Warehouse | 128 GB | 256+ GB | Requ√™tes complexes gourmandes |
| Mixte Haute Performance | 128 GB | 512+ GB | Tout en m√©moire id√©alement |

**Type de RAM :** Privil√©gier ECC (Error-Correcting Code) pour la fiabilit√© en production. La RAM ECC d√©tecte et corrige automatiquement les erreurs de m√©moire.

**Vitesse :** DDR4-3200 MHz minimum, DDR5 si disponible. L'impact de la fr√©quence m√©moire est mod√©r√© mais non n√©gligeable.

---

### Stockage (Disques)

Le stockage est souvent le **goulot d'√©tranglement** principal de PostgreSQL. Les performances I/O (Input/Output) conditionnent directement les temps de r√©ponse.

#### Technologies de Stockage

##### 1. NVMe SSD (Recommand√©)
- **Performance :** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellente
- **Latence :** < 100 ¬µs (microsecondes)
- **IOPS :** 500 000 √† 1 000 000+ en lecture al√©atoire
- **Bande passante :** 3 000 √† 7 000 MB/s
- **Usage :** Production haute performance, OLTP exigeant
- **Exemples :** Samsung PM9A3, Intel P5800X, Micron 7450

**Avantage PostgreSQL 18 :** Le nouveau sous-syst√®me I/O asynchrone (AIO) exploite pleinement les NVMe pour des gains jusqu'√† 3√ó sur certaines charges.

##### 2. SATA SSD
- **Performance :** ‚≠ê‚≠ê‚≠ê‚≠ê Bonne
- **Latence :** < 500 ¬µs
- **IOPS :** 50 000 √† 100 000
- **Bande passante :** 500 √† 600 MB/s
- **Usage :** Production standard, petit budget
- **Exemples :** Samsung 870 EVO, Crucial MX500

##### 3. HDD (√Ä √âviter pour PostgreSQL)
- **Performance :** ‚≠ê‚≠ê M√©diocre
- **Latence :** 5 √† 10 ms (millisecondes !)
- **IOPS :** 100 √† 200 seulement
- **Usage :** Archivage, sauvegardes uniquement
- **Pourquoi √©viter ?** PostgreSQL g√©n√®re beaucoup d'I/O al√©atoires, domaine o√π les HDD sont catastrophiques.

#### Architecture de Stockage

**Configuration recommand√©e en production :**

```
Serveur PostgreSQL (Bare Metal)
‚îú‚îÄ‚îÄ Disque 1 (NVMe) : Syst√®me d'exploitation (OS)
‚îÇ   ‚îî‚îÄ‚îÄ 100-200 GB
‚îú‚îÄ‚îÄ Disques 2-3 (NVMe en RAID 1) : Donn√©es PostgreSQL (PGDATA)
‚îÇ   ‚îî‚îÄ‚îÄ Selon volume de donn√©es
‚îú‚îÄ‚îÄ Disques 4-5 (NVMe en RAID 1) : WAL (Write-Ahead Log)
‚îÇ   ‚îî‚îÄ‚îÄ 50-100 GB minimum
‚îî‚îÄ‚îÄ Disques 6-N (SATA/HDD) : Sauvegardes et archives
    ‚îî‚îÄ‚îÄ 2-3√ó taille des donn√©es
```

**S√©paration des WAL :** Placer les WAL sur des disques d√©di√©s r√©duit la contention I/O et am√©liore les performances transactionnelles.

#### RAID : Quel Niveau Choisir ?

| RAID | Redondance | Performance Lecture | Performance √âcriture | Usage PostgreSQL |
|------|-----------|---------------------|---------------------|------------------|
| **RAID 0** | ‚ùå Aucune | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚ö†Ô∏è D√©veloppement uniquement |
| **RAID 1** | ‚úÖ Mirroring | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚úÖ WAL, petites bases |
| **RAID 5** | ‚úÖ Parit√© | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚ö†Ô∏è D√©conseill√© (√©critures lentes) |
| **RAID 10** | ‚úÖ Stripe+Mirror | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚úÖ **Recommand√© pour PGDATA** |
| **RAID 6** | ‚úÖ Double parit√© | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | üîß Archives, sauvegardes |

**Configuration id√©ale en production :**
- **PGDATA :** RAID 10 (4 √† 8 disques NVMe)
- **WAL :** RAID 1 (2 disques NVMe d√©di√©s)
- **Sauvegardes :** RAID 6 ou pas de RAID (backups multiples)

**Contr√¥leur RAID :** Privil√©gier un contr√¥leur mat√©riel avec cache BBU (Battery Backup Unit) de 2 √† 4 GB pour s√©curiser les √©critures en cas de coupure.

---

### R√©seau

#### Configuration R√©seau de Base

- **Carte r√©seau :** 10 GbE minimum (25 GbE ou 40 GbE pour haute performance)
- **Connectivit√© :** Redondance r√©seau (bonding/teaming) pour la haute disponibilit√©
- **Latence :** < 1 ms sur le r√©seau local (LAN)

#### Bonnes Pratiques R√©seau

1. **S√©paration des r√©seaux :**
   ```
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ  Serveur PostgreSQL Bare Metal  ‚îÇ
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
   ‚îÇ eth0: R√©seau de production      ‚îÇ ‚Üí Connexions clients
   ‚îÇ eth1: R√©seau de r√©plication     ‚îÇ ‚Üí Streaming vers standby
   ‚îÇ eth2: R√©seau de sauvegarde      ‚îÇ ‚Üí Transferts pg_basebackup
   ‚îÇ eth3: R√©seau d'administration   ‚îÇ ‚Üí SSH, monitoring
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
   ```

2. **Jumbo Frames :** Activer les trames de 9000 bytes (MTU) pour am√©liorer le d√©bit r√©seau sur connexions 10 GbE+

3. **TCP Tuning :** Ajustement des param√®tres kernel pour PostgreSQL (voir section OS)

---

## Configuration du Syst√®me d'Exploitation

### Choix de l'OS

**Distributions Linux recommand√©es :**

1. **Ubuntu Server LTS** (22.04 ou 24.04)
   - ‚úÖ Support officiel PostgreSQL excellent
   - ‚úÖ Documentation abondante
   - ‚úÖ Packages maintenus par PGDG (PostgreSQL Global Development Group)
   - üéØ **Recommand√© pour d√©butants**

2. **Rocky Linux / AlmaLinux** (successeurs de CentOS)
   - ‚úÖ Stabilit√© enterprise
   - ‚úÖ Cycle de vie long (10 ans)
   - üéØ **Recommand√© pour production conservatrice**

3. **Debian**
   - ‚úÖ Tr√®s stable
   - ‚úÖ L√©ger en ressources
   - üéØ **Recommand√© pour experts**

4. **Red Hat Enterprise Linux (RHEL)**
   - ‚úÖ Support commercial
   - ‚úÖ Certifications
   - üí∞ Payant

**√Ä √©viter en production :** Distributions non-LTS, rolling release (Arch, Fedora), ou exp√©rimentales.

---

### Optimisations Kernel Linux

#### 1. Param√®tres de M√©moire Virtuelle

Cr√©er le fichier `/etc/sysctl.d/99-postgresql.conf` :

```bash
# Gestion de la m√©moire partag√©e
# Permet √† PostgreSQL d'allouer de grands segments de m√©moire partag√©e
kernel.shmmax = 68719476736  # 64 GB (ajuster selon RAM)
kernel.shmall = 4294967296   # Pages m√©moire

# Swappiness : √©viter le swap au maximum
# Valeur 0-100, plus c'est bas, moins le kernel utilise le swap
vm.swappiness = 1

# Dirty pages : contr√¥le de l'√©criture sur disque
# Pourcentage de RAM avant flush forc√©
vm.dirty_ratio = 10
vm.dirty_background_ratio = 3

# √âviter l'OOM Killer de tuer PostgreSQL
vm.overcommit_memory = 2
vm.overcommit_ratio = 80
```

**Explications pour d√©butants :**

- **M√©moire partag√©e (shmmax/shmall) :** PostgreSQL utilise de la m√©moire partag√©e entre tous ses processus. Il faut autoriser le syst√®me √† allouer suffisamment.

- **Swappiness :** Le "swap" est l'utilisation du disque comme extension de la RAM. C'est TR√àS lent. On configure le syst√®me pour √©viter au maximum de "swapper".

- **Dirty pages :** Les donn√©es modifi√©es en RAM (pages "sales") doivent √™tre √©crites sur disque. On contr√¥le quand et comment ces √©critures se produisent pour √©viter des pics d'I/O soudains.

- **Overcommit :** Linux peut promettre plus de m√©moire qu'il n'en a (overcommit). Si la RAM est satur√©e, le syst√®me peut tuer des processus (OOM Killer). On configure pour prot√©ger PostgreSQL.

#### 2. Param√®tres R√©seau

Ajouter au m√™me fichier `/etc/sysctl.d/99-postgresql.conf` :

```bash
# Buffer TCP/IP pour connexions nombreuses
net.core.rmem_default = 262144
net.core.rmem_max = 4194304
net.core.wmem_default = 262144
net.core.wmem_max = 4194304

# Backlog de connexions
net.core.somaxconn = 4096
net.ipv4.tcp_max_syn_backlog = 4096

# R√©utilisation rapide des sockets TIME_WAIT
net.ipv4.tcp_tw_reuse = 1

# Keepalive TCP (d√©tection rapide de connexions mortes)
net.ipv4.tcp_keepalive_time = 200
net.ipv4.tcp_keepalive_intvl = 20
net.ipv4.tcp_keepalive_probes = 3
```

**Appliquer les changements :**
```bash
sudo sysctl -p /etc/sysctl.d/99-postgresql.conf
```

#### 3. Limites de Ressources

Modifier `/etc/security/limits.d/postgresql.conf` :

```bash
# Utilisateur PostgreSQL
postgres soft nofile 65536    # Descripteurs de fichiers
postgres hard nofile 65536
postgres soft nproc  65536    # Nombre de processus
postgres hard nproc  65536
postgres soft memlock unlimited  # M√©moire verrouill√©e
postgres hard memlock unlimited
```

**Pourquoi ?** PostgreSQL peut g√©rer des milliers de connexions, chacune n√©cessitant des descripteurs de fichiers (connexions r√©seau, fichiers ouverts).

---

### Filesystem et Options de Montage

#### Choix du Syst√®me de Fichiers

| Filesystem | Performance | Fiabilit√© | Recommandation |
|-----------|-------------|-----------|----------------|
| **ext4** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚úÖ **Recommand√©** (d√©faut, √©prouv√©) |
| **XFS** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚úÖ **Excellent** (gros volumes) |
| **btrfs** | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚ö†Ô∏è Mature mais moins test√© |
| **ZFS** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | üîß Complexe (n√©cessite expertise) |

**Recommandation g√©n√©rale :** **ext4** pour d√©buter, **XFS** si vous avez de tr√®s gros volumes (>10 TB).

#### Options de Montage Optimales

Fichier `/etc/fstab` pour la partition PostgreSQL :

```bash
# Partition PGDATA (exemple avec /dev/sda2 mont√© sur /var/lib/postgresql)
UUID=xxx  /var/lib/postgresql  ext4  noatime,nodiratime,nobarrier  0  2

# Partition WAL (si s√©par√©e)
UUID=yyy  /var/lib/postgresql/18/main/pg_wal  ext4  noatime,nodiratime,nobarrier  0  2
```

**Explications des options :**

- **noatime :** Ne met pas √† jour l'heure du dernier acc√®s aux fichiers. √âconomise des √©critures inutiles.
- **nodiratime :** M√™me principe pour les r√©pertoires.
- **nobarrier :** D√©sactive les barri√®res d'√©criture (‚ö†Ô∏è uniquement si batterie BBU sur contr√¥leur RAID ou UPS).

**‚ö†Ô∏è Attention :** `nobarrier` am√©liore les performances mais risque de corruption en cas de coupure √©lectrique soudaine. N'utiliser que si infrastructure √©lectrique fiable (UPS + BBU).

---

## Configuration PostgreSQL pour Bare Metal

### Param√®tres de Base (postgresql.conf)

Emplacement : `/etc/postgresql/18/main/postgresql.conf` (Ubuntu) ou `/var/lib/postgresql/18/data/postgresql.conf`

#### 1. M√©moire et Connexions

```ini
# =====================================
# CONNEXIONS
# =====================================
max_connections = 200
# D√©butant : 100-200 connexions pour OLTP typique
# Avanc√© : Utiliser PgBouncer pour pooling, limiter √† 100-150 ici

# =====================================
# M√âMOIRE
# =====================================

# Shared Buffers : Cache principal de PostgreSQL
# R√®gle : 25% de la RAM totale (max 40%)
shared_buffers = 32GB  # Pour 128 GB RAM
# Explication : PostgreSQL garde les donn√©es fr√©quentes ici

# Work Memory : M√©moire par op√©ration de tri/hash
# R√®gle : (RAM totale √ó 0.25) / max_connections
work_mem = 64MB  # Pour 128 GB RAM et 200 connexions
# Explication : Chaque tri, hash join utilise cette m√©moire
# ‚ö†Ô∏è Trop √©lev√© = risque OOM avec beaucoup de connexions

# Maintenance Work Memory : Pour VACUUM, CREATE INDEX, etc.
# R√®gle : 5-10% de la RAM, jusqu'√† 2 GB
maintenance_work_mem = 2GB
# Explication : Acc√©l√®re les op√©rations de maintenance

# Effective Cache Size : Informe le planificateur de la RAM disponible
# R√®gle : 50-75% de la RAM totale
effective_cache_size = 96GB  # Pour 128 GB RAM
# Explication : Pas une allocation, juste une indication pour le planificateur
```

#### 2. Write-Ahead Log (WAL)

```ini
# =====================================
# WAL (Write-Ahead Log)
# =====================================

# Niveau de journalisation
wal_level = replica
# Options : minimal, replica, logical
# 'replica' permet la r√©plication streaming

# Taille maximale du WAL
max_wal_size = 16GB  # Augmenter pour r√©duire les checkpoints
min_wal_size = 4GB

# Compression WAL (PostgreSQL 18+)
wal_compression = zstd  # Nouveau : zstd plus performant que lz4
# R√©duit l'espace disque et am√©liore les performances I/O

# Slots de r√©plication (si r√©plication pr√©vue)
max_wal_senders = 5
max_replication_slots = 5
```

#### 3. Checkpoints (Points de Coh√©rence)

```ini
# =====================================
# CHECKPOINTS
# =====================================

# D√©lai maximum entre checkpoints
checkpoint_timeout = 15min  # D√©faut : 5min (trop court)
# Augmenter r√©duit les I/O mais rallong le crash recovery

# Ratio de compl√©tion
checkpoint_completion_target = 0.9
# √âtale les √©critures sur 90% de l'intervalle checkpoint

# Avertissement si checkpoints trop fr√©quents
checkpoint_warning = 60s
# Log un warning si checkpoints < 60s (signe de sous-dimensionnement)
```

#### 4. I/O Asynchrone (PostgreSQL 18)

```ini
# =====================================
# I/O ASYNCHRONE (PostgreSQL 18)
# =====================================

# M√©thode I/O : 'sync' (d√©faut) ou 'async' (nouveau)
io_method = 'async'
# 'async' exploite io_uring (Linux) ou I/O completion ports (Windows)
# Gain : jusqu'√† 3√ó de performance sur NVMe

# Workers I/O asynchrones
io_async_workers = 16
# R√®gle : Nombre de c≈ìurs CPU / 2

# Profondeur de file I/O
io_async_queue_depth = 256
# Pour NVMe, 256-512 optimal
```

**Note pour d√©butants :** L'I/O asynchrone est une nouveaut√© majeure de PostgreSQL 18. Elle permet de lancer plusieurs op√©rations disque en parall√®le au lieu de les faire s√©quentiellement. C'est une r√©volution de performance sur mat√©riel moderne.

#### 5. Parall√©lisation des Requ√™tes

```ini
# =====================================
# PARALL√âLISATION
# =====================================

# Nombre de workers parall√®les par requ√™te
max_parallel_workers_per_gather = 4
# D√©pend du type de charge (OLAP : 8-16, OLTP : 2-4)

# Nombre total de workers parall√®les
max_parallel_workers = 16
# R√®gle : Nombre de c≈ìurs CPU / 2

# Workers pour maintenance
max_parallel_maintenance_workers = 4
# Pour CREATE INDEX, VACUUM parall√©lis√©s
```

#### 6. Autovacuum (PostgreSQL 18)

```ini
# =====================================
# AUTOVACUUM (PostgreSQL 18 am√©liore)
# =====================================

autovacuum = on  # Toujours activ√© !

# Workers autovacuum (PostgreSQL 18 am√©liore dynamiquement)
autovacuum_max_workers = 6
# Nouveaut√© PG 18 : ajustement dynamique possible

# Seuil maximum (nouveau dans PG 18)
autovacuum_vacuum_max_threshold = 10000000
# Emp√™che les VACUUM trop massifs d'une traite

# Co√ªt et d√©lai
autovacuum_vacuum_cost_delay = 2ms  # Ralentir pour √©viter impact I/O
autovacuum_vacuum_cost_limit = 800  # Budget "co√ªt" par round
```

#### 7. Logging et Monitoring

```ini
# =====================================
# LOGGING
# =====================================

# Destination des logs
logging_collector = on
log_directory = '/var/log/postgresql'
log_filename = 'postgresql-%Y-%m-%d.log'
log_rotation_age = 1d
log_rotation_size = 100MB

# Contenu des logs
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
log_timezone = 'UTC'

# Requ√™tes lentes
log_min_duration_statement = 1000  # Log requ√™tes > 1s
log_statement = 'ddl'  # Log toutes les DDL (CREATE, DROP, etc.)

# Checkpoints et verrous
log_checkpoints = on
log_lock_waits = on  # Log attentes de verrous > deadlock_timeout
deadlock_timeout = 1s

# Auto-explain (extension √† activer)
shared_preload_libraries = 'pg_stat_statements,auto_explain'
auto_explain.log_min_duration = 5000  # EXPLAIN AUTO des requ√™tes > 5s
auto_explain.log_analyze = on
auto_explain.log_buffers = on
```

#### 8. S√©curit√© de Base

```ini
# =====================================
# S√âCURIT√â
# =====================================

# √âcoute r√©seau
listen_addresses = '0.0.0.0'  # Toutes interfaces (s√©curiser via firewall)
# Production : IP sp√©cifique, ex: '10.0.1.50'

port = 5432

# SSL/TLS
ssl = on
ssl_cert_file = '/etc/postgresql/18/main/server.crt'
ssl_key_file = '/etc/postgresql/18/main/server.key'
ssl_ciphers = 'HIGH:MEDIUM:+3DES:!aNULL'
ssl_prefer_server_ciphers = on

# PostgreSQL 18 : Configuration TLS 1.3
ssl_min_protocol_version = 'TLSv1.2'
ssl_tls13_ciphers = 'TLS_AES_256_GCM_SHA384:TLS_AES_128_GCM_SHA256'

# Data Checksums (PG 18 : activ√© par d√©faut √† l'initdb)
# D√©tection de corruption de donn√©es
data_checksums = on
```

---

## S√©curit√© et Durcissement (Hardening)

### Configuration pg_hba.conf

Fichier : `/etc/postgresql/18/main/pg_hba.conf`

**Exemple de configuration s√©curis√©e :**

```conf
# TYPE  DATABASE   USER          ADDRESS           METHOD

# Connexion locale (socket Unix)
local   all        postgres                        peer

# Connexion localhost (boucle locale)
host    all        all           127.0.0.1/32      scram-sha-256
host    all        all           ::1/128           scram-sha-256

# R√©seau interne (adapter selon votre r√©seau)
host    all        all           10.0.0.0/8        scram-sha-256

# R√©plication (depuis serveur standby)
host    replication   replicator    10.0.1.51/32      scram-sha-256

# Refuser tout le reste
host    all        all           0.0.0.0/0         reject
```

**Explications pour d√©butants :**

- **TYPE :** `local` (socket Unix), `host` (TCP/IP), `hostssl` (SSL obligatoire)
- **DATABASE :** Nom de la base ou `all`
- **USER :** Utilisateur PostgreSQL ou `all`
- **ADDRESS :** Adresse IP/r√©seau autoris√©
- **METHOD :** Mode d'authentification
  - `trust` : aucun mot de passe (‚ö†Ô∏è JAMAIS en production)
  - `scram-sha-256` : hash s√©curis√© (recommand√©)
  - `md5` : obsol√®te (d√©pr√©ci√© en PG 18)
  - `cert` : certificat client SSL

**Nouveaut√© PostgreSQL 18 :** Support OAuth 2.0 pour authentification moderne (int√©gration SSO).

### Pare-feu (Firewall)

**UFW (Ubuntu) :**

```bash
# Autoriser SSH
sudo ufw allow 22/tcp

# Autoriser PostgreSQL uniquement depuis r√©seau interne
sudo ufw allow from 10.0.0.0/8 to any port 5432

# Activer le firewall
sudo ufw enable
```

**FirewallD (Rocky/RHEL) :**

```bash
# Zone interne
sudo firewall-cmd --permanent --zone=internal --add-source=10.0.0.0/8
sudo firewall-cmd --permanent --zone=internal --add-service=postgresql
sudo firewall-cmd --reload
```

### Mises √† Jour de S√©curit√©

**Principe :** Appliquer les patches de s√©curit√© r√©guli√®rement, mais de mani√®re contr√¥l√©e.

**Proc√©dure recommand√©e :**

1. **Surveiller les CVE :** S'abonner √† la liste de diffusion PostgreSQL security
2. **Tester en pr√©-production :** Ne jamais patcher directement en production
3. **Fen√™tre de maintenance :** Planifier les mises √† jour
4. **Sauvegarde pr√©alable :** Toujours sauvegarder avant toute intervention

**Mise √† jour mineure (ex: 18.1 ‚Üí 18.2) :**

```bash
# Sauvegarde
sudo -u postgres pg_dump -Fc dbname > /backup/dbname_before_update.dump

# Mise √† jour des paquets
sudo apt update && sudo apt upgrade postgresql-18

# Red√©marrage (downtime < 1 minute g√©n√©ralement)
sudo systemctl restart postgresql
```

---

## Monitoring et Observabilit√©

### M√©triques Vitales √† Surveiller

#### 1. Sant√© Syst√®me

**CPU :**
```bash
# Charge moyenne
uptime
# Target : load average < nombre de c≈ìurs

# Utilisation par processus
top -u postgres
```

**M√©moire :**
```bash
# Utilisation globale
free -h

# √âviter le swap !
vmstat 1
# si > si/so > 0 : probl√®me de swap
```

**Disque :**
```bash
# Utilisation espace
df -h /var/lib/postgresql

# I/O en temps r√©el
iostat -x 1
# Surveiller : %util (< 80%), await (< 10ms pour SSD)
```

#### 2. M√©triques PostgreSQL

**Connexions actives :**
```sql
SELECT count(*) FROM pg_stat_activity WHERE state = 'active';
-- Target : < 80% de max_connections
```

**Cache hit ratio (doit √™tre > 99%) :**
```sql
SELECT
  sum(heap_blks_hit) / nullif(sum(heap_blks_hit) + sum(heap_blks_read), 0) * 100 AS cache_hit_ratio
FROM pg_statio_user_tables;
```

**Taille des bases :**
```sql
SELECT
  datname,
  pg_size_pretty(pg_database_size(datname)) AS size
FROM pg_database
ORDER BY pg_database_size(datname) DESC;
```

**Tables les plus volumineuses :**
```sql
SELECT
  schemaname || '.' || tablename AS table_fullname,
  pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
LIMIT 10;
```

### Installation de pg_stat_statements

**Extension indispensable** pour identifier les requ√™tes lentes.

```sql
-- En tant que superuser
CREATE EXTENSION pg_stat_statements;

-- Top 10 requ√™tes les plus lentes
SELECT
  query,
  calls,
  total_exec_time / 1000 AS total_time_sec,
  mean_exec_time / 1000 AS mean_time_sec,
  stddev_exec_time / 1000 AS stddev_time_sec
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 10;
```

---

## Sauvegardes sur Bare Metal

### Strat√©gies de Sauvegarde

#### 1. Sauvegarde Logique (pg_dump)

**Avantages :**
- Portable entre versions PostgreSQL
- Restauration s√©lective (table par table)
- Fichier compress√©

**Inconv√©nients :**
- Lente sur grosses bases (>100 GB)
- Charge la base pendant le dump

**Script automatis√© :**

```bash
#!/bin/bash
# /usr/local/bin/backup_postgres.sh

BACKUP_DIR="/backup/postgresql"
DATE=$(date +%Y%m%d_%H%M%S)
DATABASE="mydb"

# Cr√©ation r√©pertoire
mkdir -p "$BACKUP_DIR"

# Dump compress√©
pg_dump -U postgres -Fc "$DATABASE" > "$BACKUP_DIR/${DATABASE}_${DATE}.dump"

# Rotation (garder 7 jours)
find "$BACKUP_DIR" -name "${DATABASE}_*.dump" -mtime +7 -delete

# V√©rification
if [ $? -eq 0 ]; then
    echo "Backup OK : ${DATABASE}_${DATE}.dump"
else
    echo "Backup FAILED !" | mail -s "PostgreSQL Backup Error" admin@example.com
fi
```

**Cron quotidien (3h du matin) :**
```bash
0 3 * * * /usr/local/bin/backup_postgres.sh >> /var/log/backup.log 2>&1
```

#### 2. Sauvegarde Physique (pg_basebackup)

**Avantages :**
- Tr√®s rapide (copie fichiers)
- Permet PITR (Point-In-Time Recovery)
- Base de la r√©plication

**Inconv√©nients :**
- Volumineuse (toute l'instance)
- M√™me version majeure PostgreSQL obligatoire

**Commande :**
```bash
pg_basebackup -h localhost -U replicator -D /backup/base_$(date +%Y%m%d) -Fp -Xs -P -R
```

#### 3. Strat√©gie 3-2-1

**R√®gle d'or des sauvegardes :**
- **3 copies** de vos donn√©es
- **2 m√©dias** diff√©rents (ex: disque local + NAS)
- **1 copie** hors site (ex: cloud, datacenter distant)

**Exemple d'architecture :**
```
Serveur Bare Metal PostgreSQL
  ‚îú‚îÄ Donn√©es en production (RAID 10)
  ‚îÇ
  ‚îú‚îÄ Backup 1 : Disques locaux d√©di√©s (RAID 6)
  ‚îÇ   ‚îî‚îÄ pg_dump quotidien + pg_basebackup hebdo
  ‚îÇ
  ‚îú‚îÄ Backup 2 : NAS r√©seau
  ‚îÇ   ‚îî‚îÄ Synchronisation rsync des backups locaux
  ‚îÇ
  ‚îî‚îÄ Backup 3 : Cloud (S3, Azure Blob, etc.)
      ‚îî‚îÄ Envoi chiffr√© des backups critiques
```

---

## R√©capitulatif : Checklist de Configuration Optimale

### Mat√©riel

- [ ] **CPU :** 16-32+ c≈ìurs, fr√©quence 2.8+ GHz
- [ ] **RAM :** 64-256 GB avec ECC
- [ ] **Stockage :** NVMe en RAID 10 pour PGDATA, RAID 1 pour WAL
- [ ] **R√©seau :** 10+ GbE avec redondance
- [ ] **Alimentation :** UPS pour protection coupures

### Syst√®me d'Exploitation

- [ ] **OS :** Ubuntu Server LTS / Rocky Linux
- [ ] **Kernel :** Param√®tres sysctl optimis√©s (swappiness, dirty_ratio)
- [ ] **Filesystem :** ext4 ou XFS avec noatime
- [ ] **Limites :** nofile, nproc augment√©s pour utilisateur postgres
- [ ] **S√©curit√© :** Firewall configur√©, SELinux/AppArmor actif

### PostgreSQL

- [ ] **Version :** PostgreSQL 18 install√© depuis d√©p√¥t officiel PGDG
- [ ] **M√©moire :** shared_buffers, work_mem, maintenance_work_mem ajust√©s
- [ ] **WAL :** wal_level=replica, compression zstd activ√©e
- [ ] **I/O :** io_method='async' configur√© (PostgreSQL 18)
- [ ] **Autovacuum :** Actif avec param√®tres adapt√©s
- [ ] **Logging :** auto_explain et pg_stat_statements activ√©s
- [ ] **SSL/TLS :** Certificats configur√©s, TLS 1.2+ minimum

### S√©curit√©

- [ ] **pg_hba.conf :** SCRAM-SHA-256 obligatoire, acc√®s restreints
- [ ] **R√¥les :** Principe du moindre privil√®ge appliqu√©
- [ ] **Data Checksums :** Activ√©s (d√©faut PG 18)
- [ ] **Sauvegardes :** Strat√©gie 3-2-1 impl√©ment√©e
- [ ] **Monitoring :** Supervision active (Prometheus/Grafana ou √©quivalent)

### Monitoring

- [ ] **pg_stat_statements :** Extension install√©e et configur√©e
- [ ] **Alertes :** Seuils d√©finis (connexions, cache, disque, r√©plication)
- [ ] **Logs :** Rotation active, analyse automatis√©e (pgBadger)
- [ ] **M√©triques syst√®me :** CPU, RAM, I/O, r√©seau supervis√©s

---

## Avantages et Limites du Bare Metal

### Avantages ‚úÖ

1. **Performance maximale**
   - Acc√®s direct au mat√©riel sans overhead de virtualisation
   - Latence minimale (critique pour OLTP haute fr√©quence)
   - I/O optimal, surtout avec PostgreSQL 18 et I/O asynchrone

2. **Contr√¥le total**
   - Configuration kernel et mat√©riel sur mesure
   - Pas de "voisins bruyants" (noisy neighbors) comme en cloud
   - D√©terminisme des performances

3. **Co√ªt pr√©visible**
   - Investissement initial, puis co√ªt fixe mensuel (√©lectricit√©, h√©bergement)
   - Pas de facturation √† l'usage
   - ROI int√©ressant sur 3-5 ans pour charges stables

4. **Conformit√©**
   - Donn√©es restent sur infrastructure contr√¥l√©e
   - Audits simplifi√©s
   - Respect des r√©glementations strictes (RGPD, HDS, etc.)

### Limites ‚ö†Ô∏è

1. **Scalabilit√© limit√©e**
   - Mont√©e en charge n√©cessite achat mat√©riel (d√©lais)
   - Impossible de scaler √©lastiquement comme en cloud
   - Capacit√© maximale fix√©e par le hardware

2. **Co√ªt initial √©lev√©**
   - Investissement mat√©riel important (10 000 - 100 000‚Ç¨+)
   - N√©cessite infrastructure datacenter (racks, climatisation, √©lectricit√©)

3. **Maintenance lourde**
   - Gestion mat√©rielle (pannes disque, RAM d√©fectueuse)
   - Mises √† jour hardware complexes
   - √âquipe technique n√©cessaire 24/7

4. **Pas de haute disponibilit√© native**
   - N√©cessite architecture complexe (r√©plication, Patroni, load balancing)
   - Single Point of Failure si pas de r√©plication
   - Disaster Recovery plus difficile qu'en cloud

---

## Conclusion

Le d√©ploiement **bare metal** de PostgreSQL reste la r√©f√©rence en termes de **performance brute** et de **contr√¥le total**. Avec PostgreSQL 18 et ses am√©liorations I/O asynchrones, les gains de performance sur mat√©riel moderne (NVMe, CPU multi-c≈ìurs) sont spectaculaires.

**Quand choisir bare metal ?**
- ‚úÖ Charges critiques √† haute performance
- ‚úÖ Conformit√© r√©glementaire stricte
- ‚úÖ Charges stables et pr√©visibles
- ‚úÖ √âquipe technique exp√©riment√©e

**Quand privil√©gier d'autres solutions ?**
- ‚ùå Startup en croissance rapide ‚Üí **Cloud manag√©**
- ‚ùå Charges tr√®s variables ‚Üí **Cloud √©lastique**
- ‚ùå √âquipe technique limit√©e ‚Üí **DBaaS (RDS, Azure, etc.)**
- ‚ùå Besoin de multi-r√©gion rapide ‚Üí **Cloud avec r√©plication globale**

**Points cl√©s √† retenir :**
1. L'optimisation mat√©rielle (CPU, RAM, NVMe) est cruciale
2. La configuration OS (kernel, filesystem) impacte directement les performances
3. PostgreSQL 18 apporte des gains majeurs (I/O async, autovacuum am√©lior√©)
4. La s√©curit√© et les sauvegardes ne sont PAS n√©gociables
5. Le monitoring continu est indispensable

Un d√©ploiement bare metal bien configur√© peut servir des **millions de transactions par jour** avec une **latence sub-milliseconde**. Mais il n√©cessite expertise et rigueur op√©rationnelle.

---

**Prochaines √©tapes sugg√©r√©es :**
- 19.1.2. Virtual Machines (VM)
- 19.1.3. Conteneurs (Docker, Podman)
- 19.1.4. Kubernetes (StatefulSets, Operators)
- 16. Administration, Configuration et S√©curit√© (approfondissement)

‚è≠Ô∏è [Virtual Machines (VM)](/19-postgresql-en-production/01.2-virtual-machines.md)
