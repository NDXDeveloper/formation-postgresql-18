üîù Retour au [Sommaire](/SOMMAIRE.md)

# 19.6.4. Backup et DR (Disaster Recovery)

## Introduction

**"The question is not IF you will need backups, but WHEN."**

Les sauvegardes (backups) sont votre **assurance vie** en production. Sans elles, une erreur humaine, une corruption de disque, ou une attaque ransomware peut d√©truire des ann√©es de donn√©es en quelques secondes.

Le **Disaster Recovery** (DR) va au-del√† des simples sauvegardes : c'est l'ensemble des processus, politiques et proc√©dures qui garantissent la **continuit√© d'activit√©** en cas de catastrophe (incendie, panne datacenter, cyberattaque, etc.).

Cette section couvre :
- Les diff√©rents types de sauvegardes PostgreSQL
- Les strat√©gies de sauvegarde efficaces
- La restauration et le Point-In-Time Recovery (PITR)
- L'automatisation et la validation
- La planification de la reprise apr√®s sinistre

> **R√®gle d'or** : Une sauvegarde qui n'a jamais √©t√© test√©e n'est **pas** une sauvegarde. C'est une **esp√©rance**.

---

## 1. Concepts Fondamentaux

### 1.1. RTO et RPO : D√©finir vos Objectifs

Avant toute strat√©gie de backup, d√©finissez :

**RPO (Recovery Point Objective)** : Combien de donn√©es pouvez-vous vous permettre de perdre ?
- RPO = 24h ‚Üí Backup quotidien acceptable
- RPO = 1h ‚Üí N√©cessite archivage WAL continu
- RPO = 0 ‚Üí R√©plication synchrone

**RTO (Recovery Time Objective)** : Combien de temps pour r√©tablir le service ?
- RTO = 4h ‚Üí Restauration standard acceptable
- RTO = 15 min ‚Üí N√©cessite r√©plication + failover automatique
- RTO = 0 ‚Üí Haute disponibilit√© avec failover instantan√©

**Exemple** :

| Application      | RPO      | RTO      | Strat√©gie                                |
|------------------|----------|----------|------------------------------------------|
| Blog personnel   | 24h      | 4h       | pg_dump quotidien                        |
| E-commerce       | 15 min   | 30 min   | PITR + r√©plication asynchone             |
| Banque en ligne  | 0        | 1 min    | R√©plication synchrone + failover auto    |

### 1.2. Types de Sauvegardes

PostgreSQL offre deux approches principales :

**1. Sauvegardes Logiques** (pg_dump)
- Export SQL ou format personnalis√©
- Lecture humaine possible (SQL)
- Restauration s√©lective (tables sp√©cifiques)
- Ind√©pendant de la version PostgreSQL (migration facile)
- **Inconv√©nient** : Lent sur grosses bases

**2. Sauvegardes Physiques** (pg_basebackup)
- Copie binaire du r√©pertoire de donn√©es
- Rapide, m√™me pour gros volumes
- Permet le Point-In-Time Recovery (PITR)
- **Inconv√©nient** : Doit √™tre m√™me version/architecture

**Recommandation** : Les deux ! Logique pour flexibilit√©, physique pour vitesse.

---

## 2. Sauvegardes Logiques avec pg_dump

### 2.1. pg_dump : Sauvegarder une Base

**Commande de base** :

```bash
pg_dump -U postgres -d myapp -f myapp_backup.sql
```

**Formats disponibles** :

```bash
# 1. Format SQL (texte, lisible)
pg_dump -U postgres -d myapp -f myapp.sql

# 2. Format personnalis√© (custom) - RECOMMAND√â
pg_dump -U postgres -d myapp -Fc -f myapp.dump

# 3. Format directory (parall√©lisation)
pg_dump -U postgres -d myapp -Fd -j 4 -f myapp_dir/

# 4. Format tar
pg_dump -U postgres -d myapp -Ft -f myapp.tar
```

**Explications** :
- `-Fc` : Format custom, compress√©, permet restauration s√©lective
- `-Fd` : Format directory, permet parall√©lisation avec `-j`
- `-j 4` : Utilise 4 workers en parall√®le (plus rapide)

### 2.2. Options Importantes

```bash
# Backup complet avec toutes les options
pg_dump \
  -U postgres \
  -d myapp \
  -Fc \                           # Format custom
  -Z 9 \                          # Compression max (0-9)
  -f /backups/myapp_$(date +%Y%m%d_%H%M%S).dump \
  --verbose \                     # Afficher progression
  --quote-all-identifiers \       # Quote tous les identifiants
  --no-owner \                    # Ne pas inclure les propri√©taires
  --no-privileges                 # Ne pas inclure les permissions
```

**Options utiles** :

| Option                    | Description                                        |
|---------------------------|----------------------------------------------------|
| `--schema=SCHEMA`         | Backup d'un sch√©ma uniquement                      |
| `--table=TABLE`           | Backup d'une table uniquement                      |
| `--exclude-table=PATTERN` | Exclure certaines tables                           |
| `--data-only`             | Donn√©es uniquement (sans DDL)                      |
| `--schema-only`           | Structure uniquement (sans donn√©es)                |
| `--inserts`               | Utiliser INSERT au lieu de COPY (compatible)       |
| `--column-inserts`        | INSERT avec noms de colonnes                       |
| `--clean`                 | Ajouter DROP avant CREATE                          |
| `--if-exists`             | Utiliser IF EXISTS dans DROP                       |

### 2.3. Exemples Pratiques

**Backup d'une table sp√©cifique** :

```bash
pg_dump -U postgres -d myapp -t users -Fc -f users_backup.dump
```

**Backup de plusieurs tables** :

```bash
pg_dump -U postgres -d myapp -t users -t orders -t products -Fc -f tables_backup.dump
```

**Backup sans tables de logs** :

```bash
pg_dump -U postgres -d myapp \
  --exclude-table='logs_*' \
  --exclude-table='audit_*' \
  -Fc -f myapp_no_logs.dump
```

**Backup structure uniquement** :

```bash
pg_dump -U postgres -d myapp --schema-only -f schema.sql
```

### 2.4. pg_dumpall : Sauvegarder Tout le Cluster

**Cas d'usage** : Backup de toutes les bases + r√¥les + configurations globales.

```bash
# Backup complet du cluster
pg_dumpall -U postgres -f cluster_full_backup.sql

# R√¥les et tablespaces uniquement
pg_dumpall -U postgres --globals-only -f globals.sql
```

**Limitations** :
- Format SQL uniquement (pas de compression custom)
- Ne parall√©lise pas (lent sur gros volumes)

**Recommandation** : Utilisez `pg_dump` individuellement par base + `pg_dumpall --globals-only`.

### 2.5. Restauration avec pg_restore

**Format custom ou directory** :

```bash
# Restauration compl√®te
pg_restore -U postgres -d myapp myapp_backup.dump

# Restauration avec DROP des objets existants
pg_restore -U postgres -d myapp --clean --if-exists myapp_backup.dump

# Restauration en parall√®le (format directory)
pg_restore -U postgres -d myapp -j 4 myapp_dir/

# Restauration d'une table sp√©cifique
pg_restore -U postgres -d myapp -t users myapp_backup.dump

# Liste des objets dans le backup
pg_restore --list myapp_backup.dump
```

**Options importantes** :

| Option                | Description                                        |
|-----------------------|----------------------------------------------------|
| `--clean`             | DROP objets avant restauration                     |
| `--if-exists`         | Utiliser IF EXISTS (pas d'erreur si absent)        |
| `--create`            | Cr√©er la base avant restauration                   |
| `-j N`                | Parall√©liser sur N workers                         |
| `--verbose`           | Mode verbeux                                       |
| `--exit-on-error`     | Arr√™ter √† la premi√®re erreur                       |
| `--no-owner`          | Ne pas restaurer les propri√©taires                 |
| `--no-privileges`     | Ne pas restaurer les permissions                   |

**Format SQL** :

```bash
# Restauration depuis SQL
psql -U postgres -d myapp -f myapp_backup.sql
```

---

## 3. Sauvegardes Physiques avec pg_basebackup

### 3.1. Principe

`pg_basebackup` cr√©e une **copie binaire** du r√©pertoire de donn√©es PostgreSQL. C'est la base du **Point-In-Time Recovery** (PITR).

**Avantages** :
- Tr√®s rapide (copie binaire)
- Permet PITR avec archivage WAL
- Base de la r√©plication
- Pas de verrouillage de tables

**Pr√©requis** :
- R√©plication configur√©e (`wal_level = replica`)
- Slot de r√©plication (recommand√©)

### 3.2. Configuration Pr√©alable

**Fichier** : `postgresql.conf`

```conf
# Activer l'archivage WAL
wal_level = replica
archive_mode = on
archive_command = 'test ! -f /mnt/wal_archive/%f && cp %p /mnt/wal_archive/%f'
# Ou via script plus robuste
# archive_command = '/usr/local/bin/archive_wal.sh %p %f'

# Cr√©er le r√©pertoire d'archives
# mkdir -p /mnt/wal_archive
# chown postgres:postgres /mnt/wal_archive
```

**Fichier** : `pg_hba.conf`

```conf
# Autoriser la r√©plication
host    replication     replicator      127.0.0.1/32            scram-sha-256
host    replication     replicator      10.0.1.0/24             scram-sha-256
```

**Cr√©er un utilisateur de r√©plication** :

```sql
CREATE ROLE replicator WITH REPLICATION LOGIN PASSWORD 'secure_password';
```

**Restart** :

```bash
sudo systemctl restart postgresql-18
```

### 3.3. Cr√©er un Backup Physique

**Commande de base** :

```bash
pg_basebackup \
  -U replicator \
  -h localhost \
  -D /backups/base_$(date +%Y%m%d_%H%M%S) \
  -Fp \                             # Format plain (r√©pertoire)
  -Xs \                             # Stream WAL (inclus dans backup)
  -P \                              # Afficher progression
  -v                                # Verbose
```

**Formats disponibles** :

```bash
# Format plain (r√©pertoire)
pg_basebackup -D /backups/base -Fp

# Format tar (archive)
pg_basebackup -D /backups/base.tar -Ft

# Format tar avec compression
pg_basebackup -D /backups/base.tar.gz -Ft -z -Z 9
```

**Options importantes** :

| Option    | Description                                                     |
|-----------|-----------------------------------------------------------------|
| `-D DIR`  | R√©pertoire de destination                                       |
| `-Fp`     | Format plain (r√©pertoire)                                       |
| `-Ft`     | Format tar                                                      |
| `-z`      | Compresser (avec tar)                                           |
| `-Z 0-9`  | Niveau de compression                                           |
| `-Xs`     | Stream WAL (inclus dans backup)                                 |
| `-Xf`     | Fetch WAL √† la fin                                              |
| `-P`      | Progression                                                     |
| `-c fast` | Checkpoint rapide                                               |
| `-R`      | Cr√©er fichiers de config pour standby (recovery.signal, etc.)  |
| `-S slot` | Utiliser un slot de r√©plication                                 |

### 3.4. Backup avec Slot de R√©plication (Recommand√©)

**Avantage** : Garantit que les WAL n√©cessaires ne sont pas supprim√©s pendant le backup.

```sql
-- Cr√©er un slot de r√©plication
SELECT pg_create_physical_replication_slot('backup_slot');
```

```bash
# Backup avec slot
pg_basebackup \
  -U replicator \
  -h localhost \
  -D /backups/base_$(date +%Y%m%d_%H%M%S) \
  -Fp \
  -Xs \
  -S backup_slot \
  -P -v
```

```sql
-- Supprimer le slot apr√®s backup
SELECT pg_drop_replication_slot('backup_slot');
```

### 3.5. Script d'Automatisation

```bash
#!/bin/bash
# /usr/local/bin/backup_postgres.sh

set -e

BACKUP_DIR="/backups/postgres"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_PATH="${BACKUP_DIR}/base_${DATE}"
RETENTION_DAYS=7

echo "=== PostgreSQL Physical Backup ==="
echo "Date: $(date)"
echo "Destination: ${BACKUP_PATH}"

# Cr√©er le r√©pertoire
mkdir -p "${BACKUP_DIR}"

# Cr√©er slot de r√©plication
echo "Creating replication slot..."
psql -U postgres -c "SELECT pg_create_physical_replication_slot('backup_slot_${DATE}');" || true

# Backup
echo "Starting backup..."
pg_basebackup \
  -U replicator \
  -h localhost \
  -D "${BACKUP_PATH}" \
  -Fp \
  -Xs \
  -S "backup_slot_${DATE}" \
  -P -v

# Supprimer le slot
echo "Dropping replication slot..."
psql -U postgres -c "SELECT pg_drop_replication_slot('backup_slot_${DATE}');"

# Cr√©er un manifeste
echo "Creating manifest..."
echo "Backup Date: $(date)" > "${BACKUP_PATH}/backup_manifest.txt"
echo "PostgreSQL Version: $(psql -U postgres -t -c 'SELECT version();')" >> "${BACKUP_PATH}/backup_manifest.txt"
du -sh "${BACKUP_PATH}" >> "${BACKUP_PATH}/backup_manifest.txt"

# Compression (optionnel)
echo "Compressing backup..."
tar -czf "${BACKUP_PATH}.tar.gz" -C "${BACKUP_DIR}" "base_${DATE}"
rm -rf "${BACKUP_PATH}"

# Nettoyage des anciens backups
echo "Cleaning old backups (> ${RETENTION_DAYS} days)..."
find "${BACKUP_DIR}" -name "base_*.tar.gz" -mtime +${RETENTION_DAYS} -delete

echo "Backup completed: ${BACKUP_PATH}.tar.gz"
echo "Size: $(du -sh ${BACKUP_PATH}.tar.gz | cut -f1)"
```

**Rendre ex√©cutable** :

```bash
chmod +x /usr/local/bin/backup_postgres.sh
```

**Planifier via cron** :

```bash
# Backup quotidien √† 2h du matin
0 2 * * * /usr/local/bin/backup_postgres.sh >> /var/log/postgres_backup.log 2>&1
```

---

## 4. Point-In-Time Recovery (PITR)

### 4.1. Concept

Le **PITR** permet de restaurer la base √† n'importe quel moment entre :
- Le backup physique (pg_basebackup)
- La date actuelle (ou un moment sp√©cifique)

**Exemple** :
- Backup effectu√© lundi 00h00
- Erreur humaine mercredi 14h30 (DELETE sans WHERE)
- PITR permet de restaurer √† mercredi 14h29 (juste avant l'erreur)

### 4.2. Configuration de l'Archivage WAL

**Fichier** : `postgresql.conf`

```conf
# Activer l'archivage
wal_level = replica
archive_mode = on
archive_command = 'test ! -f /mnt/wal_archive/%f && cp %p /mnt/wal_archive/%f'

# Optionnel : augmenter max_wal_senders si r√©plication
max_wal_senders = 10
wal_keep_size = 1GB
```

**Script d'archivage robuste** :

```bash
#!/bin/bash
# /usr/local/bin/archive_wal.sh

WAL_FILE=$1
WAL_NAME=$2
ARCHIVE_DIR="/mnt/wal_archive"

# Cr√©er le r√©pertoire si n√©cessaire
mkdir -p "${ARCHIVE_DIR}"

# Copier avec v√©rification
if cp "${WAL_FILE}" "${ARCHIVE_DIR}/${WAL_NAME}"; then
  # V√©rifier l'int√©grit√© (optionnel)
  if diff "${WAL_FILE}" "${ARCHIVE_DIR}/${WAL_NAME}" > /dev/null 2>&1; then
    exit 0
  else
    echo "ERROR: WAL copy verification failed" >&2
    rm -f "${ARCHIVE_DIR}/${WAL_NAME}"
    exit 1
  fi
else
  echo "ERROR: Failed to copy WAL file" >&2
  exit 1
fi
```

**Permissions** :

```bash
chmod +x /usr/local/bin/archive_wal.sh
chown postgres:postgres /usr/local/bin/archive_wal.sh
```

**Mettre √† jour postgresql.conf** :

```conf
archive_command = '/usr/local/bin/archive_wal.sh %p %f'
```

### 4.3. Restauration PITR : √âtape par √âtape

**Sc√©nario** : Base corrompue √† 14h30, dernier backup √† 00h00, restaurer √† 14h29.

**√âtape 1 : Arr√™ter PostgreSQL**

```bash
sudo systemctl stop postgresql-18
```

**√âtape 2 : Sauvegarder les Donn√©es Corrompues** (au cas o√π)

```bash
mv /var/lib/pgsql/18/data /var/lib/pgsql/18/data_corrupt_$(date +%Y%m%d)
```

**√âtape 3 : Restaurer le Backup Physique**

```bash
# Extraire le backup
tar -xzf /backups/base_20251123_000000.tar.gz -C /var/lib/pgsql/18/data

# Ou copier si format plain
# cp -r /backups/base_20251123_000000 /var/lib/pgsql/18/data
```

**√âtape 4 : Configurer la R√©cup√©ration**

Cr√©er `postgresql.auto.conf` ou modifier `postgresql.conf` :

```conf
# Configuration de r√©cup√©ration
restore_command = 'cp /mnt/wal_archive/%f %p'
recovery_target_time = '2025-11-23 14:29:00'
recovery_target_action = 'promote'
```

**Cr√©er le signal de r√©cup√©ration** :

```bash
touch /var/lib/pgsql/18/data/recovery.signal
```

**√âtape 5 : D√©marrer PostgreSQL**

```bash
sudo systemctl start postgresql-18
```

**√âtape 6 : Surveiller les Logs**

```bash
tail -f /var/lib/pgsql/18/data/log/postgresql-*.log
```

**R√©sultat attendu** :

```
LOG:  starting point-in-time recovery to 2025-11-23 14:29:00+00
LOG:  restored log file "000000010000000000000001" from archive
LOG:  redo starts at 0/1000028
LOG:  consistent recovery state reached at 0/2000000
LOG:  restored log file "000000010000000000000002" from archive
...
LOG:  recovery stopping before commit of transaction 12345, time 2025-11-23 14:30:15
LOG:  recovery has paused
LOG:  recovery complete, database system is ready for connections
```

**√âtape 7 : V√©rifier**

```sql
-- V√©rifier que les donn√©es sont bien l√†
SELECT count(*) FROM users;

-- V√©rifier le timestamp de r√©cup√©ration
SELECT pg_last_xact_replay_timestamp();
```

### 4.4. Options de recovery_target

```conf
# Par temps
recovery_target_time = '2025-11-23 14:29:00'

# Par transaction ID
recovery_target_xid = '12344'

# Par nom (avec pg_create_restore_point)
recovery_target_name = 'before_migration'

# Par LSN (Log Sequence Number)
recovery_target_lsn = '0/3000000'

# Immediate (d√®s que consistent)
recovery_target = 'immediate'
```

**Actions apr√®s r√©cup√©ration** :

```conf
# Promouvoir en primary
recovery_target_action = 'promote'

# Arr√™ter
recovery_target_action = 'shutdown'

# Pause (pour inspection)
recovery_target_action = 'pause'
```

---

## 5. Strat√©gies de Sauvegarde

### 5.1. La R√®gle 3-2-1

**3** copies de vos donn√©es
**2** types de m√©dia diff√©rents
**1** copie hors site (off-site)

**Exemple** :
1. **Copie production** : Base de donn√©es active
2. **Backup local** : Disque SSD sur serveur (pg_basebackup quotidien)
3. **Backup distant** : Cloud S3/Azure Blob (copie du backup local)

**M√©dias diff√©rents** :
- SSD local (rapide, restauration rapide)
- HDD externe (grande capacit√©)
- Cloud storage (durabilit√©, g√©o-r√©plication)

### 5.2. Fr√©quences Recommand√©es

| Type             | Fr√©quence         | R√©tention      | Objectif                    |
|------------------|-------------------|----------------|-----------------------------|
| **pg_dump**      | Quotidien         | 7 jours        | Restauration rapide tables  |
| **pg_basebackup**| Quotidien         | 7 jours        | PITR r√©cent                 |
| **Hebdomadaire** | Dimanche          | 4 semaines     | R√©cup√©ration moyen terme    |
| **Mensuel**      | 1er du mois       | 12 mois        | Conformit√©, audit           |
| **Annuel**       | 1er janvier       | 7 ans          | Archivage l√©gal             |

### 5.3. Strat√©gies par Type d'Application

**Petite Application (< 10 GB)** :

```bash
# Backup quotidien logique (simple et suffisant)
0 2 * * * pg_dump -U postgres -d myapp -Fc -f /backups/myapp_$(date +\%Y\%m\%d).dump

# R√©tention : 7 jours
0 3 * * * find /backups -name "myapp_*.dump" -mtime +7 -delete
```

**Application Moyenne (10-100 GB)** :

```bash
# Backup physique quotidien
0 2 * * * /usr/local/bin/backup_postgres.sh

# Backup logique hebdomadaire (dimanche)
0 3 * * 0 pg_dump -U postgres -d myapp -Fc -f /backups/weekly/myapp_$(date +\%Y\%m\%d).dump

# Archivage WAL continu (dans postgresql.conf)
archive_mode = on
archive_command = 'cp %p /mnt/wal_archive/%f'
```

**Grosse Application (> 100 GB)** :

```bash
# Backup physique quotidien + streaming WAL
archive_mode = on
archive_command = 'aws s3 cp %p s3://my-bucket/wal/%f'

# Backup hebdomadaire complet + incr√©mental quotidien
# Utiliser pgBackRest ou Barman
```

### 5.4. Tableau de D√©cision

| Taille DB | RPO      | RTO      | Solution recommand√©e                               |
|-----------|----------|----------|----------------------------------------------------|
| < 10 GB   | 24h      | 4h       | pg_dump quotidien                                  |
| 10-50 GB  | 1h       | 2h       | pg_basebackup + WAL archiving                      |
| 50-500 GB | 15 min   | 30 min   | pgBackRest + r√©plication                           |
| > 500 GB  | 5 min    | 10 min   | Barman + r√©plication synchrone                     |
| Mission   | 0        | 1 min    | R√©plication synchrone multi-zone + failover auto   |

---

## 6. Outils Avanc√©s de Backup

### 6.1. pgBackRest

**pgBackRest** est l'outil de backup le plus avanc√© pour PostgreSQL.

**Fonctionnalit√©s** :
- Backup complet, diff√©rentiel, incr√©mental
- Compression et chiffrement
- Parall√©lisation
- Backup vers S3/Azure/GCS
- Restauration PITR simplifi√©e
- V√©rification d'int√©grit√©

**Installation** :

```bash
# RHEL/CentOS
sudo dnf install pgbackrest

# Debian/Ubuntu
sudo apt install pgbackrest
```

**Configuration** (`/etc/pgbackrest.conf`) :

```ini
[global]
repo1-path=/var/lib/pgbackrest
repo1-retention-full=2
repo1-retention-diff=4
start-fast=y
log-level-console=info
log-level-file=debug

[myapp]
pg1-path=/var/lib/pgsql/18/data
pg1-port=5432
pg1-user=postgres
```

**Commandes** :

```bash
# Backup complet
pgbackrest --stanza=myapp backup --type=full

# Backup incr√©mental
pgbackrest --stanza=myapp backup --type=incr

# Backup diff√©rentiel
pgbackrest --stanza=myapp backup --type=diff

# Restauration
pgbackrest --stanza=myapp restore

# PITR
pgbackrest --stanza=myapp restore \
  --type=time \
  --target="2025-11-23 14:29:00"

# Info sur les backups
pgbackrest --stanza=myapp info
```

### 6.2. Barman

**Barman** (Backup and Recovery Manager) par 2ndQuadrant.

**Fonctionnalit√©s** :
- Backup physique avec compression
- Archivage WAL
- PITR
- G√©o-r√©plication des backups
- Interface web

**Installation** :

```bash
# RHEL/CentOS
sudo dnf install barman

# Debian/Ubuntu
sudo apt install barman
```

**Configuration** (`/etc/barman.conf`) :

```ini
[barman]
barman_user = barman
configuration_files_directory = /etc/barman.d
barman_home = /var/lib/barman
log_file = /var/log/barman/barman.log
compression = gzip

[myapp]
description = "Production database"
ssh_command = ssh postgres@dbserver
conninfo = host=dbserver user=barman dbname=postgres
backup_method = postgres
backup_options = concurrent_backup
archiver = on
```

**Commandes** :

```bash
# Backup
barman backup myapp

# Liste des backups
barman list-backup myapp

# Restauration
barman recover myapp latest /var/lib/pgsql/18/data

# PITR
barman recover myapp latest /var/lib/pgsql/18/data \
  --target-time "2025-11-23 14:29:00"

# Check
barman check myapp
```

### 6.3. WAL-G

**WAL-G** : Outil moderne, cloud-first.

**Avantages** :
- Con√ßu pour le cloud (S3, GCS, Azure)
- Compression avanc√©e (zstd, lz4)
- Chiffrement natif
- Backup incr√©mental efficace

**Installation** :

```bash
# Download latest release
wget https://github.com/wal-g/wal-g/releases/download/v2.0.1/wal-g-pg-ubuntu-20.04-amd64.tar.gz
tar -xzf wal-g-pg-ubuntu-20.04-amd64.tar.gz
sudo mv wal-g-pg-ubuntu-20.04-amd64 /usr/local/bin/wal-g
```

**Configuration** (`~/.walg.json`) :

```json
{
  "WALG_S3_PREFIX": "s3://my-backup-bucket/postgres",
  "AWS_REGION": "us-east-1",
  "WALG_COMPRESSION_METHOD": "zstd",
  "WALG_DELTA_MAX_STEPS": "5",
  "PGDATA": "/var/lib/pgsql/18/data"
}
```

**Commandes** :

```bash
# Backup
wal-g backup-push

# Restauration
wal-g backup-fetch /var/lib/pgsql/18/data LATEST

# Liste des backups
wal-g backup-list
```

---

## 7. Backup vers le Cloud

### 7.1. AWS S3

**pg_dump vers S3** :

```bash
#!/bin/bash
# Backup vers S3

BACKUP_FILE="myapp_$(date +%Y%m%d_%H%M%S).dump"
BACKUP_PATH="/tmp/${BACKUP_FILE}"
S3_BUCKET="s3://my-postgres-backups"

# Cr√©er le backup
pg_dump -U postgres -d myapp -Fc -f "${BACKUP_PATH}"

# Uploader vers S3
aws s3 cp "${BACKUP_PATH}" "${S3_BUCKET}/${BACKUP_FILE}"

# Nettoyage local
rm -f "${BACKUP_PATH}"

# Lifecycle policy S3 (via AWS CLI ou Console)
# - Transition vers Glacier apr√®s 30 jours
# - Suppression apr√®s 365 jours
```

**Archive WAL vers S3** :

```conf
# postgresql.conf
archive_command = 'aws s3 cp %p s3://my-wal-archive/%f'
```

**Restauration depuis S3** :

```conf
# postgresql.conf (r√©cup√©ration)
restore_command = 'aws s3 cp s3://my-wal-archive/%f %p'
```

### 7.2. Azure Blob Storage

```bash
#!/bin/bash
# Backup vers Azure Blob

BACKUP_FILE="myapp_$(date +%Y%m%d_%H%M%S).dump"
BACKUP_PATH="/tmp/${BACKUP_FILE}"
CONTAINER="postgres-backups"

# Backup
pg_dump -U postgres -d myapp -Fc -f "${BACKUP_PATH}"

# Upload vers Azure
az storage blob upload \
  --account-name mystorageaccount \
  --container-name "${CONTAINER}" \
  --name "${BACKUP_FILE}" \
  --file "${BACKUP_PATH}"

# Nettoyage
rm -f "${BACKUP_PATH}"
```

### 7.3. Google Cloud Storage

```bash
#!/bin/bash
# Backup vers GCS

BACKUP_FILE="myapp_$(date +%Y%m%d_%H%M%S).dump"
BACKUP_PATH="/tmp/${BACKUP_FILE}"
GCS_BUCKET="gs://my-postgres-backups"

# Backup
pg_dump -U postgres -d myapp -Fc -f "${BACKUP_PATH}"

# Upload vers GCS
gsutil cp "${BACKUP_PATH}" "${GCS_BUCKET}/${BACKUP_FILE}"

# Nettoyage
rm -f "${BACKUP_PATH}"
```

---

## 8. Tests de Restauration

### 8.1. Pourquoi Tester ?

**Statistiques terrifiantes** :
- 30% des backups ne peuvent pas √™tre restaur√©s
- 60% des entreprises d√©couvrent que leur backup est corrompu au moment critique
- La plupart des entreprises ne testent JAMAIS leurs backups

**Cons√©quence** : Un backup non test√© = pas de backup.

### 8.2. Plan de Test Mensuel

**Checklist** :

```bash
#!/bin/bash
# /usr/local/bin/test_backup_restore.sh

set -e

TEST_DIR="/tmp/restore_test_$(date +%Y%m%d_%H%M%S)"
BACKUP_FILE="/backups/latest/myapp.dump"
TEST_PORT=5433

echo "=== PostgreSQL Backup Restore Test ==="
echo "Date: $(date)"

# 1. Cr√©er un cluster de test
echo "Creating test cluster..."
initdb -D "${TEST_DIR}/data"

# 2. Configurer le port (√©viter conflit)
echo "port = ${TEST_PORT}" >> "${TEST_DIR}/data/postgresql.conf"

# 3. D√©marrer le cluster de test
echo "Starting test cluster..."
pg_ctl -D "${TEST_DIR}/data" -l "${TEST_DIR}/logfile" start

# 4. Cr√©er la base
echo "Creating database..."
psql -p ${TEST_PORT} -U postgres -c "CREATE DATABASE myapp_test;"

# 5. Restaurer le backup
echo "Restoring backup..."
pg_restore -p ${TEST_PORT} -U postgres -d myapp_test "${BACKUP_FILE}"

# 6. V√©rifier l'int√©grit√©
echo "Verifying restore..."
TABLE_COUNT=$(psql -p ${TEST_PORT} -U postgres -d myapp_test -t -c "SELECT count(*) FROM information_schema.tables WHERE table_schema = 'public';")
echo "Tables restored: ${TABLE_COUNT}"

if [ "${TABLE_COUNT}" -gt 0 ]; then
  echo "‚úÖ RESTORE TEST PASSED"
  EXIT_CODE=0
else
  echo "‚ùå RESTORE TEST FAILED"
  EXIT_CODE=1
fi

# 7. Nettoyage
echo "Cleaning up..."
pg_ctl -D "${TEST_DIR}/data" stop
rm -rf "${TEST_DIR}"

exit ${EXIT_CODE}
```

**Planifier via cron** :

```bash
# Test mensuel le 1er √† 4h
0 4 1 * * /usr/local/bin/test_backup_restore.sh >> /var/log/backup_test.log 2>&1
```

### 8.3. Tests PITR

**Sc√©nario de test complet** :

```bash
#!/bin/bash
# Test PITR complet

# 1. Noter l'heure actuelle
CURRENT_TIME=$(date +"%Y-%m-%d %H:%M:%S")
echo "Current time: ${CURRENT_TIME}"

# 2. Ins√©rer des donn√©es de test
psql -U postgres -d myapp -c "CREATE TABLE pitr_test (id serial, created_at timestamp default now());"
psql -U postgres -d myapp -c "INSERT INTO pitr_test (id) SELECT generate_series(1, 1000);"

# 3. Backup physique
pg_basebackup -U replicator -D /backups/pitr_test -Fp -Xs -P

# 4. Attendre 1 minute
sleep 60

# 5. "D√©truire" les donn√©es (simuler erreur)
DELETE_TIME=$(date +"%Y-%m-%d %H:%M:%S")
psql -U postgres -d myapp -c "DROP TABLE pitr_test;"

# 6. Restaurer avec PITR (avant le DROP)
# ... (proc√©dure PITR d√©taill√©e section 4.3)

# 7. V√©rifier
# Les 1000 lignes doivent √™tre l√†
```

---

## 9. Disaster Recovery : Plan d'Action

### 9.1. Sc√©narios de Sinistre

| Sc√©nario                      | Gravit√© | Solution                                        |
|-------------------------------|---------|------------------------------------------------|
| Erreur humaine (DELETE)      | Mod√©r√©  | PITR vers timestamp avant erreur               |
| Corruption disque             | √âlev√©   | Restauration depuis backup + WAL               |
| Panne datacenter              | Critique| Failover vers standby g√©o-r√©pliqu√©             |
| Ransomware                    | Critique| Restauration depuis backup off-site immutable  |
| Catastrophe naturelle         | Extr√™me | DR site dans r√©gion diff√©rente                 |

### 9.2. Runbook : R√©cup√©ration Apr√®s Sinistre

**Document √† avoir imprim√© et disponible 24/7.**

```markdown
# RUNBOOK: PostgreSQL Disaster Recovery

## Contact d'urgence
- DBA Principal: +33 6 XX XX XX XX
- DBA Secondaire: +33 6 YY YY YY YY
- Support Cloud: support@provider.com

## √âtape 1 : √âvaluation (5 min)
- [ ] Confirmer l'incident (v√©rifier monitoring)
- [ ] Identifier la cause (erreur humaine, hardware, attaque)
- [ ] D√©terminer l'√©tendue (une base, tout le cluster)
- [ ] Notifier les parties prenantes

## √âtape 2 : Arr√™t d'Urgence (si n√©cessaire)
```bash
sudo systemctl stop postgresql-18
# Ou kill -QUIT $(head -1 /var/lib/pgsql/18/data/postmaster.pid)
```

## √âtape 3 : Choix de la Strat√©gie
- [ ] PITR si erreur r√©cente
- [ ] Restauration compl√®te si corruption
- [ ] Failover si standby disponible

## √âtape 4 : Restauration PITR (si applicable)
```bash
# Voir section 4.3 pour proc√©dure d√©taill√©e
```

## √âtape 5 : Restauration Compl√®te
```bash
# 1. Backup donn√©es corrompues
mv /var/lib/pgsql/18/data /var/lib/pgsql/18/data_corrupt

# 2. Extraire backup
tar -xzf /backups/latest.tar.gz -C /var/lib/pgsql/18/data

# 3. Configurer r√©cup√©ration WAL
echo "restore_command = 'cp /mnt/wal_archive/%f %p'" >> postgresql.conf

# 4. D√©marrer
sudo systemctl start postgresql-18
```

## √âtape 6 : Validation
- [ ] Service d√©marr√©
- [ ] Connexions applicatives OK
- [ ] V√©rifier int√©grit√© donn√©es
- [ ] V√©rifier r√©plication (si applicable)

## √âtape 7 : Post-Mortem
- [ ] Documenter l'incident
- [ ] Identifier cause racine
- [ ] Am√©liorer proc√©dures
- [ ] Mettre √† jour runbook
```

### 9.3. Tests de DR

**Fr√©quence recommand√©e** : Trimestriel

**Exercice complet** :
1. Simuler une panne totale (arr√™t volontaire)
2. √âquipe DR restore depuis backup sans aide
3. Chronom√©trer le RTO effectif
4. Valider l'int√©grit√© des donn√©es
5. Documenter les √©carts avec le RTO cible

---

## 10. Checklist de Production

### ‚úÖ Configuration Backup

- [ ] `wal_level = replica` configur√©
- [ ] `archive_mode = on` activ√©
- [ ] `archive_command` configur√© et test√©
- [ ] R√©pertoire d'archives avec permissions correctes
- [ ] Utilisateur de r√©plication cr√©√©
- [ ] pg_hba.conf configure pour r√©plication

### ‚úÖ Sauvegardes Quotidiennes

- [ ] pg_basebackup quotidien automatis√©
- [ ] pg_dump hebdomadaire automatis√©
- [ ] Archivage WAL continu fonctionnel
- [ ] Logs de backup centralis√©s
- [ ] Alertes en cas d'√©chec de backup

### ‚úÖ Stockage et R√©tention

- [ ] Backups locaux (restauration rapide)
- [ ] Backups cloud (durabilit√©)
- [ ] R√®gle 3-2-1 respect√©e
- [ ] R√©tention d√©finie (7j, 4 semaines, 12 mois)
- [ ] Nettoyage automatique anciens backups

### ‚úÖ S√©curit√© des Backups

- [ ] Backups chiffr√©s (au repos)
- [ ] Transferts chiffr√©s (TLS/SSL)
- [ ] Acc√®s restreint aux backups
- [ ] Immutabilit√© activ√©e (cloud)
- [ ] Backups g√©o-r√©pliqu√©s

### ‚úÖ Tests et Validation

- [ ] Test de restauration mensuel
- [ ] Test PITR trimestriel
- [ ] Test de DR complet semestriel
- [ ] Documentation des proc√©dures
- [ ] Runbook accessible 24/7

### ‚úÖ Monitoring

- [ ] Alerte si backup √©choue
- [ ] Alerte si archivage WAL bloqu√©
- [ ] Monitoring espace disque archives
- [ ] Dashboard taille backups
- [ ] Alerte si backup trop ancien (> 25h)

### ‚úÖ Documentation

- [ ] Proc√©dure de backup document√©e
- [ ] Proc√©dure de restauration document√©e
- [ ] Runbook DR accessible
- [ ] Contacts d'urgence √† jour
- [ ] Localisation des backups document√©e

---

## 11. Bonnes Pratiques

### 11.1. Dos

‚úÖ **Testez vos backups r√©guli√®rement**
- Restauration mensuelle obligatoire
- Tests DR trimestriels

‚úÖ **Automatisez tout**
- Backups automatis√©s via cron/systemd
- Nettoyage automatique des anciens backups
- Alertes automatiques en cas d'√©chec

‚úÖ **Documentez tout**
- Proc√©dures claires et accessibles
- Runbooks imprim√©s disponibles
- Historique des tests conserv√©

‚úÖ **Chiffrez vos backups**
- Chiffrement au repos (cloud, disque)
- Chiffrement en transit (TLS)

‚úÖ **Surveillez l'espace disque**
- Archives WAL peuvent remplir rapidement
- Alertes avant saturation

‚úÖ **Gardez plusieurs g√©n√©rations**
- Ne gardez pas qu'un seul backup
- R√©tention progressive (7j, 4w, 12m)

### 11.2. Don'ts

‚ùå **Ne faites pas confiance aveugl√©ment**
- Backup non test√© = pas de backup
- Validez toujours l'int√©grit√©

‚ùå **Ne stockez pas que localement**
- Incendie, vol, panne = perte totale
- Toujours avoir une copie off-site

‚ùå **Ne n√©gligez pas les WAL**
- Sans WAL, pas de PITR
- Surveiller l'archivage continu

‚ùå **N'oubliez pas les globals**
- R√¥les, tablespaces, configs
- pg_dumpall --globals-only

‚ùå **Ne saturez pas la production**
- Backups pendant heures creuses
- Limiter l'impact I/O (nice, ionice)

---

## 12. Outils de Monitoring Backup

### 12.1. check_postgres

```bash
# Installation
sudo apt install check-postgres

# V√©rifier l'√¢ge du dernier backup
check_postgres --action=last_vacuum --warning=25h --critical=26h
```

### 12.2. Script de V√©rification

```bash
#!/bin/bash
# /usr/local/bin/check_backup_freshness.sh

BACKUP_DIR="/backups"
MAX_AGE_HOURS=25

LATEST_BACKUP=$(find "${BACKUP_DIR}" -name "*.dump" -o -name "*.tar.gz" | sort | tail -1)

if [ -z "${LATEST_BACKUP}" ]; then
  echo "CRITICAL: No backup found"
  exit 2
fi

AGE_SECONDS=$(( $(date +%s) - $(stat -c %Y "${LATEST_BACKUP}") ))
AGE_HOURS=$(( AGE_SECONDS / 3600 ))

if [ ${AGE_HOURS} -gt ${MAX_AGE_HOURS} ]; then
  echo "CRITICAL: Latest backup is ${AGE_HOURS}h old (> ${MAX_AGE_HOURS}h)"
  exit 2
elif [ ${AGE_HOURS} -gt 24 ]; then
  echo "WARNING: Latest backup is ${AGE_HOURS}h old"
  exit 1
else
  echo "OK: Latest backup is ${AGE_HOURS}h old"
  exit 0
fi
```

---

## 13. Ressources et Documentation

### Documentation Officielle
- [PostgreSQL Backup](https://www.postgresql.org/docs/18/backup.html)
- [pg_dump](https://www.postgresql.org/docs/18/app-pgdump.html)
- [pg_basebackup](https://www.postgresql.org/docs/18/app-pgbasebackup.html)
- [PITR](https://www.postgresql.org/docs/18/continuous-archiving.html)

### Outils
- **pgBackRest** : https://pgbackrest.org/
- **Barman** : https://www.pgbarman.org/
- **WAL-G** : https://github.com/wal-g/wal-g

### Guides et Blogs
- **2ndQuadrant Backup Guide** : https://www.2ndquadrant.com/en/blog/
- **Percona PostgreSQL Backup** : https://www.percona.com/blog/
- **AWS RDS Backup** : https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html

---

## Conclusion

Les backups et le Disaster Recovery ne sont **pas optionnels** en production. Ce sont les filets de s√©curit√© qui vous permettent de dormir la nuit.

**R√©capitulatif des priorit√©s** :

1. **Jour 1** : Automatiser pg_dump quotidien + test manuel
2. **Semaine 1** : Configurer pg_basebackup + archivage WAL
3. **Semaine 2** : Backups cloud + r√®gle 3-2-1
4. **Mois 1** : Tests automatis√©s mensuels
5. **Mois 2** : Runbook DR complet + tests trimestriels

**Les trois piliers** :
1. **Backups automatis√©s** : Quotidiens, fiables, diversifi√©s
2. **Tests r√©guliers** : Mensuels, document√©s, chronom√©tr√©s
3. **Plan DR** : Document√©, accessible, pratiqu√©

> "Hope is not a strategy. Backup is."

Avec une strat√©gie de backup solide, vous ne serez jamais √† la merci d'un accident. Vos donn√©es sont prot√©g√©es, votre entreprise est r√©siliente, et vous pouvez vous concentrer sur l'innovation plut√¥t que sur la peur de perdre tout.

---

**Section suivante** : 19.6.5. Documentation runbooks

‚è≠Ô∏è [Documentation runbooks](/19-postgresql-en-production/06.5-documentation-runbooks.md)
