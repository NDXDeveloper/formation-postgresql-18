üîù Retour au [Sommaire](/SOMMAIRE.md)

# 19.4.3. Transaction Wraparound (XID exhaustion) et pr√©vention

## Introduction : Un probl√®me silencieux mais catastrophique

Le **Transaction Wraparound** (ou √©puisement des XID) est l'un des probl√®mes les plus graves que PostgreSQL puisse rencontrer. C'est comme une bombe √† retardement qui, si elle n'est pas d√©samorc√©e, peut **arr√™ter compl√®tement** votre base de donn√©es.

La bonne nouvelle ? Ce probl√®me est :
- ‚úÖ **Totalement pr√©visible** : PostgreSQL vous avertit bien √† l'avance
- ‚úÖ **Facilement √©vitable** : Avec une maintenance appropri√©e
- ‚úÖ **Automatiquement g√©r√©** : Dans la plupart des configurations modernes

Ce chapitre va vous expliquer **ce qu'est** le wraparound, **pourquoi** il se produit, **comment le d√©tecter** avant qu'il soit trop tard, et **comment le pr√©venir** d√©finitivement.

---

## Comprendre les bases : Qu'est-ce qu'un Transaction ID (XID) ?

### L'identifiant de chaque transaction

Dans PostgreSQL, **chaque transaction** re√ßoit un identifiant unique appel√© **XID** (Transaction ID). C'est un simple nombre entier.

```sql
-- Voir votre XID actuel
SELECT txid_current();
-- R√©sultat possible : 1234567
```

### Pourquoi PostgreSQL utilise des XID ?

Les XID sont au c≈ìur du syst√®me **MVCC** (Multiversion Concurrency Control) de PostgreSQL. Ils permettent de savoir :

- **Quelles versions de donn√©es** sont visibles pour quelle transaction
- **Quelle transaction** a cr√©√© ou modifi√© une ligne
- **Si une transaction** √©tait en cours avant ou apr√®s une autre

**Analogie** : Imaginez une biblioth√®que o√π chaque visiteur re√ßoit un num√©ro d'entr√©e. Ce num√©ro d√©termine quels livres (versions de donn√©es) il peut voir.

### XID dans chaque ligne de table

Chaque ligne de vos tables stocke deux XID invisibles :

```sql
-- Voir les colonnes syst√®me cach√©es d'une ligne
SELECT
    xmin,        -- XID de la transaction qui a cr√©√© la ligne
    xmax,        -- XID de la transaction qui l'a supprim√©e (0 si toujours visible)
    ctid,        -- Position physique
    *
FROM users
WHERE id = 1;
```

**Exemple de r√©sultat** :
```
 xmin    | xmax | ctid  | id | username | email
---------+------+-------+----+----------+------------------
 1002345 |    0 | (0,1) |  1 | alice    | alice@example.com
```

**Interpr√©tation** :
- `xmin = 1002345` : Ligne cr√©√©e par la transaction 1002345
- `xmax = 0` : Ligne toujours vivante (pas supprim√©e)

---

## Le probl√®me : Les limites d'un nombre entier

### XID est un entier 32 bits

PostgreSQL utilise un **entier non sign√© de 32 bits** pour les XID. Cela signifie :

```
Valeurs possibles : 0 √† 4 294 967 295 (environ 4,3 milliards)
```

### Que se passe-t-il apr√®s 4 milliards de transactions ?

Apr√®s avoir utilis√© tous les XID disponibles, PostgreSQL **recommence √† z√©ro**. C'est le **wraparound** (retour √† z√©ro).

```
Transaction 4 294 967 295  (dernier XID)
Transaction          0     (retour au d√©but - wraparound!)
Transaction          1
Transaction          2
...
```

### Le danger : La confusion temporelle

Sans pr√©caution, le wraparound cr√©erait une **catastrophe logique** :

**Sc√©nario catastrophe** :
1. Transaction XID = 100 cr√©e une ligne (xmin = 100)
2. Wraparound se produit
3. Transaction XID = 100 (nouveau tour) tente de lire les donn√©es
4. PostgreSQL pense que cette ligne a √©t√© cr√©√©e **dans le futur** !
5. La ligne devient **invisible** alors qu'elle devrait √™tre visible

**R√©sultat** : Vos donn√©es disparaissent myst√©rieusement ! üò±

---

## La solution de PostgreSQL : Les Frozen XIDs

### Le concept de "gel" (freezing)

Pour √©viter le probl√®me du wraparound, PostgreSQL **"g√®le"** (freeze) les anciennes transactions. Cela signifie :

**Avant le gel** :
```
Ligne : xmin = 1002345 (cr√©√©e par transaction 1002345)
```

**Apr√®s le gel** :
```
Ligne : xmin = 2 (valeur sp√©ciale "FrozenTransactionId")
```

La valeur sp√©ciale `2` (ou `FrozenTransactionId`) signifie : **"Cette ligne est visible pour toutes les transactions, peu importe le wraparound"**.

### Comment le gel fonctionne

Le gel est effectu√© par le processus **VACUUM** :

```sql
-- VACUUM g√®le les anciennes lignes
VACUUM users;

-- VACUUM FREEZE force le gel imm√©diat
VACUUM FREEZE users;
```

**Ce que VACUUM fait** :
1. Parcourt toutes les lignes de la table
2. Pour chaque ligne "ancienne" (xmin ancien)
3. Remplace xmin par FrozenTransactionId (2)
4. Marque la ligne comme "gel√©e" pour toujours

---

## Les param√®tres critiques du wraparound

PostgreSQL a plusieurs param√®tres qui contr√¥lent quand et comment le gel se produit.

### 1. vacuum_freeze_min_age

**D√©finition** : √Çge minimum (en transactions) avant qu'une ligne puisse √™tre gel√©e.

```sql
SHOW vacuum_freeze_min_age;
-- Valeur par d√©faut : 50000000 (50 millions de transactions)
```

**Signification** : VACUUM ne g√®lera une ligne que si son xmin a au moins 50 millions de transactions d'√©cart avec le XID actuel.

**Pourquoi pas geler imm√©diatement ?**
- Geler co√ªte en I/O (√©criture sur disque)
- Les lignes r√©centes peuvent encore √™tre modifi√©es
- On attend que les lignes soient "stables"

### 2. vacuum_freeze_table_age

**D√©finition** : √Çge d'une table (en transactions) qui d√©clenche un VACUUM complet pour geler.

```sql
SHOW vacuum_freeze_table_age;
-- Valeur par d√©faut : 150000000 (150 millions)
```

**Signification** : Quand la plus ancienne transaction non gel√©e d'une table atteint 150 millions de transactions d'√¢ge, VACUUM parcourt **toute la table** pour geler agressivement.

### 3. autovacuum_freeze_max_age

**D√©finition** : √Çge maximum absolu avant qu'un VACUUM d'urgence soit forc√©.

```sql
SHOW autovacuum_freeze_max_age;
-- Valeur par d√©faut : 200000000 (200 millions)
```

**Signification** : √Ä 200 millions de transactions d'√¢ge, PostgreSQL **force un VACUUM automatique** m√™me si autovacuum est d√©sactiv√©. C'est la derni√®re ligne de d√©fense.

‚ö†Ô∏è **CRITIQUE** : Si une table atteint `autovacuum_freeze_max_age`, PostgreSQL lancera un VACUUM prioritaire qui peut impacter les performances.

### 4. autovacuum_multixact_freeze_max_age

**D√©finition** : Similaire pour les MultiXacts (transactions concurrentes sur la m√™me ligne).

```sql
SHOW autovacuum_multixact_freeze_max_age;
-- Valeur par d√©faut : 400000000 (400 millions)
```

---

## D√©tection : Surveiller l'√¢ge des transactions

### M√©thode 1 : V√©rifier l'√¢ge global de la base de donn√©es

```sql
-- √Çge de la base de donn√©es (en transactions)
SELECT
    datname,
    age(datfrozenxid) AS age_in_transactions,
    datfrozenxid
FROM pg_database
ORDER BY age(datfrozenxid) DESC;
```

**Exemple de r√©sultat** :
```
 datname  | age_in_transactions | datfrozenxid
----------+---------------------+--------------
 mydb     |          95000000   |      1005000
 postgres |           2000000   |      1098000
 template1|           1500000   |      1098500
```

**Interpr√©tation** :
- `age_in_transactions` : Nombre de transactions depuis le dernier gel complet
- Plus l'√¢ge est √©lev√©, plus on se rapproche du danger
- **ALERTE** si > 1 milliard (25% de la limite de 4 milliards)

### M√©thode 2 : V√©rifier l'√¢ge par table

```sql
SELECT
    schemaname,
    tablename,
    age(relfrozenxid) AS age_in_transactions,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_catalog.pg_tables t
JOIN pg_catalog.pg_class c ON c.relname = t.tablename
ORDER BY age(relfrozenxid) DESC
LIMIT 20;
```

**Exemple de r√©sultat** :
```
 schemaname | tablename | age_in_transactions |  size
------------+-----------+---------------------+---------
 public     | logs      |          180000000  | 250 GB
 public     | events    |          170000000  | 180 GB
 public     | users     |           50000000  | 15 GB
```

**Interpr√©tation** :
- La table `logs` approche dangereusement de `autovacuum_freeze_max_age` (200M)
- Elle a besoin d'un VACUUM urgent

### M√©thode 3 : Pourcentage avant le wraparound

```sql
SELECT
    datname,
    age(datfrozenxid) AS age_in_transactions,
    round(100.0 * age(datfrozenxid) / 2000000000, 2) AS percent_towards_wraparound
FROM pg_database
ORDER BY age(datfrozenxid) DESC;
```

**Exemple de r√©sultat** :
```
 datname  | age_in_transactions | percent_towards_wraparound
----------+---------------------+---------------------------
 mydb     |          180000000  |                      9.00
 postgres |            2000000  |                      0.10
```

**Seuils d'alerte** :
- **< 5%** : Tout va bien ‚úÖ
- **5-10%** : Surveiller üëÄ
- **10-20%** : Attention, planifier maintenance ‚ö†Ô∏è
- **> 20%** : URGENT, action imm√©diate requise üö®

### M√©thode 4 : V√©rifier les warnings PostgreSQL

PostgreSQL √©met des warnings dans les logs :

```
WARNING: database "mydb" must be vacuumed within 11000000 transactions
HINT: To avoid a database shutdown, execute a database-wide VACUUM in "mydb".
```

**V√©rifier les logs** :
```bash
sudo tail -f /var/log/postgresql/postgresql-*.log | grep -i "wraparound\|must be vacuumed"
```

---

## Les zones de danger : Comprendre les seuils

Voici les √©tapes progressives vers le wraparound :

```
         0 --------------------------- 200M ------------------------- 2B ---------------------------- 4B
         |                              |                            |                              |
         Transactions cr√©√©es    autovacuum_freeze_max_age    Wraparound Warning          Shutdown!
                                   (VACUUM forc√©)              (PostgreSQL alerte)      (Arr√™t pour protection)
```

### Zone verte (0 - 200M transactions)

‚úÖ **Tout va bien**
- Autovacuum fonctionne normalement
- Le gel se fait automatiquement

### Zone orange (200M - 2B transactions)

‚ö†Ô∏è **Attention requise**
- Autovacuum se d√©clenche en mode agressif
- Performance peut √™tre affect√©e
- **Action** : Investiguer pourquoi VACUUM n'a pas fonctionn√©

### Zone rouge (2B - 2.1B transactions)

üö® **DANGER CRITIQUE**
- PostgreSQL √©met des warnings constants
- Base de donn√©es en mode "survie"
- **Action** : VACUUM manuel d'urgence

### Zone noire (> 2.1B transactions)

üíÄ **CATASTROPHE**
- PostgreSQL **refuse toutes les nouvelles transactions**
- Seules les op√©rations VACUUM sont autoris√©es
- Database en **lecture seule forc√©e**

**Message d'erreur** :
```
ERROR: database is not accepting commands to avoid wraparound data loss in database "mydb"
HINT: Stop the postmaster and vacuum that database in single-user mode.
```

---

## Pr√©vention : Les bonnes pratiques

### 1. V√©rifier qu'autovacuum est activ√©

```sql
-- V√©rifier globalement
SHOW autovacuum;
-- R√©sultat attendu : on

-- V√©rifier pour une table sp√©cifique
SELECT
    schemaname,
    tablename,
    (reloptions::text LIKE '%autovacuum_enabled=off%') AS autovacuum_disabled
FROM pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema');
```

**Si autovacuum est d√©sactiv√© sur une table** :

```sql
-- R√©activer autovacuum pour une table
ALTER TABLE my_table SET (autovacuum_enabled = true);

-- Ou supprimer le param√®tre pour utiliser la config globale
ALTER TABLE my_table RESET (autovacuum_enabled);
```

‚ö†Ô∏è **IMPORTANT** : Ne JAMAIS d√©sactiver autovacuum globalement en production !

### 2. Configurer autovacuum de mani√®re appropri√©e

```sql
-- Dans postgresql.conf

# Activer autovacuum (OBLIGATOIRE)
autovacuum = on

# Nombre de workers (augmenter pour grandes bases)
autovacuum_max_workers = 6

# Fr√©quence de v√©rification (par d√©faut : 1 minute)
autovacuum_naptime = 1min

# Nouveaut√© PG 18 : Ajustement dynamique des workers
autovacuum_worker_slots = 10

# Seuils de d√©clenchement (par d√©faut souvent suffisant)
autovacuum_vacuum_threshold = 50
autovacuum_vacuum_scale_factor = 0.2

# Nouveaut√© PG 18 : Seuil max pour grandes tables
autovacuum_vacuum_max_threshold = 1000000
```

### 3. Monitoring et alertes proactives

Cr√©ez une vue pour monitorer facilement :

```sql
CREATE OR REPLACE VIEW v_wraparound_monitoring AS
SELECT
    datname,
    age(datfrozenxid) AS age_in_transactions,
    round(100.0 * age(datfrozenxid) / 2000000000, 2) AS percent_towards_wraparound,
    CASE
        WHEN age(datfrozenxid) < 100000000 THEN 'OK'
        WHEN age(datfrozenxid) < 200000000 THEN 'WATCH'
        WHEN age(datfrozenxid) < 1000000000 THEN 'WARNING'
        ELSE 'CRITICAL'
    END AS status,
    2000000000 - age(datfrozenxid) AS transactions_until_emergency
FROM pg_database
ORDER BY age(datfrozenxid) DESC;

-- Consulter facilement
SELECT * FROM v_wraparound_monitoring;
```

**Configurer des alertes** :

```sql
-- Cr√©er une fonction d'alerte
CREATE OR REPLACE FUNCTION check_wraparound_danger()
RETURNS TABLE(datname name, age bigint, percent numeric, status text) AS $$
BEGIN
    RETURN QUERY
    SELECT
        d.datname,
        age(d.datfrozenxid)::bigint AS age,
        round(100.0 * age(d.datfrozenxid) / 2000000000, 2) AS percent,
        CASE
            WHEN age(d.datfrozenxid) > 1000000000 THEN 'CRITICAL'
            WHEN age(d.datfrozenxid) > 200000000 THEN 'WARNING'
            ELSE 'OK'
        END AS status
    FROM pg_database d
    WHERE age(d.datfrozenxid) > 200000000;
END;
$$ LANGUAGE plpgsql;

-- Planifier avec pg_cron
SELECT cron.schedule(
    'check-wraparound',
    '0 */4 * * *',  -- Toutes les 4 heures
    'SELECT * FROM check_wraparound_danger()'
);
```

### 4. VACUUM manuel pr√©ventif pour tables critiques

Pour les tr√®s grandes tables :

```sql
-- Identifier les tables probl√©matiques
SELECT
    schemaname || '.' || tablename AS full_table_name,
    age(relfrozenxid) AS age_in_transactions,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
    last_vacuum,
    last_autovacuum
FROM pg_catalog.pg_tables t
JOIN pg_catalog.pg_class c ON c.relname = t.tablename
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
  AND age(relfrozenxid) > 150000000
ORDER BY age(relfrozenxid) DESC;

-- VACUUM manuel avec monitoring
\timing on
VACUUM (VERBOSE, ANALYZE) large_table;
```

**Option pour tables tr√®s volumineuses** :

```sql
-- VACUUM par morceaux (attention : technique avanc√©e)
-- Augmenter temporairement maintenance_work_mem
SET maintenance_work_mem = '4GB';
VACUUM (VERBOSE, ANALYZE) huge_table;
RESET maintenance_work_mem;
```

### 5. Planification de VACUUM pendant heures creuses

Si VACUUM impacte vos performances :

```sql
-- Utiliser pg_cron pour planifier la nuit
SELECT cron.schedule(
    'vacuum-large-tables',
    '0 2 * * *',  -- 2h du matin tous les jours
    $$VACUUM (VERBOSE, ANALYZE) logs$$
);

SELECT cron.schedule(
    'vacuum-events',
    '0 3 * * *',
    $$VACUUM (VERBOSE, ANALYZE) events$$
);
```

**Alternative avec crontab syst√®me** :

```bash
# √âditer crontab
crontab -e

# Ajouter
0 2 * * * /usr/bin/psql -U postgres -d mydb -c "VACUUM (VERBOSE) logs;" >> /var/log/vacuum.log 2>&1
```

### 6. Ajuster les co√ªts de VACUUM

Si VACUUM est trop agressif et impacte les performances :

```sql
-- Dans postgresql.conf

# Limiter l'impact I/O de VACUUM (valeurs plus basses = moins agressif)
vacuum_cost_delay = 10ms          # Pause entre op√©rations (0 = aucune pause)
vacuum_cost_page_hit = 1          # Co√ªt page en cache
vacuum_cost_page_miss = 10        # Co√ªt page lue depuis disque
vacuum_cost_page_dirty = 20       # Co√ªt page √©crite
vacuum_cost_limit = 200           # Limite avant pause

# Pour autovacuum sp√©cifiquement
autovacuum_vacuum_cost_delay = 2ms
autovacuum_vacuum_cost_limit = 200
```

**Augmenter la vitesse pour maintenance urgente** :

```sql
-- Augmenter temporairement pour VACUUM manuel rapide
SET vacuum_cost_delay = 0;  -- Aucune pause, pleine vitesse
VACUUM logs;
RESET vacuum_cost_delay;
```

---

## R√©solution d'urgence : Table en danger critique

### Sc√©nario : Table approche autovacuum_freeze_max_age

```sql
-- Identifier la table en danger
SELECT
    schemaname || '.' || tablename AS table_name,
    age(relfrozenxid) AS age,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_catalog.pg_tables t
JOIN pg_catalog.pg_class c ON c.relname = t.tablename
WHERE age(relfrozenxid) > 180000000
ORDER BY age(relfrozenxid) DESC
LIMIT 5;
```

### Solution 1 : VACUUM manuel imm√©diat

```sql
-- Option 1 : VACUUM standard (recommand√©)
VACUUM (VERBOSE, ANALYZE) problematic_table;

-- Option 2 : VACUUM FREEZE (plus agressif, g√®le tout)
VACUUM (FREEZE, VERBOSE, ANALYZE) problematic_table;
```

**Surveiller la progression** :

```sql
-- Dans une autre session, monitorer
SELECT
    pid,
    phase,
    heap_blks_total,
    heap_blks_scanned,
    heap_blks_vacuumed,
    round(100.0 * heap_blks_scanned / NULLIF(heap_blks_total, 0), 2) AS percent_complete
FROM pg_stat_progress_vacuum
WHERE relid = 'problematic_table'::regclass;
```

### Solution 2 : Pour table vraiment √©norme (> 1TB)

Si VACUUM complet prend trop de temps, consid√©rez le partitionnement :

```sql
-- Nouvelle table partitionn√©e
CREATE TABLE logs_new (
    id BIGSERIAL,
    message TEXT,
    created_at TIMESTAMP
) PARTITION BY RANGE (created_at);

-- Cr√©er des partitions
CREATE TABLE logs_2024_01 PARTITION OF logs_new
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE logs_2024_02 PARTITION OF logs_new
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
-- ...

-- Migrer progressivement avec INSERT ... SELECT
-- En plusieurs transactions pour ne pas bloquer
BEGIN;
INSERT INTO logs_new
SELECT * FROM logs
WHERE created_at >= '2024-01-01' AND created_at < '2024-01-02';
COMMIT;
-- R√©p√©ter par jour ou semaine
```

---

## Cas d'urgence extr√™me : Base de donn√©es en lecture seule

Si PostgreSQL refuse les nouvelles transactions :

```
ERROR: database is not accepting commands to avoid wraparound data loss
```

### √âtape 1 : Ne pas paniquer üòÖ

C'est une **protection**, pas une destruction. PostgreSQL prot√®ge vos donn√©es.

### √âtape 2 : Mode single-user

```bash
# 1. Arr√™ter PostgreSQL
sudo systemctl stop postgresql

# 2. D√©marrer en mode single-user
sudo -u postgres postgres --single -D /var/lib/postgresql/data mydb

# 3. Dans le mode single-user, ex√©cuter VACUUM
VACUUM FREEZE;

# 4. Quitter (Ctrl+D)

# 5. Red√©marrer normalement
sudo systemctl start postgresql
```

### √âtape 3 : VACUUM agressif de toutes les bases

```sql
-- Une fois la base red√©marr√©e
VACUUM (FREEZE, VERBOSE) ANALYZE;

-- Pour chaque base de donn√©es
\c mydb
VACUUM (FREEZE, VERBOSE) ANALYZE;

\c otherdb
VACUUM (FREEZE, VERBOSE) ANALYZE;
```

### √âtape 4 : V√©rifier que tout est revenu √† la normale

```sql
SELECT
    datname,
    age(datfrozenxid) AS age,
    round(100.0 * age(datfrozenxid) / 2000000000, 2) AS percent
FROM pg_database
ORDER BY age DESC;
```

L'√¢ge devrait √™tre redescendu √† quelques millions de transactions.

---

## Nouveaut√©s PostgreSQL 18 concernant VACUUM

PostgreSQL 18 apporte plusieurs am√©liorations pour VACUUM :

### 1. Statistiques VACUUM enrichies

```sql
-- Nouveaut√© PG 18 : Statistiques d√©taill√©es dans pg_stat_all_tables
SELECT
    schemaname,
    tablename,
    last_vacuum,
    last_autovacuum,
    vacuum_count,
    autovacuum_count,
    n_tup_ins,          -- Lignes ins√©r√©es
    n_tup_upd,          -- Lignes mises √† jour
    n_tup_del,          -- Lignes supprim√©es
    n_live_tup,         -- Lignes vivantes
    n_dead_tup,         -- Lignes mortes (√† nettoyer)
    last_analyze,
    last_autoanalyze
FROM pg_stat_all_tables
WHERE schemaname = 'public'
ORDER BY n_dead_tup DESC;
```

### 2. Autovacuum plus intelligent

```sql
-- Nouveaut√© PG 18 : Param√®tres dynamiques
-- Dans postgresql.conf

# Workers ajustables dynamiquement
autovacuum_worker_slots = 10

# Seuil maximum pour √©viter autovacuum trop fr√©quent sur √©normes tables
autovacuum_vacuum_max_threshold = 1000000
```

### 3. Statistiques I/O et WAL par backend

```sql
-- Suivre le WAL g√©n√©r√© (indication de l'activit√©)
SELECT
    datname,
    sum(wal_bytes) AS total_wal_bytes,
    pg_size_pretty(sum(wal_bytes)) AS total_wal_size
FROM pg_stat_database
GROUP BY datname
ORDER BY sum(wal_bytes) DESC;
```

---

## Monitoring automatis√© avec scripts

### Script bash de monitoring quotidien

```bash
#!/bin/bash
# wraparound_check.sh

PGUSER="postgres"
PGDATABASE="postgres"
THRESHOLD_WARNING=200000000
THRESHOLD_CRITICAL=1000000000

# V√©rifier l'√¢ge des bases
RESULT=$(psql -U $PGUSER -d $PGDATABASE -t -c "
SELECT
    datname || ': ' || age(datfrozenxid)
FROM pg_database
WHERE age(datfrozenxid) > $THRESHOLD_WARNING
ORDER BY age(datfrozenxid) DESC;
")

if [ -n "$RESULT" ]; then
    echo "‚ö†Ô∏è WRAPAROUND WARNING ‚ö†Ô∏è"
    echo "$RESULT"

    # V√©rifier si critique
    CRITICAL=$(psql -U $PGUSER -d $PGDATABASE -t -c "
    SELECT COUNT(*)
    FROM pg_database
    WHERE age(datfrozenxid) > $THRESHOLD_CRITICAL;
    ")

    if [ "$CRITICAL" -gt 0 ]; then
        echo "üö® CRITICAL: Immediate action required!"
        # Envoyer alerte (email, Slack, etc.)
    fi
else
    echo "‚úÖ All databases are safe from wraparound"
fi
```

**Planifier avec cron** :

```bash
# Tous les jours √† 8h
0 8 * * * /usr/local/bin/wraparound_check.sh >> /var/log/wraparound_check.log 2>&1
```

### Int√©gration avec Prometheus

```yaml
# prometheus.yml - Alertes wraparound

groups:
  - name: postgresql_wraparound
    rules:
      - alert: PostgreSQLWraparoundWarning
        expr: pg_database_age > 200000000
        for: 1h
        labels:
          severity: warning
        annotations:
          summary: "PostgreSQL database {{ $labels.datname }} approaching wraparound"
          description: "Age: {{ $value }} transactions"

      - alert: PostgreSQLWraparoundCritical
        expr: pg_database_age > 1000000000
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "PostgreSQL database {{ $labels.datname }} in CRITICAL wraparound danger!"
          description: "Age: {{ $value }} transactions - IMMEDIATE ACTION REQUIRED"
```

---

## FAQ : Questions fr√©quentes

### Q1 : Combien de temps prend un VACUUM FREEZE ?

**R√©ponse** : D√©pend de la taille de la table et du disque.

**Estimation approximative** :
- Table 10 GB sur SSD : ~5-15 minutes
- Table 100 GB sur SSD : ~30-90 minutes
- Table 1 TB sur SSD : ~5-15 heures

**Facteurs d'acc√©l√©ration** :
- Augmenter `maintenance_work_mem`
- Utiliser SSD NVMe
- Mettre `vacuum_cost_delay = 0` temporairement

### Q2 : VACUUM bloque-t-il les lectures/√©critures ?

**R√©ponse** :
- ‚ùå VACUUM normal **ne bloque pas** les lectures ni les √©critures
- ‚ö†Ô∏è VACUUM FULL **bloque tout** (exclusif), √©vitez-le en production
- ‚úÖ VACUUM FREEZE se comporte comme VACUUM normal (non bloquant)

### Q3 : Puis-je annuler un VACUUM en cours ?

**R√©ponse** : Oui, avec `pg_cancel_backend(pid)` ou `pg_terminate_backend(pid)`.

**Cons√©quence** : Le travail d√©j√† fait est conserv√©, mais la table n'est pas compl√®tement gel√©e.

### Q4 : Que faire si autovacuum ne s'ex√©cute jamais ?

**Causes possibles** :
1. Autovacuum d√©sactiv√© (v√©rifier avec `SHOW autovacuum;`)
2. Pas assez de workers (`autovacuum_max_workers` trop faible)
3. Transactions longues bloquent VACUUM
4. `vacuum_cost_delay` trop √©lev√© (VACUUM trop lent)

**Solution** :
```sql
-- V√©rifier les verrous
SELECT * FROM pg_stat_activity WHERE state = 'active' AND query_start < now() - interval '1 hour';

-- Augmenter les workers
ALTER SYSTEM SET autovacuum_max_workers = 6;
SELECT pg_reload_conf();
```

### Q5 : Les r√©plicas ont-ils aussi besoin de VACUUM ?

**R√©ponse** :
- **R√©plication physique** : Les r√©plicas re√ßoivent les modifications VACUUM automatiquement
- **R√©plication logique** : Oui, chaque instance doit faire son propre VACUUM

---

## Checklist de pr√©vention du wraparound

### Quotidien

- [ ] V√©rifier que autovacuum est actif
- [ ] Consulter les logs pour warnings
- [ ] V√©rifier via monitoring (Grafana, Prometheus)

### Hebdomadaire

- [ ] Ex√©cuter la requ√™te de monitoring : `SELECT * FROM v_wraparound_monitoring;`
- [ ] V√©rifier les tables avec `age(relfrozenxid) > 100M`
- [ ] Analyser les statistiques de VACUUM : `SELECT * FROM pg_stat_user_tables;`

### Mensuel

- [ ] VACUUM manuel des tables les plus volumineuses
- [ ] V√©rifier la configuration autovacuum
- [ ] Analyser l'efficacit√© de VACUUM (logs)
- [ ] V√©rifier disk space (VACUUM n√©cessite espace temporaire)

### Trimestriel

- [ ] Revoir les param√®tres `autovacuum_freeze_max_age`, `vacuum_freeze_min_age`
- [ ] Tester un VACUUM FREEZE complet en maintenance
- [ ] Auditer les tables avec autovacuum d√©sactiv√©

---

## Configuration recommand√©e

### Pour base de donn√©es standard (< 500 GB)

```ini
# postgresql.conf

# Autovacuum
autovacuum = on
autovacuum_max_workers = 3
autovacuum_naptime = 1min
autovacuum_vacuum_threshold = 50
autovacuum_vacuum_scale_factor = 0.2

# Freeze
vacuum_freeze_min_age = 50000000
vacuum_freeze_table_age = 150000000
autovacuum_freeze_max_age = 200000000

# Performance VACUUM
maintenance_work_mem = 1GB
autovacuum_work_mem = -1  # Utilise maintenance_work_mem
autovacuum_vacuum_cost_delay = 2ms
```

### Pour tr√®s grande base (> 1 TB)

```ini
# postgresql.conf

# Plus de workers pour parall√©liser
autovacuum_max_workers = 8
autovacuum_worker_slots = 12  # PG 18

# Seuils ajust√©s pour grandes tables
autovacuum_vacuum_scale_factor = 0.05  # 5% au lieu de 20%
autovacuum_vacuum_max_threshold = 5000000  # PG 18

# Plus de m√©moire
maintenance_work_mem = 4GB

# Freeze plus agressif pour √©viter accumulation
vacuum_freeze_table_age = 100000000
autovacuum_freeze_max_age = 150000000
```

---

## Outils de diagnostic avanc√©s

### Extension pg_visibility

```sql
-- Installer l'extension
CREATE EXTENSION pg_visibility;

-- V√©rifier les pages gel√©es d'une table
SELECT
    all_visible,
    all_frozen,
    count(*)
FROM pg_visibility_map('large_table')
GROUP BY all_visible, all_frozen;
```

**Interpr√©tation** :
- `all_frozen = true` : Pages compl√®tement gel√©es (bon)
- `all_frozen = false` : Pages n√©cessitant un gel

### Extension pgstattuple

```sql
-- Installer
CREATE EXTENSION pgstattuple;

-- Analyser une table
SELECT
    table_len,
    tuple_count,
    tuple_len,
    tuple_percent,
    dead_tuple_count,
    dead_tuple_len,
    dead_tuple_percent,
    free_space,
    free_percent
FROM pgstattuple('large_table');
```

**Utilisation** : Identifier les tables avec beaucoup de lignes mortes n√©cessitant VACUUM.

---

## Ressources compl√©mentaires

- **Documentation officielle** : [Routine Database Maintenance](https://www.postgresql.org/docs/current/routine-vacuuming.html)
- **Wiki PostgreSQL** : [Vacuum](https://wiki.postgresql.org/wiki/Vacuum)
- **Blog 2ndQuadrant** : "Understanding Transaction ID Wraparound"
- **Percona Blog** : "PostgreSQL Vacuum and Wraparound"

---

## R√©sum√© des points cl√©s

‚úÖ **XID (Transaction ID)** : Identifiant unique de chaque transaction, limit√© √† 4 milliards

‚úÖ **Wraparound** : Retour √† z√©ro des XID apr√®s 4 milliards, causant confusion temporelle

‚úÖ **Freezing** : PostgreSQL "g√®le" les anciennes transactions pour √©viter le wraparound

‚úÖ **VACUUM** : Processus qui g√®le les lignes et pr√©vient le wraparound

‚úÖ **autovacuum_freeze_max_age** : 200M par d√©faut, limite critique √† 2 milliards

‚úÖ **Monitoring** : V√©rifier `age(datfrozenxid)` r√©guli√®rement

‚úÖ **Alertes** : Mettre en place monitoring proactif (< 5% = OK, > 20% = URGENT)

‚úÖ **Pr√©vention** : Autovacuum activ√© + configuration appropri√©e + monitoring

‚úÖ **Urgence** : VACUUM FREEZE manuel si table approche limite

‚úÖ **Protection finale** : PostgreSQL refuse les transactions pour prot√©ger les donn√©es

---

## Conclusion

Le Transaction Wraparound peut sembler effrayant, mais c'est un probl√®me **totalement ma√Ætrisable** avec :

1. **Autovacuum activ√©** (ne JAMAIS d√©sactiver)
2. **Monitoring r√©gulier** de `age(datfrozenxid)`
3. **Alertes proactives** avant d'atteindre les seuils critiques
4. **Maintenance planifi√©e** pour les tr√®s grandes tables

PostgreSQL vous prot√®ge avec plusieurs niveaux de d√©fense :
- Autovacuum automatique
- VACUUM forc√© √† 200M transactions
- Warnings dans les logs
- Mode lecture seule en dernier recours

Avec une configuration appropri√©e et un monitoring minimal, vous ne devriez **jamais** rencontrer ce probl√®me en production. Le wraparound n'est un danger que pour les bases de donn√©es mal maintenues ou avec autovacuum d√©sactiv√©.

**Votre meilleure d√©fense** : Laissez autovacuum faire son travail, et surveillez occasionnellement que tout va bien !

---

**Prochaine √©tape** : 19.4.4 - Corruption de donn√©es et Checksums

---


‚è≠Ô∏è [Corruption de donn√©es et Checksums](/19-postgresql-en-production/04.4-corruption-donnees-checksums.md)
