ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 19.3.4. StratÃ©gies Blue/Green et Logical Replication

## Introduction

Pour les environnements critiques nÃ©cessitant un **downtime minimal** (voire quasi-nul) lors des migrations PostgreSQL, deux stratÃ©gies avancÃ©es se distinguent : le **dÃ©ploiement Blue/Green** et la **rÃ©plication logique**. Ces approches permettent de migrer vers PostgreSQL 18 avec un impact minimal sur la disponibilitÃ© du service.

## Le concept Blue/Green Deployment

### Qu'est-ce que Blue/Green ?

Le dÃ©ploiement Blue/Green est une technique oÃ¹ vous maintenez **deux environnements identiques** :
- **Blue (Bleu)** : L'environnement actuel en production
- **Green (Vert)** : Le nouvel environnement (nouvelle version)

L'idÃ©e est de basculer instantanÃ©ment du Blue vers le Green une fois que ce dernier est prÃªt.

### Analogie simple : Le restaurant

Imaginez un restaurant qui veut rÃ©nover complÃ¨tement sa cuisine :

**Approche traditionnelle (avec downtime)** :
```
1. Fermer le restaurant (downtime)
2. RÃ©nover la cuisine (plusieurs heures/jours)
3. Rouvrir le restaurant
â†’ Clients mÃ©contents, perte de revenus
```

**Approche Blue/Green** :
```
1. Construire une nouvelle cuisine Ã  cÃ´tÃ© (Green)
2. La prÃ©parer entiÃ¨rement pendant que l'ancienne (Blue) fonctionne
3. Ã€ minuit, faire basculer les commandes vers la nouvelle cuisine
4. Downtime : 5 minutes (temps de basculement)
â†’ Clients satisfaits, impact minimal
```

### SchÃ©ma conceptuel

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Avant la migration (Production sur Blue)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚         Applications                                        â”‚
â”‚              â†“                                              â”‚
â”‚         Load Balancer                                       â”‚
â”‚              â†“                                              â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚    â”‚  Blue (PG 17)   â”‚         â”‚  Green (PG 18)  â”‚          â”‚
â”‚    â”‚  âœ… ACTIF       â”‚         â”‚  ğŸ”¨ En prÃ©paration         â”‚
â”‚    â”‚  Production     â”‚         â”‚  Tests en cours â”‚          â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  AprÃ¨s la migration (Production sur Green)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚         Applications                                        â”‚
â”‚              â†“                                              â”‚
â”‚         Load Balancer                                       â”‚
â”‚              â†“                                              â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚    â”‚  Blue (PG 17)   â”‚         â”‚  Green (PG 18)  â”‚          â”‚
â”‚    â”‚  ğŸ’¤ Standby     â”‚         â”‚  âœ… ACTIF       â”‚          â”‚
â”‚    â”‚  Backup         â”‚         â”‚  Production     â”‚          â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Les avantages clÃ©s

```
âœ… Downtime minimal : Seulement le temps de basculement (secondes Ã  minutes)
âœ… Rollback instantanÃ© : Si problÃ¨me, on rebascule sur Blue
âœ… Tests en conditions rÃ©elles : Green peut Ãªtre testÃ© avant bascule
âœ… Validation progressive : Migration par Ã©tapes
âœ… SÃ©rÃ©nitÃ© : Filet de sÃ©curitÃ© permanent
```

## La RÃ©plication Logique (Logical Replication)

### Qu'est-ce que la rÃ©plication logique ?

La **rÃ©plication logique** est une fonctionnalitÃ© PostgreSQL qui permet de copier les donnÃ©es d'une base (source) vers une autre (cible) en temps rÃ©el, au niveau logique (lignes de donnÃ©es) plutÃ´t qu'au niveau physique (blocs disque).

### DiffÃ©rence avec la rÃ©plication physique

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  RÃ©plication Physique (Streaming Replication)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  Master (PG 17)  â”€â”€â”€â”€ WAL bytes â”€â”€â”€â”€â†’  Replica (PG 17)      â”‚
â”‚                       (binaire)                             â”‚
â”‚                                                             â”‚
â”‚  CaractÃ©ristiques :                                         â”‚
â”‚  â€¢ MÃªme version PostgreSQL obligatoire                      â”‚
â”‚  â€¢ Copie bloc par bloc (niveau disque)                      â”‚
â”‚  â€¢ RÃ©plique TOUTE la base                                   â”‚
â”‚  â€¢ UtilisÃ© pour HA (Haute DisponibilitÃ©)                    â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  RÃ©plication Logique                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  Source (PG 17)  â”€â”€â”€â”€ Changes (SQL) â”€â”€â”€â”€â†’  Target (PG 18)   â”‚
â”‚                       (logique)                             â”‚
â”‚                                                             â”‚
â”‚  CaractÃ©ristiques :                                         â”‚
â”‚  â€¢ Versions diffÃ©rentes possibles âœ… (17 â†’ 18)              â”‚
â”‚  â€¢ RÃ©plique au niveau des lignes                            â”‚
â”‚  â€¢ SÃ©lection des tables Ã  rÃ©pliquer                         â”‚
â”‚  â€¢ UtilisÃ© pour migrations, intÃ©grations                    â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Concepts clÃ©s

#### 1. Publication (Publication)

Une **publication** dÃ©finit quelles donnÃ©es seront rÃ©pliquÃ©es depuis la source :

```sql
-- Sur la source (PG 17)
-- "Je publie ces tables pour que d'autres puissent les recevoir"

CREATE PUBLICATION my_migration_pub
FOR ALL TABLES;  -- Toutes les tables

-- Ou de maniÃ¨re sÃ©lective
CREATE PUBLICATION my_migration_pub
FOR TABLE users, orders, products;  -- Tables spÃ©cifiques
```

**Analogie** : C'est comme un journal qui dÃ©cide quels articles publier.

#### 2. Subscription (Souscription)

Une **souscription** dÃ©finit comment la cible reÃ§oit les donnÃ©es :

```sql
-- Sur la cible (PG 18)
-- "Je m'abonne Ã  cette publication pour recevoir les donnÃ©es"

CREATE SUBSCRIPTION my_migration_sub
CONNECTION 'host=pg17-server dbname=mydb user=repl_user password=secret'
PUBLICATION my_migration_pub;
```

**Analogie** : C'est comme s'abonner Ã  un journal pour recevoir les articles.

#### 3. Replication Slot

Un **slot de rÃ©plication** garantit que les changements ne sont pas perdus :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Fonctionnement du Replication Slot                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  Source (PG 17) :                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚ Changements :                           â”‚                â”‚
â”‚  â”‚ [1][2][3][4][5][6][7][8][9][10]         â”‚                â”‚
â”‚  â”‚           â†‘                             â”‚                â”‚
â”‚  â”‚       Slot position                     â”‚                â”‚
â”‚  â”‚   (dernier changement envoyÃ©)           â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                             â”‚
â”‚  Le slot garde en mÃ©moire/WAL tous les changements          â”‚
â”‚  non encore envoyÃ©s Ã  la cible                              â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Fonctionnement en temps rÃ©el

```
Temps T0 : Source (PG 17)          Target (PG 18)
           users: 1000 rows  â”€â”€â”€â”€â”€â†’ users: 1000 rows (copie initiale)

Temps T1 : INSERT nouveau user (id=1001)
           users: 1001 rows  â”€â”€â”€â”€â”€â†’ Replication logique
                                    users: 1001 rows (synchronisÃ©)

Temps T2 : UPDATE user id=500
           users: modifiÃ©    â”€â”€â”€â”€â”€â†’ Replication logique
                                    users: modifiÃ© (synchronisÃ©)

Temps T3 : DELETE user id=50
           users: 1000 rows  â”€â”€â”€â”€â”€â†’ Replication logique
                                    users: 1000 rows (synchronisÃ©)

Les deux bases restent synchronisÃ©es en continu !
```

## StratÃ©gie Blue/Green avec Logical Replication

### Vue d'ensemble

La combinaison de Blue/Green et de la rÃ©plication logique est la stratÃ©gie **la plus avancÃ©e** pour les migrations critiques :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  StratÃ©gie Blue/Green + Logical Replication                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  Phase 1 : Setup (Jour J-7)                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ Blue (17)  â”‚ â”€â”€â”€â”€ replication â”€â†’â”‚ Green (18) â”‚           â”‚
â”‚  â”‚ Production â”‚     logique        â”‚ Standby    â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚        â†“                                                    â”‚
â”‚   Applications                                              â”‚
â”‚                                                             â”‚
â”‚  Phase 2 : Synchronisation (J-7 Ã  J-Day)                    â”‚
â”‚  Blue et Green restent synchronisÃ©s en continu              â”‚
â”‚  Tests possibles sur Green sans impacter Blue               â”‚
â”‚                                                             â”‚
â”‚  Phase 3 : Cutover (J-Day, 5 minutes)                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ Blue (17)  â”‚                    â”‚ Green (18) â”‚           â”‚
â”‚  â”‚ Standby    â”‚                    â”‚ Production â”‚â†â”€â”€â”       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚       â”‚
â”‚                                           â†‘         â”‚       â”‚
â”‚                                      Applications   â”‚       â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ã‰tapes dÃ©taillÃ©es

#### Ã‰tape 1 : PrÃ©paration (J-7 Ã  J-1)

**Sur le serveur source (Blue - PG 17)** :

```sql
-- 1. Configurer PostgreSQL pour la rÃ©plication logique
-- Ã‰diter postgresql.conf
wal_level = logical  -- Au lieu de 'replica' ou 'minimal'
max_replication_slots = 10  -- Suffisant pour quelques subscriptions
max_wal_senders = 10

-- RedÃ©marrer PostgreSQL
-- pg_ctl restart
```

```sql
-- 2. CrÃ©er un utilisateur de rÃ©plication
CREATE ROLE replication_user WITH REPLICATION LOGIN PASSWORD 'secure_password';
GRANT SELECT ON ALL TABLES IN SCHEMA public TO replication_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public
    GRANT SELECT ON TABLES TO replication_user;
```

```sql
-- 3. Configurer pg_hba.conf pour autoriser la connexion
-- Ajouter cette ligne :
-- host    all    replication_user    <IP-Green-Server>/32    scram-sha-256
```

```sql
-- 4. CrÃ©er la publication
CREATE PUBLICATION migration_to_pg18 FOR ALL TABLES;

-- VÃ©rifier
SELECT * FROM pg_publication;
```

**Sur le serveur cible (Green - PG 18)** :

```bash
# 1. Installer PostgreSQL 18
apt-get install postgresql-18

# 2. Initialiser le cluster
initdb -D /var/lib/postgresql/18/main
```

```sql
-- 3. CrÃ©er la structure de la base (schÃ©ma uniquement)
-- Option A : pg_dump du schÃ©ma seulement
pg_dump -h pg17-server -U postgres -d mydb --schema-only | \
    psql -h localhost -U postgres -d mydb

-- Option B : CrÃ©er manuellement avec les DDL
```

```sql
-- 4. CrÃ©er la souscription
CREATE SUBSCRIPTION migration_from_pg17
CONNECTION 'host=pg17-server port=5432 dbname=mydb user=replication_user password=secure_password'
PUBLICATION migration_to_pg18
WITH (copy_data = true);  -- Copie initiale des donnÃ©es
```

**Observation** : La synchronisation initiale commence automatiquement !

```bash
# Surveiller la progression
psql -d mydb -c "
SELECT
    subname,
    pid,
    received_lsn,
    latest_end_lsn,
    latest_end_time
FROM pg_stat_subscription;
"
```

#### Ã‰tape 2 : Synchronisation continue (J-7 Ã  J-Day)

Pendant cette pÃ©riode, les deux serveurs restent synchronisÃ©s :

```
Blue (PG 17) - Production              Green (PG 18) - Standby
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Applications Ã©crivent               â† RÃ©plication logique â†’  DonnÃ©es synchronisÃ©es
en continu                                                    en temps rÃ©el

INSERT, UPDATE, DELETE  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  RÃ©pliquÃ© instantanÃ©ment
sur Blue                                              sur Green
```

**Pendant cette phase** :

```sql
-- Sur Green, vÃ©rifier que la synchronisation fonctionne
-- Compter les lignes
SELECT 'Blue', COUNT(*) FROM users;  -- Sur Blue (via connexion)
SELECT 'Green', COUNT(*) FROM users; -- Sur Green

-- Les deux doivent correspondre !
```

**Tester Green sans impact sur Blue** :

```bash
# On peut se connecter Ã  Green en lecture seule
psql -h green-server -d mydb

# Lancer des requÃªtes de test
EXPLAIN ANALYZE SELECT ...;

# VÃ©rifier les performances
# Valider que PostgreSQL 18 fonctionne comme attendu
```

#### Ã‰tape 3 : PrÃ©paration du Cutover (H-1)

```sql
-- Sur Blue, vÃ©rifier l'Ã©tat de la rÃ©plication
SELECT * FROM pg_stat_replication;

-- Sur Green, vÃ©rifier le lag (dÃ©calage)
SELECT
    now() - latest_end_time AS replication_lag
FROM pg_stat_subscription;

-- Le lag doit Ãªtre < 1 seconde pour un cutover optimal
```

```bash
# PrÃ©parer les scripts de cutover
cat > cutover.sh << 'EOF'
#!/bin/bash
set -e

echo "ğŸ”„ DÃ©but du Cutover Blue â†’ Green"

# 1. Mettre les applications en mode read-only sur Blue
echo "1. Applications en read-only..."
# (DÃ©pend de votre architecture)

# 2. Attendre que Green rattrape son retard
echo "2. Attente synchronisation finale..."
psql -h green-server -d mydb -c "
SELECT pg_sleep(5);
SELECT now() - latest_end_time AS lag FROM pg_stat_subscription;
"

# 3. DÃ©sactiver la subscription sur Green
echo "3. DÃ©sactivation subscription..."
psql -h green-server -d mydb -c "
ALTER SUBSCRIPTION migration_from_pg17 DISABLE;
"

# 4. ArrÃªter les applications
echo "4. ArrÃªt des applications..."
# systemctl stop my-app

# 5. Basculer le DNS/Load Balancer vers Green
echo "5. Bascule vers Green..."
# (DÃ©pend de votre infrastructure)

# 6. RedÃ©marrer les applications pointant vers Green
echo "6. RedÃ©marrage applications sur Green..."
# systemctl start my-app

echo "âœ… Cutover terminÃ© !"
EOF

chmod +x cutover.sh
```

#### Ã‰tape 4 : Le Cutover (FenÃªtre de maintenance)

**Timeline du cutover** :

```
T-00:00  DÃ©but de la fenÃªtre de maintenance
         â””â”€ Notifications envoyÃ©es aux utilisateurs

T+00:05  Applications en mode lecture seule (Blue)
         â””â”€ Les utilisateurs peuvent encore lire

T+00:07  VÃ©rification synchronisation Green/Blue
         â””â”€ Lag < 1 seconde confirmÃ©

T+00:08  ArrÃªt des applications
         â””â”€ DOWNTIME COMMENCE

T+00:09  DÃ©sactivation subscription sur Green
         â””â”€ Green devient autonome

T+00:10  Bascule DNS/Load Balancer vers Green
         â””â”€ Trafic redirigÃ© vers PostgreSQL 18

T+00:12  RedÃ©marrage applications sur Green
         â””â”€ Tests de fumÃ©e (smoke tests)

T+00:15  Validation fonctionnelle
         â””â”€ Quelques transactions de test

T+00:20  Ouverture au public
         â””â”€ DOWNTIME TERMINÃ‰ (12 minutes)

T+01:00  Monitoring intensif
         â””â”€ Surveillance mÃ©triques

T+24:00  Si tout OK, marquer Blue obsolÃ¨te
         â””â”€ Green devient le nouveau Blue
```

**Downtime effectif** : ~12 minutes (T+00:08 Ã  T+00:20)

#### Ã‰tape 5 : Post-Cutover et Validation

```sql
-- Sur Green (nouvelle production)
-- VÃ©rifier la version
SELECT version();
-- PostgreSQL 18.0 ...

-- VÃ©rifier les connexions
SELECT COUNT(*) FROM pg_stat_activity;

-- VÃ©rifier les donnÃ©es
SELECT COUNT(*) FROM users;
SELECT COUNT(*) FROM orders;
SELECT COUNT(*) FROM products;

-- Comparer avec les counts de Blue (avant cutover)
```

```bash
# Monitoring des performances
psql -d mydb -c "
SELECT
    schemaname,
    tablename,
    seq_scan,
    idx_scan,
    n_tup_ins,
    n_tup_upd,
    n_tup_del
FROM pg_stat_user_tables
ORDER BY seq_scan + idx_scan DESC
LIMIT 20;
"
```

```sql
-- Activer pg_stat_statements si pas dÃ©jÃ  fait
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- Surveiller les requÃªtes lentes
SELECT
    query,
    calls,
    mean_exec_time,
    total_exec_time
FROM pg_stat_statements
WHERE mean_exec_time > 100  -- > 100ms
ORDER BY mean_exec_time DESC
LIMIT 20;
```

#### Ã‰tape 6 : Rollback (si nÃ©cessaire)

Si un problÃ¨me majeur est dÃ©tectÃ© aprÃ¨s le cutover :

```bash
#!/bin/bash
# rollback.sh

echo "âš ï¸  Rollback vers Blue (PG 17)"

# 1. ArrÃªter les applications
systemctl stop my-app

# 2. Basculer DNS/Load Balancer vers Blue
# (commandes spÃ©cifiques Ã  votre infra)

# 3. RedÃ©marrer les applications sur Blue
systemctl start my-app

echo "âœ… Rollback terminÃ©. Blue (PG 17) en production."
```

**Important** : Le rollback n'est possible que si :
- Blue n'a PAS reÃ§u de nouvelles Ã©critures depuis le cutover
- Le problÃ¨me est dÃ©tectÃ© rapidement (< 1 heure gÃ©nÃ©ralement)

Pour un rollback plus tard :
- Il faudrait une rÃ©plication inverse (Green â†’ Blue)
- Ou restaurer une sauvegarde de Blue et rejouer les transactions

## Comparaison des stratÃ©gies de migration

### Tableau rÃ©capitulatif

| CritÃ¨re | pg_upgrade | pg_upgrade --swap | Blue/Green + Replication |
|---------|-----------|-------------------|-------------------------|
| **Downtime** | 2-8h | 1-4h | 5-30 min |
| **ComplexitÃ©** | ğŸŸ¢ Simple | ğŸŸ¢ Simple | ğŸ”´ Complexe |
| **Rollback** | Possible | Facile | TrÃ¨s facile |
| **CoÃ»t infra** | ğŸ’° Faible | ğŸ’° Faible | ğŸ’°ğŸ’° Moyen |
| **Risque** | ğŸŸ¡ Moyen | ğŸŸ¡ Moyen | ğŸŸ¢ Faible |
| **Tests prÃ©alables** | âŒ LimitÃ©s | âŒ LimitÃ©s | âœ…âœ… Complets |
| **Production critique** | âš ï¸ | âš ï¸ | âœ…âœ… IdÃ©al |
| **Validation progressive** | âŒ Non | âŒ Non | âœ… Oui |

### Diagramme de dÃ©cision

```
                Besoin de migrer PG 17 â†’ PG 18
                            |
                            |
                 Quel est le downtime acceptable ?
                    /              |              \
                  < 30 min      30min-4h         > 4h OK
                    |              |              |
                    |              |           pg_upgrade
                    |              |           --copy
                    |              |
                    |         pg_upgrade
                    |         --swap --jobs
                    |
              Budget et ressources ?
                /              \
           Suffisant        LimitÃ©
              |                |
         Blue/Green       pg_upgrade --swap
         + Replication    avec prÃ©paration
```

### Cas d'usage par type d'entreprise

#### Startup / PME

```
Taille base : < 500 GB
Budget : LimitÃ©
Ã‰quipe : 1-3 personnes
Downtime acceptable : 2-4h

Recommandation : pg_upgrade --swap --jobs
Raison :
- Simple Ã  mettre en Å“uvre
- CoÃ»t minimal
- Suffisant pour la plupart des cas
```

#### Entreprise moyenne

```
Taille base : 500 GB - 2 TB
Budget : Moyen
Ã‰quipe : 3-10 personnes
Downtime acceptable : 1-2h

Recommandation : pg_upgrade --swap --jobs OU Blue/Green
DÃ©cision selon :
- CriticitÃ© du service
- ExpÃ©rience Ã©quipe avec rÃ©plication
```

#### Grande entreprise / FinTech / E-commerce

```
Taille base : > 2 TB
Budget : Confortable
Ã‰quipe : 10+ personnes (DevOps, DBA)
Downtime acceptable : < 30 minutes

Recommandation : Blue/Green + Logical Replication
Raison :
- Downtime minimal requis
- CapacitÃ© Ã  tester avant bascule
- Rollback instantanÃ©
- Vaut l'investissement
```

## Architecture avancÃ©e : Multi-rÃ©gion Blue/Green

Pour les dÃ©ploiements mondiaux avec exigences de disponibilitÃ© extrÃªmes :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Architecture Multi-RÃ©gion                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  RÃ©gion US-East (Primary)                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ Blue (PG 17)  â†â”€ replication â”€â†’  Green (PG 18) |         â”‚
â”‚  â”‚ Production           logique       Standby     â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚         â†“ Physical replication                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚  â”‚ Replica (PG 17) - US-West          â”‚                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚         â†“ Physical replication                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚  â”‚ Replica (PG 17) - EU               â”‚                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚                                                             â”‚
â”‚  Migration progressive :                                    â”‚
â”‚  1. US-East Blue â†’ Green                                    â”‚
â”‚  2. Puis replicas suivent                                   â”‚
â”‚  3. Migration par rÃ©gion                                    â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## PrÃ©requis et configuration de la rÃ©plication logique

### Configuration PostgreSQL source (PG 17)

**postgresql.conf** :

```conf
# RÃ©plication logique
wal_level = logical  # CRITIQUE : nÃ©cessaire pour logical replication
max_replication_slots = 10  # Nombre de subscriptions possibles
max_wal_senders = 10  # Processus WAL sender

# Recommandations de performance
wal_sender_timeout = 60s
max_slot_wal_keep_size = 10GB  # Ã‰vite que les WAL dÃ©bordent
```

**pg_hba.conf** :

```conf
# Autoriser la rÃ©plication logique depuis Green
host    mydb    replication_user    <IP-Green>/32    scram-sha-256
host    replication    replication_user    <IP-Green>/32    scram-sha-256
```

### Configuration PostgreSQL cible (PG 18)

**postgresql.conf** :

```conf
# Rien de spÃ©cial requis pour recevoir la rÃ©plication logique
# Mais recommandations pour production :

max_worker_processes = 16  # Suffisant pour logical replication workers
max_logical_replication_workers = 8
max_sync_workers_per_subscription = 4  # ParallÃ©lisation de la copie initiale

# Performance
shared_buffers = 8GB  # Ajuster selon RAM
work_mem = 64MB
maintenance_work_mem = 2GB
```

### CrÃ©er les objets de rÃ©plication

#### Sur la source (Blue - PG 17)

```sql
-- 1. CrÃ©er l'utilisateur de rÃ©plication
CREATE USER replication_user WITH REPLICATION PASSWORD 'very_secure_password';

-- 2. Donner les permissions nÃ©cessaires
GRANT CONNECT ON DATABASE mydb TO replication_user;
GRANT USAGE ON SCHEMA public TO replication_user;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO replication_user;

-- 3. Permissions pour les futures tables
ALTER DEFAULT PRIVILEGES IN SCHEMA public
    GRANT SELECT ON TABLES TO replication_user;

-- 4. CrÃ©er la publication
-- Option A : Toutes les tables
CREATE PUBLICATION migration_pub FOR ALL TABLES;

-- Option B : Tables spÃ©cifiques
CREATE PUBLICATION migration_pub FOR TABLE
    users, orders, products, payments, reviews;

-- Option C : Certains schÃ©mas seulement
CREATE PUBLICATION migration_pub FOR TABLES IN SCHEMA public, app_schema;

-- 5. VÃ©rifier la publication
SELECT * FROM pg_publication;
SELECT * FROM pg_publication_tables;
```

#### Sur la cible (Green - PG 18)

```sql
-- 1. CrÃ©er la structure (schÃ©ma seulement)
-- Via pg_dump --schema-only ou scripts DDL

-- 2. VÃ©rifier que les tables existent et sont vides
SELECT schemaname, tablename, n_live_tup
FROM pg_stat_user_tables
WHERE schemaname = 'public';
-- Toutes doivent avoir n_live_tup = 0

-- 3. CrÃ©er la subscription
CREATE SUBSCRIPTION migration_sub
CONNECTION 'host=blue-server port=5432 dbname=mydb user=replication_user password=very_secure_password sslmode=require'
PUBLICATION migration_pub
WITH (
    copy_data = true,  -- Copie initiale des donnÃ©es
    create_slot = true,  -- CrÃ©e automatiquement un slot sur la source
    enabled = true,  -- DÃ©marre immÃ©diatement
    slot_name = 'migration_slot',
    synchronous_commit = 'off'  -- Performances
);

-- 4. VÃ©rifier l'Ã©tat
SELECT
    subname,
    subenabled,
    subslotname,
    subpublications
FROM pg_subscription;

-- 5. Surveiller la copie initiale
SELECT
    subname,
    pid,
    relid::regclass AS table_name,
    received_lsn,
    latest_end_lsn,
    latest_end_time,
    now() - latest_end_time AS lag
FROM pg_stat_subscription
JOIN pg_subscription_rel ON pg_stat_subscription.subid = pg_subscription_rel.srsubid;
```

### Surveiller la rÃ©plication

#### Sur la source (Blue)

```sql
-- Voir les slots de rÃ©plication
SELECT
    slot_name,
    slot_type,
    active,
    restart_lsn,
    confirmed_flush_lsn,
    pg_size_pretty(
        pg_wal_lsn_diff(pg_current_wal_lsn(), confirmed_flush_lsn)
    ) AS pending_wal
FROM pg_replication_slots
WHERE slot_type = 'logical';

-- Surveiller les WAL senders
SELECT
    pid,
    usename,
    application_name,
    client_addr,
    state,
    sync_state,
    pg_wal_lsn_diff(pg_current_wal_lsn(), sent_lsn) AS send_lag,
    pg_wal_lsn_diff(pg_current_wal_lsn(), write_lsn) AS write_lag,
    pg_wal_lsn_diff(pg_current_wal_lsn(), flush_lsn) AS flush_lag,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS replay_lag
FROM pg_stat_replication;
```

#### Sur la cible (Green)

```sql
-- Ã‰tat gÃ©nÃ©ral de la subscription
SELECT
    subname,
    subenabled,
    pid,
    received_lsn,
    latest_end_lsn,
    latest_end_time,
    now() - latest_end_time AS replication_lag
FROM pg_stat_subscription;

-- DÃ©tails par table
SELECT
    srsubid,
    srrelid::regclass AS table_name,
    srsubstate AS state,
    srsublsn
FROM pg_subscription_rel
ORDER BY srrelid;

-- Ã‰tats possibles :
-- 'i' = initialize (copie initiale en cours)
-- 'd' = data is being copied (copie)
-- 's' = synchronized (synchronisÃ©)
-- 'r' = ready (prÃªt)
```

### Script de monitoring complet

```bash
#!/bin/bash
# monitor_replication.sh

echo "ğŸ“Š Ã‰tat de la rÃ©plication logique"
echo "=================================="
echo ""

echo "ğŸ”µ Source (Blue - PG 17)"
psql -h blue-server -U postgres -d mydb -c "
SELECT
    slot_name,
    active,
    pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), confirmed_flush_lsn)) AS lag
FROM pg_replication_slots
WHERE slot_type = 'logical';
"

echo ""
echo "ğŸŸ¢ Cible (Green - PG 18)"
psql -h green-server -U postgres -d mydb -c "
SELECT
    subname,
    subenabled,
    now() - latest_end_time AS lag,
    CASE
        WHEN now() - latest_end_time < interval '5 seconds' THEN 'âœ… OK'
        WHEN now() - latest_end_time < interval '1 minute' THEN 'âš ï¸  Warning'
        ELSE 'âŒ Problem'
    END AS status
FROM pg_stat_subscription;
"

echo ""
echo "ğŸ“ˆ Comparaison des donnÃ©es"
psql -h blue-server -U postgres -d mydb -t -c "
SELECT 'Blue', COUNT(*) FROM users
UNION ALL
SELECT 'Green', COUNT(*) FROM users;
" | column -t

echo ""
echo "Synchronisation : $(date)"
```

## Limitations et considÃ©rations

### Limitations de la rÃ©plication logique

#### 1. Objets non rÃ©pliquÃ©s

La rÃ©plication logique ne rÃ©plique **QUE les donnÃ©es des tables**. N'est PAS rÃ©pliquÃ© :

```
âŒ SÃ©quences (SEQUENCE)
   â†’ Doivent Ãªtre synchronisÃ©es manuellement

âŒ Vues matÃ©rialisÃ©es
   â†’ Doivent Ãªtre refreshÃ©es sur la cible

âŒ Large Objects (LOBs)
   â†’ Non supportÃ©s

âŒ DDL (CREATE, ALTER, DROP)
   â†’ La structure doit exister sur la cible avant

âŒ SchÃ©mas/Databases
   â†’ Doivent Ãªtre crÃ©Ã©s manuellement

âœ… DonnÃ©es des tables (INSERT, UPDATE, DELETE)
   â†’ RÃ©pliquÃ©s automatiquement
```

**Solution pour les sÃ©quences** :

```sql
-- Avant le cutover, synchroniser les sÃ©quences
-- Sur Blue, obtenir les valeurs actuelles
SELECT schemaname, sequencename, last_value
FROM pg_sequences;

-- Sur Green, ajuster
SELECT setval('users_id_seq', 1000000);  -- Valeur de Blue
SELECT setval('orders_id_seq', 5000000);
-- etc.
```

#### 2. Tables sans clÃ© primaire

```sql
-- Les tables DOIVENT avoir une clÃ© primaire ou REPLICA IDENTITY

-- VÃ©rifier les tables sans PK
SELECT
    schemaname,
    tablename
FROM pg_tables t
LEFT JOIN pg_constraint c ON t.tablename = c.conrelid::regclass::text
    AND c.contype = 'p'
WHERE schemaname = 'public'
    AND c.conname IS NULL;

-- Solution : Ajouter une PK ou REPLICA IDENTITY
ALTER TABLE ma_table ADD PRIMARY KEY (id);

-- Ou utiliser REPLICA IDENTITY FULL (moins performant)
ALTER TABLE ma_table REPLICA IDENTITY FULL;
```

#### 3. Types de donnÃ©es incompatibles

Certains types peuvent poser problÃ¨me entre versions :

```sql
-- Types potentiellement problÃ©matiques :
-- - Types personnalisÃ©s (ENUM modifiÃ©s)
-- - Types dÃ©pendant d'extensions
-- - Types avec changements de reprÃ©sentation interne

-- VÃ©rifier avant migration
SELECT DISTINCT typname
FROM pg_type t
JOIN pg_class c ON t.typrelid = c.oid
WHERE c.relnamespace::regnamespace::text = 'public';
```

#### 4. Contraintes et triggers

```sql
-- Les contraintes et triggers sur la cible peuvent causer des conflits

-- Exemple : Si une contrainte CHECK est diffÃ©rente
-- Blue : CHECK (age >= 0)
-- Green : CHECK (age >= 18)  -- Plus stricte !

-- Les UPDATE rÃ©pliquÃ©s de Blue peuvent Ã©chouer sur Green
-- Solution : Harmoniser AVANT la rÃ©plication
```

### Performance et impacts

#### Impact sur la source (Blue)

```
La rÃ©plication logique ajoute une charge sur la source :

CPU :     +5-10% (dÃ©codage logique des WAL)
MÃ©moire : +100-500 MB par subscription
I/O :     +10-20% (Ã©criture/lecture WAL)
RÃ©seau :  DÃ©pend du taux de changement

Recommandation :
- Tester en DEV/staging d'abord
- Monitorer les performances pendant la phase de sync
```

#### Taille du lag acceptable

```
Lag de rÃ©plication = Retard entre Blue et Green

Acceptable :
< 1 seconde  : âœ… Excellent
< 10 secondes : âœ… Bon
< 1 minute : âš ï¸  Attention
> 1 minute : âŒ ProblÃ¨me

Causes d'un lag Ã©levÃ© :
- Trop d'Ã©critures sur Blue
- Green sous-dimensionnÃ© (CPU/RAM/I/O)
- RÃ©seau lent entre Blue et Green
- Longues transactions sur Blue
```

#### Gestion des longues transactions

```sql
-- Les longues transactions sur Blue bloquent la rÃ©plication

-- Identifier les transactions longues
SELECT
    pid,
    usename,
    state,
    now() - xact_start AS transaction_duration,
    query
FROM pg_stat_activity
WHERE state = 'active'
    AND now() - xact_start > interval '5 minutes';

-- Recommandation : Ã‰viter les transactions > 30 minutes
-- pendant la phase de rÃ©plication active
```

## DÃ©pannage et rÃ©solution de problÃ¨mes

### ProblÃ¨me 1 : Subscription ne dÃ©marre pas

**SymptÃ´me** :
```sql
SELECT * FROM pg_stat_subscription;
-- pid = NULL, latest_end_time = NULL
```

**Diagnostic** :
```bash
# VÃ©rifier les logs de PostgreSQL Green
tail -f /var/log/postgresql/postgresql-18-main.log

# Erreurs courantes :
# - "connection refused" : ProblÃ¨me rÃ©seau/firewall
# - "authentication failed" : Mauvais mot de passe
# - "publication not found" : Publication n'existe pas sur Blue
```

**Solution** :
```sql
-- VÃ©rifier la connexion manuellement
\c 'host=blue-server port=5432 dbname=mydb user=replication_user'

-- Si Ã§a fonctionne, le problÃ¨me est ailleurs
-- RecrÃ©er la subscription si nÃ©cessaire
DROP SUBSCRIPTION migration_sub;
CREATE SUBSCRIPTION migration_sub [...]
```

### ProblÃ¨me 2 : Copie initiale trÃ¨s lente

**SymptÃ´me** :
```sql
-- AprÃ¨s 1 heure, tables toujours en Ã©tat 'i' (initialize)
SELECT srrelid::regclass, srsubstate
FROM pg_subscription_rel;
```

**Solutions** :

```sql
-- 1. Augmenter le parallÃ©lisme
ALTER SUBSCRIPTION migration_sub
SET (streaming = parallel, max_parallel_workers = 4);

-- 2. Si trÃ¨s grosse table, copier manuellement
-- Sur Blue
pg_dump -h blue-server -U postgres -t grosse_table mydb | gzip > grosse_table.sql.gz

-- DÃ©sactiver temporairement la subscription
ALTER SUBSCRIPTION migration_sub DISABLE;

-- Copier et restaurer sur Green
gunzip < grosse_table.sql.gz | psql -h green-server -U postgres mydb

-- RÃ©activer
ALTER SUBSCRIPTION migration_sub ENABLE;
ALTER SUBSCRIPTION migration_sub REFRESH PUBLICATION;
```

### ProblÃ¨me 3 : Lag qui augmente continuellement

**SymptÃ´me** :
```sql
-- Lag qui passe de 5s Ã  1min Ã  5min...
SELECT now() - latest_end_time AS lag FROM pg_stat_subscription;
-- lag augmente sans cesse
```

**Diagnostic** :
```sql
-- Sur Green, vÃ©rifier les ressources
-- CPU saturÃ© ?
SELECT * FROM pg_stat_activity WHERE state = 'active';

-- Locks bloquants ?
SELECT * FROM pg_locks WHERE NOT granted;

-- Sur Blue, vÃ©rifier le volume de changements
SELECT count(*) FROM pg_stat_activity WHERE state = 'active';
```

**Solutions** :

```bash
# 1. Augmenter les ressources de Green (CPU/RAM)

# 2. RÃ©duire la charge sur Blue temporairement

# 3. Optimiser Green (index, statistiques)
psql -h green-server -d mydb -c "ANALYZE;"
```

### ProblÃ¨me 4 : Conflits de donnÃ©es

**SymptÃ´me** :
```
ERROR: duplicate key value violates unique constraint
```

**Cause** : Green a reÃ§u des Ã©critures directes (ne devrait pas !)

**Solution** :
```sql
-- Green doit Ãªtre en LECTURE SEULE pendant la sync

-- VÃ©rifier qu'aucune connexion n'Ã©crit sur Green
SELECT pid, usename, datname, state, query
FROM pg_stat_activity
WHERE datname = 'mydb'
    AND state = 'active'
    AND query !~* 'SELECT';

-- Si Ã©critures dÃ©tectÃ©es, les arrÃªter
SELECT pg_terminate_backend(pid) FROM pg_stat_activity
WHERE [...conditions...];

-- Puis resynchroniser la table affectÃ©e
ALTER SUBSCRIPTION migration_sub REFRESH PUBLICATION;
```

### ProblÃ¨me 5 : Slot de rÃ©plication saturÃ© (WAL explosion)

**SymptÃ´me** :
```bash
# Disque Blue presque plein
df -h
# /var/lib/postgresql/ at 95%
```

**Diagnostic** :
```sql
-- Sur Blue, vÃ©rifier la taille du slot
SELECT
    slot_name,
    pg_size_pretty(
        pg_wal_lsn_diff(pg_current_wal_lsn(), confirmed_flush_lsn)
    ) AS pending_wal_size
FROM pg_replication_slots
WHERE slot_type = 'logical';

-- Si pending_wal_size > 10 GB â†’ ProblÃ¨me
```

**Solution** :
```sql
-- Si Green ne peut pas rattraper :
-- Option A : Augmenter les ressources de Green

-- Option B : Temporairement, nettoyer les vieux WAL (DANGER)
-- Cela cassera la rÃ©plication !
SELECT pg_drop_replication_slot('migration_slot');

-- Puis recrÃ©er la subscription avec copie initiale
```

## Cas d'usage rÃ©el : Migration e-commerce

### Contexte

```
Entreprise : Boutique en ligne internationale
Base de donnÃ©es :
  - Taille : 1.5 TB
  - Tables : 3,000
  - Transactions/sec : ~500 TPS en moyenne, 2000 TPS en pic
  - CriticitÃ© : TrÃ¨s Ã©levÃ©e (chaque minute de downtime = perte revenus)
Contrainte : Downtime absolu < 15 minutes
```

### Timeline de migration

#### J-30 : Planification

```
âœ… RÃ©union Ã©quipe : StratÃ©gie Blue/Green validÃ©e
âœ… Provisionner serveur Green (identique Ã  Blue)
âœ… Tests de rÃ©plication logique sur environnement de staging
âœ… RÃ©daction runbook dÃ©taillÃ©
âœ… Tests de charge sur Green (validation performances)
```

#### J-14 : PrÃ©paration

```
âœ… Installer PostgreSQL 18 sur Green
âœ… Configurer Blue pour rÃ©plication logique (wal_level=logical)
âœ… CrÃ©er publication sur Blue
âœ… Migrer le schÃ©ma vers Green (pg_dump --schema-only)
âœ… Validation schÃ©ma : OK
```

#### J-7 : Mise en place rÃ©plication

```bash
# Dimanche 3h du matin (charge faible)

# 1. CrÃ©er la subscription
time psql -h green -d ecommerce -c "
CREATE SUBSCRIPTION ecommerce_migration
CONNECTION 'host=blue ...'
PUBLICATION ecommerce_pub
WITH (copy_data = true, max_parallel_workers = 8);
"

# Copie initiale : 3h45
# Synchronisation Ã©tablie : 7h15

# 2. Monitoring intensif toute la journÃ©e
./monitor_replication.sh > /var/log/replication_status.log
```

#### J-6 Ã  J-1 : Synchronisation et tests

```
Lundi-Samedi :
âœ… Green reste synchronisÃ© (lag < 2 secondes constant)
âœ… Tests de fumÃ©e quotidiens sur Green
âœ… Validation des performances (EXPLAIN ANALYZE sur requÃªtes critiques)
âœ… VÃ©rification intÃ©gritÃ© donnÃ©es (checksums, counts)
âœ… Simulation du cutover en staging
âœ… PrÃ©paration scripts automatisÃ©s
```

#### J-Day (Dimanche) : Cutover

```
02:00  DÃ©but fenÃªtre maintenance (notification clients 48h avant)

02:05  Mise en lecture seule progressive (non-critique d'abord)
       - DÃ©sactivation features non-essentielles
       - Users : mode navigation seulement

02:10  VÃ©rification lag Green < 1 seconde : âœ…

02:12  Applications en read-only complet
       - Plus d'ajout au panier
       - Plus de commandes
       - Consultation OK

02:15  DerniÃ¨re vÃ©rification synchronisation
       Blue: users: 5,234,567 rows
       Green: users: 5,234,567 rows âœ…

02:17  DOWNTIME COMPLET commence
       - ArrÃªt applications

02:18  DÃ©sactivation subscription
       ALTER SUBSCRIPTION ecommerce_migration DISABLE;

02:19  Synchronisation sÃ©quences
       Script : sync_sequences.sh
       DurÃ©e : 30 secondes

02:20  Validation finale donnÃ©es Green
       Script : validate_data.sh
       Tous les counts : OK âœ…

02:22  Bascule DNS vers Green
       TTL dÃ©jÃ  abaissÃ© Ã  60s il y a 24h

02:25  RedÃ©marrage applications pointant vers Green
       Helm upgrade -f values_green.yaml

02:27  Smoke tests automatisÃ©s
       - Connexion DB : OK
       - SELECT basiques : OK
       - INSERT test : OK

02:30  Tests fonctionnels
       - CrÃ©er compte : OK
       - Ajouter panier : OK
       - Commander : OK âœ…

02:33  Ouverture progressive
       - 10% utilisateurs
       - Monitoring : OK
       - 50% utilisateurs
       - Monitoring : OK

02:40  Ouverture complÃ¨te
       DOWNTIME TERMINÃ‰ (23 minutes)

03:00  Green en production complÃ¨te
       Blue conservÃ© en standby

12:00  AprÃ¨s 9h de production sur Green
       Tout OK, Blue marquÃ© obsolÃ¨te
```

### RÃ©sultats

```
Downtime effectif : 23 minutes (objectif < 15 min non atteint mais acceptable)
Perte de transactions : ~200 commandes (rÃ©cupÃ©rÃ©es aprÃ¨s ouverture)
ProblÃ¨mes rencontrÃ©s :
  - SÃ©quence orders_id_seq mal synchronisÃ©e (fixÃ© en 2 min)
  - DNS propagation plus lente que prÃ©vu (d'oÃ¹ 23 min au lieu de 15)
Performances PG 18 vs PG 17 :
  - RequÃªtes complexes : +15% plus rapides
  - Index scans : +20% plus efficaces
Satisfaction :
  - Ã‰quipe tech : TrÃ¨s satisfaite
  - Business : Impact minimal acceptÃ©
```

## Bonnes pratiques et recommandations

### Avant de commencer

#### Checklist de prÃ©paration

```
â–¡ Valider que la rÃ©plication logique est adaptÃ©e Ã  votre cas
â–¡ Tester sur environnement de staging complet
â–¡ Documenter tous les objets non rÃ©pliquÃ©s (sÃ©quences, vues mat.)
â–¡ VÃ©rifier que toutes les tables ont une PK ou REPLICA IDENTITY
â–¡ Provisionner Green avec ressources >= Blue
â–¡ PrÃ©voir bande passante rÃ©seau suffisante entre Blue et Green
â–¡ Installer outils de monitoring (Grafana, pg_stat_statements)
â–¡ RÃ©diger runbook dÃ©taillÃ© avec procÃ©dures de rollback
â–¡ Planifier fenÃªtre de maintenance avec prÃ©avis suffisant
â–¡ Informer toutes les parties prenantes (dev, ops, business)
```

### Pendant la rÃ©plication

#### Monitoring continu

```bash
#!/bin/bash
# Cronjob toutes les 5 minutes

LAG=$(psql -h green -t -c "
SELECT EXTRACT(EPOCH FROM (now() - latest_end_time))
FROM pg_stat_subscription;" | xargs)

if (( $(echo "$LAG > 60" | bc -l) )); then
    echo "âš ï¸  ALERT: Replication lag > 60s: ${LAG}s"
    # Envoyer alerte (email, Slack, PagerDuty...)
fi

if (( $(echo "$LAG < 5" | bc -l) )); then
    echo "âœ… Replication lag OK: ${LAG}s"
fi
```

#### Validation des donnÃ©es

```sql
-- Script de validation quotidien
-- compare_blue_green.sql

DO $$
DECLARE
    blue_count bigint;
    green_count bigint;
    table_rec record;
BEGIN
    FOR table_rec IN
        SELECT tablename
        FROM pg_tables
        WHERE schemaname = 'public'
    LOOP
        EXECUTE format('SELECT COUNT(*) FROM %I', table_rec.tablename)
        INTO blue_count;

        -- Connexion Ã  Green via dblink ou script externe

        IF blue_count != green_count THEN
            RAISE WARNING 'Mismatch in table %: Blue=%, Green=%',
                table_rec.tablename, blue_count, green_count;
        END IF;
    END LOOP;
END $$;
```

### Jour du cutover

#### Validation prÃ©-cutover

```bash
#!/bin/bash
# pre_cutover_validation.sh

echo "ğŸ” Validation prÃ©-cutover"

# 1. Lag < 1 seconde
LAG=$(psql -h green -t -c "
SELECT EXTRACT(EPOCH FROM (now() - latest_end_time))
FROM pg_stat_subscription;" | xargs)

if (( $(echo "$LAG > 1" | bc -l) )); then
    echo "âŒ Lag trop Ã©levÃ©: ${LAG}s (max 1s)"
    exit 1
fi
echo "âœ… Lag OK: ${LAG}s"

# 2. Toutes les tables synchronisÃ©es
NOT_SYNCED=$(psql -h green -t -c "
SELECT COUNT(*) FROM pg_subscription_rel WHERE srsubstate != 'r';" | xargs)

if [ "$NOT_SYNCED" != "0" ]; then
    echo "âŒ $NOT_SYNCED tables non synchronisÃ©es"
    exit 1
fi
echo "âœ… Toutes les tables synchronisÃ©es"

# 3. Pas de locks bloquants sur Blue
LOCKS=$(psql -h blue -t -c "
SELECT COUNT(*) FROM pg_locks WHERE NOT granted;" | xargs)

if [ "$LOCKS" != "0" ]; then
    echo "âš ï¸  $LOCKS locks en attente sur Blue"
fi

# 4. Espace disque suffisant
DISK_BLUE=$(ssh blue-server "df -h /var/lib/postgresql | tail -1 | awk '{print \$5}' | sed 's/%//'")
DISK_GREEN=$(ssh green-server "df -h /var/lib/postgresql | tail -1 | awk '{print \$5}' | sed 's/%//'")

if [ "$DISK_BLUE" -gt 85 ] || [ "$DISK_GREEN" -gt 85 ]; then
    echo "âš ï¸  Espace disque limitÃ© (Blue: ${DISK_BLUE}%, Green: ${DISK_GREEN}%)"
fi

echo "âœ… Validation prÃ©-cutover terminÃ©e"
```

### AprÃ¨s le cutover

#### Surveillance post-migration

```sql
-- Monitorer les performances pendant 24-48h

-- 1. RequÃªtes plus lentes qu'avant
SELECT
    query,
    calls,
    mean_exec_time,
    total_exec_time
FROM pg_stat_statements
WHERE mean_exec_time >
    (SELECT percentile_cont(0.95) WITHIN GROUP (ORDER BY mean_exec_time)
     FROM pg_stat_statements)
ORDER BY mean_exec_time DESC
LIMIT 20;

-- 2. Tables avec scans sÃ©quentiels Ã©levÃ©s
SELECT
    schemaname,
    tablename,
    seq_scan,
    seq_tup_read,
    idx_scan,
    CASE
        WHEN seq_scan > 0 THEN seq_tup_read / seq_scan
        ELSE 0
    END AS avg_seq_tup_per_scan
FROM pg_stat_user_tables
WHERE seq_scan > 100
ORDER BY seq_scan DESC
LIMIT 20;

-- 3. Index inutilisÃ©s
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan
FROM pg_stat_user_indexes
WHERE idx_scan = 0
    AND schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY pg_relation_size(indexrelid) DESC;
```

## Conclusion

La stratÃ©gie **Blue/Green avec Logical Replication** reprÃ©sente l'approche la plus sophistiquÃ©e pour les migrations PostgreSQL critiques.

### RÃ©capitulatif

- âœ… **Downtime minimal** : 5-30 minutes (vs plusieurs heures)
- âœ… **Tests prÃ©alables** : Validation complÃ¨te avant cutover
- âœ… **Rollback rapide** : Retour Ã  Blue en quelques minutes
- âœ… **Confiance** : Filet de sÃ©curitÃ© permanent
- âœ… **Progressif** : Migration par Ã©tapes possibles

### Quand l'utiliser ?

```
Utiliser Blue/Green + Logical Replication si :

âœ… Downtime < 30 minutes requis
âœ… Service critique (FinTech, E-commerce, SaaS)
âœ… Budget infrastructure disponible
âœ… Ã‰quipe avec expertise PostgreSQL
âœ… Base > 500 GB
âœ… PossibilitÃ© de tester en staging
```

### Quand prÃ©fÃ©rer pg_upgrade ?

```
Utiliser pg_upgrade --swap si :

âœ… Downtime 1-4h acceptable
âœ… Budget limitÃ©
âœ… Ã‰quipe rÃ©duite
âœ… Base < 500 GB
âœ… Service non critique 24/7
```

### Points clÃ©s Ã  retenir

1. **La rÃ©plication logique permet des migrations avec downtime minimal**
2. **Blue/Green offre un filet de sÃ©curitÃ© (rollback facile)**
3. **NÃ©cessite planification et tests rigoureux**
4. **CoÃ»t infrastructure plus Ã©levÃ© (2 clusters en parallÃ¨le)**
5. **IdÃ©al pour production critique**

### ComplÃ©ments recommandÃ©s

Pour maÃ®triser complÃ¨tement les migrations PostgreSQL 18 :

- **Section 19.3.1** : PrÃ©servation des statistiques
- **Section 19.3.2** : Option --swap pour rapiditÃ©
- **Section 19.3.3** : ParallÃ©lisation avec --jobs
- **Section 17** : RÃ©plication et Haute DisponibilitÃ© (concepts approfondis)

---

**Note** : La stratÃ©gie Blue/Green + Logical Replication peut sembler complexe, mais elle est comparable Ã  construire une nouvelle maison Ã  cÃ´tÃ© de l'ancienne avant d'y dÃ©mÃ©nager, plutÃ´t que de rÃ©nover en habitant dedans. Vous testez la nouvelle version pendant que l'ancienne fonctionne, puis vous basculez rapidement. C'est la mÃ©thode la plus sÃ»re pour les services critiques !

â­ï¸ [Tests de migration et validation](/19-postgresql-en-production/03.5-tests-migration-validation.md)
