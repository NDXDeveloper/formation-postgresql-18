üîù Retour au [Sommaire](/SOMMAIRE.md)

# 19.6.2. Configuration Optimale

## Introduction

PostgreSQL est livr√© avec des **param√®tres par d√©faut tr√®s conservateurs**, con√ßus pour fonctionner sur des machines modestes. En production, ces valeurs sont souvent **inadapt√©es** et peuvent limiter consid√©rablement les performances.

La configuration optimale de PostgreSQL consiste √† ajuster les param√®tres en fonction de :
- Vos **ressources mat√©rielles** (RAM, CPU, disques)
- Votre **type de charge** (OLTP, OLAP, mixte)
- Vos **besoins applicatifs** (latence, d√©bit, concurrence)

Cette section vous guide √† travers les param√®tres essentiels et les strat√©gies de tuning pour maximiser les performances de votre base de donn√©es.

> **Avertissement** : La configuration optimale n'est **pas universelle**. Les valeurs propos√©es ici sont des **points de d√©part** √† ajuster selon votre contexte sp√©cifique. Testez toujours vos modifications en environnement de staging avant la production.

---

## Comprendre le Fichier de Configuration

### Localisation de postgresql.conf

Le fichier principal de configuration est `postgresql.conf` :

```bash
# Trouver le fichier de configuration
sudo -u postgres psql -c "SHOW config_file;"
# R√©sultat typique : /var/lib/pgsql/18/data/postgresql.conf

# Ou via psql
psql -U postgres -c "SHOW config_file;"
```

### Recharger la Configuration

Apr√®s modification, rechargez la configuration :

```bash
# M√©thode 1 : Via pg_ctl
sudo -u postgres pg_ctl reload -D /var/lib/pgsql/18/data

# M√©thode 2 : Via SQL
psql -U postgres -c "SELECT pg_reload_conf();"

# M√©thode 3 : Via systemd
sudo systemctl reload postgresql-18
```

> **Note** : Certains param√®tres n√©cessitent un **red√©marrage complet** (marqu√©s par `# restart required`).

### V√©rifier les Param√®tres Actifs

```sql
-- Voir un param√®tre sp√©cifique
SHOW shared_buffers;

-- Voir tous les param√®tres modifi√©s par rapport aux d√©fauts
SELECT name, setting, unit, source
FROM pg_settings
WHERE source != 'default'
ORDER BY name;

-- Voir les param√®tres n√©cessitant un restart
SELECT name, setting, pending_restart
FROM pg_settings
WHERE pending_restart = true;
```

---

## 1. Param√®tres M√©moire Critiques

### 1.1. shared_buffers : Le Cache Central

**R√¥le** : M√©moire partag√©e pour mettre en cache les pages de donn√©es. C'est le **param√®tre le plus important**.

**Valeur par d√©faut** : 128 MB (beaucoup trop faible)

**Recommandation g√©n√©rale** :
- **25% de la RAM** pour serveurs d√©di√©s
- Maximum efficace : **8-16 GB** (au-del√†, le b√©n√©fice diminue)

**Exemples** :

```conf
# Serveur avec 16 GB de RAM
shared_buffers = 4GB

# Serveur avec 64 GB de RAM
shared_buffers = 16GB

# Serveur avec 128 GB de RAM
shared_buffers = 16GB  # Pas plus, le reste pour le cache OS
```

**Pourquoi ne pas mettre 50% ou plus ?**
- PostgreSQL s'appuie aussi sur le **cache du syst√®me d'exploitation** (page cache)
- Un √©quilibre optimal : PostgreSQL cache + OS cache = meilleures performances

**N√©cessite un restart** : ‚úÖ Oui

### 1.2. effective_cache_size : Indicateur pour le Planificateur

**R√¥le** : Informe le planificateur de la quantit√© de m√©moire disponible pour le cache (PostgreSQL + OS).

**Valeur par d√©faut** : 4 GB

**Recommandation** :
- **50-75% de la RAM totale** (sur serveur d√©di√©)

**Exemples** :

```conf
# Serveur avec 16 GB de RAM
effective_cache_size = 12GB

# Serveur avec 64 GB de RAM
effective_cache_size = 48GB

# Serveur avec 128 GB de RAM
effective_cache_size = 96GB
```

**Impact** : N'alloue PAS de m√©moire, juste un **hint** pour le planificateur. Peut influencer le choix entre scan s√©quentiel et index scan.

**N√©cessite un restart** : ‚ùå Non (reload suffit)

### 1.3. work_mem : M√©moire par Op√©ration de Tri/Hash

**R√¥le** : M√©moire allou√©e √† **chaque op√©ration** de tri, hash join, agr√©gation, etc.

**Valeur par d√©faut** : 4 MB (souvent insuffisant)

**Pi√®ge** : Cette m√©moire est allou√©e **par op√©ration ET par connexion**. Une requ√™te complexe peut utiliser `work_mem √ó nombre d'op√©rations √ó nombre de connexions`.

**Formule de dimensionnement** :

```
work_mem = (RAM totale √ó 0.25) / max_connections / 10
```

**Exemples** :

```conf
# Serveur 16 GB, 100 connexions max
# (16 GB √ó 0.25) / 100 / 10 = 4 MB ‚Üí Augmenter
work_mem = 32MB

# Serveur 64 GB, 50 connexions (OLAP)
work_mem = 128MB

# Serveur 16 GB, 500 connexions (OLTP haute concurrence)
work_mem = 8MB
```

**Strat√©gie avanc√©e** : Configurer au niveau session pour les requ√™tes analytiques :

```sql
-- Avant une requ√™te lourde
SET work_mem = '256MB';
SELECT ... FROM ... JOIN ... GROUP BY ...;
RESET work_mem;
```

**Sympt√¥me de work_mem insuffisant** : Logs indiquant `temporary file` cr√©√©s sur disque.

```
LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp12345.0", size 52428800
```

**N√©cessite un restart** : ‚ùå Non (reload suffit)

### 1.4. maintenance_work_mem : M√©moire pour Maintenance

**R√¥le** : M√©moire pour op√©rations de maintenance (VACUUM, CREATE INDEX, ALTER TABLE, REINDEX).

**Valeur par d√©faut** : 64 MB

**Recommandation** :
- **5-10% de la RAM**, avec un maximum de **2 GB**
- Pour bases volumineuses : Jusqu'√† **8-16 GB** peut √™tre b√©n√©fique

**Exemples** :

```conf
# Serveur 16 GB
maintenance_work_mem = 1GB

# Serveur 64 GB
maintenance_work_mem = 4GB

# Serveur 128 GB
maintenance_work_mem = 8GB
```

**Impact** : Acc√©l√®re les cr√©ations d'index, VACUUM, et r√©organisations de tables.

**N√©cessite un restart** : ‚ùå Non (reload suffit)

### 1.5. Tableau R√©capitulatif M√©moire

| RAM Serveur | shared_buffers | effective_cache_size | work_mem (OLTP) | work_mem (OLAP) | maintenance_work_mem |
|-------------|----------------|----------------------|-----------------|-----------------|----------------------|
| 4 GB        | 1 GB           | 3 GB                 | 4-8 MB          | 32-64 MB        | 256 MB               |
| 16 GB       | 4 GB           | 12 GB                | 16-32 MB        | 64-128 MB       | 1 GB                 |
| 64 GB       | 16 GB          | 48 GB                | 32-64 MB        | 128-256 MB      | 4 GB                 |
| 128 GB      | 16 GB          | 96 GB                | 32-64 MB        | 256-512 MB      | 8 GB                 |

---

## 2. Configuration des Connexions

### 2.1. max_connections : Nombre Maximum de Connexions

**R√¥le** : Limite le nombre de connexions simultan√©es.

**Valeur par d√©faut** : 100

**R√©flexion importante** : PostgreSQL utilise un mod√®le **process-per-connection**. Chaque connexion consomme :
- Environ **10 MB de RAM** minimum
- Un processus syst√®me

**Pi√®ge courant** : Augmenter `max_connections` sans Connection Pooling = catastrophe.

**Recommandations** :

```conf
# OLTP avec Connection Pooler (PgBouncer)
max_connections = 100-200

# OLTP sans Connection Pooler (petit trafic)
max_connections = 50-100

# OLAP / Data Warehouse
max_connections = 20-50

# ‚ùå √Ä √©viter absolument
max_connections = 1000  # Surcharge le serveur
```

**Solution** : Utiliser un **Connection Pooler** (PgBouncer, PgPool-II) pour multiplexer les connexions.

**Architecture recommand√©e** :

```
Application (1000 connexions logiques)
         ‚Üì
    PgBouncer (pool de 100)
         ‚Üì
    PostgreSQL (max_connections = 100)
```

**N√©cessite un restart** : ‚úÖ Oui

### 2.2. superuser_reserved_connections

**R√¥le** : R√©serve des connexions pour les superutilisateurs (d√©pannage).

**Valeur par d√©faut** : 3

**Recommandation** :

```conf
# Garder quelques slots pour l'admin
superuser_reserved_connections = 5
```

**Sc√©nario** : Si `max_connections` est satur√©, vous pouvez toujours vous connecter en superutilisateur pour diagnostiquer.

**N√©cessite un restart** : ‚úÖ Oui

---

## 3. Configuration WAL (Write-Ahead Log)

Le WAL est essentiel pour :
- **Durabilit√©** (ACID)
- **R√©plication**
- **Point-In-Time Recovery (PITR)**

### 3.1. wal_level : Niveau de D√©tail du WAL

**R√¥le** : D√©termine la quantit√© d'informations √©crites dans le WAL.

**Valeurs possibles** :
- `minimal` : Minimum (pas de r√©plication)
- `replica` : R√©plication physique (d√©faut)
- `logical` : R√©plication logique

**Recommandation production** :

```conf
# Pour r√©plication physique ou logique
wal_level = replica

# Si r√©plication logique n√©cessaire
wal_level = logical
```

**N√©cessite un restart** : ‚úÖ Oui

### 3.2. max_wal_size : Taille Maximum du WAL

**R√¥le** : D√©clenche un checkpoint quand le WAL atteint cette taille.

**Valeur par d√©faut** : 1 GB (souvent insuffisant)

**Recommandation** :

```conf
# Serveur haute activit√© (OLTP)
max_wal_size = 4GB

# Data Warehouse (OLAP, gros bulk loads)
max_wal_size = 16GB

# Serveur tr√®s haute activit√©
max_wal_size = 32GB
```

**Avantage** : R√©duit la fr√©quence des checkpoints, am√©liore les performances d'√©criture.

**N√©cessite un restart** : ‚ùå Non (reload suffit)

### 3.3. min_wal_size : Taille Minimum du WAL

**R√¥le** : Conserve au moins cette quantit√© de WAL (√©vite de recr√©er des fichiers).

**Valeur par d√©faut** : 80 MB

**Recommandation** :

```conf
# Proportionnel √† max_wal_size (environ 25%)
min_wal_size = 1GB  # Si max_wal_size = 4GB
min_wal_size = 4GB  # Si max_wal_size = 16GB
```

**N√©cessite un restart** : ‚ùå Non (reload suffit)

### 3.4. checkpoint_timeout : Intervalle entre Checkpoints

**R√¥le** : Force un checkpoint au moins toutes les X secondes.

**Valeur par d√©faut** : 5 min (300s)

**Recommandation** :

```conf
# R√©duire la fr√©quence des checkpoints (IO burst)
checkpoint_timeout = 15min  # 900s

# OLAP / Data Warehouse
checkpoint_timeout = 30min  # 1800s
```

**Trade-off** : Plus long = moins d'IO, mais recovery plus long en cas de crash.

**N√©cessite un restart** : ‚ùå Non (reload suffit)

### 3.5. checkpoint_completion_target : √âtaler les √âcritures

**R√¥le** : √âtale les √©critures du checkpoint sur cette fraction de `checkpoint_timeout`.

**Valeur par d√©faut** : 0.9 (90%)

**Recommandation** :

```conf
# √âtaler au maximum (r√©duire les pics d'IO)
checkpoint_completion_target = 0.9
```

**Effet** : Lisse les √©critures disque, √©vite les I/O burst.

**N√©cessite un restart** : ‚ùå Non (reload suffit)

### 3.6. wal_buffers : Buffer WAL en M√©moire

**R√¥le** : Buffer m√©moire avant √©criture sur disque.

**Valeur par d√©faut** : -1 (auto, 1/32 de shared_buffers, min 64KB, max 16MB)

**Recommandation** :

```conf
# Laisser en auto (performant dans la plupart des cas)
wal_buffers = -1

# Ou augmenter pour charge tr√®s √©lev√©e
wal_buffers = 32MB
```

**N√©cessite un restart** : ‚úÖ Oui

---

## 4. Configuration I/O (Nouveaut√© PostgreSQL 18)

### 4.1. io_method : M√©thode d'I/O Asynchrone

**Nouveaut√© majeure PostgreSQL 18** : Support des **I/O asynchrones** (AIO) pour des gains de performance jusqu'√† **3√ó plus rapide** sur certaines charges.

**Valeurs possibles** :
- `sync` : I/O synchrones (classique)
- `async` : I/O asynchrones (nouveau)

**Recommandation** :

```conf
# Activer les I/O asynchrones (PG 18+)
io_method = 'async'
```

**Pr√©requis** :
- PostgreSQL 18+
- Syst√®me d'exploitation supportant `io_uring` (Linux 5.1+) ou √©quivalent

**V√©rification** :

```sql
SHOW io_method;
-- R√©sultat attendu : async
```

**Impact** : Am√©liore drastiquement les performances sur :
- Scans de tables volumineuses
- Bulk loads
- Op√©rations de tri et agr√©gation massives

**N√©cessite un restart** : ‚úÖ Oui

### 4.2. V√©rifier le Support AIO

```bash
# V√©rifier si io_uring est disponible (Linux)
cat /proc/sys/kernel/io_uring_disabled
# 0 = activ√©, 1 = d√©sactiv√©
```

Si d√©sactiv√©, activer :

```bash
sudo sysctl -w kernel.io_uring_disabled=0
echo "kernel.io_uring_disabled=0" | sudo tee -a /etc/sysctl.conf
```

---

## 5. Configuration Autovacuum (Nouveaut√© PostgreSQL 18)

L'**autovacuum** est critique pour maintenir les performances. PostgreSQL 18 apporte des am√©liorations significatives.

### 5.1. autovacuum : Activer l'Autovacuum

**R√¥le** : Active le vacuum automatique.

**Valeur par d√©faut** : `on`

**Recommandation** :

```conf
# ‚úÖ TOUJOURS activ√© en production
autovacuum = on

# ‚ùå D√©sactiver = catastrophe garantie
autovacuum = off  # Ne JAMAIS faire √ßa !
```

**N√©cessite un restart** : ‚ùå Non (reload suffit)

### 5.2. autovacuum_max_workers : Parall√©lisation

**R√¥le** : Nombre de workers autovacuum simultan√©s.

**Valeur par d√©faut** : 3

**Nouveaut√© PostgreSQL 18** : Ajustement dynamique avec `autovacuum_worker_slots`.

**Recommandation** :

```conf
# Serveur modeste (4-8 cores)
autovacuum_max_workers = 3

# Serveur puissant (16+ cores)
autovacuum_max_workers = 6-8

# Data Warehouse (tables massives)
autovacuum_max_workers = 10
```

**Limite** : Augmenter consomme plus de CPU et I/O.

**N√©cessite un restart** : ‚úÖ Oui

### 5.3. autovacuum_vacuum_scale_factor : Seuil de D√©clenchement

**R√¥le** : D√©clenche un vacuum quand % de lignes modifi√©es.

**Valeur par d√©faut** : 0.2 (20%)

**Probl√®me** : Sur tables massives, 20% = √©norme d√©lai avant vacuum.

**Recommandation** :

```conf
# R√©duire pour tables volumineuses
autovacuum_vacuum_scale_factor = 0.05  # 5%

# Ou configurer par table (pour tables critiques)
ALTER TABLE ma_grande_table
SET (autovacuum_vacuum_scale_factor = 0.01);  # 1%
```

**N√©cessite un restart** : ‚ùå Non (reload suffit)

### 5.4. autovacuum_vacuum_max_threshold (Nouveaut√© PG 18)

**Nouveaut√© PostgreSQL 18** : Nouveau param√®tre pour limiter le nombre de lignes √† traiter par vacuum.

**R√¥le** : Plafond maximum de lignes mortes avant vacuum.

**Valeur par d√©faut** : Aucune (illimit√©)

**Recommandation** :

```conf
# Limiter pour √©viter les vacuums trop longs
autovacuum_vacuum_max_threshold = 10000000  # 10M de lignes
```

**Cas d'usage** : √âviter qu'un vacuum monopolise les ressources trop longtemps.

**N√©cessite un restart** : ‚ùå Non (reload suffit)

### 5.5. autovacuum_vacuum_cost_delay : Limiter l'Impact

**R√¥le** : Temps de pause entre op√©rations I/O (throttling).

**Valeur par d√©faut** : 2 ms

**Recommandation** :

```conf
# R√©duire pour vacuum plus agressif (si I/O disponibles)
autovacuum_vacuum_cost_delay = 0  # Pas de throttling

# Augmenter pour vacuum moins intrusif
autovacuum_vacuum_cost_delay = 10ms
```

**N√©cessite un restart** : ‚ùå Non (reload suffit)

### 5.6. Tableau R√©capitulatif Autovacuum

| Param√®tre                          | D√©faut | OLTP           | OLAP         |
|------------------------------------|--------|----------------|--------------|
| autovacuum                         | on     | on             | on           |
| autovacuum_max_workers             | 3      | 4-6            | 8-10         |
| autovacuum_vacuum_scale_factor     | 0.2    | 0.05-0.1       | 0.02         |
| autovacuum_vacuum_max_threshold    | ‚àû      | 10M            | 50M          |
| autovacuum_vacuum_cost_delay       | 2ms    | 0-2ms          | 5ms          |

---

## 6. Configuration du Planificateur

### 6.1. random_page_cost : Co√ªt d'I/O Al√©atoire

**R√¥le** : Informe le planificateur du co√ªt relatif d'un acc√®s disque al√©atoire vs s√©quentiel.

**Valeur par d√©faut** : 4.0 (pour disques m√©caniques)

**Recommandation** :

```conf
# SSD / NVMe
random_page_cost = 1.1

# HDD (disques m√©caniques)
random_page_cost = 4.0

# Stockage cloud (latence variable)
random_page_cost = 1.5-2.0
```

**Impact** : Influence le choix entre index scan et sequential scan.

**N√©cessite un restart** : ‚ùå Non (reload suffit)

### 6.2. effective_io_concurrency : Parall√©lisation I/O

**R√¥le** : Nombre d'op√©rations I/O simultan√©es que le syst√®me peut g√©rer.

**Valeur par d√©faut** : 1

**Recommandation** :

```conf
# SSD / NVMe
effective_io_concurrency = 200

# RAID array
effective_io_concurrency = 100-300

# HDD seul
effective_io_concurrency = 2
```

**Impact** : Am√©liore les performances de Bitmap Heap Scan.

**N√©cessite un restart** : ‚ùå Non (reload suffit)

### 6.3. default_statistics_target : Pr√©cision des Statistiques

**R√¥le** : Nombre d'√©chantillons pour les statistiques du planificateur.

**Valeur par d√©faut** : 100

**Recommandation** :

```conf
# Augmenter pour requ√™tes complexes (joins multiples)
default_statistics_target = 200

# Data Warehouse
default_statistics_target = 500
```

**Trade-off** : Plus √©lev√© = meilleur plan, mais ANALYZE plus lent.

**N√©cessite un restart** : ‚ùå Non (reload suffit)

---

## 7. Configuration par Type de Charge

### 7.1. OLTP (Online Transaction Processing)

**Caract√©ristiques** :
- Haute concurrence (nombreuses connexions)
- Transactions courtes
- Latence critique
- Writes et reads fr√©quents

**Configuration recommand√©e** :

```conf
# M√©moire
shared_buffers = 4GB              # 25% RAM (16GB serveur)
effective_cache_size = 12GB       # 75% RAM
work_mem = 16MB                   # Faible (haute concurrence)
maintenance_work_mem = 1GB

# Connexions
max_connections = 200             # Avec PgBouncer
superuser_reserved_connections = 5

# WAL
wal_level = replica
max_wal_size = 4GB
checkpoint_timeout = 10min
checkpoint_completion_target = 0.9

# I/O (PG 18)
io_method = 'async'
random_page_cost = 1.1            # SSD
effective_io_concurrency = 200

# Autovacuum
autovacuum = on
autovacuum_max_workers = 4
autovacuum_vacuum_scale_factor = 0.05
autovacuum_vacuum_cost_delay = 2ms

# Planificateur
default_statistics_target = 100
```

### 7.2. OLAP (Online Analytical Processing)

**Caract√©ristiques** :
- Faible concurrence
- Requ√™tes longues et complexes
- D√©bit (throughput) prioritaire
- Beaucoup d'agr√©gations et jointures

**Configuration recommand√©e** :

```conf
# M√©moire
shared_buffers = 16GB             # 25% RAM (64GB serveur)
effective_cache_size = 48GB       # 75% RAM
work_mem = 256MB                  # √âlev√© (peu de connexions)
maintenance_work_mem = 4GB

# Connexions
max_connections = 50              # Peu de connexions
superuser_reserved_connections = 5

# WAL
wal_level = replica
max_wal_size = 16GB               # Gros bulk loads
checkpoint_timeout = 30min
checkpoint_completion_target = 0.9

# I/O (PG 18)
io_method = 'async'
random_page_cost = 1.1            # SSD
effective_io_concurrency = 300

# Autovacuum
autovacuum = on
autovacuum_max_workers = 8
autovacuum_vacuum_scale_factor = 0.02
autovacuum_vacuum_cost_delay = 0ms  # Pas de throttling

# Planificateur
default_statistics_target = 500   # Statistiques pr√©cises
```

### 7.3. Mixed Workload (OLTP + OLAP)

**Compromis** entre les deux profils :

```conf
# M√©moire
shared_buffers = 8GB
effective_cache_size = 24GB
work_mem = 64MB
maintenance_work_mem = 2GB

# Connexions
max_connections = 100

# WAL
max_wal_size = 8GB
checkpoint_timeout = 15min

# I/O
io_method = 'async'
random_page_cost = 1.1
effective_io_concurrency = 200

# Autovacuum
autovacuum_max_workers = 6
autovacuum_vacuum_scale_factor = 0.05

# Planificateur
default_statistics_target = 200
```

---

## 8. Outils d'Aide √† la Configuration

### 8.1. PGTune

**PGTune** g√©n√®re une configuration optimale selon votre mat√©riel.

**En ligne** : https://pgtune.leopard.in.ua/

**Utilisation** :
1. Renseigner les informations serveur :
   - Version PostgreSQL (18)
   - Type de charge (OLTP, OLAP, Mixed, Desktop)
   - RAM totale
   - Nombre de CPUs
   - Type de stockage (SSD, HDD)
   - Nombre de connexions max

2. Copier la configuration g√©n√©r√©e dans `postgresql.conf`

**Exemple** :

```
Version PostgreSQL: 18
Type: OLTP
RAM: 16 GB
CPUs: 8
Storage: SSD
Connexions: 200
```

**R√©sultat** :
```conf
max_connections = 200
shared_buffers = 4GB
effective_cache_size = 12GB
maintenance_work_mem = 1GB
checkpoint_completion_target = 0.9
wal_buffers = 16MB
default_statistics_target = 100
random_page_cost = 1.1
effective_io_concurrency = 200
work_mem = 10485kB
min_wal_size = 1GB
max_wal_size = 4GB
```

### 8.2. pg_config

Voir la configuration compil√©e de PostgreSQL :

```bash
pg_config --configure
```

### 8.3. Scripts de Validation

**V√©rifier la configuration active** :

```sql
-- Param√®tres modifi√©s
SELECT name, setting, unit, source
FROM pg_settings
WHERE source != 'default'
ORDER BY name;

-- Param√®tres n√©cessitant un restart
SELECT name, setting, pending_restart
FROM pg_settings
WHERE pending_restart
ORDER BY name;
```

---

## 9. Connection Pooling avec PgBouncer

PostgreSQL ne scale pas bien avec des milliers de connexions directes. Solution : **PgBouncer**.

### 9.1. Pourquoi PgBouncer ?

**Probl√®me** : Chaque connexion PostgreSQL = 1 processus (~10 MB RAM).

- 1000 connexions = 10 GB RAM + overhead CPU
- Context switching √©lev√©
- Performances d√©grad√©es

**Solution** : PgBouncer multiplexe les connexions.

**Architecture** :

```
Application: 1000 connexions logiques
         ‚Üì
    PgBouncer (pool)
         ‚Üì
PostgreSQL: 100 connexions physiques
```

### 9.2. Installation

```bash
# RHEL/CentOS
sudo dnf install pgbouncer

# Debian/Ubuntu
sudo apt install pgbouncer
```

### 9.3. Configuration de Base

**Fichier** : `/etc/pgbouncer/pgbouncer.ini`

```ini
[databases]
myapp = host=localhost port=5432 dbname=myapp

[pgbouncer]
# Mode de pooling
pool_mode = transaction

# Connexions PostgreSQL
default_pool_size = 25
max_client_conn = 1000

# Authentification
auth_type = scram-sha-256
auth_file = /etc/pgbouncer/userlist.txt

# √âcoute
listen_addr = 0.0.0.0
listen_port = 6432

# Logs
logfile = /var/log/pgbouncer/pgbouncer.log
pidfile = /var/run/pgbouncer/pgbouncer.pid
```

### 9.4. Modes de Pooling

**1. Transaction Mode** (recommand√© pour la plupart des cas)

```ini
pool_mode = transaction
```

- Connexion rendue au pool apr√®s chaque **transaction**
- Ratio √©lev√© (1:100)
- Compatible avec la plupart des applications

**Limitations** :
- Pas de `SET` persistant entre transactions
- Pas de cursors/prepared statements partag√©s

**2. Session Mode**

```ini
pool_mode = session
```

- Connexion rendue apr√®s **d√©connexion du client**
- Ratio faible (1:10)
- Compatible avec toutes les fonctionnalit√©s PostgreSQL

**3. Statement Mode**

```ini
pool_mode = statement
```

- Connexion rendue apr√®s chaque **requ√™te**
- Ratio tr√®s √©lev√©, mais tr√®s limitatif

### 9.5. Dimensionnement

**Formule** :

```
default_pool_size = max_connections PostgreSQL / nombre de bases pool√©es
```

**Exemple** :

- PostgreSQL : `max_connections = 100`
- 2 bases : myapp, analytics
- PgBouncer : `default_pool_size = 50` (50 pour myapp, 50 pour analytics)

### 9.6. Configuration PostgreSQL Ajust√©e

Avec PgBouncer, r√©duire `max_connections` :

```conf
# postgresql.conf
max_connections = 100  # Au lieu de 1000

# PgBouncer g√®re la concurrence applicative
```

---

## 10. Validation et Monitoring de Configuration

### 10.1. Checklist Post-Configuration

```sql
-- ‚úÖ V√©rifier shared_buffers
SHOW shared_buffers;
-- Attendu : ~25% RAM

-- ‚úÖ V√©rifier effective_cache_size
SHOW effective_cache_size;
-- Attendu : ~75% RAM

-- ‚úÖ V√©rifier work_mem
SHOW work_mem;
-- Attendu : Selon charge (16-256 MB)

-- ‚úÖ V√©rifier max_connections
SHOW max_connections;
-- Attendu : 50-200 (avec PgBouncer)

-- ‚úÖ V√©rifier WAL
SHOW max_wal_size;
-- Attendu : 4-16 GB

-- ‚úÖ V√©rifier I/O asynchrone (PG 18)
SHOW io_method;
-- Attendu : async

-- ‚úÖ V√©rifier autovacuum
SHOW autovacuum;
-- Attendu : on
```

### 10.2. Monitoring des Ressources

```sql
-- Cache hit ratio (doit √™tre > 95%)
SELECT
  sum(heap_blks_read) as heap_read,
  sum(heap_blks_hit) as heap_hit,
  sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)) as ratio
FROM pg_statio_user_tables;

-- Connexions actives
SELECT count(*) FROM pg_stat_activity WHERE state = 'active';

-- Temporary files (sympt√¥me de work_mem insuffisant)
SELECT
  datname,
  temp_files,
  pg_size_pretty(temp_bytes) as temp_size
FROM pg_stat_database
WHERE temp_files > 0
ORDER BY temp_bytes DESC;
```

### 10.3. Ajustements It√©ratifs

La configuration optimale est **it√©rative** :

1. **Baseline** : Appliquer les recommandations de cette section
2. **Monitoring** : Observer pendant 1-2 semaines
3. **Identifier** : Bottlenecks (CPU, I/O, RAM, locks)
4. **Ajuster** : Param√®tres sp√©cifiques
5. **Valider** : Mesurer l'impact
6. **R√©p√©ter** : Cycle continu

---

## 11. Configuration Syst√®me (OS Tuning)

### 11.1. Limites de Fichiers Ouverts

```bash
# /etc/security/limits.conf
postgres soft nofile 65536
postgres hard nofile 65536
```

### 11.2. Shared Memory (si besoin)

```bash
# /etc/sysctl.conf
kernel.shmmax = 17179869184  # 16 GB
kernel.shmall = 4194304      # Pages
```

Appliquer :

```bash
sudo sysctl -p
```

### 11.3. Swappiness

```bash
# R√©duire le swap (pr√©f√©rer RAM)
vm.swappiness = 10

# Appliquer
sudo sysctl -w vm.swappiness=10
echo "vm.swappiness=10" | sudo tee -a /etc/sysctl.conf
```

### 11.4. Transparent Huge Pages (THP)

D√©sactiver THP (recommand√© pour bases de donn√©es) :

```bash
# Temporaire
echo never | sudo tee /sys/kernel/mm/transparent_hugepage/enabled

# Permanent (via grub)
sudo grubby --update-kernel=ALL --args="transparent_hugepage=never"
sudo reboot
```

---

## 12. Template de Configuration PostgreSQL 18

Voici un **template complet** pour PostgreSQL 18 en production (serveur 16 GB, OLTP, SSD).

```conf
# ==========================================
# POSTGRESQL 18 - CONFIGURATION PRODUCTION
# ==========================================
# Serveur: 16 GB RAM, 8 CPUs, SSD
# Charge: OLTP (haute concurrence)
# Mise √† jour: 2025-11

# ==========================================
# CONNEXIONS
# ==========================================
max_connections = 200
superuser_reserved_connections = 5

# ==========================================
# M√âMOIRE
# ==========================================
shared_buffers = 4GB
effective_cache_size = 12GB
work_mem = 16MB
maintenance_work_mem = 1GB

# ==========================================
# WAL (Write-Ahead Log)
# ==========================================
wal_level = replica
max_wal_size = 4GB
min_wal_size = 1GB
checkpoint_timeout = 10min
checkpoint_completion_target = 0.9
wal_buffers = 16MB

# ==========================================
# I/O (PostgreSQL 18)
# ==========================================
io_method = 'async'
random_page_cost = 1.1
effective_io_concurrency = 200

# ==========================================
# PLANIFICATEUR
# ==========================================
default_statistics_target = 100
constraint_exclusion = partition

# ==========================================
# AUTOVACUUM (PostgreSQL 18)
# ==========================================
autovacuum = on
autovacuum_max_workers = 4
autovacuum_naptime = 30s
autovacuum_vacuum_scale_factor = 0.05
autovacuum_vacuum_max_threshold = 10000000
autovacuum_analyze_scale_factor = 0.05
autovacuum_vacuum_cost_delay = 2ms
autovacuum_vacuum_cost_limit = 200

# ==========================================
# LOGGING
# ==========================================
logging_collector = on
log_directory = 'log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_rotation_age = 1d
log_rotation_size = 100MB
log_connections = on
log_disconnections = on
log_duration = off
log_statement = 'ddl'
log_min_duration_statement = 1000
log_line_prefix = '%t [%p]: user=%u,db=%d,app=%a,client=%h '

# ==========================================
# S√âCURIT√â
# ==========================================
ssl = on
ssl_cert_file = '/path/to/server.crt'
ssl_key_file = '/path/to/server.key'
ssl_min_protocol_version = 'TLSv1.3'
password_encryption = scram-sha-256

# ==========================================
# R√âPLICATION (si applicable)
# ==========================================
# max_wal_senders = 10
# wal_keep_size = 1GB
# hot_standby = on
```

---

## 13. Ressources et Documentation

### Documentation Officielle
- [PostgreSQL Server Configuration](https://www.postgresql.org/docs/18/runtime-config.html)
- [Resource Consumption](https://www.postgresql.org/docs/18/runtime-config-resource.html)
- [WAL Configuration](https://www.postgresql.org/docs/18/runtime-config-wal.html)

### Outils
- **PGTune** : https://pgtune.leopard.in.ua/
- **pg_config** : Commande syst√®me
- **pg_settings** : Vue syst√®me

### Livres
- "PostgreSQL: Up and Running" (Regina Obe, Leo Hsu)
- "The Art of PostgreSQL" (Dimitri Fontaine)

### Blogs
- **Percona Blog** : https://www.percona.com/blog/
- **2ndQuadrant** : https://www.2ndquadrant.com/en/blog/
- **Cybertec** : https://www.cybertec-postgresql.com/en/blog/

---

## Conclusion

La configuration optimale de PostgreSQL est un **√©quilibre** entre :
- **Ressources mat√©rielles** disponibles
- **Type de charge** (OLTP, OLAP, mixte)
- **Besoins applicatifs** (latence, d√©bit, concurrence)

**Points cl√©s √† retenir** :

1. **M√©moire** : `shared_buffers` (25% RAM), `effective_cache_size` (75% RAM), `work_mem` (ajust√© selon concurrence)
2. **Connexions** : Utiliser PgBouncer au-del√† de 100-200 connexions
3. **WAL** : Augmenter `max_wal_size` pour r√©duire les checkpoints
4. **I/O** : Activer `io_method = 'async'` (PG 18) pour gains massifs
5. **Autovacuum** : Toujours activ√©, ajuster selon le volume
6. **Monitoring** : Valider et ajuster en continu

**La configuration n'est jamais "termin√©e"** - c'est un processus continu d'observation, d'ajustement et de validation. Commencez avec les valeurs recommand√©es ici, puis affinez selon vos observations terrain.

---

**Section suivante** : 19.6.3. Monitoring et alerting

‚è≠Ô∏è [Monitoring et alerting](/19-postgresql-en-production/06.3-monitoring-alerting.md)
