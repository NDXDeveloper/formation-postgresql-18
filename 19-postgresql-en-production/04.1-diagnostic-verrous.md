üîù Retour au [Sommaire](/SOMMAIRE.md)

# 19.4.1. Diagnostic des verrous (pg_locks, pg_blocking_pids)

## Introduction : Qu'est-ce qu'un verrou ?

Avant de plonger dans le diagnostic, comprenons d'abord ce qu'est un **verrou** (ou *lock* en anglais) dans PostgreSQL.

Imaginez une biblioth√®que o√π plusieurs personnes veulent consulter ou modifier le m√™me livre en m√™me temps. Pour √©viter le chaos, il faut √©tablir des r√®gles : si quelqu'un est en train de corriger une page, personne d'autre ne peut modifier cette page en m√™me temps. C'est exactement le r√¥le des verrous dans une base de donn√©es.

### Pourquoi les verrous sont-ils n√©cessaires ?

Les verrous garantissent l'**int√©grit√© des donn√©es** dans un environnement concurrent. Ils emp√™chent :

- **Les √©critures simultan√©es conflictuelles** : Deux transactions ne peuvent pas modifier la m√™me ligne en m√™me temps
- **Les lectures incoh√©rentes** : Une transaction ne doit pas lire des donn√©es en cours de modification
- **Les modifications de structure dangereuses** : Emp√™cher la suppression d'une table pendant qu'elle est utilis√©e

PostgreSQL g√®re automatiquement la majorit√© des verrous gr√¢ce √† son syst√®me MVCC (Multiversion Concurrency Control), mais il arrive parfois que des **blocages** (*blocking*) se produisent.

---

## Les sympt√¥mes d'un probl√®me de verrous

Comment savoir si vous avez un probl√®me de verrous ? Voici les signes typiques :

1. **Des requ√™tes qui "pendent"** : Une requ√™te qui devrait prendre 100ms prend maintenant plusieurs secondes, voire minutes
2. **L'application devient lente** : Les utilisateurs se plaignent de temps de r√©ponse anormalement longs
3. **Des timeouts** : L'application re√ßoit des erreurs de type "timeout" ou "deadlock detected"
4. **Une base de donn√©es qui semble "fig√©e"** : Certaines op√©rations ne se terminent jamais

---

## Comprendre les types de verrous

PostgreSQL utilise diff√©rents types de verrous. Voici les principaux que vous rencontrerez :

### Verrous au niveau des lignes (Row-Level Locks)

- **FOR UPDATE** : Verrou exclusif sur une ligne, emp√™che toute modification
- **FOR SHARE** : Verrou partag√©, permet la lecture mais pas la modification

### Verrous au niveau des tables (Table-Level Locks)

PostgreSQL d√©finit 8 modes de verrous de table, du moins au plus restrictif :

1. **ACCESS SHARE** : Acquis par `SELECT` (lecture simple)
2. **ROW SHARE** : Acquis par `SELECT FOR UPDATE`
3. **ROW EXCLUSIVE** : Acquis par `INSERT`, `UPDATE`, `DELETE`
4. **SHARE UPDATE EXCLUSIVE** : Acquis par `VACUUM`, `CREATE INDEX CONCURRENTLY`
5. **SHARE** : Acquis par `CREATE INDEX` (sans CONCURRENTLY)
6. **SHARE ROW EXCLUSIVE** : Protection contre modifications concurrentes
7. **EXCLUSIVE** : Bloque tous sauf ACCESS SHARE
8. **ACCESS EXCLUSIVE** : Le plus restrictif, acquis par `ALTER TABLE`, `DROP TABLE`, `TRUNCATE`

**Important pour les d√©butants** : Vous n'avez pas besoin de m√©moriser tous ces modes. Retenez simplement que :
- Les lectures (`SELECT`) sont g√©n√©ralement non-bloquantes
- Les √©critures (`INSERT`, `UPDATE`, `DELETE`) peuvent se bloquer mutuellement
- Les modifications de structure (`ALTER TABLE`, `DROP`) bloquent tout

---

## La vue `pg_locks` : Votre outil de diagnostic principal

La vue syst√®me `pg_locks` est **la fen√™tre** qui vous permet de voir tous les verrous actifs dans votre base de donn√©es.

### Structure de base de pg_locks

```sql
SELECT * FROM pg_locks LIMIT 5;
```

Cette vue contient de nombreuses colonnes. Voici les plus importantes pour d√©buter :

| Colonne | Description |
|---------|-------------|
| `locktype` | Type de verrou (relation, tuple, transactionid, etc.) |
| `database` | OID de la base de donn√©es concern√©e |
| `relation` | OID de la table concern√©e (NULL si non applicable) |
| `pid` | ID du processus PostgreSQL qui d√©tient le verrou |
| `mode` | Mode du verrou (AccessShareLock, RowExclusiveLock, etc.) |
| `granted` | `true` si le verrou est acquis, `false` s'il est en attente |
| `fastpath` | `true` si acquisition rapide (optimisation interne) |

### Interpr√©ter la colonne `granted`

C'est la colonne la plus importante pour diagnostiquer un probl√®me :

- **`granted = true`** : Le processus **d√©tient** actuellement le verrou
- **`granted = false`** : Le processus **attend** d'obtenir le verrou (il est bloqu√© !)

---

## Premi√®re requ√™te de diagnostic : Identifier les verrous en attente

Voici une requ√™te simple pour voir quels processus sont **bloqu√©s** en attente d'un verrou :

```sql
SELECT
    pid,
    usename,
    pg_blocking_pids(pid) AS blocked_by,
    query AS current_query
FROM pg_stat_activity
WHERE cardinality(pg_blocking_pids(pid)) > 0;
```

**Explication ligne par ligne** :

- `pid` : L'identifiant du processus bloqu√©
- `usename` : Le nom de l'utilisateur qui a lanc√© la requ√™te
- `pg_blocking_pids(pid)` : **Fonction magique** qui retourne les PID des processus bloquants
- `query` : La requ√™te qui est bloqu√©e
- `WHERE cardinality(pg_blocking_pids(pid)) > 0` : Filtre pour ne garder que les processus effectivement bloqu√©s

### Exemple de r√©sultat

```
 pid  | usename  | blocked_by |           current_query
------+----------+------------+-----------------------------------
 1234 | app_user | {5678}     | UPDATE orders SET status = 'paid' WHERE id = 42;
```

**Interpr√©tation** : Le processus 1234 est bloqu√© par le processus 5678.

---

## La fonction `pg_blocking_pids()` : Votre meilleure amie

Introduite dans PostgreSQL 9.6, `pg_blocking_pids()` est une fonction qui simplifie √©norm√©ment le diagnostic.

### Syntaxe

```sql
pg_blocking_pids(pid integer) ‚Üí integer[]
```

Elle retourne un **tableau** contenant les PID de tous les processus qui bloquent le processus sp√©cifi√©.

### Exemple d'utilisation

```sql
-- Trouver qui bloque le processus 1234
SELECT pg_blocking_pids(1234);

-- R√©sultat possible : {5678}
```

### Construire une vue compl√®te du blocage

Pour avoir une vue d'ensemble, vous pouvez cr√©er cette requ√™te qui montre √† la fois les bloquants et les bloqu√©s :

```sql
SELECT
    blocked_activity.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_activity.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_query,
    blocking_activity.query AS blocking_query
FROM pg_stat_activity AS blocked_activity
JOIN pg_stat_activity AS blocking_activity
    ON blocking_activity.pid = ANY(pg_blocking_pids(blocked_activity.pid))
WHERE cardinality(pg_blocking_pids(blocked_activity.pid)) > 0;
```

**Cette requ√™te vous donne** :
- Qui est bloqu√© (`blocked_pid`, `blocked_user`, `blocked_query`)
- Qui bloque (`blocking_pid`, `blocking_user`, `blocking_query`)

---

## Requ√™te avanc√©e : Vue d√©taill√©e avec informations de verrous

Pour aller plus loin, voici une requ√™te qui combine `pg_locks` et `pg_stat_activity` :

```sql
SELECT
    l.pid,
    l.mode,
    l.granted,
    l.locktype,
    l.relation::regclass AS table_name,
    a.usename,
    a.query,
    a.state,
    age(now(), a.query_start) AS query_duration
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
WHERE NOT l.granted
ORDER BY a.query_start;
```

**Que montre cette requ√™te ?**

- Les verrous **non accord√©s** (`NOT l.granted`)
- Le nom de la table concern√©e (`l.relation::regclass`)
- La dur√©e d'attente (`age(now(), a.query_start)`)
- L'√©tat du processus (`a.state`)

### Exemple de r√©sultat

```
 pid  |       mode        | granted | locktype |   table_name   | usename  | query_duration
------+-------------------+---------+----------+----------------+----------+----------------
 1234 | RowExclusiveLock  | false   | tuple    | orders         | app_user | 00:02:15
```

**Interpr√©tation** : Le processus 1234 attend depuis 2 minutes et 15 secondes un verrou de type "RowExclusiveLock" sur la table `orders`.

---

## Diagnostic en temps r√©el : Trouver la cha√Æne de blocage

Parfois, vous avez une **cha√Æne de blocages** : A bloque B, qui bloque C, qui bloque D...

Voici une requ√™te r√©cursive (avec CTE) pour visualiser toute la cha√Æne :

```sql
WITH RECURSIVE lock_chain AS (
    -- Ancrage : Les processus qui ne sont pas bloqu√©s mais qui bloquent d'autres
    SELECT
        pid,
        pg_blocking_pids(pid) AS blocking_pids,
        array[pid] AS chain,
        1 AS depth
    FROM pg_stat_activity
    WHERE cardinality(pg_blocking_pids(pid)) > 0

    UNION ALL

    -- R√©cursion : Remonter la cha√Æne des bloquants
    SELECT
        a.pid,
        pg_blocking_pids(a.pid),
        lc.chain || a.pid,
        lc.depth + 1
    FROM lock_chain lc
    JOIN pg_stat_activity a ON a.pid = ANY(lc.blocking_pids)
    WHERE lc.depth < 10  -- Limite de profondeur pour √©viter boucles infinies
)
SELECT
    chain AS blocking_chain,
    depth,
    a.pid,
    a.usename,
    a.query
FROM lock_chain lc
JOIN pg_stat_activity a ON a.pid = lc.chain[1]
ORDER BY depth DESC, chain;
```

**Cette requ√™te avanc√©e** montre toute la hi√©rarchie des blocages, ce qui est tr√®s utile pour comprendre un probl√®me complexe.

---

## Identifier les deadlocks (interblocages)

Un **deadlock** (ou interblocage) se produit quand deux transactions s'attendent mutuellement :

- Transaction A d√©tient le verrou sur la ligne X et attend la ligne Y
- Transaction B d√©tient le verrou sur la ligne Y et attend la ligne X

PostgreSQL **d√©tecte automatiquement** les deadlocks et en annule un (avec l'erreur `deadlock detected`).

### Comment voir les deadlocks dans les logs

Les deadlocks sont enregistr√©s dans les logs PostgreSQL. Configurez votre `postgresql.conf` :

```
log_lock_waits = on
deadlock_timeout = 1s
```

Puis consultez vos logs pour voir les d√©tails des deadlocks d√©tect√©s.

---

## R√©soudre un blocage : Les actions possibles

Une fois que vous avez identifi√© le processus bloquant, plusieurs options s'offrent √† vous :

### 1. Attendre (Solution la plus simple)

Si la transaction bloquante devrait se terminer rapidement, **attendez simplement**. Les verrous sont lib√©r√©s automatiquement √† la fin de la transaction.

### 2. Terminer la transaction bloquante (Solution radicale)

Si une transaction est rest√©e ouverte par erreur ou bloque tout le monde, vous pouvez la terminer :

```sql
-- Terminer proprement la connexion
SELECT pg_terminate_backend(5678);

-- Si √ßa ne marche pas, forcer l'arr√™t (plus violent)
SELECT pg_cancel_backend(5678);
```

**‚ö†Ô∏è ATTENTION** :
- `pg_cancel_backend()` annule uniquement la **requ√™te en cours**
- `pg_terminate_backend()` ferme compl√®tement la **connexion**
- Utilisez ces commandes avec pr√©caution en production !

### 3. Optimiser les requ√™tes pour r√©duire les blocages

√Ä plus long terme, les solutions pr√©ventives sont meilleures :

- **Raccourcir les transactions** : Ne gardez pas les transactions ouvertes longtemps
- **Indexer correctement** : Les requ√™tes plus rapides retiennent les verrous moins longtemps
- **Utiliser FOR UPDATE SKIP LOCKED** : Permet de sauter les lignes verrouill√©es plut√¥t que d'attendre
- **Ordonner les acc√®s** : Si plusieurs transactions acc√®dent aux m√™mes ressources, faites-le dans le m√™me ordre

---

## Requ√™te pratique : Vue de surveillance compl√®te

Voici une requ√™te "tout-en-un" √† garder sous la main pour surveiller votre base :

```sql
SELECT
    blocked.pid AS blocked_pid,
    blocked.usename AS blocked_user,
    blocked.state AS blocked_state,
    age(now(), blocked.query_start) AS blocked_duration,
    blocked.query AS blocked_query,
    blocker.pid AS blocker_pid,
    blocker.usename AS blocker_user,
    blocker.state AS blocker_state,
    age(now(), blocker.query_start) AS blocker_duration,
    blocker.query AS blocker_query
FROM pg_stat_activity blocked
JOIN (
    SELECT DISTINCT
        blocking.pid,
        blocked_activity.pid AS blocked_by_pid
    FROM pg_stat_activity blocking
    JOIN pg_stat_activity blocked_activity
        ON blocking.pid = ANY(pg_blocking_pids(blocked_activity.pid))
) blocker_info ON blocker_info.blocked_by_pid = blocked.pid
JOIN pg_stat_activity blocker ON blocker.pid = blocker_info.pid
WHERE cardinality(pg_blocking_pids(blocked.pid)) > 0
ORDER BY blocked.query_start;
```

---

## Comprendre la vue `pg_locks` en d√©tail

Pour les curieux qui veulent aller plus loin, voici une exploration des principaux `locktype` :

### Types de verrous (`locktype`)

| Type | Description |
|------|-------------|
| `relation` | Verrou sur une table enti√®re |
| `tuple` | Verrou sur une ligne sp√©cifique |
| `transactionid` | Verrou sur un ID de transaction (pour attendre sa fin) |
| `virtualxid` | Verrou virtuel sur l'ID de transaction courante |
| `page` | Verrou sur une page de donn√©es (rare) |
| `advisory` | Verrou applicatif personnalis√© (voir Advisory Locks) |

### Modes de verrous les plus courants

```sql
SELECT mode, count(*)
FROM pg_locks
GROUP BY mode
ORDER BY count(*) DESC;
```

R√©sultat typique :

```
        mode         | count
---------------------+-------
 AccessShareLock     | 1245
 RowExclusiveLock    | 87
 ExclusiveLock       | 12
 ShareLock           | 3
```

---

## Bonnes pratiques pour √©viter les blocages

### 1. Gardez les transactions courtes

```sql
-- ‚ùå MAUVAIS : Transaction qui reste ouverte
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- ... longue pause, autre traitement application ...
-- ... requ√™te HTTP externe ...
COMMIT;

-- ‚úÖ BON : Transaction courte et focalis√©e
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;
```

### 2. √âvitez les modifications de sch√©ma aux heures de pointe

Les `ALTER TABLE` acqui√®rent un verrou `ACCESS EXCLUSIVE` qui bloque **toutes** les autres op√©rations.

```sql
-- Pr√©f√©rez les heures creuses pour :
ALTER TABLE users ADD COLUMN last_login TIMESTAMP;
DROP INDEX idx_old;
TRUNCATE TABLE logs;
```

### 3. Utilisez des index appropri√©s

Des requ√™tes lentes retiennent les verrous plus longtemps. Une bonne indexation r√©duit drastiquement les risques de blocage.

### 4. Configurez des timeouts appropri√©s

Dans votre application ou dans PostgreSQL :

```sql
-- Timeout de 5 secondes pour une requ√™te
SET statement_timeout = '5s';

-- Timeout pour l'acquisition d'un verrou
SET lock_timeout = '2s';
```

---

## Surveillance proactive : Cr√©er une vue personnalis√©e

Pour faciliter le monitoring r√©gulier, vous pouvez cr√©er une vue qui encapsule votre requ√™te de diagnostic :

```sql
CREATE OR REPLACE VIEW v_blocked_queries AS
SELECT
    blocked.pid AS blocked_pid,
    blocked.usename AS blocked_user,
    age(now(), blocked.query_start) AS wait_duration,
    blocked.query AS blocked_query,
    blocker.pid AS blocking_pid,
    blocker.usename AS blocking_user,
    blocker.query AS blocking_query,
    blocker.state AS blocking_state
FROM pg_stat_activity blocked
JOIN pg_stat_activity blocker
    ON blocker.pid = ANY(pg_blocking_pids(blocked.pid))
WHERE cardinality(pg_blocking_pids(blocked.pid)) > 0;
```

Ensuite, il suffit de faire :

```sql
SELECT * FROM v_blocked_queries;
```

---

## Outils graphiques pour visualiser les verrous

Si vous pr√©f√©rez une interface graphique, plusieurs outils peuvent vous aider :

### pgAdmin 4

- Onglet "Dashboard" ‚Üí Section "Server Activity"
- Menu "Tools" ‚Üí "Server Activity" (affiche `pg_stat_activity` et permet de terminer des processus)

### DBeaver

- Outils ‚Üí "Database Monitor" ‚Üí Vue "Locks"

### Monitoring avanc√© avec Grafana

Des dashboards Grafana pr√©-configur√©s existent pour PostgreSQL, avec des panneaux d√©di√©s aux verrous et blocages.

---

## Cas d'√©tude : Diagnostiquer un probl√®me r√©el

Imaginons ce sc√©nario : Votre application web est soudainement tr√®s lente. Voici la d√©marche de diagnostic :

### √âtape 1 : Identifier s'il y a des blocages

```sql
SELECT count(*)
FROM pg_stat_activity
WHERE cardinality(pg_blocking_pids(pid)) > 0;
```

**R√©sultat** : `45` ‚Üí Il y a 45 processus bloqu√©s !

### √âtape 2 : Identifier les coupables

```sql
SELECT
    blocker.pid,
    blocker.usename,
    blocker.query,
    count(*) AS blocked_count
FROM pg_stat_activity blocker
JOIN pg_stat_activity blocked
    ON blocker.pid = ANY(pg_blocking_pids(blocked.pid))
GROUP BY blocker.pid, blocker.usename, blocker.query
ORDER BY blocked_count DESC;
```

**R√©sultat** : Le processus 8765 bloque 42 autres processus avec la requ√™te :

```sql
UPDATE products SET stock = stock - 1 WHERE id = 123;
```

### √âtape 3 : Comprendre pourquoi

```sql
SELECT
    state,
    age(now(), state_change) AS time_in_state,
    age(now(), xact_start) AS transaction_age
FROM pg_stat_activity
WHERE pid = 8765;
```

**R√©sultat** :
```
 state  | time_in_state | transaction_age
--------+---------------+-----------------
 idle in transaction | 00:15:32 | 00:15:32
```

**Diagnostic** : La transaction est rest√©e ouverte depuis 15 minutes en √©tat "idle in transaction" ! L'application a probablement oubli√© de faire un `COMMIT` ou `ROLLBACK`.

### √âtape 4 : R√©soudre

```sql
-- Terminer cette connexion probl√©matique
SELECT pg_terminate_backend(8765);
```

### √âtape 5 : Pr√©vention

Ajoutez dans `postgresql.conf` :

```
idle_in_transaction_session_timeout = 60000  # 60 secondes
```

Cela fermera automatiquement les transactions inactives apr√®s 60 secondes.

---

## Commandes rapides √† m√©moriser

Voici un r√©capitulatif des commandes essentielles pour le diagnostic de verrous :

```sql
-- 1. Voir tous les processus bloqu√©s
SELECT pid, usename, pg_blocking_pids(pid), query
FROM pg_stat_activity
WHERE cardinality(pg_blocking_pids(pid)) > 0;

-- 2. Voir tous les verrous actifs
SELECT * FROM pg_locks WHERE NOT granted;

-- 3. Voir qui bloque qui (version simple)
SELECT
    blocked.pid AS blocked,
    blocker.pid AS blocker,
    blocked.query AS blocked_query
FROM pg_stat_activity blocked
JOIN pg_stat_activity blocker
    ON blocker.pid = ANY(pg_blocking_pids(blocked.pid));

-- 4. Terminer un processus bloquant
SELECT pg_terminate_backend(PID);

-- 5. Annuler une requ√™te sans tuer la connexion
SELECT pg_cancel_backend(PID);
```

---

## Ressources pour aller plus loin

- **Documentation officielle PostgreSQL** : [Chapitre "Explicit Locking"](https://www.postgresql.org/docs/current/explicit-locking.html)
- **pg_stat_activity** : [Documentation de la vue](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-VIEW)
- **pg_locks** : [Documentation de la vue](https://www.postgresql.org/docs/current/view-pg-locks.html)
- **Wiki PostgreSQL** : "Lock Monitoring" (contient des requ√™tes avanc√©es communautaires)

---

## R√©sum√© des points cl√©s

‚úÖ **Les verrous sont normaux** : Ils garantissent l'int√©grit√© des donn√©es

‚úÖ **`pg_locks`** : Vue syst√®me pour voir tous les verrous actifs

‚úÖ **`pg_blocking_pids()`** : Fonction pour identifier facilement qui bloque qui

‚úÖ **`granted = false`** : Signal d'alarme, un processus attend un verrou

‚úÖ **Terminer avec pr√©caution** : `pg_terminate_backend()` est une solution de dernier recours

‚úÖ **Pr√©vention** : Transactions courtes, bons index, timeouts configur√©s

‚úÖ **Monitoring proactif** : Cr√©ez des vues et des alertes pour d√©tecter les probl√®mes t√¥t

---

## Conclusion

Le diagnostic des verrous est une comp√©tence essentielle pour tout d√©veloppeur ou DevOps travaillant avec PostgreSQL. Avec les outils pr√©sent√©s (`pg_locks`, `pg_blocking_pids()`, et `pg_stat_activity`), vous √™tes maintenant √©quip√© pour :

1. **Identifier rapidement** les situations de blocage
2. **Comprendre** qui bloque qui et pourquoi
3. **R√©soudre** les situations d'urgence
4. **Pr√©venir** les probl√®mes futurs

N'oubliez pas : la meilleure r√©solution de probl√®me est la **pr√©vention**. Des transactions courtes, une bonne indexation et une surveillance proactive vous √©viteront la majorit√© des cauchemars li√©s aux verrous.

---

**Prochaine √©tape** : 19.4.2 - Saturation des ressources (CPU, RAM, I/O)

---


‚è≠Ô∏è [Saturation des ressources (CPU, RAM, I/O)](/19-postgresql-en-production/04.2-saturation-ressources.md)
