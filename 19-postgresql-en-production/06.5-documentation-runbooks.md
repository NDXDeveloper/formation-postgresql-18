üîù Retour au [Sommaire](/SOMMAIRE.md)

# 19.6.5. Documentation Runbooks

## Introduction

Un **runbook** (ou playbook) est un document op√©rationnel qui d√©crit **√©tape par √©tape** comment g√©rer une situation sp√©cifique : incident, t√¢che de maintenance, proc√©dure de d√©ploiement, etc.

**Pourquoi les runbooks sont critiques** :

1. **R√©duire le stress** : En urgence, avoir un guide clair √©vite la panique
2. **Acc√©l√©rer la r√©solution** : Pas besoin de chercher comment faire
3. **Standardiser** : Tout le monde suit la m√™me proc√©dure √©prouv√©e
4. **Former** : Les nouveaux membres apprennent rapidement
5. **Am√©liorer** : Documenter permet d'optimiser les processus

**Analogie** : Un runbook est comme une recette de cuisine. Sans recette, vous pouvez cuisiner, mais c'est plus long, plus risqu√©, et moins reproductible. Avec une bonne recette, m√™me un d√©butant peut r√©ussir.

> **Principe cl√©** : En production, √† 3h du matin avec un incident critique, vous ne voulez pas r√©fl√©chir. Vous voulez **suivre un processus √©prouv√©**.

Cette section vous guide pour cr√©er des runbooks efficaces pour PostgreSQL.

---

## 1. Anatomie d'un Bon Runbook

### 1.1. Structure Standard

Un runbook efficace contient toujours :

```markdown
# RUNBOOK: [Titre descriptif]

## M√©tadonn√©es
- **Cr√©√© par**: Nom de l'auteur
- **Date cr√©ation**: YYYY-MM-DD
- **Derni√®re mise √† jour**: YYYY-MM-DD
- **Version**: X.Y
- **Criticit√©**: [Critique/√âlev√©e/Moyenne/Faible]
- **Fr√©quence**: [Quotidien/Hebdo/Mensuel/Rare/Urgence]

## Contexte
[Quand utiliser ce runbook ? Quel probl√®me r√©sout-il ?]

## Sympt√¥mes
[Comment reconna√Ætre cette situation ?]
- Sympt√¥me 1
- Sympt√¥me 2
- Sympt√¥me 3

## Pr√©requis
[Acc√®s, permissions, outils n√©cessaires]
- [ ] Acc√®s SSH au serveur
- [ ] Acc√®s psql en tant que postgres
- [ ] Monitoring dashboard disponible

## Proc√©dure
### √âtape 1: [Action]
[Description d√©taill√©e]
```bash
# Commande √† ex√©cuter
```
**R√©sultat attendu**: [Ce que vous devez voir]
**Si √©chec**: [Que faire si √ßa ne marche pas]

### √âtape 2: [Action]
...

## Validation
[Comment v√©rifier que le probl√®me est r√©solu ?]
- [ ] Crit√®re 1
- [ ] Crit√®re 2

## Rollback
[Comment annuler les changements si n√©cessaire]

## Pr√©vention
[Comment √©viter que √ßa se reproduise]

## Contacts d'urgence
- DBA Senior: +33 6 XX XX XX XX
- Support Cloud: support@provider.com

## Historique des utilisations
| Date       | Par qui | Contexte | R√©sultat |
|------------|---------|----------|----------|
| 2025-11-23 | Alice   | Prod     | ‚úÖ OK    |
```

### 1.2. Principes de R√©daction

**DO** ‚úÖ :
- √âcrire pour quelqu'un qui ne conna√Æt pas le sujet
- Utiliser des commandes copiables-collables
- Indiquer les r√©sultats attendus
- Ajouter des captures d'√©cran si utile
- Tester le runbook avant de le publier
- Mettre √† jour apr√®s chaque utilisation

**DON'T** ‚ùå :
- Supposer des connaissances implicites
- Utiliser du jargon sans l'expliquer
- Omettre les cas d'erreur
- Oublier les contacts d'urgence
- Laisser vieillir sans maintenance

---

## 2. Runbooks Essentiels PostgreSQL

### 2.1. RUNBOOK: Saturation des Connexions

```markdown
# RUNBOOK: R√©solution Saturation des Connexions PostgreSQL

## M√©tadonn√©es
- **Criticit√©**: Critique
- **RTO**: 5 minutes
- **Version**: 1.2
- **Derni√®re MAJ**: 2025-11-23

## Contexte
PostgreSQL refuse de nouvelles connexions car `max_connections` est atteint.
Applications affichent "FATAL: sorry, too many clients already".

## Sympt√¥mes
- ‚ùå Applications ne peuvent plus se connecter
- ‚ö†Ô∏è Dashboard monitoring: connexions = max_connections
- ‚ö†Ô∏è Logs PostgreSQL: "too many clients already"

## Pr√©requis
- [ ] Acc√®s SSH au serveur PostgreSQL
- [ ] Acc√®s psql via socket Unix (bypass limit)
- [ ] Acc√®s monitoring dashboard

## Proc√©dure

### √âtape 1: Confirmer le Probl√®me

```bash
# Se connecter via socket Unix (bypass connexion limit)
sudo -u postgres psql

# V√©rifier les connexions actives
SELECT count(*) as current,
       (SELECT setting::int FROM pg_settings WHERE name = 'max_connections') as max
FROM pg_stat_activity;
```

**R√©sultat attendu**:
```
 current | max
---------+-----
     100 | 100
```

**Si current ‚âà max** ‚Üí Probl√®me confirm√©, continuer.

### √âtape 2: Identifier les Connexions

```sql
-- Vue d'ensemble
SELECT
  state,
  count(*) as count,
  round(100.0 * count(*) / sum(count(*)) OVER (), 1) as percent
FROM pg_stat_activity
GROUP BY state
ORDER BY count DESC;
```

**Analyser les r√©sultats**:
- Beaucoup de **idle** ‚Üí Applications gardent connexions ouvertes
- Beaucoup de **idle in transaction** ‚Üí Transactions non termin√©es
- Beaucoup de **active** ‚Üí Charge r√©elle √©lev√©e

### √âtape 3: Tuer les Connexions Idle

```sql
-- Lister les connexions idle > 10 minutes
SELECT
  pid,
  usename,
  application_name,
  client_addr,
  state,
  now() - state_change as idle_time,
  query
FROM pg_stat_activity
WHERE state = 'idle'
  AND now() - state_change > interval '10 minutes'
ORDER BY idle_time DESC;

-- Tuer ces connexions (REMPLACER LES PID)
SELECT pg_terminate_backend(12345);
SELECT pg_terminate_backend(12346);
-- ... r√©p√©ter pour chaque PID
```

**R√©sultat attendu**: Connexions lib√©r√©es, applications peuvent se reconnecter.

### √âtape 4: Tuer les Transactions Bloqu√©es

```sql
-- Transactions idle in transaction > 5 minutes
SELECT
  pid,
  usename,
  state,
  now() - xact_start as duration,
  query
FROM pg_stat_activity
WHERE state = 'idle in transaction'
  AND now() - xact_start > interval '5 minutes'
ORDER BY duration DESC;

-- Tuer (DANGER: peut causer rollback)
SELECT pg_terminate_backend(PID);
```

**‚ö†Ô∏è ATTENTION**: Tuer une transaction provoque un ROLLBACK.
Coordonner avec les √©quipes applicatives si possible.

### √âtape 5: Solution d'Urgence (Si Toujours Satur√©)

```sql
-- Augmenter temporairement max_connections
ALTER SYSTEM SET max_connections = 200;

-- Recharger la configuration
SELECT pg_reload_conf();
```

**‚ö†Ô∏è NOTE**: N√©cessite un **RESTART** pour prendre effet complet.
Planifier un restart en fen√™tre de maintenance.

```bash
# Restart PostgreSQL
sudo systemctl restart postgresql-18
```

## Validation

- [ ] Connexions lib√©r√©es: `SELECT count(*) FROM pg_stat_activity;` < max_connections
- [ ] Applications peuvent se connecter
- [ ] Pas de nouvelles erreurs dans les logs
- [ ] Monitoring dashboard: connexions < 80%

## Rollback

```sql
-- Si augmentation temporaire de max_connections
ALTER SYSTEM RESET max_connections;
-- Restart requis
```

## Pr√©vention (Action Post-Incident)

1. **Court terme**:
   - Installer PgBouncer (connection pooling)
   - Configurer connection timeout dans applications

2. **Moyen terme**:
   - Auditer les applications: Qui garde les connexions ?
   - Impl√©menter connection pooling c√¥t√© app
   - Monitorer trend des connexions

3. **Long terme**:
   - Revoir l'architecture (microservices trop de connexions ?)
   - Dimensionner max_connections appropri√©
   - Alertes si connexions > 80%

## Contacts d'Urgence
- DBA Principal: +33 6 XX XX XX XX (disponible 24/7)
- Lead Dev Backend: +33 6 YY YY YY YY
- Astreinte Ops: ops-oncall@company.com

## Historique
| Date       | Qui     | Contexte          | R√©sultat       |
|------------|---------|-------------------|----------------|
| 2025-11-20 | Alice   | Prod - Black Friday| ‚úÖ R√©solu 8min |
| 2025-10-15 | Bob     | Staging - Test    | ‚úÖ R√©solu 5min |
```

---

### 2.2. RUNBOOK: Requ√™tes Lentes Bloquant la Production

```markdown
# RUNBOOK: Gestion des Requ√™tes Lentes

## M√©tadonn√©es
- **Criticit√©**: √âlev√©e
- **RTO**: 10 minutes
- **Version**: 1.1

## Contexte
Une ou plusieurs requ√™tes lentes saturent les ressources et ralentissent
toutes les autres op√©rations.

## Sympt√¥mes
- ‚ö†Ô∏è CPU > 90% de fa√ßon soutenue
- ‚ö†Ô∏è Latence applicative √©lev√©e (p95 > 1s)
- ‚ö†Ô∏è Monitoring: Requ√™tes actives avec temps d'ex√©cution √©lev√©

## Proc√©dure

### √âtape 1: Identifier les Requ√™tes Lentes

```sql
-- Requ√™tes actives > 10 secondes
SELECT
  pid,
  usename,
  application_name,
  state,
  now() - query_start as duration,
  query
FROM pg_stat_activity
WHERE state = 'active'
  AND now() - query_start > interval '10 seconds'
ORDER BY duration DESC
LIMIT 10;
```

**Noter les PIDs** des requ√™tes probl√©matiques.

### √âtape 2: Analyser le Plan d'Ex√©cution

```sql
-- Se connecter en tant que l'utilisateur probl√©matique
SET ROLE username;

-- EXPLAIN ANALYZE sur la requ√™te (copier depuis pg_stat_activity)
EXPLAIN (ANALYZE, BUFFERS)
SELECT ... -- COLLER LA REQU√äTE ICI
```

**Identifier**:
- Sequential Scans sur grosses tables
- Nested Loops sur tables volumineuses
- Sorts sans index appropri√©

### √âtape 3: D√©cision Tuer ou Laisser

**Crit√®res pour tuer**:
- Dur√©e > 5 minutes ET pas critique m√©tier
- Bloque d'autres transactions (v√©rifier locks)
- Utilise trop de ressources (temp files massifs)

**Crit√®res pour laisser**:
- Batch pr√©vu (import, migration)
- Transaction critique m√©tier
- Presque termin√© (> 90% avancement si visible)

### √âtape 4: Tuer la Requ√™te (si n√©cessaire)

```sql
-- Tuer gentiment (laisse finir l'instruction en cours)
SELECT pg_cancel_backend(PID);

-- Attendre 30 secondes...

-- Si toujours l√†, tuer brutalement
SELECT pg_terminate_backend(PID);
```

### √âtape 5: Solution Temporaire (Optimiser)

```sql
-- Si index manquant est √©vident
CREATE INDEX CONCURRENTLY idx_table_column ON table(column);

-- Si requ√™te r√©currente, augmenter work_mem pour cette session
ALTER USER username SET work_mem = '256MB';
```

## Validation

- [ ] Requ√™te termin√©e ou tu√©e
- [ ] CPU redescendu < 70%
- [ ] Latence applicative normale
- [ ] Pas de nouvelles requ√™tes lentes similaires

## Pr√©vention

1. Analyser la requ√™te avec EXPLAIN
2. Cr√©er index appropri√©
3. R√©√©crire requ√™te si inefficace
4. Ajouter monitoring sp√©cifique
5. Alerter si cette requ√™te redevient lente

## Contacts
- DBA: +33 6 XX XX XX XX
- Dev Team Lead: +33 6 YY YY YY YY
```

---

### 2.3. RUNBOOK: Espace Disque Satur√©

```markdown
# RUNBOOK: Gestion Espace Disque Critique

## M√©tadonn√©es
- **Criticit√©**: Critique
- **RTO**: 15 minutes
- **Version**: 1.3

## Contexte
Le disque contenant PostgreSQL est plein ou presque plein.
PostgreSQL peut s'arr√™ter ou refuser d'√©crire.

## Sympt√¥mes
- ‚ùå PostgreSQL crashe ou refuse √©critures
- ‚ö†Ô∏è Monitoring: Disk usage > 90%
- ‚ö†Ô∏è Logs: "No space left on device"

## Pr√©requis
- [ ] Acc√®s root au serveur
- [ ] Connaissance architecture disques
- [ ] Backup r√©cent disponible

## Proc√©dure

### √âtape 1: V√©rifier l'Espace Disque

```bash
# Vue d'ensemble
df -h

# Focus sur PostgreSQL
df -h /var/lib/pgsql
df -h /mnt/wal_archive  # Si WAL archiving
```

**Noter le pourcentage utilis√©**.

### √âtape 2: Identifier les Gros Consommateurs

```bash
# Taille r√©pertoire data
sudo du -sh /var/lib/pgsql/18/data

# Top 10 fichiers les plus gros
sudo find /var/lib/pgsql/18/data -type f -exec du -h {} + | sort -rh | head -20
```

**Cas courants**:
- WAL archives non nettoy√©s
- Tables/index temporaires √©normes
- Logs PostgreSQL non rotat√©s

### √âtape 3: Nettoyage d'Urgence

**Option A: Nettoyer les Logs**

```bash
# V√©rifier taille logs
sudo du -sh /var/lib/pgsql/18/data/log

# Archiver et compresser (si possible)
sudo tar -czf /tmp/old_logs_$(date +%Y%m%d).tar.gz /var/lib/pgsql/18/data/log/*.log.1 /var/lib/pgsql/18/data/log/*.log.2
sudo rm /var/lib/pgsql/18/data/log/*.log.1 /var/lib/pgsql/18/data/log/*.log.2

# Ou supprimer directement (PERTE D'HISTORIQUE)
sudo rm /var/lib/pgsql/18/data/log/*.log.1
```

**Option B: Nettoyer WAL Archives**

```bash
# ‚ö†Ô∏è DANGER: Ne supprimer que si backup r√©cent OK
sudo du -sh /mnt/wal_archive

# Garder seulement 3 derniers jours (exemple)
sudo find /mnt/wal_archive -name "*.gz" -mtime +3 -delete
sudo find /mnt/wal_archive -name "0*" -mtime +3 -delete
```

**Option C: VACUUM FULL (Attention: LOCK tables)**

```sql
-- Identifier les tables avec le plus de bloat
SELECT
  schemaname || '.' || tablename as table_name,
  pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size,
  n_dead_tup
FROM pg_stat_user_tables
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
LIMIT 10;

-- VACUUM FULL sur table sp√©cifique (BLOQUE TOUT)
-- ‚ö†Ô∏è Coordonner avec √©quipes m√©tier
VACUUM FULL table_with_bloat;
```

### √âtape 4: Solution Temporaire (Monter Volume Suppl√©mentaire)

```bash
# Si volume suppl√©mentaire disponible
sudo mkdir /mnt/extra_space
sudo mount /dev/sdX /mnt/extra_space

# D√©placer WAL archives
sudo mv /mnt/wal_archive/* /mnt/extra_space/wal_archive/
sudo ln -s /mnt/extra_space/wal_archive /mnt/wal_archive
```

### √âtape 5: Red√©marrer PostgreSQL (si n√©cessaire)

```bash
# V√©rifier √©tat
sudo systemctl status postgresql-18

# Red√©marrer si arr√™t√©
sudo systemctl start postgresql-18

# V√©rifier logs
sudo tail -f /var/lib/pgsql/18/data/log/postgresql-*.log
```

## Validation

- [ ] Espace disque lib√©r√© (< 80%)
- [ ] PostgreSQL d√©marr√© et fonctionnel
- [ ] Applications peuvent √©crire
- [ ] Pas d'erreurs dans logs
- [ ] Monitoring disk OK

## Pr√©vention

1. **Imm√©diat**:
   - Configurer log rotation aggressive
   - Nettoyer WAL archives automatiquement
   - Alerte √† 70% (pas 90%)

2. **Court terme**:
   - Augmenter taille volume
   - Archiver logs vers stockage externe
   - VACUUM r√©gulier des grosses tables

3. **Long terme**:
   - Partitionnement des grosses tables
   - Archivage donn√©es historiques
   - Monitoring proactif espace disque

## Contacts
- Infrastructure: +33 6 XX XX XX XX
- DBA: +33 6 YY YY YY YY
- Cloud Support: support@provider.com (si cloud)
```

---

### 2.4. RUNBOOK: R√©plication Cass√©e

```markdown
# RUNBOOK: R√©solution R√©plication PostgreSQL

## M√©tadonn√©es
- **Criticit√©**: √âlev√©e
- **RTO**: 30 minutes
- **Version**: 1.2

## Contexte
La r√©plication entre primary et standby est cass√©e ou en retard.

## Sympt√¥mes
- ‚ö†Ô∏è Monitoring: Replication lag > 5 minutes
- ‚ö†Ô∏è Standby: "invalid record length"
- ‚ö†Ô∏è Dashboard: Standby status = "disconnected"

## Proc√©dure

### √âtape 1: V√©rifier l'√âtat de la R√©plication

**Sur le Primary**:

```sql
-- Voir les standbys connect√©s
SELECT
  client_addr,
  state,
  sent_lsn,
  write_lsn,
  flush_lsn,
  replay_lsn,
  sync_state,
  pg_wal_lsn_diff(sent_lsn, replay_lsn) as lag_bytes
FROM pg_stat_replication;
```

**R√©sultat attendu**: Au moins 1 ligne par standby.
**Si vide** ‚Üí Standby d√©connect√©.

**Sur le Standby**:

```sql
SELECT pg_is_in_recovery();
-- Doit retourner 't' (true)

SELECT
  now() - pg_last_xact_replay_timestamp() as replication_lag,
  pg_is_wal_replay_paused();
```

### √âtape 2: Diagnostiquer la Cause

**Cas A: Standby D√©connect√©**

```bash
# V√©rifier logs standby
sudo tail -100 /var/lib/pgsql/18/data/log/postgresql-*.log

# Rechercher erreurs
grep -i "error\|fatal\|could not" /var/lib/pgsql/18/data/log/postgresql-*.log
```

**Erreurs courantes**:
- "invalid record length" ‚Üí WAL corrompu
- "requested WAL segment has already been removed" ‚Üí WAL manquant
- "could not connect" ‚Üí Probl√®me r√©seau

**Cas B: Lag Excessif**

```sql
-- V√©rifier activit√© sur primary
SELECT count(*) FROM pg_stat_activity WHERE state = 'active';

-- V√©rifier I/O sur standby
SELECT * FROM pg_stat_io;  -- PG 18
```

### √âtape 3: Solutions par Cas

**Solution A: WAL Manquant (Recr√©er Standby)**

```bash
# Sur le standby - Arr√™ter PostgreSQL
sudo systemctl stop postgresql-18

# Sauvegarder config
sudo cp /var/lib/pgsql/18/data/postgresql.conf /tmp/
sudo cp /var/lib/pgsql/18/data/postgresql.auto.conf /tmp/

# Supprimer data directory
sudo rm -rf /var/lib/pgsql/18/data

# Recr√©er depuis primary
sudo -u postgres pg_basebackup \
  -h primary.example.com \
  -U replicator \
  -D /var/lib/pgsql/18/data \
  -Fp -Xs -P -R

# Restaurer config locale
sudo cp /tmp/postgresql.conf /var/lib/pgsql/18/data/
sudo cp /tmp/postgresql.auto.conf /var/lib/pgsql/18/data/

# Red√©marrer
sudo systemctl start postgresql-18
```

**Solution B: Probl√®me R√©seau**

```bash
# Tester connectivit√©
telnet primary.example.com 5432

# V√©rifier pg_hba.conf sur primary
# Doit contenir:
# host    replication     replicator      STANDBY_IP/32   scram-sha-256

# V√©rifier firewall
sudo firewall-cmd --list-all
```

**Solution C: Lag Performance (Standby Lent)**

```sql
-- Sur standby, augmenter ressources
ALTER SYSTEM SET max_parallel_workers = 8;
ALTER SYSTEM SET hot_standby_feedback = on;
SELECT pg_reload_conf();
```

### √âtape 4: V√©rifier la Reprise

```sql
-- Sur primary
SELECT client_addr, state, sync_state
FROM pg_stat_replication;
-- √âtat doit √™tre 'streaming'

-- Sur standby
SELECT
  now() - pg_last_xact_replay_timestamp() as lag,
  pg_last_wal_replay_lsn();
-- Lag doit diminuer
```

## Validation

- [ ] Standby visible dans pg_stat_replication
- [ ] State = 'streaming'
- [ ] Lag < 30 secondes
- [ ] Standby logs sans erreurs
- [ ] Tests applicatifs sur standby OK

## Pr√©vention

1. Augmenter `wal_keep_size` sur primary
2. Utiliser slots de r√©plication
3. Monitorer lag en continu
4. Alerter si lag > 1 minute
5. Documentation r√©seau √† jour

## Contacts
- DBA: +33 6 XX XX XX XX
- R√©seau: +33 6 YY YY YY YY
```

---

### 2.5. RUNBOOK: VACUUM Bloqu√©

```markdown
# RUNBOOK: D√©bloquer VACUUM Probl√©matique

## M√©tadonn√©es
- **Criticit√©**: Moyenne
- **RTO**: 20 minutes
- **Version**: 1.0

## Contexte
Un VACUUM (manuel ou autovacuum) tourne depuis tr√®s longtemps
ou ne se termine jamais.

## Sympt√¥mes
- ‚ö†Ô∏è VACUUM actif depuis > 2 heures
- ‚ö†Ô∏è Bloat continue d'augmenter
- ‚ö†Ô∏è pg_stat_activity: √©tat "autovacuum"

## Proc√©dure

### √âtape 1: Identifier le VACUUM Bloqu√©

```sql
SELECT
  pid,
  usename,
  state,
  now() - xact_start as duration,
  query
FROM pg_stat_activity
WHERE query LIKE '%VACUUM%'
  AND state = 'active'
ORDER BY duration DESC;
```

### √âtape 2: Identifier ce qui Bloque

```sql
-- Longues transactions bloquant VACUUM
SELECT
  pid,
  usename,
  state,
  now() - xact_start as duration,
  query
FROM pg_stat_activity
WHERE state IN ('idle in transaction', 'active')
  AND now() - xact_start > interval '30 minutes'
ORDER BY duration DESC;
```

**Explication**: Une transaction longue emp√™che VACUUM de nettoyer
les tuples morts (car ils pourraient encore √™tre visibles par cette transaction).

### √âtape 3: Tuer les Transactions Bloquantes

```sql
-- V√©rifier que ce n'est pas une transaction critique
-- Puis tuer
SELECT pg_terminate_backend(PID_TRANSACTION_LONGUE);
```

### √âtape 4: Laisser VACUUM Continuer ou Relancer

```sql
-- Si VACUUM continue, surveiller progression
SELECT
  pid,
  phase,
  heap_blks_scanned,
  heap_blks_vacuumed,
  round(100.0 * heap_blks_vacuumed / NULLIF(heap_blks_scanned, 0), 1) as percent
FROM pg_stat_progress_vacuum;

-- Si besoin de relancer manuellement
VACUUM (VERBOSE, ANALYZE) table_name;
```

## Validation

- [ ] VACUUM termin√©
- [ ] Dead tuples diminu√©
- [ ] Bloat stabilis√©
- [ ] Pas de nouvelles transactions longues

## Pr√©vention

1. √âviter longues transactions "idle in transaction"
2. Configurer `idle_in_transaction_session_timeout`
3. Augmenter autovacuum workers
4. Monitorer transactions longues

## Contacts
- DBA: +33 6 XX XX XX XX
```

---

## 3. Templates de Runbooks

### 3.1. Template Vierge

```markdown
# RUNBOOK: [Titre]

## M√©tadonn√©es
- **Cr√©√© par**:
- **Date cr√©ation**:
- **Derni√®re MAJ**:
- **Version**: 1.0
- **Criticit√©**: [Critique/√âlev√©e/Moyenne/Faible]
- **Fr√©quence**: [Quotidien/Hebdo/Mensuel/Rare/Urgence]
- **RTO cible**: [Temps max de r√©solution]

## Contexte
[Description du probl√®me ou de la t√¢che]

## Sympt√¥mes (si incident)
- Sympt√¥me 1
- Sympt√¥me 2

## Pr√©requis
- [ ] Pr√©requis 1
- [ ] Pr√©requis 2

## Proc√©dure

### √âtape 1: [Action]
[Description]

```bash
# Commandes
```

**R√©sultat attendu**:
**Si √©chec**:

### √âtape 2: [Action]
...

## Validation
- [ ] Crit√®re 1
- [ ] Crit√®re 2

## Rollback (si applicable)
[Comment annuler]

## Pr√©vention
[Actions pour √©viter r√©currence]

## Contacts
- Contact 1: [Nom, t√©l√©phone, email]
- Contact 2: [Nom, t√©l√©phone, email]

## Notes
[Observations, cas particuliers]

## Historique
| Date | Qui | Contexte | R√©sultat |
|------|-----|----------|----------|
|      |     |          |          |
```

### 3.2. Template Incident Critique

```markdown
# RUNBOOK URGENCE: [Titre]

## üö® INCIDENT CRITIQUE üö®

**TEMPS DE R√âSOLUTION CIBLE: [X] MINUTES**

## Quick Actions (Go, No Go)
- [ ] **GO** si [conditions]
- [ ] **NO GO** si [conditions] ‚Üí Escalader imm√©diatement

## Contacts d'Urgence (Appeler MAINTENANT)
1. **DBA On-Call**: [Nom] - [T√©l√©phone]
2. **Manager**: [Nom] - [T√©l√©phone]
3. **Vendor Support**: [Num√©ro]

## Proc√©dure d'Urgence (5 minutes max)

### 1Ô∏è‚É£ STOP THE BLEEDING (30 secondes)
```bash
[Commande pour stopper l'h√©morragie]
```

### 2Ô∏è‚É£ ASSESS (2 minutes)
```sql
[Requ√™tes diagnostiques rapides]
```

### 3Ô∏è‚É£ FIX (2 minutes)
```bash
[Solution rapide]
```

### 4Ô∏è‚É£ VERIFY (30 secondes)
- [ ] [V√©rification rapide 1]
- [ ] [V√©rification rapide 2]

## Post-Incident (Apr√®s r√©solution)
- [ ] Communication stakeholders
- [ ] Post-mortem planifi√©
- [ ] Documentation incident
- [ ] Actions de pr√©vention
```

### 3.3. Template Maintenance Planifi√©e

```markdown
# RUNBOOK MAINTENANCE: [Titre]

## M√©tadonn√©es
- **Fen√™tre maintenance**: [Date/Heure]
- **Dur√©e estim√©e**: [X] heures
- **Downtime accept√©**: [Oui/Non]
- **Rollback possible**: [Oui/Non]

## Pr√©-Maintenance (J-1)

### Checklist Pr√©paration
- [ ] Backup complet v√©rifi√©
- [ ] √âquipes m√©tier notifi√©es
- [ ] Fen√™tre maintenance confirm√©e
- [ ] Acc√®s v√©rifi√©s
- [ ] Proc√©dure de rollback test√©e
- [ ] Monitoring en place

## Maintenance (Jour J)

### Phase 1: Pr√©paration (T0)
[Actions pr√©paratoires]

### Phase 2: D√©but maintenance (T0 + 10min)
```bash
# Mettre en maintenance
```

### Phase 3: Op√©ration (T0 + 20min)
[Op√©rations principales]

### Phase 4: Validation (T0 + 40min)
[Tests de validation]

### Phase 5: Fin maintenance (T0 + 50min)
```bash
# Remettre en service
```

## Validation
- [ ] Service fonctionnel
- [ ] Monitoring OK
- [ ] Tests applicatifs OK
- [ ] Communication fin maintenance

## Rollback (Si Probl√®me)
[Proc√©dure compl√®te de rollback]

## Post-Maintenance
- [ ] Documentation mise √† jour
- [ ] Le√ßons apprises
- [ ] Monitoring 24h post-maintenance
```

---

## 4. Gestion des Runbooks

### 4.1. Organisation

**Structure de r√©pertoires recommand√©e**:

```
runbooks/
‚îú‚îÄ‚îÄ README.md                      # Index de tous les runbooks
‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îú‚îÄ‚îÄ incident.md
‚îÇ   ‚îú‚îÄ‚îÄ maintenance.md
‚îÇ   ‚îî‚îÄ‚îÄ standard.md
‚îú‚îÄ‚îÄ incidents/
‚îÇ   ‚îú‚îÄ‚îÄ 01-saturation-connexions.md
‚îÇ   ‚îú‚îÄ‚îÄ 02-requetes-lentes.md
‚îÇ   ‚îú‚îÄ‚îÄ 03-espace-disque.md
‚îÇ   ‚îú‚îÄ‚îÄ 04-replication-cassee.md
‚îÇ   ‚îî‚îÄ‚îÄ 05-vacuum-bloque.md
‚îú‚îÄ‚îÄ maintenance/
‚îÇ   ‚îú‚îÄ‚îÄ upgrade-postgresql.md
‚îÇ   ‚îú‚îÄ‚îÄ reindex-database.md
‚îÇ   ‚îî‚îÄ‚îÄ migration-serveur.md
‚îú‚îÄ‚îÄ operations/
‚îÇ   ‚îú‚îÄ‚îÄ backup-restore.md
‚îÇ   ‚îú‚îÄ‚îÄ failover-manuel.md
‚îÇ   ‚îî‚îÄ‚îÄ ajout-utilisateur.md
‚îî‚îÄ‚îÄ deprecated/
    ‚îî‚îÄ‚îÄ [anciens runbooks]
```

### 4.2. Conventions de Nommage

```
[ID]-[titre-court].md

Exemples:
- INC-01-saturation-connexions.md
- MAINT-05-upgrade-pg18.md
- OPS-03-backup-restore.md
```

**Pr√©fixes**:
- `INC` : Incident
- `MAINT` : Maintenance
- `OPS` : Op√©ration courante
- `EMG` : Urgence critique

### 4.3. Versioning

Utilisez Git pour versionner vos runbooks :

```bash
# Initialiser repo
git init runbooks
cd runbooks

# Structure de commits
git commit -m "feat: Ajouter runbook saturation connexions"
git commit -m "fix: Corriger commande dans runbook r√©plication"
git commit -m "docs: Mettre √† jour contacts d'urgence"
```

**Tags pour versions stables** :

```bash
git tag -a v1.0 -m "Version 1.0 - Runbooks production ready"
git push origin v1.0
```

### 4.4. Review et Validation

**Processus de validation** :

1. **Cr√©ation**: Auteur r√©dige le runbook
2. **Review technique**: Senior DBA valide techniquement
3. **Test en staging**: Ex√©cution compl√®te en environnement test
4. **Review op√©rationnelle**: √âquipe ops v√©rifie clart√©
5. **Approbation**: Manager signe
6. **Publication**: Ajout au repository officiel

**Template de Pull Request** :

```markdown
## Nouveau Runbook: [Titre]

### Type
- [ ] Incident
- [ ] Maintenance
- [ ] Op√©ration courante
- [ ] Urgence

### Checklist
- [ ] Test√© en environnement staging
- [ ] Valid√© par senior DBA
- [ ] Contacts √† jour
- [ ] Captures d'√©cran ajout√©es (si pertinent)
- [ ] R√©f√©rences document√©es

### Contexte
[Pourquoi ce runbook est n√©cessaire]

### Testeurs
- [ ] @alice : Test√© le 2025-11-20, OK
- [ ] @bob : Review le 2025-11-21, suggestions int√©gr√©es
```

---

## 5. Outils et Plateformes

### 5.1. Markdown + Git (Simple et Efficace)

**Avantages**:
- ‚úÖ Versionning natif
- ‚úÖ Diff et merge faciles
- ‚úÖ Gratuit
- ‚úÖ Accessible partout

**Outils**:
- GitHub/GitLab/Bitbucket
- Markdown editors (Typora, MarkText, VSCode)

### 5.2. Wiki (Confluence, Notion)

**Avantages**:
- ‚úÖ Interface graphique
- ‚úÖ Collaboration temps r√©el
- ‚úÖ Recherche puissante
- ‚úÖ Int√©grations (Slack, Jira)

**Exemple Confluence** :

```
Runbooks PostgreSQL
‚îú‚îÄ üö® Incidents Critiques
‚îÇ  ‚îú‚îÄ Saturation des connexions
‚îÇ  ‚îú‚îÄ Espace disque plein
‚îÇ  ‚îî‚îÄ R√©plication cass√©e
‚îú‚îÄ üîß Maintenance
‚îÇ  ‚îú‚îÄ Upgrade PostgreSQL
‚îÇ  ‚îî‚îÄ Reindex complet
‚îî‚îÄ üìñ Op√©rations Courantes
   ‚îú‚îÄ Backup/Restore
   ‚îî‚îÄ Ajout utilisateur
```

### 5.3. PagerDuty Runbooks

**Int√©gration avec alerting** :

```yaml
# pagerduty_runbook.yaml
runbook_url: "https://wiki.company.com/runbooks/postgres-connections"
auto_attach: true
```

Quand une alerte se d√©clenche, le runbook est automatiquement li√©.

### 5.4. Runbooks Interactifs (Jupyter, Rundeck)

**Jupyter Notebook** pour runbooks ex√©cutables :

```python
# Runbook: Check PostgreSQL Health
import psycopg2

# Connexion
conn = psycopg2.connect(
    host="localhost",
    database="myapp",
    user="postgres"
)

# √âtape 1: V√©rifier connexions
query = """
SELECT count(*) as current,
       (SELECT setting::int FROM pg_settings WHERE name='max_connections') as max
FROM pg_stat_activity;
"""
cur = conn.cursor()
cur.execute(query)
print(cur.fetchone())

# √âtape 2: ...
```

**Rundeck** pour automatisation :

- Interface web pour ex√©cuter runbooks
- Logs d'ex√©cution automatiques
- Contr√¥le d'acc√®s

---

## 6. Maintenance des Runbooks

### 6.1. Cycle de Vie

```
Cr√©ation ‚Üí Validation ‚Üí Publication ‚Üí Utilisation ‚Üí Review ‚Üí MAJ ‚Üí Archivage
                                          ‚Üì
                                    Am√©lioration Continue
```

### 6.2. Triggers de Mise √† Jour

**Mettre √† jour un runbook quand** :

1. **Apr√®s chaque utilisation**
   - Ajouter dans historique
   - Noter probl√®mes rencontr√©s
   - Am√©liorer si proc√©dure impr√©cise

2. **Changement d'infrastructure**
   - Migration cloud
   - Nouvelle version PostgreSQL
   - Changement d'architecture

3. **Incidents**
   - Post-mortem identifie lacune
   - Nouvelle proc√©dure d√©couverte

4. **Review planifi√©e**
   - Trimestriel : Review tous runbooks
   - V√©rifier obsolescence
   - Valider contacts

### 6.3. M√©triques de Qualit√©

**Indicateurs d'un bon runbook** :

| M√©trique                     | Cible   | Comment mesurer                               |
|------------------------------|---------|-----------------------------------------------|
| Temps de r√©solution          | < RTO   | Comparer dur√©e r√©elle vs RTO                  |
| Taux de succ√®s              | > 95%   | % d'ex√©cutions sans escalade                  |
| Clart√©                       | High    | Feedback utilisateurs (scale 1-5)             |
| Compl√©tude                   | 100%    | % d'√©tapes couvertes vs incidents r√©els       |
| Freshness                    | < 6 mois| √Çge depuis derni√®re MAJ                       |

**Dashboard runbooks** :

```markdown
## Runbooks Health Dashboard

| Runbook              | Derni√®re MAJ | Utilis√© (3 mois) | Succ√®s | Notes |
|----------------------|--------------|------------------|--------|-------|
| Saturation connexions| 2025-11-20   | 5 fois           | 100%   | ‚úÖ OK |
| Requ√™tes lentes      | 2025-10-15   | 12 fois          | 90%    | ‚ö†Ô∏è √Ä am√©liorer |
| Espace disque        | 2025-09-01   | 1 fois           | 100%   | ‚ö†Ô∏è Vieux |
| R√©plication cass√©e   | 2025-11-18   | 0 fois           | N/A    | ‚úÖ OK |
```

---

## 7. Formation et Onboarding

### 7.1. Formation Nouveaux Membres

**Programme d'onboarding** :

**Semaine 1** :
- Lire tous les runbooks incidents critiques
- Ex√©cuter en staging (simulation)
- Quiz de validation

**Semaine 2** :
- Participer √† une astreinte avec senior
- Observer r√©solution d'incident r√©el
- Pair programming sur runbooks

**Semaine 3** :
- Premi√®re astreinte en autonomie (avec backup)
- Cr√©er ou am√©liorer un runbook

**Semaine 4** :
- Validation finale (simulation incident complexe)
- Certification "Ops ready"

### 7.2. Simulation d'Incidents (GameDay)

**Exercice trimestriel** :

```markdown
# GameDay: Incident PostgreSQL

## Sc√©nario
Il est 14h. Le monitoring alerte :
- CPU 95%
- Connexions: 98/100
- Latence applicative: 5s (vs 50ms normal)

## Objectifs
1. Diagnostiquer en 5 min
2. R√©soudre en 15 min
3. Documenter actions

## √âvaluation
- Temps de r√©solution
- Utilisation runbook
- Communication
- Post-mortem qualit√©
```

### 7.3. Certification Interne

**Checklist certification "DBA Ops"** :

- [ ] Conna√Æt tous les runbooks critiques
- [ ] A r√©solu 3 incidents en simulation
- [ ] A cr√©√© ou am√©lior√© 1 runbook
- [ ] A particip√© √† 2 astreintes
- [ ] A pass√© le quiz certification (> 80%)

---

## 8. Runbooks et Culture DevOps

### 8.1. Documentation as Code

Traiter les runbooks comme du code :

```yaml
# .gitlab-ci.yml
runbooks-lint:
  script:
    - markdownlint runbooks/**/*.md
    - check-links runbooks/**/*.md

runbooks-test:
  script:
    - python test_runbooks.py

runbooks-publish:
  script:
    - mkdocs build
    - aws s3 sync site/ s3://runbooks.company.com/
  only:
    - main
```

### 8.2. Blameless Post-Mortems

Apr√®s chaque incident :

```markdown
# Post-Mortem: [Titre Incident]

## Timeline
- **14:00**: Alerte monitoring
- **14:02**: √âquipe ops notifi√©e
- **14:05**: Diagnostic initial
- **14:10**: Solution appliqu√©e
- **14:15**: Service r√©tabli
- **14:30**: Post-mortem d√©bute

## Root Cause
[Cause racine identifi√©e]

## Pourquoi le runbook n'a pas suffi ?
- √âtape X manquait
- Commande Y obsol√®te
- Contact Z pas √† jour

## Actions
1. [ ] Mettre √† jour runbook (Owner: Alice, Due: 2025-11-25)
2. [ ] Ajouter alerte pr√©ventive (Owner: Bob, Due: 2025-11-27)
3. [ ] Former √©quipe sur nouveau process (Owner: Charlie, Due: 2025-12-01)

## Lessons Learned
[Ce que nous avons appris]
```

---

## 9. Checklist Runbooks Production

### ‚úÖ Cr√©ation et Organisation

- [ ] Repository Git configur√©
- [ ] Structure de r√©pertoires d√©finie
- [ ] Templates standardis√©s
- [ ] Conventions de nommage respect√©es
- [ ] README.md avec index √† jour

### ‚úÖ Runbooks Essentiels Cr√©√©s

- [ ] Saturation des connexions
- [ ] Requ√™tes lentes
- [ ] Espace disque plein
- [ ] R√©plication cass√©e
- [ ] VACUUM bloqu√©
- [ ] Upgrade PostgreSQL
- [ ] Backup/Restore
- [ ] Failover manuel

### ‚úÖ Qualit√© et Validation

- [ ] Tous runbooks test√©s en staging
- [ ] Review par senior DBA
- [ ] Contacts d'urgence √† jour
- [ ] Captures d'√©cran ajout√©es
- [ ] R√©sultats attendus document√©s

### ‚úÖ Accessibilit√©

- [ ] Runbooks accessibles 24/7
- [ ] Version imprim√©e disponible (critiques)
- [ ] Liens dans monitoring/alerting
- [ ] Acc√®s mobile test√©

### ‚úÖ Processus

- [ ] Workflow de cr√©ation d√©fini
- [ ] Process de review √©tabli
- [ ] Schedule de maintenance (trimestriel)
- [ ] Training nouveaux membres
- [ ] GameDays planifi√©s

### ‚úÖ Monitoring

- [ ] Dashboard runbooks sant√©
- [ ] M√©triques d'utilisation track√©es
- [ ] Feedback collect√©
- [ ] Am√©lioration continue

---

## 10. Ressources et Outils

### Documentation et Guides
- **Google SRE Book** : https://sre.google/sre-book/table-of-contents/
- **PagerDuty Incident Response** : https://response.pagerduty.com/
- **Runbook Template (GitHub)** : https://github.com/SkeltonThatcher/run-book-template

### Outils de Documentation
- **MkDocs** : Documentation from Markdown
- **Docusaurus** : Documentation websites
- **GitBook** : Modern documentation platform
- **Confluence** : Enterprise wiki
- **Notion** : Collaborative workspace

### Outils de Gestion
- **Rundeck** : Runbook automation
- **PagerDuty** : Incident management
- **OpsGenie** : Alert management
- **Jupyter** : Interactive runbooks

### Standards et Best Practices
- **ITIL** : IT Service Management
- **SRE Principles** : Google SRE practices
- **DevOps Handbook** : DevOps best practices

---

## Conclusion

Les runbooks sont votre **filet de s√©curit√©** en production. Ils transforment le chaos d'un incident en une proc√©dure claire et reproductible.

**Les 7 Principes des Runbooks Efficaces** :

1. **Clart√©** : √âcrire pour quelqu'un qui panique √† 3h du matin
2. **Compl√©tude** : Chaque √©tape, chaque commande, chaque r√©sultat
3. **Testabilit√©** : Valid√© en staging avant production
4. **Accessibilit√©** : Disponible 24/7, partout
5. **Maintenabilit√©** : √Ä jour, versionn√©, revu r√©guli√®rement
6. **Actionabilit√©** : Pas de th√©orie, que de la pratique
7. **Am√©lioration continue** : Apprendre de chaque utilisation

**Roadmap de mise en place** :

| Semaine | Actions                                                      |
|---------|--------------------------------------------------------------|
| 1       | Cr√©er repository, templates, 3 runbooks critiques            |
| 2       | Tester runbooks en staging, corriger                         |
| 3       | Former √©quipe, premi√®re simulation                           |
| 4       | Publier runbooks, int√©grer monitoring                        |
| 5-12    | Cr√©er runbooks additionnels, am√©lioration continue           |

> "The difference between a good engineer and a great engineer is documentation."

Avec des runbooks de qualit√©, votre √©quipe sera :
- Plus **rapide** (temps de r√©solution r√©duit)
- Plus **confiante** (proc√©dure claire)
- Plus **efficace** (moins d'erreurs)
- Plus **r√©siliente** (knowledge distribu√©)

Investissez dans vos runbooks aujourd'hui. Votre futur vous (et votre √©quipe) vous remercieront.

---


‚è≠Ô∏è [Drivers, Connexion Applicative et Bonnes Pratiques](/20-drivers-connexion-applicative/README.md)
