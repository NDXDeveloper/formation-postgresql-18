üîù Retour au [Sommaire](/SOMMAIRE.md)

# 19.5.2. Tests de restauration r√©guliers

## Introduction

Vous avez mis en place une strat√©gie de sauvegarde solide pour votre base de donn√©es PostgreSQL. Vous dormez tranquille en pensant que vos donn√©es sont prot√©g√©es. **Mais voici la question qui f√¢che : √™tes-vous vraiment certain que vos sauvegardes fonctionnent ?**

Une sauvegarde non test√©e est comme une assurance dont vous ne sauriez pas si elle vous couvre r√©ellement. Le jour o√π vous en avez besoin, il est trop tard pour d√©couvrir qu'elle ne fonctionne pas.

> **Principe fondamental en Disaster Recovery :**
> *"Une sauvegarde non test√©e n'est pas une sauvegarde, c'est une illusion de s√©curit√©."*

Ce chapitre vous explique **pourquoi**, **quand** et **comment** tester r√©guli√®rement vos proc√©dures de restauration PostgreSQL.

---

## Pourquoi tester les restaurations ?

### 1. Les sauvegardes peuvent √©chouer silencieusement

Les sauvegardes peuvent sembler fonctionner alors qu'elles sont en r√©alit√© corrompues ou incompl√®tes.

**Exemples de probl√®mes courants :**

- ‚ùå **Espace disque insuffisant** : La sauvegarde d√©marre mais s'arr√™te avant la fin
- ‚ùå **Permissions incorrectes** : Les fichiers sont cr√©√©s mais illisibles
- ‚ùå **Corruption de donn√©es** : Les fichiers sont √©crits mais corrompus
- ‚ùå **Configuration obsol√®te** : La proc√©dure ne correspond plus √† l'architecture actuelle
- ‚ùå **D√©pendances manquantes** : Extensions ou outils non disponibles sur le serveur de restauration

**Histoire vraie :**
```
Une entreprise d√©couvre apr√®s un crash que leurs sauvegardes
quotidiennes de 6 mois √©chouaient silencieusement depuis 3 mois.
Le script retournait un code de succ√®s, mais les fichiers √©taient vides.

Perte : 3 mois de donn√©es client. Entreprise en faillite 8 mois plus tard.
```

### 2. Les environnements √©voluent

Votre infrastructure change constamment :

- Nouvelles tables et colonnes
- Nouvelles extensions PostgreSQL
- Nouvelles versions de PostgreSQL
- Changements de configuration syst√®me
- Nouvelles d√©pendances applicatives

**Une proc√©dure de restauration qui fonctionnait il y a 6 mois peut √™tre obsol√®te aujourd'hui.**

### 3. Les √©quipes changent

- Les personnes qui ont cr√©√© les proc√©dures peuvent partir
- Les nouveaux arrivants doivent √™tre form√©s
- La documentation peut devenir obsol√®te
- Les connaissances implicites se perdent

**Un test r√©gulier garantit que n'importe qui dans l'√©quipe peut effectuer une restauration.**

### 4. Valider vos objectifs RTO et RPO

Les tests sont le **seul moyen** de v√©rifier si vous respectez r√©ellement vos objectifs :

- **RTO th√©orique** : "Nous pouvons restaurer en 2 heures"
- **RTO r√©el mesur√©** : "La derni√®re restauration a pris 4 heures 30"

**Sans tests, vos objectifs RTO/RPO ne sont que des estimations optimistes.**

---

## Les statistiques qui font peur

Quelques chiffres issus d'√©tudes sur les sauvegardes et restaurations :

| Statistique | Source |
|------------|--------|
| **30% des entreprises** ne testent jamais leurs sauvegardes | Veeam Data Protection Report 2024 |
| **43% des restaurations** √©chouent lors du premier essai | Gartner 2023 |
| **60% des entreprises** qui perdent leurs donn√©es ferment dans les 6 mois | University of Texas Study |
| **1 entreprise sur 4** d√©couvre des probl√®mes de sauvegarde uniquement lors d'un sinistre r√©el | IDC Research |

**Ces statistiques sont effrayantes. Ne soyez pas une de ces statistiques.**

---

## √Ä quelle fr√©quence tester ?

La fr√©quence d√©pend de plusieurs facteurs :

### Fr√©quence recommand√©e par criticit√©

| Criticit√© syst√®me | Fr√©quence minimale | Fr√©quence id√©ale |
|------------------|-------------------|------------------|
| **Critique** (e-commerce, finance) | Mensuelle | Hebdomadaire |
| **Important** (applications m√©tier) | Trimestrielle | Mensuelle |
| **Normal** (applications internes) | Semestrielle | Trimestrielle |
| **Faible** (dev, staging) | Annuelle | Semestrielle |

### D√©clencheurs suppl√©mentaires

Testez √©galement apr√®s chaque :

- ‚úÖ **Changement majeur d'infrastructure** (migration serveur, upgrade)
- ‚úÖ **Upgrade de PostgreSQL** (version mineure ou majeure)
- ‚úÖ **Modification de la proc√©dure de backup**
- ‚úÖ **Changement dans l'√©quipe** (arriv√©e/d√©part du DBA)
- ‚úÖ **Audit de s√©curit√© ou de conformit√©**
- ‚úÖ **Incident de production** (pour r√©viser les proc√©dures)

### R√®gle d'or

> **"Testez au moins aussi souvent que vous changez votre infrastructure."**

---

## Types de tests de restauration

Il existe plusieurs niveaux de tests, du plus simple au plus complet.

### 1. Test de validation technique (Test de niveau 1)

**Objectif :** V√©rifier que les fichiers de sauvegarde sont valides et restaurables.

**Dur√©e :** 15-30 minutes

**Fr√©quence sugg√©r√©e :** Hebdomadaire (automatis√©)

**Proc√©dure :**
1. Prendre une sauvegarde
2. Restaurer sur un serveur de test isol√©
3. V√©rifier que PostgreSQL d√©marre
4. Ex√©cuter quelques requ√™tes basiques
5. V√©rifier l'int√©grit√© (checksums si activ√©s)

**Exemple de script automatis√© :**
```bash
#!/bin/bash
# test_backup_validity.sh

BACKUP_FILE="/backups/latest/pg_backup.tar"
TEST_DATA_DIR="/tmp/pg_restore_test"

echo "=== Test de validation de backup PostgreSQL ==="
echo "Date: $(date)"

# 1. Nettoyer l'environnement de test
rm -rf $TEST_DATA_DIR
mkdir -p $TEST_DATA_DIR

# 2. Extraire la sauvegarde
echo "Extraction de la sauvegarde..."
tar -xf $BACKUP_FILE -C $TEST_DATA_DIR

# 3. D√©marrer PostgreSQL en mode test
echo "D√©marrage de PostgreSQL..."
pg_ctl -D $TEST_DATA_DIR -l /tmp/pg_test.log start

# Attendre le d√©marrage
sleep 5

# 4. V√©rifier la connexion
echo "Test de connexion..."
if psql -h localhost -p 5433 -U postgres -c "SELECT version();" > /dev/null 2>&1; then
    echo "‚úÖ PostgreSQL accessible"
else
    echo "‚ùå ERREUR: PostgreSQL inaccessible"
    exit 1
fi

# 5. V√©rifier quelques tables critiques
echo "V√©rification des tables critiques..."
psql -h localhost -p 5433 -U postgres -d mydb -c "SELECT count(*) FROM users;" > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "‚úÖ Tables accessibles"
else
    echo "‚ùå ERREUR: Tables inaccessibles"
    exit 1
fi

# 6. Arr√™ter PostgreSQL
pg_ctl -D $TEST_DATA_DIR stop

# 7. Nettoyer
rm -rf $TEST_DATA_DIR

echo "=== Test termin√© avec succ√®s ==="
echo "Dur√©e: $SECONDS secondes"

# Envoyer notification (email, Slack, etc.)
# ./send_notification.sh "Backup test OK"
```

### 2. Test de restauration fonctionnelle (Test de niveau 2)

**Objectif :** V√©rifier que les donn√©es restaur√©es sont coh√©rentes et compl√®tes.

**Dur√©e :** 1-2 heures

**Fr√©quence sugg√©r√©e :** Mensuelle

**Proc√©dure :**
1. Restaurer la base compl√®te sur environnement de test
2. V√©rifier l'int√©grit√© des donn√©es (contraintes, index)
3. Ex√©cuter des requ√™tes m√©tier complexes
4. Comparer avec des snapshots de donn√©es connus
5. V√©rifier les extensions et fonctions personnalis√©es

**Checklist de validation fonctionnelle :**
```sql
-- 1. V√©rifier le nombre total de tables
SELECT count(*) FROM information_schema.tables
WHERE table_schema NOT IN ('pg_catalog', 'information_schema');
-- R√©sultat attendu: 47 tables

-- 2. V√©rifier les contraintes d'int√©grit√©
SELECT COUNT(*) FROM pg_constraint WHERE contype = 'f';
-- R√©sultat attendu: 23 foreign keys

-- 3. V√©rifier les index
SELECT count(*) FROM pg_indexes WHERE schemaname = 'public';
-- R√©sultat attendu: 65 indexes

-- 4. V√©rifier les extensions
SELECT * FROM pg_extension;
-- Extensions attendues: postgis, pg_stat_statements, uuid-ossp

-- 5. Compter les enregistrements des tables critiques
SELECT
    'users' as table_name, count(*) as row_count FROM users
UNION ALL
SELECT 'orders', count(*) FROM orders
UNION ALL
SELECT 'products', count(*) FROM products;
-- Comparer avec les valeurs en production

-- 6. V√©rifier l'int√©grit√© r√©f√©rentielle
-- Exemple: tous les orders doivent avoir un user_id valide
SELECT COUNT(*) FROM orders o
LEFT JOIN users u ON o.user_id = u.id
WHERE u.id IS NULL;
-- R√©sultat attendu: 0

-- 7. Tester les fonctions personnalis√©es
SELECT calculate_order_total(12345);
-- V√©rifier que le r√©sultat est coh√©rent

-- 8. V√©rifier les triggers
SELECT count(*) FROM pg_trigger WHERE tgisinternal = false;
-- R√©sultat attendu: 8 triggers
```

### 3. Test de restauration compl√®te avec chronom√©trage (Test de niveau 3)

**Objectif :** Valider le RTO r√©el et la proc√©dure compl√®te de bout en bout.

**Dur√©e :** 3-6 heures (selon votre RTO)

**Fr√©quence sugg√©r√©e :** Trimestrielle

**Proc√©dure :**
1. **Simulation r√©aliste** : Partir d'un serveur vierge
2. **Chronom√©trer chaque √©tape** de la restauration
3. **Suivre le runbook** √† la lettre (comme en production)
4. **Valider avec les √©quipes m√©tier** que tout fonctionne
5. **Mesurer les performances** apr√®s restauration
6. **Documenter les √©carts** avec le RTO/RPO th√©orique

**Template de chronom√©trage :**
```
=== TEST DE RESTAURATION COMPLET ===
Date: 2025-11-23
Backup source: backup_2025-11-22_23h00.tar.gz
Testeur: Jean Dupont
Environnement: serveur-test-dr-01

CHRONOM√âTRAGE D√âTAILL√â:

[00:00] D√©but du test - Incident simul√© d√©tect√©
[00:05] D√©cision prise: restauration depuis backup
[00:10] T√©l√©chargement du backup depuis S3 (85 GB)
        ‚îî‚îÄ Dur√©e: 15 minutes
[00:25] Pr√©paration du serveur (installation PostgreSQL)
        ‚îî‚îÄ Dur√©e: 10 minutes
[00:35] Extraction de la sauvegarde
        ‚îî‚îÄ Dur√©e: 20 minutes
[00:55] Configuration PostgreSQL (postgresql.conf, pg_hba.conf)
        ‚îî‚îÄ Dur√©e: 10 minutes
[01:05] D√©marrage de PostgreSQL
        ‚îî‚îÄ Dur√©e: 5 minutes
[01:10] Application des WAL archives (Point-in-Time Recovery)
        ‚îî‚îÄ Dur√©e: 25 minutes
[01:35] Validation technique (connexion, tables, index)
        ‚îî‚îÄ Dur√©e: 15 minutes
[01:50] Validation fonctionnelle (requ√™tes m√©tier)
        ‚îî‚îÄ Dur√©e: 20 minutes
[02:10] Validation avec √©quipe m√©tier
        ‚îî‚îÄ Dur√©e: 30 minutes
[02:40] Ajustements configuration (tuning)
        ‚îî‚îÄ Dur√©e: 20 minutes
[03:00] Tests de performance (queries lentes)
        ‚îî‚îÄ Dur√©e: 15 minutes
[03:15] Service d√©clar√© op√©rationnel

R√âSUM√â:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
RTO Objectif:        2 heures (120 min)
RTO R√©el mesur√©:     3 heures 15 min (195 min)
√âcart:               +65 minutes ‚ö†Ô∏è

RPO Objectif:        15 minutes
RPO R√©el:            13 minutes ‚úÖ
Donn√©es perdues:     127 transactions

PROBL√àMES IDENTIFI√âS:
1. T√©l√©chargement S3 plus lent que pr√©vu (bande passante limit√©e)
2. Configuration PostgreSQL non pr√©-configur√©e (10 min perdues)
3. Validation m√©tier a pris plus longtemps que pr√©vu

ACTIONS CORRECTIVES:
1. Augmenter bande passante S3 ou pr√©-charger backups localement
2. Cr√©er template PostgreSQL pr√©-configur√©
3. Automatiser validation fonctionnelle (scripts SQL)
4. Revoir objectif RTO: 2h30 plus r√©aliste

Prochaine revue: Janvier 2026
```

### 4. Test en situation r√©elle (Disaster Recovery Drill)

**Objectif :** Simuler un incident majeur avec toute l'√©quipe.

**Dur√©e :** 1 journ√©e compl√®te

**Fr√©quence sugg√©r√©e :** Annuelle (ou semestrielle pour syst√®mes critiques)

**Caract√©ristiques :**
- **Non annonc√©** (ou annonc√© la veille seulement)
- **Toute l'√©quipe mobilis√©e** (dev, ops, m√©tier, management)
- **Sc√©nario r√©aliste** : panne datacenter, ransomware, erreur humaine
- **Communication d'incident** test√©e (qui appeler ? quand ?)
- **Processus de d√©cision** valid√© (qui d√©cide de basculer ?)
- **Post-mortem** obligatoire avec toutes les parties prenantes

**Exemple de sc√©nario :**
```
SC√âNARIO: RANSOMWARE ATTACK

09h00 - D√©tection: Serveur PostgreSQL chiffr√© par ransomware
09h05 - Alerte √©quipe via PagerDuty
09h10 - War room √©tablie (conf call)
09h15 - D√©cision: Ne pas payer ran√ßon, restaurer depuis backup
09h20 - Activation du Plan DR
09h25 - Mise en isolation du serveur compromis
09h30 - D√©marrage restauration sur nouveau serveur
        [... d√©roulement selon proc√©dure ...]
12h45 - Service restaur√©
13h00 - Communication clients
14h00 - Post-mortem (√† chaud)
J+1   - Post-mortem d√©taill√©
J+7   - Rapport final et plan d'action

LE√áONS APPRISES:
- D√©lai de communication trop long (15 min)
- Un membre de l'√©quipe n'avait pas acc√®s au runbook
- Mots de passe AWS stock√©s uniquement sur serveur compromis
- Monitoring n'a pas d√©tect√© l'intrusion initiale
```

---

## M√©thodologie : Comment organiser un test de restauration

### Phase 1 : Pr√©paration (J-7 √† J-1)

#### 1.1. D√©finir les objectifs du test

Documentez clairement :
- **Type de test** : Validation technique, fonctionnel, ou complet ?
- **Port√©e** : Quelle base ? Quelles tables ? Toutes les donn√©es ?
- **Crit√®res de succ√®s** : Qu'est-ce qui d√©finit une restauration r√©ussie ?
- **RTO cible** : Combien de temps avez-vous ?

**Exemple de document d'objectifs :**
```markdown
# Test de Restauration - Novembre 2025

## Objectifs
- Valider la proc√©dure de restauration compl√®te
- Mesurer le RTO r√©el
- Former le nouvel administrateur syst√®me

## Port√©e
- Base: production_db (150 GB)
- Backup source: backup quotidien du 22/11/2025
- Point de restauration: 23h00 UTC

## Crit√®res de succ√®s
- ‚úÖ PostgreSQL d√©marre sans erreur
- ‚úÖ Toutes les tables sont accessibles
- ‚úÖ Int√©grit√© r√©f√©rentielle valid√©e
- ‚úÖ Application m√©tier se connecte et fonctionne
- ‚úÖ RTO < 2h30

## √âquipe
- Responsable: Alice (DBA)
- Participants: Bob (DevOps), Carol (Dev Lead)
- Observateur: Dave (Manager)
```

#### 1.2. Pr√©parer l'environnement de test

- ‚úÖ **Serveur de test isol√©** : Ne jamais tester sur production !
- ‚úÖ **Ressources suffisantes** : CPU, RAM, disque √©quivalents √† la prod
- ‚úÖ **Acc√®s r√©seau configur√©** : Firewall, VPN, acc√®s S3/backup storage
- ‚úÖ **Outils install√©s** : PostgreSQL (m√™me version), extensions n√©cessaires
- ‚úÖ **Monitoring temporaire** : Pour mesurer les performances

#### 1.3. Communiquer le test

Informez toutes les parties prenantes :
- Date et heure du test
- Dur√©e estim√©e
- Personnes impliqu√©es
- Impact potentiel (normalement aucun sur production)

### Phase 2 : Ex√©cution du test (Jour J)

#### 2.1. Checkpoint initial

Avant de commencer :
```bash
# Prendre un snapshot de l'√©tat actuel en production
psql -d production_db -c "SELECT NOW() as test_start_time;"

# Noter les m√©triques importantes
psql -d production_db -c "
    SELECT
        schemaname,
        relname,
        n_live_tup,
        n_dead_tup,
        last_vacuum,
        last_analyze
    FROM pg_stat_user_tables
    ORDER BY n_live_tup DESC
    LIMIT 20;
" > /tmp/prod_stats_before_test.txt
```

#### 2.2. Suivre le runbook

Ex√©cutez la proc√©dure **exactement comme document√©e**.

**Important :**
- ‚úÖ Ne pas improviser
- ‚úÖ Noter toute d√©viation du plan
- ‚úÖ Chronom√©trer chaque √©tape
- ‚úÖ Documenter les probl√®mes en temps r√©el

**Exemple de journal d'ex√©cution :**
```
10:00:00 | D√©but du test
10:00:05 | Commande: aws s3 cp s3://backups/prod/backup.tar.gz .
10:15:22 | T√©l√©chargement termin√© (15min17s) - Plus lent que pr√©vu
10:15:30 | Commande: tar -xzf backup.tar.gz
10:35:45 | Extraction termin√©e (20min15s)
10:36:00 | PROBL√àME: Fichier postgresql.conf manquant
10:38:15 | R√âSOLUTION: Copi√© depuis template (2min15s perdue)
10:38:30 | Commande: pg_ctl start -D /data/postgres
10:39:00 | PostgreSQL d√©marr√© (30s)
...
```

#### 2.3. Validation progressive

√Ä chaque √©tape majeure, validez :

```sql
-- Apr√®s d√©marrage PostgreSQL
SELECT version();

-- V√©rifier les bases de donn√©es
\l

-- V√©rifier les tables d'une base critique
\c production_db
\dt

-- Compter les lignes des tables principales
SELECT 'users' as table_name, count(*) FROM users
UNION ALL
SELECT 'orders', count(*) FROM orders;

-- V√©rifier les contraintes
SELECT conname, contype
FROM pg_constraint
WHERE conrelid = 'orders'::regclass;

-- Tester une requ√™te m√©tier complexe
SELECT
    DATE(o.created_at) as date,
    COUNT(*) as order_count,
    SUM(o.total) as revenue
FROM orders o
WHERE o.created_at >= NOW() - INTERVAL '7 days'
GROUP BY DATE(o.created_at)
ORDER BY date DESC;
```

#### 2.4. Validation applicative

Si possible, connectez l'application :
- D√©marrer l'application sur l'environnement de test
- Pointer vers la base restaur√©e
- Tester les fonctionnalit√©s critiques
- V√©rifier les logs applicatifs

### Phase 3 : Validation finale et nettoyage (J √† J+1)

#### 3.1. Rapport de test

Cr√©ez un rapport structur√© :

```markdown
# RAPPORT DE TEST DE RESTAURATION
Date: 2025-11-23
Responsable: Alice Dubois

## R√âSUM√â EX√âCUTIF
- ‚úÖ Test r√©ussi avec r√©serves
- ‚úÖ RTO mesur√©: 2h47min (objectif: 2h30)
- ‚ùå 3 probl√®mes mineurs identifi√©s

## M√âTRIQUES
| M√©trique | Objectif | R√©el | Statut |
|----------|----------|------|--------|
| RTO | 2h30 | 2h47 | ‚ö†Ô∏è +17min |
| RPO | 15min | 12min | ‚úÖ OK |
| Donn√©es perdues | <500 trans. | 387 trans. | ‚úÖ OK |
| Int√©grit√© | 100% | 100% | ‚úÖ OK |

## CHRONOLOGIE
[Voir journal d'ex√©cution d√©taill√© en annexe]

## PROBL√àMES IDENTIFI√âS

### P1 (Mineur): Configuration PostgreSQL manquante
**Description:** Le fichier postgresql.conf n'√©tait pas inclus
dans la sauvegarde
**Impact:** +2min15s sur RTO
**Action corrective:** Modifier script de backup pour inclure
les fichiers de configuration
**Responsable:** Bob (DevOps)
**√âch√©ance:** 30/11/2025

### P2 (Mineur): Documentation obsol√®te
**Description:** Le runbook mentionnait une commande obsol√®te
**Impact:** +5min (temps perdu √† chercher)
**Action corrective:** Mise √† jour du runbook
**Responsable:** Alice (DBA)
**√âch√©ance:** 25/11/2025

### P3 (Mineur): Bande passante S3 limit√©e
**Description:** T√©l√©chargement plus lent que pr√©vu (15min au lieu de 10)
**Impact:** +5min sur RTO
**Action corrective:** Pr√©charger les backups r√©cents en local
**Responsable:** Bob (DevOps)
**√âch√©ance:** 15/12/2025

## POINTS POSITIFS
- ‚úÖ Proc√©dure globalement solide
- ‚úÖ √âquipe bien coordonn√©e
- ‚úÖ Aucune perte de donn√©es critiques
- ‚úÖ Int√©grit√© valid√©e √† 100%

## RECOMMANDATIONS
1. Augmenter RTO objectif √† 3h (plus r√©aliste)
2. Automatiser davantage la validation
3. Refaire un test dans 1 mois apr√®s correctifs

## PROCHAINES ACTIONS
| Action | Responsable | √âch√©ance | Statut |
|--------|-------------|----------|--------|
| Corriger script backup | Bob | 30/11 | üîÑ En cours |
| MAJ runbook | Alice | 25/11 | ‚úÖ Fait |
| Test de suivi | Alice | 15/01/26 | ‚è≥ Planifi√© |

Signatures:
- Alice Dubois (DBA) - 23/11/2025
- Bob Martin (DevOps) - 23/11/2025
- Dave Wilson (Manager) - 24/11/2025
```

#### 3.2. Post-mortem (Retrospective)

Organisez une r√©union d'√©quipe (30-60 min) :

**Questions √† discuter :**
1. Qu'est-ce qui a bien fonctionn√© ?
2. Qu'est-ce qui a mal fonctionn√© ?
3. Qu'avons-nous appris ?
4. Quelles actions correctives prenons-nous ?
5. Quand refaire un test ?

**Format "Start, Stop, Continue" :**
- **Start** : Qu'est-ce qu'on devrait commencer √† faire ?
- **Stop** : Qu'est-ce qu'on devrait arr√™ter de faire ?
- **Continue** : Qu'est-ce qu'on devrait continuer ?

#### 3.3. Mise √† jour de la documentation

Suite au test, mettez √† jour :
- ‚úÖ Le runbook de restauration
- ‚úÖ Les estimations RTO/RPO
- ‚úÖ Les scripts d'automatisation
- ‚úÖ La liste des contacts d'urgence
- ‚úÖ Les pr√©requis techniques

#### 3.4. Nettoyage

- Arr√™ter et supprimer l'environnement de test
- Archiver les logs et rapports
- Programmer le prochain test
- Communiquer les r√©sultats aux parties prenantes

---

## Automatisation des tests

Pour les tests de niveau 1 (validation technique), automatisez au maximum.

### Script d'automatisation complet

```bash
#!/bin/bash
#
# auto_test_restore.sh
# Test automatis√© de restauration PostgreSQL
# √Ä ex√©cuter via cron: 0 2 * * 0 (tous les dimanches √† 2h)
#

set -e  # Arr√™t si erreur

# Configuration
BACKUP_DIR="/backups/daily"
TEST_DIR="/tmp/pg_restore_test_$(date +%Y%m%d_%H%M%S)"
LOG_FILE="/var/log/pg_restore_tests.log"
ALERT_EMAIL="dba@entreprise.com"
SLACK_WEBHOOK="https://hooks.slack.com/services/YOUR/WEBHOOK/URL"

# Fonction de logging
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1" | tee -a $LOG_FILE
}

# Fonction d'alerte
alert() {
    local status=$1
    local message=$2

    # Email
    echo "$message" | mail -s "PostgreSQL Restore Test: $status" $ALERT_EMAIL

    # Slack
    curl -X POST $SLACK_WEBHOOK \
        -H 'Content-Type: application/json' \
        -d "{\"text\":\"üîî PostgreSQL Restore Test: $status\n$message\"}"
}

# D√©but du test
log "=== D√âBUT DU TEST DE RESTAURATION ==="
START_TIME=$(date +%s)

# 1. Identifier la derni√®re sauvegarde
LATEST_BACKUP=$(ls -t $BACKUP_DIR/*.tar.gz | head -1)
if [ -z "$LATEST_BACKUP" ]; then
    log "ERREUR: Aucune sauvegarde trouv√©e"
    alert "FAILED" "Aucune sauvegarde trouv√©e dans $BACKUP_DIR"
    exit 1
fi

log "Sauvegarde √† tester: $LATEST_BACKUP"

# 2. Pr√©parer l'environnement de test
log "Pr√©paration environnement de test: $TEST_DIR"
mkdir -p $TEST_DIR
chmod 700 $TEST_DIR

# 3. Extraire la sauvegarde
log "Extraction de la sauvegarde..."
if tar -xzf $LATEST_BACKUP -C $TEST_DIR; then
    log "‚úÖ Extraction r√©ussie"
else
    log "‚ùå ERREUR lors de l'extraction"
    alert "FAILED" "Extraction de la sauvegarde a √©chou√©"
    rm -rf $TEST_DIR
    exit 1
fi

# 4. D√©marrer PostgreSQL
log "D√©marrage de PostgreSQL..."
pg_ctl -D $TEST_DIR/data -l $TEST_DIR/postgres.log start -o "-p 5433"

# Attendre le d√©marrage (max 30 secondes)
for i in {1..30}; do
    if pg_isready -h localhost -p 5433 > /dev/null 2>&1; then
        log "‚úÖ PostgreSQL d√©marr√©"
        break
    fi
    sleep 1
done

if ! pg_isready -h localhost -p 5433 > /dev/null 2>&1; then
    log "‚ùå ERREUR: PostgreSQL n'a pas d√©marr√©"
    alert "FAILED" "PostgreSQL n'a pas d√©marr√©. Voir logs: $TEST_DIR/postgres.log"
    rm -rf $TEST_DIR
    exit 1
fi

# 5. Tests de validation
log "Ex√©cution des tests de validation..."

# Test 1: Connexion basique
if psql -h localhost -p 5433 -U postgres -c "SELECT version();" > /dev/null 2>&1; then
    log "‚úÖ Test 1: Connexion OK"
else
    log "‚ùå Test 1: Connexion FAILED"
    pg_ctl -D $TEST_DIR/data stop
    alert "FAILED" "Impossible de se connecter √† PostgreSQL"
    rm -rf $TEST_DIR
    exit 1
fi

# Test 2: Lister les bases
DATABASES=$(psql -h localhost -p 5433 -U postgres -t -c "SELECT count(*) FROM pg_database WHERE datistemplate = false;")
log "‚úÖ Test 2: $DATABASES bases de donn√©es trouv√©es"

# Test 3: V√©rifier tables critiques
TABLES=$(psql -h localhost -p 5433 -U postgres -d production_db -t -c "SELECT count(*) FROM information_schema.tables WHERE table_schema = 'public';")
log "‚úÖ Test 3: $TABLES tables trouv√©es"

# Test 4: V√©rifier int√©grit√© (checksums)
if [ -f "$TEST_DIR/data/PG_VERSION" ]; then
    PGVERSION=$(cat $TEST_DIR/data/PG_VERSION)
    log "‚úÖ Test 4: PostgreSQL version $PGVERSION"
fi

# Test 5: Requ√™te m√©tier simple
USERS_COUNT=$(psql -h localhost -p 5433 -U postgres -d production_db -t -c "SELECT count(*) FROM users;" 2>/dev/null || echo "0")
log "‚úÖ Test 5: $USERS_COUNT utilisateurs dans la base"

# 6. Arr√™ter PostgreSQL
log "Arr√™t de PostgreSQL..."
pg_ctl -D $TEST_DIR/data stop

# 7. Calculer dur√©e totale
END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))
log "‚úÖ Dur√©e totale: ${DURATION}s"

# 8. Nettoyer
log "Nettoyage de l'environnement de test..."
rm -rf $TEST_DIR

# 9. Rapport de succ√®s
log "=== TEST TERMIN√â AVEC SUCC√àS ==="
alert "SUCCESS" "Test de restauration r√©ussi en ${DURATION}s\n- Bases: $DATABASES\n- Tables: $TABLES\n- Users: $USERS_COUNT"

exit 0
```

### Configuration Cron

```bash
# Ajouter au crontab
crontab -e

# Test hebdomadaire (dimanche √† 2h du matin)
0 2 * * 0 /usr/local/bin/auto_test_restore.sh

# Test mensuel complet (premier dimanche du mois)
0 3 1-7 * 0 /usr/local/bin/full_restore_test.sh
```

---

## Checklist compl√®te de test de restauration

Utilisez cette checklist pour chaque test :

### ‚úÖ Avant le test

- [ ] Objectifs du test d√©finis et document√©s
- [ ] Environnement de test pr√©par√© et isol√©
- [ ] Derni√®re sauvegarde identifi√©e et accessible
- [ ] √âquipe inform√©e et disponible
- [ ] Runbook de restauration √† jour
- [ ] Outils et acc√®s n√©cessaires v√©rifi√©s
- [ ] Chronom√©trage pr√©par√© (timers, logs)

### ‚úÖ Pendant le test

- [ ] Heure de d√©but enregistr√©e
- [ ] Chaque √©tape du runbook suivie
- [ ] Chronom√©trage de chaque √©tape
- [ ] Probl√®mes document√©s en temps r√©el
- [ ] D√©viations not√©es
- [ ] Captures d'√©cran/logs sauvegard√©s

### ‚úÖ Validation technique

- [ ] PostgreSQL d√©marre sans erreur
- [ ] Connexion √† la base r√©ussie
- [ ] Toutes les bases de donn√©es pr√©sentes
- [ ] Toutes les tables accessibles
- [ ] Contraintes d'int√©grit√© valid√©es
- [ ] Index pr√©sents et utilisables
- [ ] Extensions charg√©es correctement
- [ ] Fonctions/Procedures op√©rationnelles
- [ ] Triggers actifs

### ‚úÖ Validation fonctionnelle

- [ ] Requ√™tes m√©tier critiques fonctionnent
- [ ] Comptage des lignes coh√©rent
- [ ] Int√©grit√© r√©f√©rentielle valid√©e
- [ ] Donn√©es sensibles pr√©sentes
- [ ] Performance acceptable
- [ ] Application peut se connecter
- [ ] Fonctionnalit√©s m√©tier test√©es

### ‚úÖ Apr√®s le test

- [ ] RTO r√©el calcul√© et document√©
- [ ] RPO r√©el v√©rifi√©
- [ ] Rapport de test r√©dig√©
- [ ] Probl√®mes identifi√©s list√©s
- [ ] Actions correctives d√©finies
- [ ] Post-mortem effectu√©
- [ ] Documentation mise √† jour
- [ ] Environnement de test nettoy√©
- [ ] Prochain test planifi√©
- [ ] Parties prenantes inform√©es

---

## Erreurs courantes √† √©viter

### ‚ùå Erreur 1 : Tester uniquement le "happy path"

**Probl√®me :** Tester uniquement le sc√©nario id√©al o√π tout fonctionne parfaitement.

**Solution :** Testez aussi les sc√©narios d'√©chec :
- Sauvegarde corrompue
- Espace disque insuffisant
- Permissions incorrectes
- Version PostgreSQL incompatible
- Extension manquante
- Perte de connectivit√© r√©seau pendant la restauration

### ‚ùå Erreur 2 : Ne pas tester les WAL archives (PITR)

**Probl√®me :** Tester uniquement la sauvegarde de base, pas la restauration point-in-time.

**Solution :** Testez r√©guli√®rement le PITR :
```bash
# Restaurer √† un point pr√©cis dans le temps
recovery_target_time = '2025-11-23 14:30:00'

# V√©rifier que les WAL archives sont applicables
# V√©rifier que vous pouvez bien r√©cup√©rer jusqu'au point souhait√©
```

### ‚ùå Erreur 3 : N√©gliger la validation applicative

**Probl√®me :** Se contenter de valider que PostgreSQL d√©marre.

**Solution :** Toujours tester avec l'application r√©elle si possible, ou au minimum avec des requ√™tes m√©tier critiques.

### ‚ùå Erreur 4 : Environnement de test non repr√©sentatif

**Probl√®me :** Tester sur un petit serveur qui ne refl√®te pas la production.

**Solution :** L'environnement de test doit √™tre aussi proche que possible de la production en termes de :
- Version PostgreSQL exacte
- Configuration similaire
- Extensions identiques
- Ressources comparables (CPU, RAM, I/O)

### ‚ùå Erreur 5 : Documentation non maintenue

**Probl√®me :** D√©couvrir pendant le test que le runbook est obsol√®te.

**Solution :** Mettre √† jour la documentation apr√®s **chaque** test, pas seulement apr√®s les √©checs.

---

## Outils et ressources utiles

### Outils de monitoring pendant les tests

1. **pg_restore avec verbose** :
```bash
pg_restore -v -d mydb backup.dump 2>&1 | tee restore.log
```

2. **Monitoring syst√®me en temps r√©el** :
```bash
# CPU, RAM, I/O
watch -n 1 'ps aux | grep postgres; free -h; iostat -x 1 1'
```

3. **Progression de la restauration** :
```sql
-- Voir l'activit√© PostgreSQL
SELECT pid, usename, application_name, state, query
FROM pg_stat_activity
WHERE state != 'idle';
```

### Scripts utiles

#### Script de comparaison pre/post restauration

```bash
#!/bin/bash
# compare_databases.sh
# Compare les statistiques avant/apr√®s restauration

DB_PROD="host=prod-server dbname=mydb"
DB_TEST="host=test-server dbname=mydb"

echo "=== COMPARAISON PROD vs TEST ==="

# Compter les tables
echo "Tables:"
psql "$DB_PROD" -t -c "SELECT count(*) FROM information_schema.tables WHERE table_schema='public';" | tr -d ' ' > /tmp/prod_tables
psql "$DB_TEST" -t -c "SELECT count(*) FROM information_schema.tables WHERE table_schema='public';" | tr -d ' ' > /tmp/test_tables
diff /tmp/prod_tables /tmp/test_tables || echo "‚ö†Ô∏è  Diff√©rence d√©tect√©e"

# Compter les lignes par table
echo "Lignes par table:"
psql "$DB_PROD" -c "
    SELECT schemaname, tablename, n_live_tup
    FROM pg_stat_user_tables
    ORDER BY tablename;
" > /tmp/prod_rows

psql "$DB_TEST" -c "
    SELECT schemaname, tablename, n_live_tup
    FROM pg_stat_user_tables
    ORDER BY tablename;
" > /tmp/test_rows

diff /tmp/prod_rows /tmp/test_rows || echo "‚ö†Ô∏è  Diff√©rence d√©tect√©e"
```

### Ressources compl√©mentaires

- **Documentation officielle PostgreSQL** : [Backup and Restore](https://www.postgresql.org/docs/current/backup.html)
- **pgBackRest** : Outil de backup/restore avanc√© avec tests int√©gr√©s
- **Barman** : Backup and Recovery Manager pour PostgreSQL
- **pg_verify_checksums** : V√©rifier l'int√©grit√© des donn√©es
- **pg_basebackup** : Sauvegarde physique avec validation

---

## Conclusion

Les tests de restauration r√©guliers ne sont pas une option, **c'est une n√©cessit√© absolue**. Une sauvegarde non test√©e n'est qu'une illusion de s√©curit√©.

### Points cl√©s √† retenir

1. **Testez r√©guli√®rement** : Au minimum trimestriellement, id√©alement mensuellement
2. **Automatisez** : Les tests de validation technique doivent √™tre automatis√©s
3. **Chronom√©trez** : Mesurez votre RTO r√©el, ne vous fiez pas aux estimations
4. **Documentez** : Chaque test doit produire un rapport
5. **Am√©liorez** : Chaque test doit conduire √† des actions correctives
6. **Impliquez l'√©quipe** : La restauration n'est pas qu'une responsabilit√© du DBA
7. **Testez les √©checs** : Ne testez pas que le sc√©nario id√©al

### Les tests de restauration vous donnent

- ‚úÖ **Confiance** : Vous savez que vos backups fonctionnent
- ‚úÖ **Pr√©paration** : L'√©quipe est form√©e et pr√™te
- ‚úÖ **Rapidit√©** : Vous connaissez votre RTO r√©el
- ‚úÖ **Documentation** : Les proc√©dures sont √† jour
- ‚úÖ **Am√©lioration continue** : Vous identifiez et corrigez les probl√®mes

### Votre prochaine action

**Planifiez d√®s maintenant votre prochain test de restauration.** Ne le repoussez pas. Les incidents arrivent toujours au pire moment, et c'est l√† que vous serez heureux d'avoir test√© vos proc√©dures r√©guli√®rement.

> **"La meilleure fa√ßon de g√©rer un incident, c'est d'y √™tre pr√©par√©."**

---

## Pour aller plus loin

Dans les sections suivantes du chapitre Disaster Recovery, nous aborderons :

- **19.5.3. G√©o-r√©plication et Multi-Region** : Prot√©ger contre les d√©sastres r√©gionaux
- **19.5.4. Strat√©gies de backup avanc√©es** : 3-2-1, incrementiel, diff√©rentiel
- **19.5.5. Automatisation du Disaster Recovery** : Patroni, orchestration


---

**Ressources mentionn√©es :**
- [pg_basebackup](https://www.postgresql.org/docs/current/app-pgbasebackup.html)
- [pg_dump/pg_restore](https://www.postgresql.org/docs/current/backup-dump.html)
- [Point-in-Time Recovery](https://www.postgresql.org/docs/current/continuous-archiving.html)

‚è≠Ô∏è [G√©o-r√©plication et Multi-Region](/19-postgresql-en-production/05.3-geo-replication-multi-region.md)
