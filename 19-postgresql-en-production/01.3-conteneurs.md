ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 19.1.3. Conteneurs (Docker, Podman)

## Introduction Ã  la Conteneurisation

### Qu'est-ce qu'un Conteneur ?

Un **conteneur** est une unitÃ© lÃ©gÃ¨re et portable qui regroupe une application et toutes ses dÃ©pendances (bibliothÃ¨ques, configuration, binaires) dans un package isolÃ© du systÃ¨me hÃ´te.

**Analogie simple :**

Imaginez que vous dÃ©mÃ©nagez :
- **Bare Metal** : Vous emportez tous vos meubles en vrac, vous devez tout remonter dans le nouveau logement
- **VM** : Vous emportez votre appartement entier (murs, Ã©lectricitÃ©, plomberie) pour le reconstruire ailleurs
- **Conteneur** : Vous mettez tout dans des cartons standardisÃ©s qui s'adaptent Ã  n'importe quel logement. Vous ouvrez le carton et c'est prÃªt !

### Vocabulaire de Base

| Terme | DÃ©finition | Exemple |
|-------|-----------|---------|
| **Conteneur** | Instance en cours d'exÃ©cution d'une image | PostgreSQL tournant dans un conteneur |
| **Image** | Template immuable contenant l'application | `postgres:18` |
| **Dockerfile** | Recette pour construire une image | Instructions pour crÃ©er image PostgreSQL personnalisÃ©e |
| **Registry** | DÃ©pÃ´t d'images | Docker Hub, Quay.io |
| **Volume** | Stockage persistant pour conteneurs | DonnÃ©es PostgreSQL PGDATA |
| **Network** | RÃ©seau virtuel pour connecter conteneurs | Bridge, host, overlay |
| **Orchestrateur** | GÃ¨re dÃ©ploiement Ã  grande Ã©chelle | Kubernetes, Docker Swarm |

### Architecture : Conteneurs vs VMs

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    VIRTUAL MACHINES                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚App + Libsâ”‚  â”‚App + Libsâ”‚  â”‚App + Libsâ”‚                  â”‚
â”‚  â”‚Guest OS  â”‚  â”‚Guest OS  â”‚  â”‚Guest OS  â”‚  â† OS complet    â”‚
â”‚  â”‚(2-4 GB)  â”‚  â”‚(2-4 GB)  â”‚  â”‚(2-4 GB)  â”‚     dans chaque  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Hyperviseur â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤               â”‚
â”‚  â”‚           Host OS + Hardware            â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚  Overhead : 5-10% | DÃ©marrage : 30-60s                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      CONTENEURS                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚App+Lâ”‚  â”‚App+Lâ”‚  â”‚App+Lâ”‚  â”‚App+Lâ”‚  â”‚App+Lâ”‚ â† Seulement   â”‚
â”‚  â”‚50 MBâ”‚  â”‚50 MBâ”‚  â”‚50 MBâ”‚  â”‚50 MBâ”‚  â”‚50 MBâ”‚    app+libs   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜               â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€ Runtime Conteneur (Docker/Podman) â”€â”€â”€â”€â”€â”¤       â”‚
â”‚  â”‚           Host OS + Kernel Linux                â”‚       â”‚
â”‚  â”‚                 Hardware                        â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚  Overhead : 2-5% | DÃ©marrage : <5s                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**DiffÃ©rences clÃ©s :**

| CaractÃ©ristique | VM | Conteneur |
|-----------------|-----|-----------|
| **Isolation** | Forte (OS complet) | Moyenne (partage kernel) |
| **Taille** | 2-20 GB | 50-500 MB |
| **DÃ©marrage** | 30-60 secondes | 1-5 secondes |
| **Overhead** | 5-10% | 2-5% |
| **DensitÃ©** | 10-20 par hÃ´te | 50-1000+ par hÃ´te |
| **PortabilitÃ©** | Moyenne | Excellente |
| **SÃ©curitÃ©** | TrÃ¨s forte | Bonne (dÃ©pend config) |

### Comment Fonctionnent les Conteneurs ?

Les conteneurs utilisent des fonctionnalitÃ©s du kernel Linux :

```
Conteneur PostgreSQL
â”œâ”€ Namespaces : Isolation (PID, network, mount, IPC, UTS)
â”‚   â””â”€ Le conteneur "pense" Ãªtre seul sur la machine
â”œâ”€ Cgroups : Limitation ressources (CPU, RAM, I/O)
â”‚   â””â”€ "Tu peux utiliser max 2 CPU et 4 GB RAM"
â”œâ”€ Union Filesystem : SystÃ¨me de fichiers en couches
â”‚   â””â”€ Layers empilÃ©es (base OS â†’ PostgreSQL â†’ config)
â””â”€ Capabilities : Permissions granulaires
    â””â”€ Moins de privilÃ¨ges que root complet
```

**Exemple concret :**

```bash
# Lancer PostgreSQL en conteneur
docker run -d \
  --name postgres18 \
  -e POSTGRES_PASSWORD=secret \
  -v pgdata:/var/lib/postgresql/data \
  postgres:18

# En quelques secondes :
# âœ… PostgreSQL 18 dÃ©marre
# âœ… IsolÃ© du systÃ¨me hÃ´te
# âœ… DonnÃ©es persistantes dans volume
# âœ… Portable : mÃªme commande sur n'importe quel OS
```

---

## Docker vs Podman : Quel Outil Choisir ?

### Docker

**PrÃ©sentation :**
- CrÃ©Ã© en 2013, leader du marchÃ©
- Architecture client-serveur (daemon)
- Ã‰cosystÃ¨me mature et riche
- Docker Hub : registre officiel avec millions d'images

**Architecture Docker :**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Utilisateur                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚ docker run postgres:18
            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Docker Client (CLI)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚ API REST
            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Docker Daemon (dockerd)        â”‚
â”‚  - Gestion conteneurs               â”‚
â”‚  - Gestion images                   â”‚
â”‚  - Gestion rÃ©seau                   â”‚
â”‚  - Gestion volumes                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      containerd + runc              â”‚
â”‚  (runtime bas-niveau)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â†“
      [Conteneurs]
```

**Avantages Docker :**
- âœ… Documentation trÃ¨s complÃ¨te
- âœ… Ã‰norme communautÃ© (Stack Overflow, forums)
- âœ… Ã‰cosystÃ¨me riche (Docker Compose, Swarm, Desktop)
- âœ… Support commercial (Docker Inc.)
- âœ… Compatible Windows et macOS (Docker Desktop)
- âœ… IntÃ©gration CI/CD mature

**InconvÃ©nients Docker :**
- âŒ NÃ©cessite daemon root (problÃ¨me sÃ©curitÃ©)
- âŒ Architecture centralisÃ©e (SPOF)
- âŒ Licence restrictive pour entreprises (Docker Desktop payant)
- âŒ ComplexitÃ© pour environnements multi-utilisateurs

**Cas d'usage Docker pour PostgreSQL :**
- DÃ©veloppement local (avec Docker Desktop)
- CI/CD (tests d'intÃ©gration)
- Petites infrastructures (<50 conteneurs)
- Ã‰quipes habituÃ©es Ã  Docker
- Environnement Windows/macOS

---

### Podman

**PrÃ©sentation :**
- CrÃ©Ã© par Red Hat en 2018
- Alternative open source Ã  Docker
- Architecture daemonless (sans daemon)
- Compatible API Docker (drop-in replacement)
- IntÃ©grÃ© Ã  RHEL, Fedora, CentOS Stream

**Architecture Podman :**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Utilisateur                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚ podman run postgres:18
            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Podman CLI                    â”‚
â”‚  (Processus utilisateur direct)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚ Fork direct
            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     conmon + runc                   â”‚
â”‚  (runtime conteneur)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â†“
      [Conteneurs]

Pas de daemon central ! Plus sÃ©curisÃ©.
```

**Avantages Podman :**
- âœ… **Sans daemon** : Pas de processus root permanent
- âœ… **Rootless** : Conteneurs sans privilÃ¨ges root
- âœ… **SÃ©curitÃ©** : Isolation utilisateur native
- âœ… **Pods** : Support natif groupes de conteneurs (comme Kubernetes)
- âœ… **Systemd** : IntÃ©gration native services systemd
- âœ… **Licence** : 100% open source Apache 2.0
- âœ… **Compatible Docker** : `alias docker=podman` fonctionne

**InconvÃ©nients Podman :**
- âŒ CommunautÃ© plus petite que Docker
- âŒ Documentation moins abondante
- âŒ Quelques incompatibilitÃ©s mineures avec Docker
- âŒ Pas de Docker Desktop Ã©quivalent (Podman Desktop en beta)
- âŒ Moins mature pour Windows/macOS

**Cas d'usage Podman pour PostgreSQL :**
- âœ… **Production Linux** (meilleure sÃ©curitÃ©)
- âœ… Environnements multi-utilisateurs
- âœ… Infrastructure Red Hat / Fedora
- âœ… Migration vers Kubernetes facilitÃ©e
- âœ… ConformitÃ© sÃ©curitÃ© stricte

---

### Comparaison DÃ©taillÃ©e

| CritÃ¨re | Docker | Podman | Recommandation |
|---------|--------|--------|----------------|
| **SÃ©curitÃ©** | â­â­â­ (daemon root) | â­â­â­â­â­ (rootless) | Podman |
| **MaturitÃ©** | â­â­â­â­â­ (10 ans) | â­â­â­â­ (5 ans) | Docker |
| **CommunautÃ©** | â­â­â­â­â­ Ã‰norme | â­â­â­â­ Grande | Docker |
| **Performance** | â­â­â­â­ | â­â­â­â­â­ (pas daemon) | Podman |
| **CompatibilitÃ©** | â­â­â­â­â­ | â­â­â­â­ (99% Docker) | Docker |
| **Production** | â­â­â­â­ | â­â­â­â­â­ | Podman |
| **DÃ©veloppement** | â­â­â­â­â­ | â­â­â­â­ | Docker |
| **Windows/Mac** | â­â­â­â­â­ | â­â­ | Docker |

**Notre recommandation :**

```
Si dÃ©veloppement (Windows/macOS) :
â””â”€ Docker Desktop

Si production Linux :
â””â”€ Podman (sÃ©curitÃ© supÃ©rieure)

Si Ã©quipe dÃ©jÃ  sur Docker :
â””â”€ Rester sur Docker (sauf besoin sÃ©curitÃ© critique)

Si infrastructure Red Hat :
â””â”€ Podman (natif)
```

**Note :** Le reste du document utilise principalement Docker pour les exemples, mais les commandes Podman sont quasi-identiques (`docker â†’ podman`).

---

## Images PostgreSQL Officielles

### Images Disponibles

**Docker Hub : `postgres`**

```
Registre : hub.docker.com/_/postgres
Versions disponibles :
â”œâ”€ postgres:18        â†’ DerniÃ¨re 18.x
â”œâ”€ postgres:18.1      â†’ Version spÃ©cifique
â”œâ”€ postgres:18-alpine â†’ Version lÃ©gÃ¨re Alpine Linux
â”œâ”€ postgres:17        â†’ PrÃ©cÃ©dente version
â”œâ”€ postgres:latest    â†’ âš ï¸ DÃ©conseillÃ© production
â””â”€ postgis/postgis:18 â†’ PostgreSQL + PostGIS
```

**Tags recommandÃ©s :**

```dockerfile
âœ… postgres:18.1            # Version spÃ©cifique (recommandÃ© production)
âœ… postgres:18              # DerniÃ¨re 18.x (dev/staging)
âš ï¸ postgres:18-alpine      # LÃ©ger mais diffÃ©rences comportement
âŒ postgres:latest          # Version changeante (jamais en production !)
```

**Pourquoi Ã©viter `:latest` ?**

```
Aujourd'hui :
  postgres:latest â†’ 18.1

Demain (aprÃ¨s release PG 19) :
  postgres:latest â†’ 19.0

Votre conteneur redÃ©marre â†’ Upgrade surprise â†’ IncompatibilitÃ©s
```

**RÃ¨gle d'or :** Toujours spÃ©cifier version exacte en production.

### Anatomie d'une Image PostgreSQL

**Couches (layers) de l'image :**

```
Image postgres:18 (~370 MB)
â”œâ”€ Layer 1 : Debian bookworm base     (~80 MB)
â”œâ”€ Layer 2 : DÃ©pendances systÃ¨me      (~50 MB)
â”œâ”€ Layer 3 : PostgreSQL 18 binaires   (~200 MB)
â”œâ”€ Layer 4 : Scripts d'initialisation (~5 MB)
â”œâ”€ Layer 5 : Configuration par dÃ©faut (~1 MB)
â””â”€ Layer 6 : Entrypoint et CMD        (~1 KB)

Avantages couches :
âœ… RÃ©utilisation (cache layers partagÃ©s)
âœ… Mises Ã  jour efficaces (seules layers modifiÃ©es)
âœ… Stockage optimisÃ© (dÃ©duplication)
```

**Fichier Dockerfile de l'image officielle (simplifiÃ©) :**

```dockerfile
FROM debian:bookworm-slim

# Variables d'environnement
ENV POSTGRES_VERSION 18
ENV PGDATA /var/lib/postgresql/data

# Installation PostgreSQL
RUN apt-get update && apt-get install -y \
    postgresql-18 \
    postgresql-contrib-18 \
    && rm -rf /var/lib/apt/lists/*

# Volume pour donnÃ©es
VOLUME /var/lib/postgresql/data

# Exposition port
EXPOSE 5432

# Point d'entrÃ©e
COPY docker-entrypoint.sh /usr/local/bin/
ENTRYPOINT ["docker-entrypoint.sh"]
CMD ["postgres"]
```

---

## Lancer PostgreSQL en Conteneur

### Commande de Base

```bash
docker run -d \
  --name postgres18-demo \
  -e POSTGRES_PASSWORD=MySecretPassword \
  -p 5432:5432 \
  postgres:18
```

**DÃ©cortiquons cette commande :**

```bash
docker run              # CrÃ©er et lancer conteneur
  -d                    # Detached (arriÃ¨re-plan)
  --name postgres18-demo  # Nom du conteneur
  -e POSTGRES_PASSWORD=MySecretPassword  # Variable d'environnement
  -p 5432:5432          # Mapping port hÃ´te:conteneur
  postgres:18           # Image Ã  utiliser
```

**Que se passe-t-il ?**

1. Docker tÃ©lÃ©charge l'image `postgres:18` (si pas dÃ©jÃ  en cache)
2. CrÃ©e un conteneur nommÃ© `postgres18-demo`
3. Configure mot de passe superuser `postgres`
4. Expose port 5432 (accessible depuis hÃ´te)
5. DÃ©marre PostgreSQL

**VÃ©rification :**

```bash
# Lister conteneurs en cours
docker ps

# Logs
docker logs postgres18-demo

# Connexion au conteneur
docker exec -it postgres18-demo psql -U postgres
```

### Variables d'Environnement Importantes

```bash
docker run -d \
  --name postgres18-prod \

  # ===== CONFIGURATION DE BASE =====
  -e POSTGRES_PASSWORD=SecretPass123    # âœ… Obligatoire
  -e POSTGRES_USER=myapp               # Utilisateur custom (dÃ©faut: postgres)
  -e POSTGRES_DB=myappdb               # Base crÃ©Ã©e au dÃ©marrage

  # ===== INITIALISATION =====
  -e POSTGRES_INITDB_ARGS="--data-checksums --encoding=UTF8 --locale=fr_FR.UTF-8"
  # Options initdb (checksums activÃ©s par dÃ©faut PG18)

  -e POSTGRES_HOST_AUTH_METHOD=scram-sha-256  # MÃ©thode auth (dÃ©faut: scram)
  # âš ï¸ Ne JAMAIS utiliser 'trust' en production !

  # ===== TUNING =====
  -e POSTGRES_SHARED_BUFFERS=2GB       # Ã‰quivalent shared_buffers
  -e POSTGRES_WORK_MEM=64MB            # Ã‰quivalent work_mem

  # ===== CHEMINS =====
  -e PGDATA=/var/lib/postgresql/data/pgdata  # Sous-rÃ©pertoire PGDATA

  postgres:18
```

**Variables communes :**

| Variable | Description | DÃ©faut | Exemple |
|----------|-------------|--------|---------|
| `POSTGRES_PASSWORD` | Mot de passe superuser | *(obligatoire)* | `MySecret123` |
| `POSTGRES_USER` | Nom superuser | `postgres` | `admin` |
| `POSTGRES_DB` | Base initiale | = `POSTGRES_USER` | `production` |
| `PGDATA` | RÃ©pertoire donnÃ©es | `/var/lib/postgresql/data` | `/pgdata` |
| `POSTGRES_INITDB_ARGS` | Arguments initdb | `--auth-host=scram-sha-256` | `--data-checksums` |
| `POSTGRES_INITDB_WALDIR` | RÃ©pertoire WAL sÃ©parÃ© | *(dans PGDATA)* | `/pg_wal` |

---

## Persistance des DonnÃ©es : Volumes

### ProblÃ¨me sans Volume

```bash
# Lancer conteneur sans volume
docker run -d --name pg-temp -e POSTGRES_PASSWORD=pass postgres:18

# CrÃ©er une table
docker exec -it pg-temp psql -U postgres -c "CREATE TABLE users (id INT);"

# ArrÃªter et supprimer conteneur
docker stop pg-temp
docker rm pg-temp

# Relancer conteneur
docker run -d --name pg-temp -e POSTGRES_PASSWORD=pass postgres:18

# La table n'existe plus ! DonnÃ©es perdues ğŸ˜±
```

**Pourquoi ?** Les donnÃ©es Ã©taient stockÃ©es dans le conteneur, pas sur l'hÃ´te.

### Solution : Volumes Docker

**3 types de montage :**

#### 1. Named Volume (RecommandÃ© Production)

```bash
# CrÃ©er volume
docker volume create pgdata-prod

# Lancer conteneur avec volume
docker run -d \
  --name postgres18-prod \
  -e POSTGRES_PASSWORD=secret \
  -v pgdata-prod:/var/lib/postgresql/data \
  postgres:18

# Avantages :
# âœ… GÃ©rÃ© par Docker (backup, migration faciles)
# âœ… Performance optimale
# âœ… IndÃ©pendant du systÃ¨me de fichiers hÃ´te
# âœ… Survit Ã  la suppression du conteneur
```

**Inspection :**

```bash
# Lister volumes
docker volume ls

# Inspecter volume
docker volume inspect pgdata-prod
# {
#   "Mountpoint": "/var/lib/docker/volumes/pgdata-prod/_data",
#   ...
# }

# Emplacement physique (nÃ©cessite root)
sudo ls -la /var/lib/docker/volumes/pgdata-prod/_data
```

#### 2. Bind Mount (DÃ©veloppement)

```bash
# CrÃ©er rÃ©pertoire local
mkdir -p ~/postgres-data

# Lancer avec bind mount
docker run -d \
  --name postgres18-dev \
  -e POSTGRES_PASSWORD=secret \
  -v ~/postgres-data:/var/lib/postgresql/data \
  postgres:18

# Avantages :
# âœ… AccÃ¨s direct fichiers depuis hÃ´te
# âœ… Facile pour dÃ©boguer
# âœ… Ã‰dition configuration Ã  chaud

# InconvÃ©nients :
# âŒ Permissions complexes (problÃ¨me UID/GID)
# âŒ Performance variable selon filesystem hÃ´te
# âŒ Moins portable
```

**ProblÃ¨me de permissions typique :**

```bash
# L'utilisateur postgres dans conteneur a UID 999
# Vos fichiers locaux appartiennent Ã  UID 1000 (vous)
# â†’ Erreur permission denied

# Solution :
sudo chown -R 999:999 ~/postgres-data
```

#### 3. tmpfs Mount (Temporaire)

```bash
# Volume en mÃ©moire RAM (non persistant)
docker run -d \
  --name postgres18-test \
  -e POSTGRES_PASSWORD=secret \
  --tmpfs /var/lib/postgresql/data:rw,size=1g \
  postgres:18

# Avantages :
# âœ… TrÃ¨s rapide (RAM)
# âœ… SÃ©curitÃ© (donnÃ©es effacÃ©es Ã  l'arrÃªt)

# InconvÃ©nients :
# âŒ Aucune persistance
# âŒ LimitÃ© par RAM
# âŒ Usage : Tests uniquement
```

### Architecture Multi-Volumes (Production)

```bash
# CrÃ©er volumes sÃ©parÃ©s
docker volume create pgdata-prod      # DonnÃ©es principales
docker volume create pg-wal-prod      # WAL sÃ©parÃ©
docker volume create pg-backups-prod  # Sauvegardes

docker run -d \
  --name postgres18-prod \
  -e POSTGRES_PASSWORD=secret \
  -e POSTGRES_INITDB_WALDIR=/pg_wal \
  -v pgdata-prod:/var/lib/postgresql/data \
  -v pg-wal-prod:/pg_wal \
  -v pg-backups-prod:/backups \
  postgres:18

# Architecture :
# Conteneur
# â”œâ”€ /var/lib/postgresql/data â†’ Volume pgdata-prod (donnÃ©es)
# â”œâ”€ /pg_wal â†’ Volume pg-wal-prod (WAL isolÃ©)
# â””â”€ /backups â†’ Volume pg-backups-prod (sauvegardes)
```

**Avantages :**
- Optimisation I/O (WAL sÃ©parÃ© rÃ©duit contention)
- Gestion sauvegardes simplifiÃ©e
- Snapshots sÃ©lectifs possibles

---

## RÃ©seau et ConnectivitÃ©

### Modes RÃ©seau Docker

#### 1. Bridge (DÃ©faut)

```bash
docker run -d \
  --name postgres18 \
  -p 5432:5432 \
  postgres:18

# Fonctionnement :
# Conteneur â†’ Bridge docker0 â†’ Interface hÃ´te â†’ RÃ©seau externe
# IP conteneur : 172.17.0.x (rÃ©seau privÃ© Docker)
# Accessible depuis hÃ´te : localhost:5432
```

**CaractÃ©ristiques :**
- âœ… Isolation rÃ©seau
- âœ… Port mapping flexible
- âŒ NAT = lÃ©gÃ¨re latence (+0.5-1ms)
- âœ… Usage : DÃ©veloppement, petite infra

#### 2. Host (Performance)

```bash
docker run -d \
  --name postgres18 \
  --network host \
  postgres:18

# Fonctionnement :
# Conteneur partage stack rÃ©seau de l'hÃ´te
# Pas d'isolation rÃ©seau
# Ã‰coute directement sur 5432 de l'hÃ´te
```

**CaractÃ©ristiques :**
- âœ… Performance maximale (pas de NAT)
- âœ… Latence minimale
- âŒ Perte isolation
- âŒ Conflits de ports possibles
- âš ï¸ Usage : Production haute performance (avec prÃ©cautions)

#### 3. Custom Network (RecommandÃ© Multi-Conteneurs)

```bash
# CrÃ©er rÃ©seau custom
docker network create pg-network

# Lancer PostgreSQL
docker run -d \
  --name postgres18 \
  --network pg-network \
  -e POSTGRES_PASSWORD=secret \
  postgres:18

# Lancer application
docker run -d \
  --name myapp \
  --network pg-network \
  -e DATABASE_URL=postgresql://postgres:secret@postgres18:5432/postgres \
  myapp:latest

# Communication :
# myapp â†’ DNS "postgres18" â†’ PostgreSQL
# Pas besoin port mapping (rÃ©seau isolÃ©)
```

**Avantages :**
- âœ… DNS automatique entre conteneurs
- âœ… Isolation rÃ©seau par projet
- âœ… Pas de publication ports externe nÃ©cessaire
- âœ… SÃ©curitÃ© accrue

### Exposition des Ports

```bash
# DiffÃ©rentes syntaxes port mapping

# Port unique
-p 5432:5432          # hÃ´te:conteneur

# Port hÃ´te diffÃ©rent
-p 5433:5432          # PostgreSQL sur port 5433 de l'hÃ´te

# IP spÃ©cifique
-p 10.0.1.50:5432:5432  # Ã‰coute uniquement sur IP spÃ©cifique

# Port alÃ©atoire hÃ´te
-p 5432               # Docker choisit port hÃ´te libre

# Tous les ports exposÃ©s
-P                    # Mappe tous EXPOSE du Dockerfile
```

**SÃ©curitÃ© :**

```bash
# âŒ Dangereux : Exposition publique
docker run -p 0.0.0.0:5432:5432 postgres:18

# âœ… Mieux : Localhost uniquement
docker run -p 127.0.0.1:5432:5432 postgres:18

# âœ… Optimal : RÃ©seau custom sans exposition
docker run --network pg-network postgres:18
```

---

## Configuration PostgreSQL en Conteneur

### MÃ©thodes de Configuration

#### 1. Variables d'Environnement (Simple)

```bash
docker run -d \
  --name postgres18 \
  -e POSTGRES_PASSWORD=secret \
  -e POSTGRES_SHARED_BUFFERS=2GB \
  -e POSTGRES_WORK_MEM=64MB \
  -e POSTGRES_MAX_CONNECTIONS=200 \
  postgres:18

# Limitations :
# âš ï¸ ParamÃ¨tres limitÃ©s
# âš ï¸ Pas toutes les options disponibles
```

#### 2. Arguments de Commande (Flexible)

```bash
docker run -d \
  --name postgres18 \
  -e POSTGRES_PASSWORD=secret \
  postgres:18 \
  postgres \
    -c shared_buffers=2GB \
    -c work_mem=64MB \
    -c max_connections=200 \
    -c log_statement=all \
    -c log_min_duration_statement=1000

# Avantages :
# âœ… Tous paramÃ¨tres disponibles
# âœ… Visible dans docker ps
# âœ… Facile Ã  modifier (recrÃ©er conteneur)
```

#### 3. Fichier postgresql.conf Custom (Production)

**CrÃ©ation fichier custom :**

```ini
# custom-postgresql.conf
listen_addresses = '*'
max_connections = 200
shared_buffers = 4GB
effective_cache_size = 12GB
work_mem = 64MB
maintenance_work_mem = 1GB
wal_level = replica
max_wal_size = 4GB
checkpoint_completion_target = 0.9

# PostgreSQL 18 spÃ©cifique
io_method = 'async'
io_async_workers = 8
wal_compression = zstd
```

**Montage dans conteneur :**

```bash
docker run -d \
  --name postgres18-prod \
  -e POSTGRES_PASSWORD=secret \
  -v $(pwd)/custom-postgresql.conf:/etc/postgresql/postgresql.conf \
  -v pgdata:/var/lib/postgresql/data \
  postgres:18 \
  postgres -c config_file=/etc/postgresql/postgresql.conf
```

#### 4. Dockerfile Custom (AvancÃ©)

```dockerfile
FROM postgres:18

# Copier configuration custom
COPY custom-postgresql.conf /etc/postgresql/postgresql.conf
COPY custom-pg_hba.conf /etc/postgresql/pg_hba.conf

# Scripts d'initialisation
COPY init-scripts/*.sql /docker-entrypoint-initdb.d/

# Variables par dÃ©faut
ENV POSTGRES_PASSWORD=changeme \
    POSTGRES_DB=production

# Commande personnalisÃ©e
CMD ["postgres", "-c", "config_file=/etc/postgresql/postgresql.conf"]
```

**Build et run :**

```bash
# Construire image
docker build -t mycompany/postgres18:1.0 .

# Lancer
docker run -d \
  --name postgres18-custom \
  -v pgdata:/var/lib/postgresql/data \
  mycompany/postgres18:1.0
```

### Configuration pg_hba.conf

**Fichier custom pg_hba.conf :**

```conf
# custom-pg_hba.conf

# TYPE  DATABASE   USER      ADDRESS          METHOD

# Connexions locales (dans conteneur)
local   all        all                        scram-sha-256

# Depuis rÃ©seau Docker (172.17.0.0/16)
host    all        all       172.17.0.0/16    scram-sha-256

# Depuis rÃ©seau custom spÃ©cifique
host    all        all       10.0.1.0/24      scram-sha-256

# RÃ©plication
host    replication  replicator  10.0.1.0/24  scram-sha-256
```

**Montage :**

```bash
docker run -d \
  --name postgres18 \
  -v $(pwd)/custom-pg_hba.conf:/var/lib/postgresql/data/pg_hba.conf \
  -v pgdata:/var/lib/postgresql/data \
  postgres:18
```

---

## Docker Compose : Orchestration Multi-Conteneurs

### Introduction Ã  Docker Compose

**Docker Compose** permet de dÃ©finir et gÃ©rer des applications multi-conteneurs via un fichier YAML.

**Avantages :**
- âœ… Configuration dÃ©clarative (Infrastructure as Code)
- âœ… Gestion multi-conteneurs simplifiÃ©e
- âœ… RÃ©seau et volumes automatiques
- âœ… ReproductibilitÃ©
- âœ… Versioning (Git)

### Exemple Simple : PostgreSQL seul

**docker-compose.yml :**

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:18
    container_name: postgres18
    restart: unless-stopped
    environment:
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-changeme}
      POSTGRES_USER: postgres
      POSTGRES_DB: myapp
    volumes:
      - pgdata:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  pgdata:
    driver: local
```

**Utilisation :**

```bash
# DÃ©marrer
docker-compose up -d

# Logs
docker-compose logs -f postgres

# ArrÃªter
docker-compose down

# ArrÃªter + supprimer volumes
docker-compose down -v
```

### Stack ComplÃ¨te : PostgreSQL + Application + pgAdmin

```yaml
version: '3.8'

services:
  # ===== PostgreSQL =====
  postgres:
    image: postgres:18
    container_name: postgres18
    restart: unless-stopped
    environment:
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-SecretPass123}
      POSTGRES_DB: production
      POSTGRES_INITDB_ARGS: "--data-checksums"
    volumes:
      - pgdata:/var/lib/postgresql/data
      - ./init-scripts:/docker-entrypoint-initdb.d  # Scripts init
      - ./postgresql.conf:/etc/postgresql/postgresql.conf
    command: postgres -c config_file=/etc/postgresql/postgresql.conf
    networks:
      - backend
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
    deploy:
      resources:
        limits:
          cpus: '4'
          memory: 8G
        reservations:
          cpus: '2'
          memory: 4G

  # ===== Application =====
  app:
    image: myapp:latest
    container_name: myapp
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      DATABASE_URL: postgresql://postgres:${POSTGRES_PASSWORD:-SecretPass123}@postgres:5432/production
    networks:
      - backend
      - frontend
    ports:
      - "8080:8080"

  # ===== pgAdmin (Administration) =====
  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: pgadmin
    restart: unless-stopped
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@example.com
      PGADMIN_DEFAULT_PASSWORD: admin
      PGADMIN_CONFIG_SERVER_MODE: 'False'
    volumes:
      - pgadmin-data:/var/lib/pgadmin
    networks:
      - backend
      - frontend
    ports:
      - "5050:80"
    depends_on:
      - postgres

networks:
  backend:
    driver: bridge
  frontend:
    driver: bridge

volumes:
  pgdata:
    driver: local
  pgadmin-data:
    driver: local
```

**FonctionnalitÃ©s avancÃ©es :**

```yaml
# Healthcheck : Attendre PostgreSQL prÃªt
depends_on:
  postgres:
    condition: service_healthy

# Limites ressources
deploy:
  resources:
    limits:
      cpus: '4'
      memory: 8G

# Variables d'environnement depuis fichier
env_file:
  - .env

# RedÃ©marrage automatique
restart: unless-stopped
```

### Scripts d'Initialisation

**Structure :**

```
project/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ init-scripts/
â”‚   â”œâ”€â”€ 01-schema.sql        # Ordre alphabÃ©tique
â”‚   â”œâ”€â”€ 02-data.sql
â”‚   â””â”€â”€ 03-functions.sql
â””â”€â”€ postgresql.conf
```

**01-schema.sql :**

```sql
-- Scripts exÃ©cutÃ©s au premier dÃ©marrage uniquement
CREATE SCHEMA IF NOT EXISTS app;

CREATE TABLE app.users (
  id SERIAL PRIMARY KEY,
  username VARCHAR(50) UNIQUE NOT NULL,
  email VARCHAR(100) UNIQUE NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_users_email ON app.users(email);
```

**02-data.sql :**

```sql
INSERT INTO app.users (username, email) VALUES
  ('admin', 'admin@example.com'),
  ('user1', 'user1@example.com');
```

---

## Gestion des Ressources (Limits)

### Limitation CPU

```bash
# Limiter Ã  2 CPU
docker run -d \
  --name postgres18 \
  --cpus="2" \
  -e POSTGRES_PASSWORD=secret \
  postgres:18

# Limiter Ã  50% d'un CPU
docker run -d \
  --name postgres18 \
  --cpus="0.5" \
  postgres:18

# CPU shares (poids relatif)
docker run -d \
  --name postgres18 \
  --cpu-shares=1024 \
  postgres:18
```

**Comportement :**
- `--cpus="2"` : Maximum 2 cÅ“urs utilisÃ©s
- Si charge < 2 CPU : utilisation normale
- Si charge > 2 CPU : limitation (throttling)

### Limitation MÃ©moire

```bash
# Limiter Ã  4 GB RAM
docker run -d \
  --name postgres18 \
  --memory="4g" \
  -e POSTGRES_PASSWORD=secret \
  postgres:18

# RAM + Swap total
docker run -d \
  --memory="4g" \
  --memory-swap="6g" \  # 4 GB RAM + 2 GB swap
  postgres:18

# RÃ©servation mÃ©moire minimale
docker run -d \
  --memory="4g" \
  --memory-reservation="2g" \  # Soft limit
  postgres:18
```

**âš ï¸ Important pour PostgreSQL :**

```bash
# DÃ©sactiver swap (recommandÃ©)
docker run -d \
  --memory="4g" \
  --memory-swap="4g" \  # Ã‰gal Ã  memory = pas de swap
  postgres:18

# Ou via postgresql.conf
-c shared_buffers=1GB  # Adapter Ã  la RAM allouÃ©e
```

### Limitation I/O

```bash
# Limiter I/O disque (IOPS)
docker run -d \
  --name postgres18 \
  --device-read-iops /dev/sda:1000 \
  --device-write-iops /dev/sda:1000 \
  postgres:18

# Limiter bande passante (MB/s)
docker run -d \
  --device-read-bps /dev/sda:100mb \
  --device-write-bps /dev/sda:100mb \
  postgres:18
```

**Cas d'usage :**
- Environnements multi-tenants
- Ã‰viter qu'un conteneur sature I/O
- Tests de performance avec contraintes

### Docker Compose avec Limites

```yaml
services:
  postgres:
    image: postgres:18
    deploy:
      resources:
        limits:
          cpus: '4'
          memory: 8G
        reservations:  # Garanties minimales
          cpus: '2'
          memory: 4G
    volumes:
      - pgdata:/var/lib/postgresql/data
```

---

## SÃ©curitÃ© des Conteneurs PostgreSQL

### 1. Ne Pas ExÃ©cuter en Root

**ProblÃ¨me :**

Par dÃ©faut, les processus dans conteneurs s'exÃ©cutent souvent en root, ce qui est un risque si le conteneur est compromis.

**Solution : Utilisateur non-root**

```dockerfile
# Dockerfile custom
FROM postgres:18

# L'image officielle utilise dÃ©jÃ  user postgres (UID 999)
# VÃ©rification
USER postgres
```

**Avec Podman (Rootless) :**

```bash
# Podman permet conteneurs complÃ¨tement sans root
podman run -d \
  --name postgres18 \
  -e POSTGRES_PASSWORD=secret \
  postgres:18

# Processus tournent sous votre UID utilisateur
# SÃ©curitÃ© maximale
```

### 2. Secrets Management

**âŒ Mauvaise pratique : Mot de passe en clair**

```bash
docker run -e POSTGRES_PASSWORD=SuperSecret123 postgres:18
# Visible dans docker inspect, logs, historique
```

**âœ… Bonne pratique : Docker Secrets (Swarm)**

```bash
# CrÃ©er secret
echo "SuperSecret123" | docker secret create postgres_password -

# Utiliser dans service
docker service create \
  --name postgres18 \
  --secret postgres_password \
  -e POSTGRES_PASSWORD_FILE=/run/secrets/postgres_password \
  postgres:18
```

**âœ… Alternative : Fichier .env**

```bash
# .env (ne pas commiter !)
POSTGRES_PASSWORD=SuperSecret123

# docker-compose.yml
services:
  postgres:
    env_file: .env

# .gitignore
.env
```

**âœ… Avec gestionnaire secrets (Vault, AWS Secrets Manager)**

```yaml
services:
  postgres:
    environment:
      POSTGRES_PASSWORD: ${VAULT_POSTGRES_PASSWORD}
```

### 3. RÃ©seau IsolÃ©

```yaml
# docker-compose.yml
services:
  postgres:
    networks:
      - backend  # RÃ©seau privÃ©
    # Pas de ports: exposÃ©s publiquement

  app:
    networks:
      - backend   # AccÃ¨de PostgreSQL
      - frontend  # Accessible publiquement
    ports:
      - "443:443"

networks:
  backend:
    internal: true  # Pas d'accÃ¨s Internet
  frontend:
```

### 4. Capabilities Linux (RÃ©duction PrivilÃ¨ges)

```bash
docker run -d \
  --name postgres18 \
  --cap-drop ALL \              # Retire toutes capabilities
  --cap-add CHOWN \             # Ajoute seulement nÃ©cessaires
  --cap-add DAC_OVERRIDE \
  --cap-add SETGID \
  --cap-add SETUID \
  postgres:18
```

### 5. Read-Only Root Filesystem

```bash
docker run -d \
  --name postgres18 \
  --read-only \                           # Filesystem root en lecture seule
  --tmpfs /tmp:rw,noexec,nosuid,size=100m \  # tmpfs pour /tmp
  --tmpfs /run:rw,noexec,nosuid,size=100m \
  -v pgdata:/var/lib/postgresql/data:rw \     # Volume RW pour donnÃ©es
  postgres:18
```

**Avantages :**
- Protection contre modifications filesystem malveillantes
- Conteneur immuable
- ConformitÃ© sÃ©curitÃ© renforcÃ©e

### 6. Scanning d'Images (VulnÃ©rabilitÃ©s)

```bash
# Avec Trivy (scanner open source)
trivy image postgres:18

# Avec Snyk
snyk container test postgres:18

# Avec Docker Scout
docker scout cves postgres:18
```

**Exemple rÃ©sultat :**

```
postgres:18 (debian bookworm)
â”œâ”€ CRITICAL: 0
â”œâ”€ HIGH: 2
â”œâ”€ MEDIUM: 15
â””â”€ LOW: 48

Recommandation : Mettre Ã  jour vers postgres:18.1
```

### 7. Politiques AppArmor / SELinux

**AppArmor (Ubuntu/Debian) :**

```bash
# Profil AppArmor custom pour PostgreSQL
docker run -d \
  --security-opt apparmor=docker-postgresql \
  postgres:18
```

**SELinux (RHEL/Fedora) :**

```bash
# Avec contexte SELinux
docker run -d \
  --security-opt label=type:container_runtime_t \
  postgres:18
```

### Checklist SÃ©curitÃ©

```yaml
# docker-compose.yml sÃ©curisÃ©
services:
  postgres:
    image: postgres:18.1  # Version spÃ©cifique
    user: postgres        # Non-root
    read_only: true       # Filesystem RO
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - DAC_OVERRIDE
      - SETGID
      - SETUID
    security_opt:
      - no-new-privileges:true
    tmpfs:
      - /tmp
      - /run
    volumes:
      - pgdata:/var/lib/postgresql/data
    networks:
      - backend  # RÃ©seau privÃ©
    environment:
      POSTGRES_PASSWORD_FILE: /run/secrets/db_password
    secrets:
      - db_password
    deploy:
      resources:
        limits:
          memory: 4G

secrets:
  db_password:
    external: true

networks:
  backend:
    internal: true
```

---

## Haute DisponibilitÃ© et RÃ©plication

### PostgreSQL Standalone (Single Node)

```yaml
# Simple mais pas de HA
services:
  postgres:
    image: postgres:18
    volumes:
      - pgdata:/var/lib/postgresql/data
```

**Limitations :**
- âŒ SPOF (Single Point of Failure)
- âŒ Pas de tolÃ©rance panne
- âŒ Downtime pendant mises Ã  jour

### RÃ©plication Streaming (Primary-Standby)

**Architecture :**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    Streaming    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Primary        â”‚  Replication    â”‚   Standby        â”‚
â”‚  (Read/Write)    â”‚ â•â•â•â•â•â•â•â•â•â•â•â•>   â”‚  (Read-Only)     â”‚
â”‚  Container 1     â”‚                 â”‚  Container 2     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                                     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Shared Volume (WAL) â”€â”€â”€â”€â”€â”˜
```

**docker-compose.yml (rÃ©plication manuelle) :**

```yaml
version: '3.8'

services:
  postgres-primary:
    image: postgres:18
    container_name: postgres-primary
    environment:
      POSTGRES_PASSWORD: secret
      POSTGRES_USER: postgres
      POSTGRES_DB: production
      # Configuration rÃ©plication
      POSTGRES_INITDB_ARGS: "-c wal_level=replica -c max_wal_senders=5"
    volumes:
      - pgdata-primary:/var/lib/postgresql/data
      - ./setup-replication.sh:/docker-entrypoint-initdb.d/setup-replication.sh
    command: |
      postgres
      -c wal_level=replica
      -c max_wal_senders=5
      -c max_replication_slots=5
      -c hot_standby=on
    networks:
      - pg-network

  postgres-standby:
    image: postgres:18
    container_name: postgres-standby
    environment:
      POSTGRES_PASSWORD: secret
      PGDATA: /var/lib/postgresql/data
    volumes:
      - pgdata-standby:/var/lib/postgresql/data
    command: |
      bash -c "
      if [ ! -f /var/lib/postgresql/data/PG_VERSION ]; then
        pg_basebackup -h postgres-primary -D /var/lib/postgresql/data -U replication -Fp -Xs -R
      fi
      postgres
      "
    depends_on:
      - postgres-primary
    networks:
      - pg-network

networks:
  pg-network:

volumes:
  pgdata-primary:
  pgdata-standby:
```

**Configuration manuelle rÃ©plication (complexe) :**

```bash
# Sur primary : CrÃ©er utilisateur rÃ©plication
docker exec -it postgres-primary psql -U postgres -c \
  "CREATE USER replication WITH REPLICATION PASSWORD 'repl_pass';"

# Configurer pg_hba.conf primary
docker exec -it postgres-primary bash -c \
  "echo 'host replication replication 0.0.0.0/0 scram-sha-256' >> /var/lib/postgresql/data/pg_hba.conf"

# Reload
docker exec -it postgres-primary psql -U postgres -c "SELECT pg_reload_conf();"

# Sur standby : pg_basebackup
docker exec -it postgres-standby bash -c \
  "pg_basebackup -h postgres-primary -D /var/lib/postgresql/data -U replication -Fp -Xs -R"
```

**âš ï¸ ComplexitÃ© :** Configuration manuelle, gestion failover compliquÃ©e.

### Solution AutomatisÃ©e : Patroni

**Patroni** = Solution HA automatisÃ©e pour PostgreSQL avec :
- Auto-failover
- DÃ©tection panne automatique
- Promotion standby automatique
- Consensus distribuÃ© (etcd, Consul, ZooKeeper)

**Architecture Patroni :**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Patroni 1  â”‚  â”‚  Patroni 2  â”‚  â”‚  Patroni 3  â”‚
â”‚  + PG (P)   â”‚  â”‚  + PG (S)   â”‚  â”‚  + PG (S)   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                â”‚                â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                 â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
                 â”‚    etcd     â”‚  â† Consensus
                 â”‚  (Cluster)  â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                 â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
                 â”‚   HAProxy   â”‚  â† Load Balancer
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**docker-compose.yml avec Patroni :**

```yaml
version: '3.8'

services:
  # ===== ETCD (Consensus) =====
  etcd:
    image: quay.io/coreos/etcd:v3.5
    environment:
      ETCD_LISTEN_CLIENT_URLS: http://0.0.0.0:2379
      ETCD_ADVERTISE_CLIENT_URLS: http://etcd:2379
    networks:
      - pg-ha

  # ===== Patroni Node 1 (Initial Primary) =====
  patroni1:
    image: patroni/patroni:latest
    hostname: patroni1
    environment:
      PATRONI_NAME: patroni1
      PATRONI_SCOPE: pg-cluster
      PATRONI_ETCD3_HOSTS: "'etcd:2379'"
      PATRONI_RESTAPI_CONNECT_ADDRESS: patroni1:8008
      PATRONI_POSTGRESQL_CONNECT_ADDRESS: patroni1:5432
      PATRONI_POSTGRESQL_DATA_DIR: /var/lib/postgresql/data
      PATRONI_POSTGRESQL_PGPASS: /tmp/pgpass
      PATRONI_SUPERUSER_USERNAME: postgres
      PATRONI_SUPERUSER_PASSWORD: postgres
      PATRONI_REPLICATION_USERNAME: replicator
      PATRONI_REPLICATION_PASSWORD: replicator
    volumes:
      - pgdata1:/var/lib/postgresql/data
    networks:
      - pg-ha
    depends_on:
      - etcd

  # ===== Patroni Node 2 (Standby) =====
  patroni2:
    image: patroni/patroni:latest
    hostname: patroni2
    environment:
      PATRONI_NAME: patroni2
      PATRONI_SCOPE: pg-cluster
      PATRONI_ETCD3_HOSTS: "'etcd:2379'"
      PATRONI_RESTAPI_CONNECT_ADDRESS: patroni2:8008
      PATRONI_POSTGRESQL_CONNECT_ADDRESS: patroni2:5432
      PATRONI_POSTGRESQL_DATA_DIR: /var/lib/postgresql/data
      PATRONI_SUPERUSER_USERNAME: postgres
      PATRONI_SUPERUSER_PASSWORD: postgres
      PATRONI_REPLICATION_USERNAME: replicator
      PATRONI_REPLICATION_PASSWORD: replicator
    volumes:
      - pgdata2:/var/lib/postgresql/data
    networks:
      - pg-ha
    depends_on:
      - etcd

  # ===== HAProxy (Load Balancer) =====
  haproxy:
    image: haproxy:latest
    ports:
      - "5432:5432"  # Primary
      - "5433:5433"  # Standbys (read-only)
      - "7000:7000"  # Stats
    volumes:
      - ./haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg
    networks:
      - pg-ha
    depends_on:
      - patroni1
      - patroni2

networks:
  pg-ha:

volumes:
  pgdata1:
  pgdata2:
```

**haproxy.cfg :**

```
global
    maxconn 100

defaults
    mode tcp
    timeout connect 5s
    timeout client 30s
    timeout server 30s

# Primary (Read/Write)
listen primary
    bind *:5432
    option httpchk
    http-check expect status 200
    default-server inter 3s fall 3 rise 2
    server patroni1 patroni1:5432 check port 8008
    server patroni2 patroni2:5432 check port 8008 backup

# Standbys (Read-Only)
listen standbys
    bind *:5433
    balance roundrobin
    option httpchk
    http-check expect status 200
    default-server inter 3s fall 3 rise 2
    server patroni1 patroni1:5432 check port 8008
    server patroni2 patroni2:5432 check port 8008

# Stats
listen stats
    bind *:7000
    stats enable
    stats uri /
```

**Fonctionnement Patroni :**

1. **Ã‰tat normal :**
   - patroni1 = Primary (Read/Write)
   - patroni2 = Standby (Read-Only)
   - HAProxy route Ã©critures vers Primary

2. **Panne Primary :**
   - Patroni dÃ©tecte panne via etcd
   - Promotion automatique patroni2 â†’ Primary
   - HAProxy redirige traffic automatiquement
   - **Downtime : 10-30 secondes**

3. **RÃ©cupÃ©ration ancien Primary :**
   - RedÃ©marre automatiquement en Standby
   - Replication reprend

---

## Production : Best Practices

### 1. Logging et Monitoring

**Configuration logs :**

```yaml
services:
  postgres:
    image: postgres:18
    command: |
      postgres
      -c log_statement=all
      -c log_min_duration_statement=1000
      -c log_connections=on
      -c log_disconnections=on
      -c log_line_prefix='%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
    volumes:
      - pgdata:/var/lib/postgresql/data
      - ./logs:/var/log/postgresql
```

**Exporter logs vers systÃ¨me centralisÃ© :**

```yaml
services:
  postgres:
    logging:
      driver: "json-file"
      options:
        max-size: "100m"
        max-file: "3"
    # Ou vers syslog, fluentd, etc.
```

**Monitoring avec Prometheus :**

```yaml
services:
  postgres:
    image: postgres:18
    # ... config ...

  postgres-exporter:
    image: prometheuscommunity/postgres-exporter:latest
    environment:
      DATA_SOURCE_NAME: "postgresql://postgres:secret@postgres:5432/postgres?sslmode=disable"
    ports:
      - "9187:9187"
    depends_on:
      - postgres
```

### 2. Health Checks

```yaml
services:
  postgres:
    image: postgres:18
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
```

**Health check avancÃ© :**

```yaml
healthcheck:
  test: |
    pg_isready -U postgres && \
    psql -U postgres -c "SELECT 1" > /dev/null 2>&1
  interval: 10s
  timeout: 5s
  retries: 3
```

### 3. Backups AutomatisÃ©s

**Script backup avec cron :**

```yaml
services:
  postgres:
    # ... config ...

  postgres-backup:
    image: postgres:18
    environment:
      POSTGRES_HOST: postgres
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: secret
      BACKUP_SCHEDULE: "0 2 * * *"  # 2h du matin
    volumes:
      - ./backups:/backups
      - ./backup-script.sh:/backup-script.sh
    command: crond -f
```

**backup-script.sh :**

```bash
#!/bin/bash
DATE=$(date +%Y%m%d_%H%M%S)
pg_dump -h postgres -U postgres -Fc production > /backups/backup_${DATE}.dump

# Rotation (garder 7 jours)
find /backups -name "backup_*.dump" -mtime +7 -delete
```

**Avec extension pg_basebackup :**

```bash
docker exec postgres-primary pg_basebackup \
  -D /backups/base_$(date +%Y%m%d) \
  -Ft -z -Xs -P
```

### 4. Mises Ã  Jour (Upgrades)

**StratÃ©gie Blue/Green :**

```yaml
# docker-compose.blue.yml (Version actuelle)
services:
  postgres:
    image: postgres:17  # Ancienne version
    container_name: postgres-blue
    ports:
      - "5432:5432"

# docker-compose.green.yml (Nouvelle version)
services:
  postgres:
    image: postgres:18  # Nouvelle version
    container_name: postgres-green
    ports:
      - "5433:5432"  # Port diffÃ©rent
```

**ProcÃ©dure upgrade :**

```bash
# 1. DÃ©marrer green (PG 18) sur port 5433
docker-compose -f docker-compose.green.yml up -d

# 2. Restore backup dans green
docker exec postgres-green psql -U postgres < backup.sql

# 3. Tester green
psql -h localhost -p 5433 -U postgres

# 4. Basculer traffic (HAProxy ou DNS)
# ...

# 5. ArrÃªter blue si OK
docker-compose -f docker-compose.blue.yml down
```

### 5. Resource Limits Production

```yaml
services:
  postgres:
    image: postgres:18
    deploy:
      resources:
        limits:
          cpus: '8'
          memory: 16G
        reservations:
          cpus: '4'
          memory: 8G
    ulimits:
      nofile:
        soft: 65536
        hard: 65536
      nproc:
        soft: 65536
        hard: 65536
```

---

## Troubleshooting Conteneurs

### ProblÃ¨me 1 : Conteneur ne DÃ©marre Pas

**SymptÃ´me :**

```bash
docker ps -a
# STATUS: Exited (1) 5 seconds ago
```

**Diagnostic :**

```bash
# Voir les logs
docker logs postgres18

# Erreur typique :
# ERROR: database files are incompatible with server
```

**Solutions courantes :**

```bash
# 1. Volume avec mauvaise version PostgreSQL
# â†’ Supprimer volume et recrÃ©er
docker volume rm pgdata
docker run -d --name postgres18 -v pgdata:/var/lib/postgresql/data postgres:18

# 2. Permissions volume incorrectes
docker run --rm -v pgdata:/data busybox chown -R 999:999 /data

# 3. Mot de passe manquant
docker run -e POSTGRES_PASSWORD=secret postgres:18
```

### ProblÃ¨me 2 : Performances DÃ©gradÃ©es

**Diagnostic :**

```bash
# CPU/RAM utilisÃ©s
docker stats postgres18

# I/O en temps rÃ©el
docker exec postgres18 iostat -x 1

# Connexions actives
docker exec postgres18 psql -U postgres -c \
  "SELECT count(*) FROM pg_stat_activity WHERE state = 'active';"
```

**Causes frÃ©quentes :**

1. **Shared buffers trop bas :**
   ```bash
   # Augmenter
   docker run -e POSTGRES_SHARED_BUFFERS=2GB postgres:18
   ```

2. **Limitation CPU :**
   ```bash
   # VÃ©rifier limites
   docker inspect postgres18 | grep -i cpu

   # Augmenter
   docker update --cpus="4" postgres18
   ```

3. **Volume I/O lent :**
   ```bash
   # Tester vitesse volume
   docker run --rm -v pgdata:/data ubuntu \
     dd if=/dev/zero of=/data/test bs=1M count=1000 oflag=direct
   ```

### ProblÃ¨me 3 : Out of Memory (OOM)

**SymptÃ´me :**

```bash
docker logs postgres18
# ... killed by OOM killer
```

**Solutions :**

```bash
# 1. Augmenter limite mÃ©moire
docker run --memory="8g" postgres:18

# 2. Adapter shared_buffers
# RÃ¨gle : shared_buffers < 25% de RAM conteneur
docker run --memory="4g" \
  postgres:18 \
  postgres -c shared_buffers=1GB

# 3. RÃ©duire work_mem si beaucoup de connexions
postgres -c work_mem=16MB
```

### ProblÃ¨me 4 : Cannot Connect from Host

**SymptÃ´me :**

```bash
psql -h localhost -p 5432 -U postgres
# connection refused
```

**Diagnostic :**

```bash
# 1. Conteneur tourne-t-il ?
docker ps | grep postgres

# 2. Port bien mappÃ© ?
docker port postgres18

# 3. PostgreSQL Ã©coute sur bonne interface ?
docker exec postgres18 netstat -tlnp | grep 5432

# 4. Firewall hÃ´te ?
sudo ufw status
```

**Solutions :**

```bash
# VÃ©rifier pg_hba.conf
docker exec postgres18 cat /var/lib/postgresql/data/pg_hba.conf
# Doit contenir : host all all 0.0.0.0/0 scram-sha-256

# VÃ©rifier listen_addresses
docker exec postgres18 psql -U postgres -c "SHOW listen_addresses;"
# Doit Ãªtre '*' ou '0.0.0.0'
```

---

## Comparaison : Bare Metal vs VM vs Conteneurs

### Tableau RÃ©capitulatif

| CritÃ¨re | Bare Metal | VM | Conteneurs |
|---------|-----------|-----|-----------|
| **Performance** | â­â­â­â­â­ 100% | â­â­â­â­ 90-95% | â­â­â­â­ 95-98% |
| **Overhead** | 0% | 5-10% | 2-5% |
| **DÃ©marrage** | Minutes | 30-60s | 1-5s |
| **Taille** | N/A | 2-20 GB | 50-500 MB |
| **DensitÃ©** | 1 serveur | 10-20/hÃ´te | 50-1000+/hÃ´te |
| **Isolation** | Totale | Forte | Moyenne |
| **PortabilitÃ©** | Faible | Moyenne | â­â­â­â­â­ Excellente |
| **CoÃ»t initial** | â‚¬â‚¬â‚¬â‚¬â‚¬ | â‚¬â‚¬â‚¬â‚¬ | â‚¬â‚¬ |
| **ComplexitÃ©** | Ã‰levÃ©e | Moyenne | Faible-Moyenne |
| **HA** | Manuelle | Automatisable | Automatisable |
| **Mises Ã  jour** | Complexes | Moyennes | Simples |
| **Backup** | Complexe | Snapshots | Volumes |

### Cas d'Usage RecommandÃ©s

**Bare Metal :**
- Trading haute frÃ©quence
- Latence critique < 1ms
- ConformitÃ© interdisant virtualisation
- Infrastructure < 3 serveurs

**VMs :**
- Infrastructure 5-100 serveurs
- Besoin Live Migration
- Charges stables longue durÃ©e
- Isolation forte requise

**Conteneurs :**
- âœ… Microservices / Architecture moderne
- âœ… CI/CD / Environnements Ã©phÃ©mÃ¨res
- âœ… DÃ©veloppement local
- âœ… Cloud-native applications
- âœ… DÃ©ploiements frÃ©quents
- âœ… Infrastructure as Code

### ScÃ©narios Hybrides

**1. VMs + Conteneurs (RecommandÃ© Production) :**

```
Infrastructure
â”œâ”€ Serveurs Physiques (3Ã—)
â”‚   â””â”€ Hyperviseur (Proxmox/VMware)
â”‚       â”œâ”€ VM 1 : Kubernetes Node 1
â”‚       â”‚   â””â”€ PostgreSQL Containers (Patroni)
â”‚       â”œâ”€ VM 2 : Kubernetes Node 2
â”‚       â”‚   â””â”€ PostgreSQL Containers (Patroni)
â”‚       â””â”€ VM 3 : Kubernetes Node 3
â”‚           â””â”€ PostgreSQL Containers (Patroni)

Avantages :
âœ… Isolation VM + FlexibilitÃ© Conteneurs
âœ… Live Migration VMs
âœ… Orchestration Kubernetes
```

**2. Bare Metal + Conteneurs (Performance Maximale) :**

```
Serveurs Bare Metal (2Ã—)
â”œâ”€ Server 1 : Docker/Podman
â”‚   â””â”€ PostgreSQL Primary Container
â””â”€ Server 2 : Docker/Podman
    â””â”€ PostgreSQL Standby Container

Usage : Bases critiques haute performance
```

---

## Podman : DiffÃ©rences et Avantages

### Commandes Ã‰quivalentes

```bash
# Docker â†’ Podman (alias possible)
alias docker=podman

# Identiques
docker run â†’ podman run
docker ps â†’ podman ps
docker images â†’ podman images
docker build â†’ podman build
```

### FonctionnalitÃ©s Uniques Podman

#### 1. Pods (comme Kubernetes)

```bash
# CrÃ©er pod (groupe de conteneurs partageant rÃ©seau)
podman pod create --name pg-pod -p 5432:5432

# Lancer PostgreSQL dans pod
podman run -d \
  --pod pg-pod \
  --name postgres \
  -e POSTGRES_PASSWORD=secret \
  postgres:18

# Lancer pgAdmin dans mÃªme pod
podman run -d \
  --pod pg-pod \
  --name pgadmin \
  dpage/pgadmin4

# Avantage : Partage localhost, comme sur Kubernetes
```

#### 2. Rootless Containers (SÃ©curitÃ©)

```bash
# En tant qu'utilisateur normal (pas root)
podman run -d \
  --name postgres18 \
  -e POSTGRES_PASSWORD=secret \
  -v pgdata:/var/lib/postgresql/data \
  postgres:18

# Processus sous votre UID
ps aux | grep postgres
# user 1000 ...
```

**SÃ©curitÃ© :**
- Pas de daemon root
- User namespaces
- Isolation renforcÃ©e

#### 3. GÃ©nÃ©ration Systemd

```bash
# GÃ©nÃ©rer service systemd depuis conteneur
podman generate systemd --new --name postgres18 > postgres.service

# Installer service
sudo cp postgres.service /etc/systemd/system/
sudo systemctl enable postgres
sudo systemctl start postgres

# Gestion comme service natif
sudo systemctl status postgres
```

#### 4. Compatible Kubernetes

```bash
# GÃ©nÃ©rer YAML Kubernetes depuis pod
podman generate kube pg-pod > postgres-k8s.yaml

# DÃ©ployer sur Kubernetes
kubectl apply -f postgres-k8s.yaml
```

---

## Conclusion : Quand Utiliser les Conteneurs ?

### Conteneurs : Le Choix Optimal Pour

âœ… **DÃ©veloppement Local**
- Setup en secondes
- Environnement reproductible
- Isolation des projets
- Versions PostgreSQL multiples

âœ… **CI/CD (Tests AutomatisÃ©s)**
- Tests d'intÃ©gration rapides
- Environnements Ã©phÃ©mÃ¨res
- ParallÃ©lisation facile
- Nettoyage automatique

âœ… **Microservices**
- DÃ©ploiement indÃ©pendant
- Scaling horizontal
- Updates sans downtime (rolling)
- Service discovery natif

âœ… **Cloud-Native Applications**
- PortabilitÃ© multi-cloud
- Infrastructure as Code
- Auto-scaling
- IntÃ©gration Kubernetes

âœ… **Prototypage et POC**
- DÃ©marrage instantanÃ©
- CoÃ»t minimal
- FlexibilitÃ© maximale

### Ã‰viter les Conteneurs Si

âŒ **DonnÃ©es critiques sans HA robuste**
- Conteneur = Ã‰phÃ©mÃ¨re par nature
- NÃ©cessite orchestration (Kubernetes, Patroni)
- Sinon, prÃ©fÃ©rer VM avec rÃ©plication native

âŒ **Performance absolue requise**
- Trading ultra haute frÃ©quence
- Latence sub-milliseconde
- Bare metal reste optimal

âŒ **Ã‰quipe sans expertise conteneurs**
- Courbe d'apprentissage
- PrÃ©fÃ©rer VM si dÃ©jÃ  maÃ®trisÃ©

âŒ **RÃ©glementations interdisant conteneurs**
- Certifications spÃ©cifiques
- Secteurs conservateurs (finance, santÃ©)

### Points ClÃ©s Ã  Retenir

1. **Conteneurs â‰  Moins SÃ©curisÃ©s** : Bien configurÃ©s (rootless, read-only, secrets), ils sont trÃ¨s sÃ»rs.

2. **Volumes = Critical** : Toujours utiliser named volumes en production, jamais de stockage Ã©phÃ©mÃ¨re.

3. **Orchestration Requise Production** : Docker Compose pour dev, Kubernetes/Patroni pour production.

4. **Performance ~95-98%** : Overhead nÃ©gligeable pour la majoritÃ© des cas d'usage.

5. **Podman > Docker en Production Linux** : SÃ©curitÃ© supÃ©rieure, architecture daemonless.

6. **PostgreSQL 18 compatible** : AmÃ©liorations I/O async bÃ©nÃ©ficient mÃªme en conteneur.

**Recommandation finale :**

```
DÃ©veloppement :
â””â”€ Docker Desktop (Windows/macOS) ou Podman (Linux)

Staging :
â””â”€ Docker Compose ou Kubernetes (petite Ã©chelle)

Production :
â”œâ”€ Small-Medium : Podman + Systemd ou Patroni
â””â”€ Large : Kubernetes avec Operators (CloudNativePG, Zalando)
```

Les conteneurs sont l'avenir du dÃ©ploiement PostgreSQL pour 80% des cas d'usage. Ils combinent flexibilitÃ©, portabilitÃ© et performance dans un package simple et moderne.

---

**Prochaines Ã©tapes suggÃ©rÃ©es :**
- 19.1.4. Kubernetes (StatefulSets, Operators)
- 20. Drivers, Connexion Applicative et Bonnes Pratiques
- 18. Extensions et IntÃ©grations

---


â­ï¸ [Kubernetes (StatefulSets, Operators : Zalando, CloudNativePG)](/19-postgresql-en-production/01.4-kubernetes.md)
