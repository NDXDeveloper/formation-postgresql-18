ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 19.3.3. NouveautÃ© PG 18 : VÃ©rifications parallÃ¨les (--jobs)

## Introduction

L'une des amÃ©liorations les plus apprÃ©ciÃ©es de PostgreSQL 18 dans `pg_upgrade` concerne l'option `--jobs` qui permet dÃ©sormais d'effectuer les **vÃ©rifications en parallÃ¨le**. Cette fonctionnalitÃ© rÃ©duit considÃ©rablement le temps nÃ©cessaire pour valider qu'une migration est possible, particuliÃ¨rement sur les bases de donnÃ©es volumineuses avec de nombreux objets.

## Comprendre la parallÃ©lisation

### Qu'est-ce que la parallÃ©lisation ?

La parallÃ©lisation consiste Ã  exÃ©cuter plusieurs tÃ¢ches **simultanÃ©ment** au lieu de les traiter une par une (sÃ©quentiellement).

#### Analogie simple : La chaÃ®ne de montage

**Mode sÃ©quentiel (sans parallÃ©lisation)** :

```
Un seul ouvrier assemble toute une voiture, puis passe Ã  la suivante :

Ouvrier 1:  [Voiture A] â†’ [Voiture B] â†’ [Voiture C]
            (2 heures)   (2 heures)   (2 heures)

Temps total : 6 heures pour 3 voitures
```

**Mode parallÃ¨le (avec parallÃ©lisation)** :

```
Trois ouvriers travaillent en mÃªme temps sur diffÃ©rentes voitures :

Ouvrier 1:  [Voiture A]
Ouvrier 2:  [Voiture B]    â† En mÃªme temps !
Ouvrier 3:  [Voiture C]
            (2 heures chacun)

Temps total : 2 heures pour 3 voitures
```

#### Application Ã  PostgreSQL

Dans le contexte de `pg_upgrade`, au lieu de vÃ©rifier les tables une par une, on peut en vÃ©rifier plusieurs simultanÃ©ment.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Mode sÃ©quentiel (1 job)                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  Worker 1:  [Table A] â†’ [Table B] â†’ [Table C] â†’ [Table D]   â”‚
â”‚             (10 min)   (10 min)   (10 min)   (10 min)       â”‚
â”‚                                                             â”‚
â”‚  Temps total : 40 minutes                                   â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Mode parallÃ¨le (4 jobs)                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  Worker 1:  [Table A]                                       â”‚
â”‚  Worker 2:  [Table B]    â† Tous en mÃªme temps !             â”‚
â”‚  Worker 3:  [Table C]                                       â”‚
â”‚  Worker 4:  [Table D]                                       â”‚
â”‚             (10 min chacun)                                 â”‚
â”‚                                                             â”‚
â”‚  Temps total : 10 minutes (4Ã— plus rapide !)                â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Concepts clÃ©s

#### 1. CPU Cores (CÅ“urs de processeur)

Votre serveur possÃ¨de plusieurs **cÅ“urs de processeur** (CPU cores) qui peuvent travailler indÃ©pendamment :

```bash
# Voir le nombre de CPU cores disponibles
lscpu | grep "^CPU(s):"
# CPU(s):              16

# Ou plus simplement
nproc
# 16
```

Un serveur avec 16 cores peut thÃ©oriquement exÃ©cuter 16 tÃ¢ches en mÃªme temps.

#### 2. Workers (Processus de travail)

Un **worker** est un processus qui effectue une partie du travail. Avec `--jobs=4`, pg_upgrade lance 4 workers qui travaillent en parallÃ¨le.

#### 3. Overhead (Surcharge)

La parallÃ©lisation n'est pas gratuite :
- Chaque worker consomme de la **mÃ©moire**
- Chaque worker peut gÃ©nÃ©rer des **I/O disque** concurrentes
- Il y a un coÃ»t de **coordination** entre les workers

Donc, plus de jobs n'est pas toujours mieux !

## L'option --jobs dans pg_upgrade

### Historique

#### Avant PostgreSQL 18

L'option `--jobs` existait dÃ©jÃ  dans les versions prÃ©cÃ©dentes de PostgreSQL, mais son utilisation Ã©tait **limitÃ©e** :

```
PostgreSQL â‰¤ 17 :
- --jobs fonctionnait pour la MIGRATION des donnÃ©es
- Mais PAS pour les VÃ‰RIFICATIONS (--check)
- La phase --check restait sÃ©quentielle, donc lente
```

**ProblÃ¨me** : Sur une base avec 10,000 tables, la phase `--check` pouvait prendre plusieurs heures, mÃªme sur un serveur puissant avec 32 cores.

#### NouveautÃ© PostgreSQL 18

```
PostgreSQL 18 :
âœ… --jobs fonctionne pour la MIGRATION (comme avant)
âœ… --jobs fonctionne aussi pour les VÃ‰RIFICATIONS (--check) â† NOUVEAU !
âœ… AccÃ©lÃ©ration drastique de la phase de validation
```

### Syntaxe et utilisation

#### Commande de base avec --jobs

```bash
pg_upgrade \
  --old-datadir=/var/lib/postgresql/17/main \
  --new-datadir=/var/lib/postgresql/18/main \
  --old-bindir=/usr/lib/postgresql/17/bin \
  --new-bindir=/usr/lib/postgresql/18/bin \
  --jobs=4  # â† 4 workers en parallÃ¨le
```

#### Avec --check (vÃ©rification)

```bash
# VÃ©rification avec 4 workers parallÃ¨les
pg_upgrade \
  --old-datadir=/var/lib/postgresql/17/main \
  --new-datadir=/var/lib/postgresql/18/main \
  --old-bindir=/usr/lib/postgresql/17/bin \
  --new-bindir=/usr/lib/postgresql/18/bin \
  --jobs=4 \
  --check  # â† Nouveau dans PG 18 : parallÃ©lisÃ© !
```

#### Combinaison avec --swap

```bash
# Migration complÃ¨te avec parallÃ©lisation et swap
pg_upgrade \
  --old-datadir=/var/lib/postgresql/17/main \
  --new-datadir=/var/lib/postgresql/18/main \
  --old-bindir=/usr/lib/postgresql/17/bin \
  --new-bindir=/usr/lib/postgresql/18/bin \
  --jobs=8 \
  --swap
```

### Comment choisir le nombre de jobs ?

#### RÃ¨gle gÃ©nÃ©rale

```
Nombre de jobs optimal â‰ˆ 50-75% du nombre de CPU cores

Exemples :
- Serveur 4 cores  â†’ --jobs=2 ou 3
- Serveur 8 cores  â†’ --jobs=4 Ã  6
- Serveur 16 cores â†’ --jobs=8 Ã  12
- Serveur 32 cores â†’ --jobs=16 Ã  24
```

**Pourquoi pas 100% ?** :
- Laisser des ressources pour le systÃ¨me d'exploitation
- Laisser des ressources pour les opÃ©rations I/O
- Ã‰viter la contention (compÃ©tition) entre workers

#### Facteurs Ã  considÃ©rer

**1. CPU disponibles**

```bash
# VÃ©rifier les CPU disponibles
nproc
# 16

# Recommandation : --jobs=8 ou --jobs=12
```

**2. MÃ©moire disponible**

Chaque worker consomme de la mÃ©moire. Formule approximative :

```
MÃ©moire par worker â‰ˆ 100-500 MB
(selon la complexitÃ© de la base)

Exemple :
- 8 workers Ã— 200 MB = 1.6 GB de RAM nÃ©cessaire
- VÃ©rifier la RAM disponible avant de dÃ©finir --jobs
```

```bash
# VÃ©rifier la RAM disponible
free -h
#               total        used        free
# Mem:           62Gi        15Gi        45Gi  â† Largement suffisant

# Si free < 4 GB, limiter le nombre de jobs
```

**3. Type de stockage**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Impact du stockage sur --jobs                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  HDD (disque mÃ©canique) :                                   â”‚
â”‚  â†’ --jobs=2 Ã  4 maximum                                     â”‚
â”‚  â†’ Trop de parallÃ©lisme = contention I/O                    â”‚
â”‚  â†’ Les tÃªtes de lecture se dÃ©placent beaucoup               â”‚
â”‚                                                             â”‚
â”‚  SSD SATA :                                                 â”‚
â”‚  â†’ --jobs=4 Ã  8                                             â”‚
â”‚  â†’ Bon compromis pour la plupart des cas                    â”‚
â”‚                                                             â”‚
â”‚  NVMe SSD :                                                 â”‚
â”‚  â†’ --jobs=8 Ã  16+                                           â”‚
â”‚  â†’ Peut gÃ©rer beaucoup de parallÃ©lisme                      â”‚
â”‚  â†’ Latence ultra-faible                                     â”‚
â”‚                                                             â”‚
â”‚  Stockage rÃ©seau (NFS, SAN) :                               â”‚
â”‚  â†’ DÃ©pend de la configuration rÃ©seau                        â”‚
â”‚  â†’ Tester avec --check d'abord                              â”‚
â”‚  â†’ GÃ©nÃ©ralement --jobs=4 Ã  8                                â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**4. Nombre de tables et index**

```
Base avec beaucoup d'objets :
- 10,000+ tables â†’ --jobs Ã©levÃ© bÃ©nÃ©fique (--jobs=8 Ã  16)
- 100 tables grosses â†’ --jobs modÃ©rÃ© suffisant (--jobs=4)

Raison : Plus il y a d'objets indÃ©pendants, plus on peut parallÃ©liser
```

#### Tableau de recommandations

| Serveur | CPU | RAM | Stockage | --jobs recommandÃ© |
|---------|-----|-----|----------|-------------------|
| Petit VPS | 2-4 cores | 4-8 GB | SSD | 2 |
| Serveur moyen | 8 cores | 16-32 GB | SSD | 4-6 |
| Serveur standard | 16 cores | 64 GB | NVMe | 8-12 |
| Serveur puissant | 32+ cores | 128+ GB | NVMe RAID | 16-24 |
| Cloud (AWS/Azure) | Variables | Variables | EBS/Premium | 4-8 |

## Impact sur les performances

### Gains de temps avec --jobs

#### ScÃ©nario 1 : Base moyenne (500 GB, 2,000 tables)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase --check (vÃ©rification avant migration)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  PostgreSQL 17 (--jobs=1 forcÃ© pour --check)  :             â”‚
â”‚  DurÃ©e : 45 minutes                                         â”‚
â”‚                                                             â”‚
â”‚  PostgreSQL 18 avec --jobs=1 :                              â”‚
â”‚  DurÃ©e : 45 minutes (identique)                             â”‚
â”‚                                                             â”‚
â”‚  PostgreSQL 18 avec --jobs=4 :                              â”‚
â”‚  DurÃ©e : 12 minutes (3.75Ã— plus rapide)                     â”‚
â”‚                                                             â”‚
â”‚  PostgreSQL 18 avec --jobs=8 :                              â”‚
â”‚  DurÃ©e : 7 minutes (6.4Ã— plus rapide)                       â”‚
â”‚                                                             â”‚
â”‚  PostgreSQL 18 avec --jobs=16 :                             â”‚
â”‚  DurÃ©e : 5 minutes (9Ã— plus rapide)                         â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Gain** : 40 minutes Ã©conomisÃ©es sur la vÃ©rification !

#### ScÃ©nario 2 : Grosse base (5 TB, 10,000 tables)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase --check (vÃ©rification avant migration)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  PostgreSQL 17 (--jobs=1 forcÃ©) :                           â”‚
â”‚  DurÃ©e : 4 heures 30 minutes                                â”‚
â”‚                                                             â”‚
â”‚  PostgreSQL 18 avec --jobs=4 :                              â”‚
â”‚  DurÃ©e : 1 heure 15 minutes (3.6Ã— plus rapide)              â”‚
â”‚                                                             â”‚
â”‚  PostgreSQL 18 avec --jobs=8 :                              â”‚
â”‚  DurÃ©e : 40 minutes (6.75Ã— plus rapide)                     â”‚
â”‚                                                             â”‚
â”‚  PostgreSQL 18 avec --jobs=16 :                             â”‚
â”‚  DurÃ©e : 25 minutes (10.8Ã— plus rapide)                     â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Gain** : Plus de 4 heures Ã©conomisÃ©es !

#### ScÃ©nario 3 : TrÃ¨s grosse base (20 TB, 50,000 tables)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase --check (vÃ©rification avant migration)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  PostgreSQL 17 (--jobs=1) :                                 â”‚
â”‚  DurÃ©e : 18 heures                                          â”‚
â”‚  Commentaire : Inacceptable en production !                 â”‚
â”‚                                                             â”‚
â”‚  PostgreSQL 18 avec --jobs=8 :                              â”‚
â”‚  DurÃ©e : 2 heures 30 minutes                                â”‚
â”‚                                                             â”‚
â”‚  PostgreSQL 18 avec --jobs=16 :                             â”‚
â”‚  DurÃ©e : 1 heure 20 minutes                                 â”‚
â”‚                                                             â”‚
â”‚  PostgreSQL 18 avec --jobs=24 :                             â”‚
â”‚  DurÃ©e : 55 minutes                                         â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Gain** : Plus de 17 heures Ã©conomisÃ©es !

### Graphique de performance

```
Temps de vÃ©rification --check (base 5 TB, 10,000 tables)

5h â”¤
   â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
   â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  PG 17 (jobs=1)
4h â”¤ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
   â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
   â”‚
3h â”¤
   â”‚
2h â”¤
   â”‚
   â”‚ â–ˆâ–ˆâ–ˆâ–ˆ
1h â”¤ â–ˆâ–ˆâ–ˆâ–ˆ  PG 18 (jobs=4)
   â”‚ â–ˆâ–ˆ
   â”‚ â–ˆâ–ˆ  PG 18 (jobs=8)
   â”‚ â–ˆ
   â”‚ â–ˆ PG 18 (jobs=16)
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     PG17  j=4  j=8  j=16
```

### Loi des rendements dÃ©croissants

Plus on ajoute de workers, moins le gain est proportionnel :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Rendements dÃ©croissants avec --jobs                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  1 â†’ 2 jobs  : Gain de 90% (presque 2Ã— plus rapide)         â”‚
â”‚  2 â†’ 4 jobs  : Gain de 80% (1.8Ã— plus rapide)               â”‚
â”‚  4 â†’ 8 jobs  : Gain de 60% (1.6Ã— plus rapide)               â”‚
â”‚  8 â†’ 16 jobs : Gain de 40% (1.4Ã— plus rapide)               â”‚
â”‚  16 â†’ 32 jobs: Gain de 20% (1.2Ã— plus rapide)               â”‚
â”‚                                                             â”‚
â”‚  Raison : Overhead, contention, limites I/O                 â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Conclusion** : Il existe un **point optimal** au-delÃ  duquel ajouter des jobs n'aide plus vraiment.

## Que vÃ©rifie pg_upgrade --check ?

Comprendre ce qui est vÃ©rifiÃ© aide Ã  comprendre pourquoi la parallÃ©lisation est si efficace.

### Liste des vÃ©rifications

#### 1. VÃ©rifications globales (non parallÃ©lisables)

Ces vÃ©rifications sont exÃ©cutÃ©es une seule fois :

```
âœ… Checking cluster versions
âœ… Checking database user is the install user
âœ… Checking database connection settings
âœ… Checking for prepared transactions
âœ… Checking for system-defined composite types in user tables
```

**Temps** : Quelques secondes Ã  quelques minutes, peu importe --jobs

#### 2. VÃ©rifications par base de donnÃ©es (partiellement parallÃ©lisables)

```
âœ… Checking for presence of required libraries
âœ… Checking database user is the install user
âœ… Checking for prepared transactions
```

**Temps avec --jobs=1** : Proportionnel au nombre de databases
**Temps avec --jobs=4** : DivisÃ© par ~3-4

#### 3. VÃ©rifications par table/index (fortement parallÃ©lisables) â† IMPACT MAJEUR

```
âœ… Checking for reg* data types in user tables
âœ… Checking for contrib/isn with bigint-passing mismatch
âœ… Checking for user-defined encoding conversions
âœ… Checking for user-defined postfix operators
âœ… Checking for incompatible polymorphic functions
âœ… Checking for tables WITH OIDS
âœ… Checking for invalid "sql_identifier" user columns
âœ… Checking for extension updates
```

**C'est ici que --jobs fait toute la diffÃ©rence !**

Avec 10,000 tables :
- `--jobs=1` : VÃ©rifie 1 table Ã  la fois â†’ 10,000 Ã©tapes sÃ©quentielles
- `--jobs=16` : VÃ©rifie 16 tables simultanÃ©ment â†’ ~625 Ã©tapes

### Exemple de vÃ©rification dÃ©taillÃ©e

#### Sans parallÃ©lisation (--jobs=1)

```
Checking for reg* data types in user tables

Table 1/10000: public.users          [====                ] 0.01%
...
(10 secondes par table Ã— 10,000 tables = 27 heures !)
```

#### Avec parallÃ©lisation (--jobs=8)

```
Checking for reg* data types in user tables (8 workers)

Worker 1: public.users          [====    ]
Worker 2: public.orders         [===     ]
Worker 3: public.products       [======  ]
Worker 4: public.payments       [==      ]
Worker 5: public.reviews        [=====   ]
Worker 6: public.addresses      [====    ]
Worker 7: public.inventory      [===     ]
Worker 8: public.shipments      [======  ]

Progress: [===============                   ] 1250/10000 (12.5%)

(10 secondes Ã— 10,000 / 8 â‰ˆ 3.5 heures)
```

## Utilisation pratique et bonnes pratiques

### ProcÃ©dure de test pour dÃ©terminer le --jobs optimal

#### Ã‰tape 1 : VÃ©rifier les ressources

```bash
# 1. Nombre de CPU
nproc
# 16

# 2. RAM disponible
free -h | grep "Mem:"
# Mem:    62Gi    15Gi    45Gi

# 3. Type de disque
lsblk -d -o name,rota
# NAME ROTA
# sda     0    â† 0 = SSD, 1 = HDD

# 4. Performance I/O
iostat -x 1 5  # Observer pendant 5 secondes
```

#### Ã‰tape 2 : Tests progressifs

```bash
# Test 1 : Baseline avec 1 worker
time pg_upgrade --jobs=1 --check [options...]
# real: 45m 23s

# Test 2 : 4 workers
time pg_upgrade --jobs=4 --check [options...]
# real: 12m 10s (3.7Ã— plus rapide)

# Test 3 : 8 workers
time pg_upgrade --jobs=8 --check [options...]
# real: 6m 45s (6.7Ã— plus rapide)

# Test 4 : 16 workers
time pg_upgrade --jobs=16 --check [options...]
# real: 5m 20s (8.5Ã— plus rapide)

# Test 5 : 32 workers (peut-Ãªtre trop ?)
time pg_upgrade --jobs=32 --check [options...]
# real: 5m 15s (8.6Ã— plus rapide - gain marginal)
```

**RÃ©sultat** : Pour ce serveur, `--jobs=16` est optimal. Au-delÃ , le gain est nÃ©gligeable.

#### Ã‰tape 3 : Surveiller les ressources pendant le test

```bash
# Dans un terminal sÃ©parÃ© pendant pg_upgrade
watch -n 1 'echo "=== CPU ==="; mpstat 1 1 | tail -2; \
            echo "=== RAM ==="; free -h | grep Mem; \
            echo "=== I/O ==="; iostat -x 1 1 | tail -n +7'
```

**Observer** :
- CPU utilization : devrait Ãªtre entre 50-80%
- RAM : devrait avoir au moins 2-4 GB de libre
- I/O wait (wa%) : devrait rester < 20%

Si I/O wait > 30% â†’ RÃ©duire --jobs (goulot d'Ã©tranglement disque)

### Script automatisÃ© pour trouver l'optimal

```bash
#!/bin/bash
# find_optimal_jobs.sh
# Teste diffÃ©rentes valeurs de --jobs et recommande l'optimal

OLD_DIR="/var/lib/postgresql/17/main"
NEW_DIR="/var/lib/postgresql/18/main"
OLD_BIN="/usr/lib/postgresql/17/bin"
NEW_BIN="/usr/lib/postgresql/18/bin"

NCPU=$(nproc)
MAX_JOBS=$((NCPU * 3 / 4))  # 75% des CPU

echo "ğŸ” Tests de performance pg_upgrade --check"
echo "CPU disponibles : $NCPU"
echo "Tests jusqu'Ã  : $MAX_JOBS jobs"
echo ""

for JOBS in 1 2 4 8 12 16; do
    if [ $JOBS -gt $MAX_JOBS ]; then
        break
    fi

    echo "ğŸ“Š Test avec --jobs=$JOBS..."

    START=$(date +%s)
    pg_upgrade \
        --old-datadir="$OLD_DIR" \
        --new-datadir="$NEW_DIR" \
        --old-bindir="$OLD_BIN" \
        --new-bindir="$NEW_BIN" \
        --jobs=$JOBS \
        --check > /dev/null 2>&1
    END=$(date +%s)

    DURATION=$((END - START))
    echo "   DurÃ©e : ${DURATION}s"
    echo ""
done

echo "âœ… Tests terminÃ©s. Analysez les rÃ©sultats ci-dessus."
echo "ğŸ’¡ Choisissez la valeur oÃ¹ le gain devient marginal."
```

### Migration en production : StratÃ©gie recommandÃ©e

#### Phase 1 : PrÃ©paration (J-7 Ã  J-1)

```bash
# 1. DÃ©terminer --jobs optimal sur environnement de test
./find_optimal_jobs.sh

# 2. Documenter la valeur choisie
echo "OPTIMAL_JOBS=8" >> migration_config.env

# 3. Tester la migration complÃ¨te sur staging
pg_upgrade --jobs=8 --check [options]
```

#### Phase 2 : VÃ©rification prÃ©-migration (H-1)

```bash
# VÃ©rification rapide avec parallÃ©lisation
time pg_upgrade \
    --jobs=8 \
    --check \
    [autres options]

# Si < 30 minutes : OK pour production
# Si > 1 heure : Revoir --jobs ou optimiser la base
```

#### Phase 3 : Migration (FenÃªtre de maintenance)

```bash
# Migration complÃ¨te avec --jobs optimisÃ©
pg_upgrade \
    --jobs=8 \
    --swap \
    --verbose \
    [autres options]
```

### Bonnes pratiques

#### âœ… Ã€ faire

```bash
# 1. Toujours tester --check avec --jobs d'abord
pg_upgrade --jobs=8 --check [options]

# 2. Utiliser --verbose pour voir la progression
pg_upgrade --jobs=8 --verbose [options]

# 3. Monitorer les ressources pendant la migration
htop  # ou top, dans un autre terminal

# 4. Documenter la valeur --jobs utilisÃ©e
echo "Migration PG 18 effectuÃ©e avec --jobs=8" >> migration.log

# 5. Laisser quelques CPU libres pour le systÃ¨me
# Si 16 CPU, utiliser --jobs=12 maximum
```

#### âŒ Ã€ Ã©viter

```bash
# 1. Ne pas utiliser --jobs Ã©gal au nombre de CPU
# Mauvais : --jobs=16 sur serveur 16-core
# Bon : --jobs=12 sur serveur 16-core

# 2. Ne pas tester --jobs uniquement en production
# Toujours tester sur dev/staging d'abord

# 3. Ne pas ignorer les warnings sur les ressources
# Si pg_upgrade dit "not enough memory", l'Ã©couter !

# 4. Ne pas utiliser --jobs trop Ã©levÃ© sur HDD
# HDD : max --jobs=4
# SSD : --jobs=8 Ã  16
# NVMe : --jobs=16+

# 5. Ne pas oublier de monitorer pendant la migration
```

### Combinaison avec autres options

#### --jobs + --check

```bash
# VÃ©rification parallÃ©lisÃ©e (nouveau PG 18)
pg_upgrade \
    --jobs=8 \
    --check \
    [options]

# Ã‰conomie de temps : Ã‰norme sur grosses bases
```

#### --jobs + --swap

```bash
# Migration complÃ¨te optimisÃ©e
pg_upgrade \
    --jobs=8 \
    --swap \
    [options]

# BÃ©nÃ©fices : RapiditÃ© + sÃ©curitÃ©
```

#### --jobs + --link

```bash
# Maximum de rapiditÃ© (mais sans filet)
pg_upgrade \
    --jobs=16 \
    --link \
    [options]

# Usage : Environnements non-critiques
```

#### --jobs + --verbose

```bash
# Voir la progression dÃ©taillÃ©e
pg_upgrade \
    --jobs=8 \
    --verbose \
    [options]

# Affiche quel worker fait quoi
```

## Monitoring et diagnostic

### Voir les workers en action

```bash
# Dans un terminal sÃ©parÃ© pendant pg_upgrade
watch -n 2 'ps aux | grep -E "pg_upgrade|postgres: worker"'

# Sortie exemple :
# postgres  12345  pg_upgrade --jobs=8 ...
# postgres  12346  postgres: worker process (analyze)
# postgres  12347  postgres: worker process (analyze)
# postgres  12348  postgres: worker process (analyze)
# postgres  12349  postgres: worker process (analyze)
# postgres  12350  postgres: worker process (analyze)
# postgres  12351  postgres: worker process (analyze)
# postgres  12352  postgres: worker process (analyze)
# postgres  12353  postgres: worker process (analyze)
```

### Surveiller l'utilisation CPU

```bash
# Utilisation CPU par cÅ“ur
mpstat -P ALL 1

# Sortie :
# CPU    %usr   %sys   %iowait  %idle
# 0      87.2   8.3    2.1      2.4    â† Worker 1
# 1      89.1   7.5    1.8      1.6    â† Worker 2
# 2      86.7   9.2    2.5      1.6    â† Worker 3
# 3      88.3   8.1    1.9      1.7    â† Worker 4
# 4      85.9   9.4    2.3      2.4    â† Worker 5
# ...

# Si %idle < 5% sur tous les CPU â†’ --jobs pourrait Ãªtre trop Ã©levÃ©
# Si %iowait > 20% â†’ Goulot d'Ã©tranglement disque
```

### Surveiller la mÃ©moire

```bash
# Utilisation mÃ©moire en temps rÃ©el
watch -n 1 'free -h'

#               total        used        free      shared  buff/cache   available
# Mem:           62Gi        25Gi        10Gi        1.0Gi        26Gi        35Gi

# Si free < 2 GB pendant pg_upgrade â†’ Risque de swap
```

### Surveiller les I/O

```bash
# Statistiques I/O
iostat -x 1

# Device   r/s    w/s    rkB/s    wkB/s  await  %util
# sda      234.5  123.2  45678    23456   12.3   78.5

# %util > 95% â†’ Disque saturÃ©, rÃ©duire --jobs
# await > 50ms â†’ Latence Ã©levÃ©e, rÃ©duire --jobs
```

### Logs dÃ©taillÃ©s

```bash
# Logs pg_upgrade avec timestamps
tail -f pg_upgrade_server.log

# Exemple de sortie avec --jobs=8 :
# [2024-11-23 10:15:23] Starting parallel workers (8 workers)
# [2024-11-23 10:15:23] Worker 1: Checking table public.users
# [2024-11-23 10:15:23] Worker 2: Checking table public.orders
# [2024-11-23 10:15:23] Worker 3: Checking table public.products
# [2024-11-23 10:15:24] Worker 1: Completed table public.users
# [2024-11-23 10:15:24] Worker 1: Checking table public.payments
# ...
```

## Cas d'usage rÃ©els

### Cas 1 : Startup avec base croissante (200 GB)

**Contexte** :
- Base : 200 GB, 1,500 tables
- Serveur : AWS RDS-like, 8 vCPU, 32 GB RAM, SSD
- Contrainte : FenÃªtre de maintenance 4 heures

**StratÃ©gie** :

```bash
# AprÃ¨s tests sur staging, configuration choisie :
JOBS=6  # 75% de 8 vCPU

# VÃ©rification (PG 18)
time pg_upgrade --jobs=6 --check [options]
# DurÃ©e : 8 minutes (vs 28 minutes avec --jobs=1)

# Migration rÃ©elle
time pg_upgrade --jobs=6 --swap [options]
# DurÃ©e totale : 45 minutes

# RÃ©sultat : Migration dans la fenÃªtre, avec temps de confort
```

**Gain** : 20 minutes Ã©conomisÃ©es sur la vÃ©rification

### Cas 2 : Entreprise avec grosse base (3 TB)

**Contexte** :
- Base : 3 TB, 8,000 tables
- Serveur : On-premise, 32 cores, 256 GB RAM, NVMe RAID
- Contrainte : Downtime < 6 heures

**StratÃ©gie** :

```bash
# Configuration aprÃ¨s tests :
JOBS=20  # ~60% de 32 cores (I/O en compte aussi)

# VÃ©rification
time pg_upgrade --jobs=20 --check [options]
# DurÃ©e : 22 minutes (vs 3h15 avec --jobs=1)

# Migration rÃ©elle
time pg_upgrade --jobs=20 --swap --link [options]
# DurÃ©e totale : 3 heures

# RÃ©sultat : Dans la fenÃªtre avec marge
```

**Gain** : Presque 3 heures Ã©conomisÃ©es !

### Cas 3 : SaaS multi-tenant (500 GB, 50,000 tables)

**Contexte** :
- Base : 500 GB, 50,000 petites tables (multi-tenant)
- Serveur : Cloud, 16 vCPU, 64 GB RAM, SSD Premium
- Contrainte : Downtime < 2 heures

**DÃ©fi** : Beaucoup de petites tables â†’ --jobs trÃ¨s efficace ici !

**StratÃ©gie** :

```bash
# Configuration optimale pour beaucoup de tables :
JOBS=12

# VÃ©rification (CRUCIAL avec autant de tables)
time pg_upgrade --jobs=12 --check [options]
# DurÃ©e : 18 minutes (vs 5+ heures avec --jobs=1 !)

# Migration
time pg_upgrade --jobs=12 --swap [options]
# DurÃ©e totale : 1h 20min

# RÃ©sultat : Largement dans la fenÃªtre
```

**Gain** : Plus de 4h30 Ã©conomisÃ©es sur la vÃ©rification !

### Cas 4 : Legacy avec vieux HDD (100 GB)

**Contexte** :
- Base : 100 GB, 500 tables
- Serveur : Ancien serveur, 8 cores, 16 GB RAM, **HDD mÃ©canique**
- Contrainte : Budget limitÃ©, pas d'upgrade matÃ©riel

**Attention** : HDD = goulot d'Ã©tranglement I/O !

**StratÃ©gie** :

```bash
# Tests progressifs :
# --jobs=8 : I/O wait 65%, inefficace
# --jobs=4 : I/O wait 35%, mieux
# --jobs=2 : I/O wait 15%, optimal

JOBS=2  # LimitÃ© par le disque, pas le CPU

# VÃ©rification
time pg_upgrade --jobs=2 --check [options]
# DurÃ©e : 15 minutes (vs 25 minutes avec --jobs=1)

# Migration
time pg_upgrade --jobs=2 --swap [options]
# DurÃ©e : 1h 10min
```

**LeÃ§on** : Sur HDD, --jobs Ã©levÃ© ne sert Ã  rien (peut mÃªme ralentir)

## Limitations et considÃ©rations

### Limitations techniques

#### 1. Nombre maximum de workers

PostgreSQL impose une limite pratique sur le nombre de workers :

```
Limite technique : --jobs=64 (maximum)

Mais en pratique :
- Au-delÃ  de 24-32 workers, gains marginaux
- Risque de contention et overhead
```

#### 2. Types d'opÃ©rations non parallÃ©lisables

Certaines opÃ©rations restent sÃ©quentielles mÃªme avec `--jobs` :

```
Non parallÃ©lisables :
âŒ VÃ©rification des versions
âŒ VÃ©rification des transactions prÃ©parÃ©es globales
âŒ Copie de fichiers systÃ¨me (pg_xact, pg_multixact)
âŒ OpÃ©rations finales de finalisation
```

Ces opÃ©rations reprÃ©sentent gÃ©nÃ©ralement < 10% du temps total.

#### 3. Goulots d'Ã©tranglement possibles

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Goulots d'Ã©tranglement limitant l'efficacitÃ© de --jobs     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  1. I/O disque (le plus frÃ©quent)                           â”‚
â”‚     â†’ HDD saturÃ© dÃ¨s --jobs=4                               â”‚
â”‚     â†’ Solution : SSD/NVMe ou limiter --jobs                 â”‚
â”‚                                                             â”‚
â”‚  2. MÃ©moire insuffisante                                    â”‚
â”‚     â†’ Swap commence = performances s'effondrent             â”‚
â”‚     â†’ Solution : Plus de RAM ou rÃ©duire --jobs              â”‚
â”‚                                                             â”‚
â”‚  3. CPU insuffisant                                         â”‚
â”‚     â†’ Moins frÃ©quent sur serveurs modernes                  â”‚
â”‚     â†’ Solution : Limiter --jobs au nombre de cores          â”‚
â”‚                                                             â”‚
â”‚  4. RÃ©seau (pour stockage rÃ©seau type NFS)                  â”‚
â”‚     â†’ Latence rÃ©seau limite le parallÃ©lisme                 â”‚
â”‚     â†’ Solution : Stockage local ou --jobs modÃ©rÃ©            â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ConsidÃ©rations de sÃ©curitÃ© et stabilitÃ©

#### Charge sur le systÃ¨me

```bash
# Pendant pg_upgrade avec --jobs Ã©levÃ©
# Le systÃ¨me peut Ãªtre fortement sollicitÃ©

# Exemple : --jobs=16 sur serveur partagÃ©
# â†’ Peut impacter d'autres services
# â†’ Planifier pendant une fenÃªtre maintenance complÃ¨te
```

#### Consommation de connexions

Chaque worker peut ouvrir des connexions Ã  la base :

```
--jobs=8 Ã— ~5 connexions par worker = ~40 connexions

VÃ©rifier max_connections :
SHOW max_connections;  -- Doit Ãªtre > nombre de workers Ã— 10
```

#### Logs et espace disque

Plus de workers = plus de logs :

```bash
# VÃ©rifier l'espace avant migration
df -h /var/log/postgresql/

# Avec --jobs=16, logs peuvent atteindre 1-2 GB
# pour une migration complÃ¨te
```

## DÃ©pannage et rÃ©solution de problÃ¨mes

### ProblÃ¨me 1 : Migration lente malgrÃ© --jobs

**SymptÃ´mes** :
```bash
pg_upgrade --jobs=16 [options]
# Progression : 1 table / 30 secondes (trÃ¨s lent)
```

**Diagnostic** :
```bash
# VÃ©rifier I/O wait
iostat -x 1
# %iowait > 50% â†’ Disque saturÃ©

# VÃ©rifier la mÃ©moire
free -h
# free < 1 GB â†’ MÃ©moire insuffisante
```

**Solution** :
```bash
# RÃ©duire --jobs
pg_upgrade --jobs=4 [options]  # Au lieu de 16

# Ou upgrade vers SSD si possible
```

### ProblÃ¨me 2 : Erreur "too many workers"

**SymptÃ´mes** :
```
ERROR: number of workers (32) exceeds maximum allowed (24)
```

**Solution** :
```bash
# RÃ©duire Ã  la valeur recommandÃ©e
pg_upgrade --jobs=24 [options]
```

### ProblÃ¨me 3 : Out of memory

**SymptÃ´mes** :
```
FATAL: out of memory
ERROR: worker process crashed
```

**Diagnostic** :
```bash
# VÃ©rifier la mÃ©moire disponible
free -h
# Si available < 4 GB â†’ ProblÃ¨me

# VÃ©rifier le swap
swapon --show
# Si swap utilisÃ© activement â†’ ProblÃ¨me
```

**Solution** :
```bash
# RÃ©duire --jobs pour consommer moins de RAM
pg_upgrade --jobs=4 [options]

# Ou augmenter la RAM du serveur
```

### ProblÃ¨me 4 : Deadlocks ou workers bloquÃ©s

**SymptÃ´mes** :
```
# Progression s'arrÃªte, workers semblent bloquÃ©s
Worker 3: [Waiting...]
Worker 5: [Waiting...]
```

**Diagnostic** :
```bash
# VÃ©rifier les processus
ps aux | grep postgres

# VÃ©rifier les locks
# (nÃ©cessite que l'ancien cluster soit dÃ©marrÃ© en mode spÃ©cial)
```

**Solution** :
```bash
# Annuler et relancer avec moins de workers
Ctrl+C  # Annuler pg_upgrade
pg_upgrade --jobs=4 [options]  # RÃ©essayer avec moins de workers
```

## Comparaison avec les versions prÃ©cÃ©dentes

### PostgreSQL 17 vs PostgreSQL 18

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Option --jobs : PG 17 vs PG 18                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  PostgreSQL 17 :                                            â”‚
â”‚  â”œâ”€ --jobs=N pour MIGRATION : âœ… Oui                        â”‚
â”‚  â””â”€ --jobs=N pour --check   : âŒ Non (forcÃ© Ã  1)            â”‚
â”‚                                                             â”‚
â”‚  PostgreSQL 18 :                                            â”‚
â”‚  â”œâ”€ --jobs=N pour MIGRATION : âœ… Oui                        â”‚
â”‚  â””â”€ --jobs=N pour --check   : âœ… Oui (NOUVEAU !)            â”‚
â”‚                                                             â”‚
â”‚  Impact :                                                   â”‚
â”‚  â†’ Phase --check 5-10Ã— plus rapide dans PG 18               â”‚
â”‚  â†’ Validation avant migration beaucoup plus praticable      â”‚
â”‚  â†’ ItÃ©rations de tests plus rapides                         â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Tableau rÃ©capitulatif

| OpÃ©ration | PG â‰¤ 17 | PG 18 | Gain |
|-----------|---------|-------|------|
| **--check avec --jobs=1** | 45 min | 45 min | - |
| **--check avec --jobs=8** | 45 min (forcÃ© Ã  1) | 6 min | 7.5Ã— |
| **Migration avec --jobs=8** | 2h | 2h | - |
| **Migration totale** | 2h45 | 2h06 | ~30% |

### TÃ©moignages (fiction illustrative)

**DBA chez une FinTech** :
> "Avant PG 18, la phase --check prenait 3 heures sur notre base de 5 TB. On ne pouvait la lancer qu'une fois par jour en DEV. Avec PG 18 et --jobs=12, c'est 20 minutes. On peut tester beaucoup plus souvent !"

**DevOps chez un e-commerce** :
> "La parallÃ©lisation de --check change tout. On peut valider notre migration le matin, faire des ajustements, et retester l'aprÃ¨s-midi. Avant, chaque test prenait toute la nuit."

## Conclusion

La parallÃ©lisation de `--check` avec `--jobs` dans PostgreSQL 18 est une amÃ©lioration qui peut sembler technique, mais qui a un **impact pratique Ã©norme** sur les migrations en production.

### RÃ©capitulatif des bÃ©nÃ©fices

- âœ… **Vitesse** : VÃ©rifications 5-10Ã— plus rapides
- âœ… **Confiance** : Tests itÃ©ratifs possibles avant migration
- âœ… **FlexibilitÃ©** : Validation rapide mÃªme sur grosses bases
- âœ… **ProductivitÃ©** : Moins de temps d'attente pour les Ã©quipes
- âœ… **SÃ©curitÃ©** : Plus de tests = moins de surprises

### Points clÃ©s Ã  retenir

1. **--jobs fonctionne dÃ©sormais pour --check** (nouveau PG 18)
2. **Choisir --jobs = 50-75% des CPU disponibles** (rÃ¨gle gÃ©nÃ©rale)
3. **Toujours tester sur DEV/staging d'abord** pour trouver l'optimal
4. **Monitorer les ressources** (CPU, RAM, I/O) pendant les tests
5. **HDD = max --jobs=4** ; **SSD/NVMe = --jobs=8-16+**

### Recommandations finales

```
Pour une migration rÃ©ussie avec --jobs :

1. Tester --check avec diffÃ©rentes valeurs de --jobs
2. Trouver le point optimal (gain vs ressources)
3. Documenter la configuration choisie
4. Utiliser cette configuration en production
5. Combiner avec --swap pour une migration optimale
```

### Prochaines sections recommandÃ©es

Pour une comprÃ©hension complÃ¨te de pg_upgrade dans PostgreSQL 18 :

- **Section 19.3.1** : PrÃ©servation des statistiques (complÃ©mentaire)
- **Section 19.3.2** : Option --swap pour sÃ©curitÃ© et rapiditÃ©
- **Section 19.3.4** : StratÃ©gies Blue/Green pour downtime minimal
- **Section 19.4** : Troubleshooting des migrations

---

**Note** : Retenez l'essentiel : PostgreSQL 18 permet de vÃ©rifier votre migration beaucoup plus rapidement en utilisant plusieurs "workers" qui travaillent en parallÃ¨le. C'est comme avoir plusieurs personnes qui vÃ©rifient diffÃ©rentes parties de votre base en mÃªme temps au lieu d'une seule personne qui fait tout sÃ©quentiellement. Le rÃ©sultat ? Des migrations plus rapides et plus sÃ»res !

â­ï¸ [StratÃ©gies Blue/Green et Logical Replication](/19-postgresql-en-production/03.4-strategies-blue-green.md)
