üîù Retour au [Sommaire](/SOMMAIRE.md)

# 11.4.3. D√©tachement et attachement de partitions

## Introduction

L'une des fonctionnalit√©s les plus puissantes du partitionnement dans PostgreSQL est la capacit√© de **d√©tacher** (DETACH) et **attacher** (ATTACH) des partitions dynamiquement, sans interrompre le service. Cette flexibilit√© permet de g√©rer efficacement le cycle de vie des donn√©es : archivage, purge, migration, maintenance, et bien plus encore.

### Analogie Simple

Imaginez une biblioth√®que avec des √©tag√®res mobiles :

```
Biblioth√®que principale (table partitionn√©e)
‚îú‚îÄ‚îÄ √âtag√®re 2023 (partition)
‚îú‚îÄ‚îÄ √âtag√®re 2024 (partition)
‚îî‚îÄ‚îÄ √âtag√®re 2025 (partition)

D√©tacher une √©tag√®re :
- Retirer physiquement l'√©tag√®re 2023 de la biblioth√®que
- Elle existe toujours comme table ind√©pendante
- Les livres sont intacts, juste "d√©connect√©s"

Attacher une √©tag√®re :
- Ajouter une nouvelle √©tag√®re (ou remettre l'ancienne)
- Elle devient instantan√©ment partie de la biblioth√®que
- Acc√®s imm√©diat aux livres qu'elle contient
```

### Pourquoi D√©tacher/Attacher ?

**Cas d'usage typiques :**

1. **Archivage** : D√©tacher les anciennes partitions pour les archiver
2. **Purge rapide** : Supprimer des donn√©es anciennes instantan√©ment
3. **Maintenance** : Op√©rations lourdes sur une partition isol√©e
4. **Migration** : D√©placer des donn√©es vers un autre tablespace
5. **R√©organisation** : Changer la structure d'une partition
6. **Import/Export** : Int√©grer des donn√©es externes comme partition

---

## Partie 1 : D√©tacher une Partition (DETACH)

### Concept

**D√©tacher** une partition signifie la **d√©connecter** de la table partitionn√©e parente tout en **conservant** la table et ses donn√©es. La partition devient une table ordinaire ind√©pendante.

### Syntaxe de Base

```sql
ALTER TABLE table_parent DETACH PARTITION partition_name;
```

### Exemple Simple

```sql
-- Table partitionn√©e
CREATE TABLE ventes (
    vente_id BIGSERIAL,
    date_vente DATE NOT NULL,
    montant NUMERIC(10,2)
) PARTITION BY RANGE (date_vente);

-- Cr√©er des partitions
CREATE TABLE ventes_2023 PARTITION OF ventes
    FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');

CREATE TABLE ventes_2024 PARTITION OF ventes
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE ventes_2025 PARTITION OF ventes
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');

-- Ins√©rer des donn√©es
INSERT INTO ventes (date_vente, montant)
SELECT
    '2023-01-01'::date + (random() * 365)::integer,
    (random() * 1000)::numeric(10,2)
FROM generate_series(1, 100000);  -- 100k lignes en 2023

-- V√©rifier les partitions
SELECT
    parent.relname AS table_parent,
    child.relname AS partition
FROM pg_inherits
JOIN pg_class parent ON pg_inherits.inhparent = parent.oid
JOIN pg_class child ON pg_inherits.inhrelid = child.oid
WHERE parent.relname = 'ventes';
```

**R√©sultat :**
```
table_parent | partition
-------------+--------------
ventes       | ventes_2023
ventes       | ventes_2024
ventes       | ventes_2025
```

### D√©tacher la Partition 2023

```sql
-- D√©tacher ventes_2023
ALTER TABLE ventes DETACH PARTITION ventes_2023;
```

**Ce qui se passe :**
1. `ventes_2023` n'est plus une partition de `ventes`
2. `ventes_2023` devient une table ordinaire ind√©pendante
3. Les donn√©es restent intactes dans `ventes_2023`
4. Les requ√™tes sur `ventes` n'incluent plus `ventes_2023`

### V√©rification Apr√®s D√©tachement

```sql
-- V√©rifier les partitions restantes
SELECT
    parent.relname AS table_parent,
    child.relname AS partition
FROM pg_inherits
JOIN pg_class parent ON pg_inherits.inhparent = parent.oid
JOIN pg_class child ON pg_inherits.inhrelid = child.oid
WHERE parent.relname = 'ventes';
```

**R√©sultat :**
```
table_parent | partition
-------------+--------------
ventes       | ventes_2024
ventes       | ventes_2025
```

`ventes_2023` n'appara√Æt plus !

```sql
-- Mais la table existe toujours
SELECT COUNT(*) FROM ventes_2023;
-- R√©sultat: 100000 (les donn√©es sont l√†)

-- Requ√™te sur ventes n'inclut plus 2023
SELECT COUNT(*) FROM ventes;
-- R√©sultat: 0 (seules 2024 et 2025, qui sont vides pour l'instant)
```

---

## D√©tachement CONCURRENT (PostgreSQL 14+)

### Probl√®me du D√©tachement Standard

Le d√©tachement standard (`DETACH PARTITION`) prend un **verrou exclusif** (ACCESS EXCLUSIVE) sur la table parent, ce qui **bloque** toutes les op√©rations (lecture et √©criture) pendant l'op√©ration.

**Impact :**
- Sur une grosse table : plusieurs secondes de blocage
- Inacceptable en production avec fort trafic

### Solution : DETACH PARTITION CONCURRENTLY

Depuis PostgreSQL 14, vous pouvez d√©tacher une partition **sans bloquer** les op√©rations.

```sql
-- D√©tachement concurrent (non-bloquant)
ALTER TABLE ventes DETACH PARTITION ventes_2023 CONCURRENTLY;
```

**Avantages :**
- ‚úÖ Pas de blocage des lectures
- ‚úÖ Pas de blocage des √©critures
- ‚úÖ Op√©ration transparente pour l'application

**Processus en deux phases :**

1. **Phase 1** : Marquer la partition comme "en cours de d√©tachement"
   - Verrou l√©ger
   - Les requ√™tes continuent de fonctionner

2. **Phase 2** : Finaliser le d√©tachement apr√®s validation
   - Attendre que toutes les transactions en cours se terminent
   - D√©tacher d√©finitivement

### Exemple Complet

```sql
-- D√©marrer le d√©tachement concurrent
ALTER TABLE ventes DETACH PARTITION ventes_2024 CONCURRENTLY;

-- L'op√©ration peut prendre du temps si des transactions sont en cours
-- Pendant ce temps, la table ventes reste accessible

-- V√©rifier l'√©tat
SELECT
    parent.relname AS table_parent,
    child.relname AS partition,
    child.relispartition AS est_partition
FROM pg_inherits
JOIN pg_class parent ON pg_inherits.inhparent = parent.oid
JOIN pg_class child ON pg_inherits.inhrelid = child.oid
WHERE parent.relname = 'ventes';
```

**Note :** Si l'op√©ration est interrompue (crash, annulation), la partition reste dans un √©tat "partiellement d√©tach√©e". Vous devrez finaliser l'op√©ration :

```sql
-- Finaliser un d√©tachement interrompu
ALTER TABLE ventes DETACH PARTITION ventes_2024 FINALIZE;
```

---

## Partie 2 : Attacher une Partition (ATTACH)

### Concept

**Attacher** une partition signifie transformer une table ordinaire en partition d'une table partitionn√©e. Les donn√©es de la table deviennent imm√©diatement accessibles via la table parent.

### Syntaxe de Base

```sql
-- Pour RANGE
ALTER TABLE table_parent ATTACH PARTITION table_name
    FOR VALUES FROM (min_value) TO (max_value);

-- Pour LIST
ALTER TABLE table_parent ATTACH PARTITION table_name
    FOR VALUES IN (value1, value2, ...);

-- Pour HASH
ALTER TABLE table_parent ATTACH PARTITION table_name
    FOR VALUES WITH (MODULUS x, REMAINDER y);
```

### Exemple : Attacher une Table Existante

```sql
-- Cr√©er une table ordinaire avec des donn√©es
CREATE TABLE nouvelles_ventes_2026 (
    vente_id BIGSERIAL,
    date_vente DATE NOT NULL,
    montant NUMERIC(10,2)
);

-- Ins√©rer des donn√©es
INSERT INTO nouvelles_ventes_2026 (date_vente, montant)
SELECT
    '2026-01-01'::date + (random() * 365)::integer,
    (random() * 1000)::numeric(10,2)
FROM generate_series(1, 50000);

-- Attacher comme partition
ALTER TABLE ventes ATTACH PARTITION nouvelles_ventes_2026
    FOR VALUES FROM ('2026-01-01') TO ('2027-01-01');
```

**Ce qui se passe :**
1. `nouvelles_ventes_2026` devient une partition de `ventes`
2. Les 50 000 lignes sont imm√©diatement accessibles via `SELECT * FROM ventes`
3. La structure doit √™tre compatible (colonnes, types)

### V√©rification

```sql
-- V√©rifier les partitions
SELECT
    parent.relname AS table_parent,
    child.relname AS partition
FROM pg_inherits
JOIN pg_class parent ON pg_inherits.inhparent = parent.oid
JOIN pg_class child ON pg_inherits.inhrelid = child.oid
WHERE parent.relname = 'ventes'
ORDER BY child.relname;

-- Compter les lignes totales
SELECT COUNT(*) FROM ventes;
-- Inclut maintenant les lignes de nouvelles_ventes_2026
```

---

## Validation des Donn√©es lors de l'Attachement

### Le Probl√®me

Lorsque vous attachez une table existante, PostgreSQL doit **v√©rifier** que toutes les donn√©es respectent les contraintes de la partition (plage de valeurs).

**Par d√©faut :**
- PostgreSQL scanne **toutes les lignes** de la table
- V√©rifie que chaque ligne respecte les bornes de partition
- Op√©ration **bloquante** et potentiellement longue

### Exemple de Validation

```sql
-- Table avec 10 millions de lignes
CREATE TABLE archive_ventes_2022 (
    vente_id BIGSERIAL,
    date_vente DATE NOT NULL,
    montant NUMERIC(10,2)
);

-- Ins√©rer 10M de lignes (simulation)
-- INSERT INTO archive_ventes_2022 ...

-- Attacher : PostgreSQL va scanner les 10M de lignes
ALTER TABLE ventes ATTACH PARTITION archive_ventes_2022
    FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');
-- Cette op√©ration peut prendre plusieurs minutes et BLOQUE la table
```

### Solution : Contrainte CHECK Pr√©-Valid√©e

Pour **√©viter le scan complet**, ajoutez une contrainte CHECK **avant** l'attachement :

```sql
-- √âtape 1 : Ajouter une contrainte CHECK sur la table √† attacher
ALTER TABLE archive_ventes_2022
ADD CONSTRAINT check_date_range
CHECK (date_vente >= '2022-01-01' AND date_vente < '2023-01-01');

-- PostgreSQL scanne la table UNE FOIS pour valider la contrainte
-- Cela peut se faire en p√©riode creuse

-- √âtape 2 : Attacher avec la contrainte valid√©e
ALTER TABLE ventes ATTACH PARTITION archive_ventes_2022
    FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');
-- INSTANTAN√â : PostgreSQL voit que la contrainte existe d√©j√†, pas besoin de re-scanner !
```

**Avantages :**
- ‚úÖ Scan de validation fait en avance (pendant p√©riode creuse)
- ‚úÖ Attachement quasi-instantan√©
- ‚úÖ Pas de blocage prolong√©

---

## Cas d'Usage Pratiques

### 1. Archivage de Donn√©es Anciennes

**Sc√©nario :** Archiver les donn√©es de 2022 sur un stockage froid.

```sql
-- √âtape 1 : D√©tacher la partition 2022
ALTER TABLE ventes DETACH PARTITION ventes_2022 CONCURRENTLY;

-- √âtape 2 : Sauvegarder les donn√©es
-- pg_dump -t ventes_2022 > archive_ventes_2022.sql

-- √âtape 3 : D√©placer vers un tablespace froid (optionnel)
ALTER TABLE ventes_2022 SET TABLESPACE tablespace_archive;

-- √âtape 4 : Supprimer de la base principale (si vraiment n√©cessaire)
DROP TABLE ventes_2022;

-- Les requ√™tes sur ventes ne touchent plus les donn√©es 2022
-- Mais elles sont sauvegard√©es et peuvent √™tre restaur√©es si besoin
```

### 2. Purge Rapide de Donn√©es

**Sc√©nario :** Supprimer toutes les donn√©es de 2020 (millions de lignes).

**M√©thode 1 : DELETE (LENT) :**
```sql
-- ‚ùå Tr√®s lent sur grosse table
DELETE FROM ventes WHERE date_vente >= '2020-01-01' AND date_vente < '2021-01-01';
-- Peut prendre des heures, g√©n√®re beaucoup de WAL, bloque les autres op√©rations
```

**M√©thode 2 : DETACH + DROP (RAPIDE) :**
```sql
-- ‚úÖ Quasi-instantan√©
-- √âtape 1 : D√©tacher
ALTER TABLE ventes DETACH PARTITION ventes_2020 CONCURRENTLY;

-- √âtape 2 : Supprimer la table
DROP TABLE ventes_2020;
-- Instantan√© : pas de scan, pas de WAL massif
```

**Gain de temps :** De plusieurs heures √† quelques secondes !

### 3. Maintenance Lourde sur une Partition

**Sc√©nario :** R√©organiser une partition pour r√©duire le bloat.

```sql
-- √âtape 1 : D√©tacher la partition
ALTER TABLE ventes DETACH PARTITION ventes_2023 CONCURRENTLY;

-- √âtape 2 : Op√©rations de maintenance sans impacter ventes
VACUUM FULL ventes_2023;  -- R√©organisation compl√®te
REINDEX TABLE ventes_2023;  -- Reconstruction des index
ANALYZE ventes_2023;  -- Mise √† jour des statistiques

-- √âtape 3 : R√©attacher
ALTER TABLE ventes ATTACH PARTITION ventes_2023
    FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');

-- Avantage : Les requ√™tes sur ventes (2024, 2025) continuent normalement
```

### 4. Migration vers Nouveau Sch√©ma

**Sc√©nario :** Ajouter une colonne √† une table partitionn√©e massivement.

```sql
-- Approche classique (tr√®s lent sur grosse table)
-- ALTER TABLE ventes ADD COLUMN region VARCHAR(50);

-- Approche par partition (plus rapide et progressif)

-- √âtape 1 : D√©tacher chaque partition
ALTER TABLE ventes DETACH PARTITION ventes_2023 CONCURRENTLY;

-- √âtape 2 : Ajouter la colonne √† la partition d√©tach√©e
ALTER TABLE ventes_2023 ADD COLUMN region VARCHAR(50) DEFAULT 'EU';

-- √âtape 3 : Mettre √† jour la valeur (sur partition isol√©e)
UPDATE ventes_2023 SET region = 'US' WHERE montant > 500;

-- √âtape 4 : Modifier la table parent pour avoir la nouvelle colonne
ALTER TABLE ventes ADD COLUMN region VARCHAR(50);

-- √âtape 5 : R√©attacher
ALTER TABLE ventes ATTACH PARTITION ventes_2023
    FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');

-- R√©p√©ter pour chaque partition
-- Permet de g√©rer la migration progressivement, partition par partition
```

### 5. Import de Donn√©es Externes

**Sc√©nario :** Importer un fichier CSV de plusieurs Go comme nouvelle partition.

```sql
-- √âtape 1 : Cr√©er une table temporaire
CREATE TABLE import_ventes_janvier_2025 (
    vente_id BIGINT,
    date_vente DATE,
    montant NUMERIC(10,2)
);

-- √âtape 2 : Importer les donn√©es (rapide car table non partitionn√©e)
COPY import_ventes_janvier_2025 FROM '/data/ventes_janvier_2025.csv' CSV HEADER;

-- √âtape 3 : Ajouter la contrainte pour √©viter le scan √† l'attachement
ALTER TABLE import_ventes_janvier_2025
ADD CONSTRAINT check_date_janvier_2025
CHECK (date_vente >= '2025-01-01' AND date_vente < '2025-02-01');

-- √âtape 4 : Cr√©er les index n√©cessaires
CREATE INDEX idx_import_ventes_date ON import_ventes_janvier_2025(date_vente);
CREATE INDEX idx_import_ventes_montant ON import_ventes_janvier_2025(montant);

-- √âtape 5 : Attacher comme partition (instantan√© gr√¢ce √† la contrainte)
ALTER TABLE ventes ATTACH PARTITION import_ventes_janvier_2025
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- Les donn√©es sont imm√©diatement disponibles dans ventes
```

### 6. √âchange de Partitions (Swap)

**Sc√©nario :** Remplacer une partition par une nouvelle version.

```sql
-- Situation : ventes_2024 contient des donn√©es corrompues

-- √âtape 1 : Cr√©er une nouvelle partition avec donn√©es correctes
CREATE TABLE ventes_2024_nouveau (
    vente_id BIGSERIAL,
    date_vente DATE NOT NULL,
    montant NUMERIC(10,2)
);

-- Ins√©rer les donn√©es corrig√©es
INSERT INTO ventes_2024_nouveau (date_vente, montant)
SELECT date_vente, montant FROM source_donnees_correctes;

-- Ajouter la contrainte
ALTER TABLE ventes_2024_nouveau
ADD CONSTRAINT check_date_2024
CHECK (date_vente >= '2024-01-01' AND date_vente < '2025-01-01');

-- √âtape 2 : Transaction atomique pour l'√©change
BEGIN;
    -- D√©tacher l'ancienne
    ALTER TABLE ventes DETACH PARTITION ventes_2024;

    -- Attacher la nouvelle
    ALTER TABLE ventes ATTACH PARTITION ventes_2024_nouveau
        FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

    -- Renommer pour coh√©rence
    ALTER TABLE ventes_2024 RENAME TO ventes_2024_backup;
    ALTER TABLE ventes_2024_nouveau RENAME TO ventes_2024;
COMMIT;

-- √âtape 3 : V√©rifier puis supprimer le backup
-- DROP TABLE ventes_2024_backup;
```

---

## Pr√©cautions et Contraintes

### 1. Compatibilit√© de Structure

La table √† attacher doit avoir **exactement la m√™me structure** que la table parent.

```sql
-- ‚ùå Erreur : colonnes diff√©rentes
CREATE TABLE mauvaise_table (
    vente_id BIGINT,  -- Type diff√©rent (BIGINT vs BIGSERIAL)
    date_vente DATE,
    montant NUMERIC(10,2)
);

ALTER TABLE ventes ATTACH PARTITION mauvaise_table
    FOR VALUES FROM ('2027-01-01') TO ('2028-01-01');
-- ERREUR : table "mauvaise_table" has different column definitions

-- ‚úÖ Solution : correspondance exacte
CREATE TABLE bonne_table (
    vente_id BIGSERIAL,  -- M√™me type que parent
    date_vente DATE NOT NULL,
    montant NUMERIC(10,2)
);
```

### 2. Donn√©es Hors Bornes

Toutes les donn√©es de la table √† attacher doivent respecter les bornes de partition.

```sql
-- Table contenant des dates hors de la plage 2026
CREATE TABLE donnees_mixtes (
    vente_id BIGSERIAL,
    date_vente DATE NOT NULL,
    montant NUMERIC(10,2)
);

INSERT INTO donnees_mixtes (date_vente, montant) VALUES
    ('2026-05-15', 100.00),  -- OK
    ('2025-12-31', 50.00),   -- Hors plage !
    ('2026-11-20', 75.00);   -- OK

-- Tentative d'attachement
ALTER TABLE ventes ATTACH PARTITION donnees_mixtes
    FOR VALUES FROM ('2026-01-01') TO ('2027-01-01');
-- ERREUR : partition constraint is violated by some row
```

**Solution :** Nettoyer les donn√©es avant :
```sql
-- Supprimer les lignes hors plage
DELETE FROM donnees_mixtes
WHERE date_vente < '2026-01-01' OR date_vente >= '2027-01-01';

-- Maintenant l'attachement fonctionne
ALTER TABLE ventes ATTACH PARTITION donnees_mixtes
    FOR VALUES FROM ('2026-01-01') TO ('2027-01-01');
```

### 3. Contraintes et Index

**Contraintes :**
- Les contraintes NOT NULL, CHECK de la table parent sont h√©rit√©es
- Les contraintes suppl√©mentaires sur la partition sont permises

**Index :**
- Les index de la table parent ne sont **pas automatiquement cr√©√©s** sur une table existante attach√©e
- Il faut cr√©er les index manuellement **avant** l'attachement

```sql
-- Bonnes pratiques avant attachement
CREATE TABLE nouvelle_partition (
    vente_id BIGSERIAL,
    date_vente DATE NOT NULL,
    montant NUMERIC(10,2)
);

-- Cr√©er les m√™mes index que sur les autres partitions
CREATE INDEX idx_nouvelle_partition_date ON nouvelle_partition(date_vente);
CREATE INDEX idx_nouvelle_partition_montant ON nouvelle_partition(montant);

-- Puis attacher
ALTER TABLE ventes ATTACH PARTITION nouvelle_partition
    FOR VALUES FROM ('2028-01-01') TO ('2029-01-01');
```

### 4. Transactions et Verrous

**D√©tachement standard :**
- Prend un verrou ACCESS EXCLUSIVE (bloque tout)
- √Ä √©viter en production

**D√©tachement concurrent :**
- Verrous plus l√©gers
- Peut prendre du temps si transactions longues en cours
- Recommand√© en production

**Attachement :**
- Prend un verrou ACCESS EXCLUSIVE (bloque tout)
- Dur√©e d√©pend de la validation des donn√©es
- Utilisez la contrainte CHECK pour acc√©l√©rer

---

## Automatisation de la Gestion des Partitions

### Script de Cr√©ation Automatique de Partitions Futures

```sql
-- Fonction pour cr√©er les partitions des 12 prochains mois
CREATE OR REPLACE FUNCTION create_monthly_partitions(
    parent_table TEXT,
    start_date DATE,
    num_months INTEGER
)
RETURNS TEXT AS $$
DECLARE
    partition_name TEXT;
    start_range DATE;
    end_range DATE;
    result TEXT := '';
    i INTEGER;
BEGIN
    FOR i IN 0..(num_months-1) LOOP
        start_range := start_date + (i || ' months')::INTERVAL;
        end_range := start_range + '1 month'::INTERVAL;

        partition_name := parent_table || '_' || TO_CHAR(start_range, 'YYYY_MM');

        -- V√©rifier si la partition existe d√©j√†
        IF NOT EXISTS (
            SELECT 1 FROM pg_class WHERE relname = partition_name
        ) THEN
            EXECUTE format(
                'CREATE TABLE %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
                partition_name, parent_table, start_range, end_range
            );
            result := result || 'Cr√©√©: ' || partition_name || E'\n';
        ELSE
            result := result || 'Existe d√©j√†: ' || partition_name || E'\n';
        END IF;
    END LOOP;

    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Utilisation
SELECT create_monthly_partitions('ventes', '2025-01-01', 12);
```

### Script d'Archivage Automatique

```sql
-- Fonction pour archiver les partitions anciennes
CREATE OR REPLACE FUNCTION archive_old_partitions(
    parent_table TEXT,
    retention_months INTEGER
)
RETURNS TEXT AS $$
DECLARE
    partition_record RECORD;
    cutoff_date DATE;
    result TEXT := '';
BEGIN
    cutoff_date := CURRENT_DATE - (retention_months || ' months')::INTERVAL;

    FOR partition_record IN
        SELECT
            child.relname AS partition_name,
            pg_get_expr(child.relpartbound, child.oid) AS bounds
        FROM pg_inherits
        JOIN pg_class parent ON pg_inherits.inhparent = parent.oid
        JOIN pg_class child ON pg_inherits.inhrelid = child.oid
        WHERE parent.relname = parent_table
    LOOP
        -- Logique simplifi√©e : d√©tacher si le nom contient une ann√©e ancienne
        IF partition_record.partition_name ~ '\d{4}' THEN
            DECLARE
                partition_year INTEGER;
                cutoff_year INTEGER;
            BEGIN
                partition_year := (regexp_match(partition_record.partition_name, '(\d{4})'))[1]::INTEGER;
                cutoff_year := EXTRACT(YEAR FROM cutoff_date)::INTEGER;

                IF partition_year < cutoff_year THEN
                    -- D√©tacher
                    EXECUTE format(
                        'ALTER TABLE %I DETACH PARTITION %I CONCURRENTLY',
                        parent_table, partition_record.partition_name
                    );

                    result := result || 'D√©tach√©: ' || partition_record.partition_name || E'\n';

                    -- Optionnel : Sauvegarder puis supprimer
                    -- EXECUTE format('DROP TABLE %I', partition_record.partition_name);
                END IF;
            END;
        END IF;
    END LOOP;

    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Utilisation : archiver les partitions > 24 mois
SELECT archive_old_partitions('ventes', 24);
```

### Extension pg_partman

Pour une gestion automatis√©e compl√®te, utilisez l'extension **pg_partman**.

```sql
-- Installation
CREATE EXTENSION pg_partman;

-- Configuration pour cr√©ation automatique
SELECT partman.create_parent(
    p_parent_table := 'public.ventes',
    p_control := 'date_vente',
    p_type := 'native',
    p_interval := 'monthly',
    p_premake := 3  -- Cr√©er 3 mois √† l'avance
);

-- Fonction de maintenance (√† ex√©cuter via cron)
SELECT partman.run_maintenance('public.ventes');

-- Configuration de la r√©tention (d√©tacher automatiquement)
UPDATE partman.part_config
SET retention = '12 months',
    retention_keep_table = true  -- Garder les tables d√©tach√©es
WHERE parent_table = 'public.ventes';
```

---

## Monitoring et Gestion

### Lister Toutes les Partitions

```sql
-- Vue compl√®te des partitions
CREATE OR REPLACE VIEW v_partitions AS
SELECT
    nmsp_parent.nspname AS schema_parent,
    parent.relname AS table_parent,
    nmsp_child.nspname AS schema_partition,
    child.relname AS partition_name,
    pg_get_expr(child.relpartbound, child.oid) AS partition_bounds,
    pg_size_pretty(pg_total_relation_size(child.oid)) AS taille,
    pg_stat_get_live_tuples(child.oid) AS nb_lignes_estimees
FROM pg_inherits
JOIN pg_class parent ON pg_inherits.inhparent = parent.oid
JOIN pg_class child ON pg_inherits.inhrelid = child.oid
JOIN pg_namespace nmsp_parent ON parent.relnamespace = nmsp_parent.oid
JOIN pg_namespace nmsp_child ON child.relnamespace = nmsp_child.oid
ORDER BY parent.relname, partition_bounds;

-- Utilisation
SELECT * FROM v_partitions WHERE table_parent = 'ventes';
```

**R√©sultat exemple :**
```
schema_parent | table_parent | partition_name | partition_bounds                        | taille  | nb_lignes
--------------+--------------+----------------+-----------------------------------------+---------+-----------
public        | ventes       | ventes_2023    | FOR VALUES FROM ('2023-01-01') TO ...   | 125 MB  | 1000000
public        | ventes       | ventes_2024    | FOR VALUES FROM ('2024-01-01') TO ...   | 130 MB  | 1050000
public        | ventes       | ventes_2025    | FOR VALUES FROM ('2025-01-01') TO ...   | 15 MB   | 120000
```

### Identifier les Partitions √† Archiver

```sql
-- Partitions anciennes candidates √† l'archivage
SELECT
    partition_name,
    partition_bounds,
    taille,
    nb_lignes_estimees,
    AGE(NOW(), (regexp_match(partition_name, '(\d{4})'))[1]::INTEGER || '-01-01') AS age
FROM v_partitions
WHERE table_parent = 'ventes'
  AND partition_name ~ '\d{4}'
  AND EXTRACT(YEAR FROM NOW())::INTEGER - (regexp_match(partition_name, '(\d{4})'))[1]::INTEGER > 2
ORDER BY partition_name;
```

### Statistiques d'Utilisation

```sql
-- Activit√© par partition
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS taille,
    n_tup_ins AS insertions,
    n_tup_upd AS mises_a_jour,
    n_tup_del AS suppressions,
    seq_scan AS scans_sequentiels,
    idx_scan AS scans_index,
    last_vacuum,
    last_autovacuum
FROM pg_stat_user_tables
WHERE tablename LIKE 'ventes_%'
ORDER BY tablename;
```

---

## Strat√©gies de Maintenance par Cycle de Vie

### Cycle de Vie Typique d'une Partition

```
1. Cr√©ation (T-1 mois)
   ‚Üì
2. Donn√©es actives (mois courant)
   ‚Üì
3. Donn√©es r√©centes (1-6 mois)
   ‚Üì
4. Donn√©es historiques (6-24 mois)
   ‚Üì
5. Archivage (d√©tachement)
   ‚Üì
6. Suppression ou stockage froid
```

### Impl√©mentation

```sql
-- 1. CR√âATION : Automatique via cron
-- Script cron quotidien :
-- 0 2 * * * psql -U user -d db -c "SELECT create_monthly_partitions('ventes', CURRENT_DATE, 3);"

-- 2. DONN√âES ACTIVES : Aucune action n√©cessaire

-- 3. DONN√âES R√âCENTES : Maintenance l√©g√®re
-- Vacuum automatique suffit g√©n√©ralement

-- 4. DONN√âES HISTORIQUES : Optimisation
-- Mensuel : ANALYZE sur partitions anciennes
DO $$
DECLARE
    partition TEXT;
BEGIN
    FOR partition IN
        SELECT relname FROM pg_class
        WHERE relname LIKE 'ventes_202%'
        AND relname < 'ventes_' || TO_CHAR(NOW() - INTERVAL '6 months', 'YYYY_MM')
    LOOP
        EXECUTE 'VACUUM ANALYZE ' || partition;
    END LOOP;
END $$;

-- 5. ARCHIVAGE : Script mensuel
-- 0 3 1 * * psql -U user -d db -c "SELECT archive_old_partitions('ventes', 24);"

-- 6. SUPPRESSION : Manuel ou automatique apr√®s sauvegarde
-- Script qui v√©rifie que la sauvegarde existe avant de supprimer
```

---

## Checklist de Production

### Avant de D√©tacher une Partition

- [ ] V√©rifier qu'aucune transaction longue n'est en cours
- [ ] Utiliser DETACH ... CONCURRENTLY pour √©viter les blocages
- [ ] Sauvegarder les donn√©es si n√©cessaire (pg_dump)
- [ ] Documenter l'op√©ration (raison, date, responsable)
- [ ] Pr√©voir une proc√©dure de rollback

### Avant d'Attacher une Partition

- [ ] V√©rifier la compatibilit√© de structure
- [ ] Ajouter une contrainte CHECK pour √©viter le scan complet
- [ ] Cr√©er les index n√©cessaires
- [ ] Valider que toutes les donn√©es respectent les bornes
- [ ] Estimer le temps d'attachement (surtout si pas de contrainte)
- [ ] Planifier pendant une p√©riode creuse si attachement long

### Apr√®s D√©tachement/Attachement

- [ ] V√©rifier que l'op√©ration a r√©ussi
- [ ] Ex√©cuter ANALYZE sur la table parent
- [ ] Tester une requ√™te pour v√©rifier l'acc√®s aux donn√©es
- [ ] Mettre √† jour la documentation
- [ ] Surveiller les performances

---

## D√©pannage et Probl√®mes Courants

### Probl√®me 1 : DETACH CONCURRENTLY Bloqu√©

**Sympt√¥me :**
```sql
ALTER TABLE ventes DETACH PARTITION ventes_2023 CONCURRENTLY;
-- L'op√©ration ne se termine pas
```

**Cause :** Des transactions longues maintiennent des verrous.

**Solution :**
```sql
-- Identifier les transactions bloquantes
SELECT
    pid,
    usename,
    application_name,
    state,
    age(clock_timestamp(), query_start) AS age,
    query
FROM pg_stat_activity
WHERE state != 'idle'
  AND pid != pg_backend_pid()
ORDER BY age DESC;

-- Si n√©cessaire, terminer les transactions probl√©matiques
SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE pid = <problem_pid>;

-- Ou attendre qu'elles se terminent naturellement
```

### Probl√®me 2 : Erreur lors de l'Attachement

**Erreur :**
```
ERROR: partition constraint is violated by some row
```

**Solution :**
```sql
-- Identifier les lignes probl√©matiques
SELECT * FROM table_a_attacher
WHERE NOT (date_vente >= '2026-01-01' AND date_vente < '2027-01-01');

-- Corriger ou supprimer ces lignes
DELETE FROM table_a_attacher
WHERE NOT (date_vente >= '2026-01-01' AND date_vente < '2027-01-01');

-- R√©essayer l'attachement
ALTER TABLE ventes ATTACH PARTITION table_a_attacher
    FOR VALUES FROM ('2026-01-01') TO ('2027-01-01');
```

### Probl√®me 3 : Partition Partiellement D√©tach√©e

**Sympt√¥me :** Apr√®s un crash pendant DETACH CONCURRENTLY.

**Solution :**
```sql
-- Finaliser le d√©tachement
ALTER TABLE ventes DETACH PARTITION ventes_2023 FINALIZE;

-- Si erreur, forcer en mode normal (bloquant)
ALTER TABLE ventes DETACH PARTITION ventes_2023;
```

### Probl√®me 4 : Index Manquants Apr√®s Attachement

**Sympt√¥me :** Requ√™tes lentes sur la nouvelle partition.

**Solution :**
```sql
-- V√©rifier les index sur les autres partitions
SELECT
    schemaname,
    tablename,
    indexname,
    indexdef
FROM pg_indexes
WHERE tablename = 'ventes_2024';

-- Cr√©er les m√™mes index sur la nouvelle partition
-- (en dehors des heures de pointe)
CREATE INDEX idx_ventes_2026_date ON ventes_2026(date_vente);
CREATE INDEX idx_ventes_2026_montant ON ventes_2026(montant);
```

---

## Bonnes Pratiques

### 1. Planification

- Cr√©er les partitions **√† l'avance** (3-6 mois)
- D√©finir une politique de r√©tention claire
- Automatiser la cr√©ation/archivage
- Documenter la strat√©gie

### 2. Ex√©cution

- Utiliser DETACH ... CONCURRENTLY en production
- Ajouter les contraintes CHECK avant attachement
- Effectuer les op√©rations pendant les p√©riodes creuses
- Tester sur un environnement de staging

### 3. Monitoring

- Surveiller la taille des partitions
- Alerter si une partition devient trop grosse
- Monitorer l'utilisation des partitions anciennes
- V√©rifier r√©guli√®rement les partitions orphelines

### 4. Sauvegarde

- Sauvegarder avant d√©tachement
- V√©rifier la sauvegarde avant suppression
- Conserver les archives selon la politique de l'entreprise
- Documenter l'emplacement des archives

---

## Conclusion

### Points Cl√©s √† Retenir

1. **D√©tachement** : D√©connecter une partition sans perdre les donn√©es
   - DETACH PARTITION standard : bloquant
   - DETACH PARTITION CONCURRENTLY : non-bloquant (PG 14+)

2. **Attachement** : Transformer une table en partition
   - N√©cessite compatibilit√© de structure
   - Ajoutez une contrainte CHECK pour √©viter le scan
   - Cr√©ez les index avant attachement

3. **Cas d'usage** :
   - Archivage et purge rapide
   - Maintenance sans impact
   - Import de donn√©es massives
   - Migration progressive

4. **Automatisation** : Indispensable en production
   - Scripts de cr√©ation anticip√©e
   - Scripts d'archivage automatique
   - Extension pg_partman pour gestion compl√®te

### Configuration Recommand√©e

```sql
-- Dans votre application ou scripts de maintenance

-- 1. Cr√©ation automatique des partitions futures
-- Cron quotidien : 0 2 * * *
SELECT create_monthly_partitions('ventes', CURRENT_DATE, 6);

-- 2. Archivage automatique
-- Cron mensuel : 0 3 1 * *
SELECT archive_old_partitions('ventes', 24);

-- 3. Maintenance
-- Cron hebdomadaire : 0 4 * * 0
VACUUM ANALYZE ventes;

-- 4. Monitoring
-- V√©rification quotidienne
SELECT * FROM v_partitions WHERE table_parent = 'ventes';
```

### Ressources

- [Documentation PostgreSQL - Table Partitioning](https://www.postgresql.org/docs/current/ddl-partitioning.html)
- [Extension pg_partman](https://github.com/pgpartman/pg_partman)

---

**Fin du Chapitre 11.4.3**

Vous ma√Ætrisez maintenant le d√©tachement et l'attachement de partitions, deux op√©rations essentielles pour g√©rer efficacement le cycle de vie des donn√©es dans une table partitionn√©e. Ces techniques vous permettent d'archiver, purger, maintenir et migrer des donn√©es sans interruption de service et avec des performances optimales.

Le partitionnement combin√© √† une gestion dynamique des partitions est un outil puissant pour g√©rer des tables de plusieurs t√©raoctets tout en maintenant d'excellentes performances.

‚è≠Ô∏è [Vues et Vues Mat√©rialis√©es : Refresh et indexation](/11-modelisation-avancee/05-vues-et-vues-materialisees.md)
