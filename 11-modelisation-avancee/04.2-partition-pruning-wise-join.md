üîù Retour au [Sommaire](/SOMMAIRE.md)

# 11.4.2. Partition Pruning et Partition-wise Join

## Introduction

Le **partitionnement** est une technique puissante pour g√©rer de grandes tables, mais son v√©ritable int√©r√™t r√©side dans les **optimisations** que PostgreSQL applique automatiquement lors de l'ex√©cution des requ√™tes. Les deux optimisations majeures sont :

1. **Partition Pruning** (√âlagage de partitions) : PostgreSQL √©limine les partitions non n√©cessaires
2. **Partition-wise Join** (Jointure par partition) : PostgreSQL joint les partitions correspondantes directement

Ces optimisations peuvent **transformer des requ√™tes qui prendraient des minutes en requ√™tes qui s'ex√©cutent en secondes**.

### Analogie Simple

Imaginez une biblioth√®que avec 1 million de livres :

**Sans partitionnement :**
```
Chercher un livre de 2024 = Parcourir 1 million de livres
```

**Avec partitionnement mais sans pruning :**
```
Livres organis√©s par ann√©e, mais on cherche quand m√™me partout
```

**Avec partitionnement ET pruning :**
```
Livres organis√©s par ann√©e ‚Üí Aller directement √† l'√©tag√®re 2024
Chercher parmi seulement 50 000 livres au lieu de 1 million
```

C'est exactement ce que fait le partition pruning : **√©liminer intelligemment les partitions inutiles**.

---

## Partie 1 : Partition Pruning (√âlagage de Partitions)

### Qu'est-ce que le Partition Pruning ?

Le **partition pruning** est le processus par lequel PostgreSQL analyse votre requ√™te et d√©termine quelles partitions il peut **ignorer compl√®tement** parce qu'elles ne peuvent pas contenir de donn√©es pertinentes.

### Exemple de Base

```sql
-- Table partitionn√©e par ann√©e
CREATE TABLE ventes (
    vente_id BIGSERIAL,
    date_vente DATE NOT NULL,
    client_id INTEGER,
    montant NUMERIC(10,2)
) PARTITION BY RANGE (date_vente);

-- Cr√©er 3 partitions
CREATE TABLE ventes_2023 PARTITION OF ventes
    FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');

CREATE TABLE ventes_2024 PARTITION OF ventes
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE ventes_2025 PARTITION OF ventes
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');

-- Ins√©rer des donn√©es
INSERT INTO ventes (date_vente, client_id, montant)
SELECT
    '2023-01-01'::date + (random() * 365)::integer,
    (random() * 10000)::integer,
    (random() * 1000)::numeric(10,2)
FROM generate_series(1, 1000000);  -- 1M de lignes en 2023

INSERT INTO ventes (date_vente, client_id, montant)
SELECT
    '2024-01-01'::date + (random() * 365)::integer,
    (random() * 10000)::integer,
    (random() * 1000)::numeric(10,2)
FROM generate_series(1, 1000000);  -- 1M de lignes en 2024

INSERT INTO ventes (date_vente, client_id, montant)
SELECT
    '2025-01-01'::date + (random() * 365)::integer,
    (random() * 10000)::integer,
    (random() * 1000)::numeric(10,2)
FROM generate_series(1, 1000000);  -- 1M de lignes en 2025
```

Nous avons maintenant **3 millions de lignes** r√©parties sur 3 partitions.

### Requ√™te Avec Partition Pruning

```sql
-- Chercher les ventes de juin 2024
EXPLAIN SELECT * FROM ventes
WHERE date_vente BETWEEN '2024-06-01' AND '2024-06-30';
```

**Plan d'ex√©cution :**
```
Seq Scan on ventes_2024 ventes
  Filter: (date_vente >= '2024-06-01'::date AND date_vente <= '2024-06-30'::date)
```

**Analyse :**
- PostgreSQL scanne **UNIQUEMENT** `ventes_2024`
- Les partitions `ventes_2023` et `ventes_2025` sont **compl√®tement ignor√©es**
- Au lieu de scanner 3M de lignes, on scanne seulement 1M
- **Performance multipli√©e par 3** gr√¢ce au pruning !

### Visualisation du Pruning

```
Requ√™te : WHERE date_vente BETWEEN '2024-06-01' AND '2024-06-30'

Sans Partition Pruning :
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ventes_2023 ‚îÇ  ‚îÇ ventes_2024 ‚îÇ  ‚îÇ ventes_2025 ‚îÇ
‚îÇ   (1M)      ‚îÇ  ‚îÇ   (1M)      ‚îÇ  ‚îÇ   (1M)      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚Üì                 ‚Üì                 ‚Üì
   Scanner          Scanner          Scanner
   (inutile)        (utile)         (inutile)

Avec Partition Pruning :
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ventes_2023 ‚îÇ  ‚îÇ ventes_2024 ‚îÇ  ‚îÇ ventes_2025 ‚îÇ
‚îÇ   (1M)      ‚îÇ  ‚îÇ   (1M)      ‚îÇ  ‚îÇ   (1M)      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚úó                 ‚Üì                 ‚úó
   Ignor√©e          Scanner           Ignor√©e
                    (utile)
```

---

## Comment Fonctionne le Partition Pruning ?

### Phase de Planification

Le partition pruning peut se produire √† **deux moments** :

1. **Plan-time pruning** : Pendant la phase de planification (avant ex√©cution)
2. **Run-time pruning** : Pendant l'ex√©cution (pour les param√®tres dynamiques)

### 1. Plan-Time Pruning (Pruning √† la Planification)

C'est le cas le plus courant et le plus efficace.

```sql
-- Requ√™te avec valeurs constantes
EXPLAIN ANALYZE SELECT * FROM ventes WHERE date_vente = '2024-05-15';
```

**Plan d'ex√©cution :**
```
Seq Scan on ventes_2024 ventes (actual time=0.015..25.367 rows=3 loops=1)
  Filter: (date_vente = '2024-05-15'::date)
  Rows Removed by Filter: 999997
Planning Time: 0.234 ms
Execution Time: 25.389 ms
```

**Ce qui s'est pass√© :**
1. PostgreSQL analyse la condition `date_vente = '2024-05-15'`
2. Il calcule que seule `ventes_2024` peut contenir cette date
3. Le plan g√©n√©r√© **ne mentionne m√™me pas** les autres partitions
4. Elles sont √©limin√©es **avant l'ex√©cution**

### 2. Run-Time Pruning (Pruning √† l'Ex√©cution)

N√©cessaire quand les valeurs de filtre ne sont pas connues √† la planification.

```sql
-- Requ√™te pr√©par√©e avec param√®tre
PREPARE ventes_mois(date) AS
    SELECT * FROM ventes WHERE date_vente = $1;

-- Ex√©cution avec diff√©rentes dates
EXECUTE ventes_mois('2024-06-15');
EXECUTE ventes_mois('2023-03-20');
EXECUTE ventes_mois('2025-09-10');
```

**Fonctionnement :**
1. Le plan est cr√©√© **une fois** sans conna√Ætre les valeurs
2. √Ä chaque ex√©cution, PostgreSQL √©limine les partitions **dynamiquement**
3. L√©g√®rement moins efficace que plan-time pruning, mais toujours tr√®s performant

---

## Cas o√π le Partition Pruning Fonctionne

### ‚úÖ 1. √âgalit√© Simple

```sql
-- Fonctionne parfaitement
SELECT * FROM ventes WHERE date_vente = '2024-05-15';
```

### ‚úÖ 2. Comparaisons de Plage

```sql
-- Fonctionne
SELECT * FROM ventes WHERE date_vente >= '2024-01-01';

-- Fonctionne
SELECT * FROM ventes WHERE date_vente < '2024-07-01';

-- Fonctionne
SELECT * FROM ventes WHERE date_vente BETWEEN '2024-03-01' AND '2024-03-31';
```

### ‚úÖ 3. Op√©rateurs IN

```sql
-- Fonctionne
SELECT * FROM ventes WHERE date_vente IN ('2024-01-15', '2024-02-20', '2024-03-10');
```

### ‚úÖ 4. Fonctions Immuables

```sql
-- Fonctionne (CURRENT_DATE est √©valu√© une fois)
SELECT * FROM ventes WHERE date_vente = CURRENT_DATE;

-- Fonctionne
SELECT * FROM ventes WHERE date_vente = DATE_TRUNC('month', CURRENT_DATE);
```

### ‚úÖ 5. Combinaisons avec AND

```sql
-- Fonctionne : pruning sur date_vente
SELECT * FROM ventes
WHERE date_vente = '2024-05-15'
  AND montant > 100;
```

---

## Cas o√π le Partition Pruning NE Fonctionne PAS (ou Mal)

### ‚ùå 1. OR sur Diff√©rentes Colonnes

```sql
-- Pruning impossible : conditions sur diff√©rentes colonnes
SELECT * FROM ventes
WHERE date_vente = '2024-05-15' OR montant > 1000;
```

**R√©sultat :** Toutes les partitions sont scann√©es car `montant > 1000` peut √™tre vrai n'importe o√π.

### ‚ùå 2. Fonctions Non-Immuables sur la Colonne de Partitionnement

```sql
-- Ne fonctionne PAS bien
SELECT * FROM ventes WHERE EXTRACT(YEAR FROM date_vente) = 2024;
```

**Probl√®me :** PostgreSQL ne peut pas facilement d√©terminer quelles partitions correspondent.

**Solution :** R√©√©crire la requ√™te :
```sql
-- ‚úÖ Fonctionne : pruning actif
SELECT * FROM ventes
WHERE date_vente >= '2024-01-01' AND date_vente < '2025-01-01';
```

### ‚ùå 3. Colonnes Non-Partitionn√©es dans le Filtre Principal

```sql
-- Pruning impossible
SELECT * FROM ventes WHERE client_id = 1001;
```

Si vous partitionnez par `date_vente` mais filtrez sur `client_id`, aucune partition ne peut √™tre √©limin√©e.

### ‚ö†Ô∏è 4. OR avec Plages qui Se Chevauchent

```sql
-- Pruning partiel seulement
SELECT * FROM ventes
WHERE date_vente = '2024-05-15' OR date_vente = '2025-06-20';
```

**R√©sultat :** Deux partitions scann√©es (`ventes_2024` et `ventes_2025`), ce qui est correct.

---

## V√©rifier le Partition Pruning avec EXPLAIN

### M√©thode 1 : EXPLAIN Simple

```sql
EXPLAIN SELECT * FROM ventes WHERE date_vente = '2024-06-15';
```

**Ce qu'il faut chercher :**
- Le nombre de partitions mentionn√©es dans le plan
- Si seule `ventes_2024` appara√Æt ‚Üí Pruning r√©ussi

### M√©thode 2 : EXPLAIN ANALYZE pour Confirmation

```sql
EXPLAIN ANALYZE SELECT * FROM ventes WHERE date_vente = '2024-06-15';
```

**Exemple de sortie :**
```
Seq Scan on ventes_2024 ventes (actual time=0.012..18.456 rows=2 loops=1)
  Filter: (date_vente = '2024-06-15'::date)
Planning Time: 0.123 ms
Execution Time: 18.478 ms
```

**Indicateurs de pruning efficace :**
- Une seule partition mentionn√©e
- Temps de planification faible
- Temps d'ex√©cution r√©duit

### M√©thode 3 : Comparer avec ONLY

```sql
-- Avec pruning automatique
EXPLAIN ANALYZE
SELECT COUNT(*) FROM ventes WHERE date_vente BETWEEN '2024-01-01' AND '2024-12-31';

-- Sans pruning (forcer le scan de la table parent uniquement)
EXPLAIN ANALYZE
SELECT COUNT(*) FROM ONLY ventes WHERE date_vente BETWEEN '2024-01-01' AND '2024-12-31';
```

La premi√®re requ√™te devrait √™tre **beaucoup plus rapide**.

---

## Configuration du Partition Pruning

### Param√®tre enable_partition_pruning

```sql
-- V√©rifier le statut (devrait √™tre ON par d√©faut)
SHOW enable_partition_pruning;
-- R√©sultat: on

-- D√©sactiver temporairement (pour tester)
SET enable_partition_pruning = off;

-- R√©activer
SET enable_partition_pruning = on;
```

**Note :** Il est **tr√®s rare** de vouloir d√©sactiver cette fonctionnalit√©. Elle est presque toujours b√©n√©fique.

### Param√®tre constraint_exclusion (Legacy)

Avant PostgreSQL 11, on utilisait `constraint_exclusion` pour un effet similaire.

```sql
-- V√©rification
SHOW constraint_exclusion;
-- Valeurs possibles: on, off, partition (recommand√©)

-- Configuration recommand√©e
SET constraint_exclusion = partition;
```

**Recommandation :** Laisser √† `partition` (par d√©faut depuis PG 11+).

---

## Partie 2 : Partition-wise Join

### Qu'est-ce qu'un Partition-wise Join ?

Un **partition-wise join** se produit quand PostgreSQL joint deux tables partitionn√©es **partition par partition** au lieu de joindre les tables enti√®res.

### Analogie

Imaginez deux biblioth√®ques organis√©es par ann√©e :

**Join classique :**
```
Comparer chaque livre de la biblioth√®que A
avec chaque livre de la biblioth√®que B
= Beaucoup de comparaisons inutiles
```

**Partition-wise join :**
```
Joindre les livres de 2024 de A avec les livres de 2024 de B
Joindre les livres de 2023 de A avec les livres de 2023 de B
etc.
= Comparaisons cibl√©es et efficaces
```

### Exemple de Configuration

```sql
-- Tables partitionn√©es de la m√™me mani√®re
CREATE TABLE commandes (
    commande_id BIGSERIAL,
    date_commande DATE NOT NULL,
    client_id INTEGER,
    montant NUMERIC(10,2)
) PARTITION BY RANGE (date_commande);

CREATE TABLE paiements (
    paiement_id BIGSERIAL,
    commande_id BIGINT,
    date_paiement DATE NOT NULL,
    montant_paye NUMERIC(10,2)
) PARTITION BY RANGE (date_paiement);

-- Partitions pour commandes
CREATE TABLE commandes_2024 PARTITION OF commandes
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE commandes_2025 PARTITION OF commandes
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');

-- Partitions pour paiements (m√™me structure)
CREATE TABLE paiements_2024 PARTITION OF paiements
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE paiements_2025 PARTITION OF paiements
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```

### Requ√™te avec Partition-wise Join

```sql
-- Activer partition-wise join
SET enable_partitionwise_join = on;

-- Jointure
EXPLAIN SELECT
    c.commande_id,
    c.date_commande,
    p.montant_paye
FROM commandes c
JOIN paiements p ON c.date_commande = p.date_paiement
WHERE c.date_commande >= '2024-01-01' AND c.date_commande < '2025-01-01';
```

**Plan d'ex√©cution (simplifi√©) :**
```
Append
  -> Hash Join
       Hash Cond: (c.date_commande = p.date_paiement)
       -> Seq Scan on commandes_2024 c
       -> Hash
            -> Seq Scan on paiements_2024 p
```

**Ce qui s'est pass√© :**
1. Partition pruning √©limine les partitions 2025
2. Partition-wise join joint directement `commandes_2024` avec `paiements_2024`
3. Pas besoin de traiter les donn√©es 2025 du tout

### Visualisation

```
Sans Partition-wise Join :
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  commandes    ‚îÇ     ‚îÇ  paiements    ‚îÇ
‚îÇ  (toutes les  ‚îÇ     ‚îÇ  (toutes les  ‚îÇ
‚îÇ   partitions) ‚îÇ ‚Üí‚Üí‚Üí ‚îÇ   partitions) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚Üì                     ‚Üì
    Joindre tout avec tout
    (co√ªteux)

Avec Partition-wise Join :
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ commandes_2024‚îÇ ‚Üí‚Üí‚Üí ‚îÇ paiements_2024‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚Üì                     ‚Üì
    Join cibl√© (rapide)

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ commandes_2025‚îÇ ‚Üí‚Üí‚Üí ‚îÇ paiements_2025‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚Üì                     ‚Üì
    Join cibl√© (rapide)
```

---

## Conditions pour Partition-wise Join

Pour qu'un partition-wise join soit possible, plusieurs conditions doivent √™tre r√©unies :

### ‚úÖ 1. Tables Partitionn√©es de Mani√®re Compatible

Les deux tables doivent √™tre partitionn√©es avec :
- La m√™me strat√©gie (RANGE, LIST ou HASH)
- Le m√™me nombre de partitions
- Les m√™mes bornes/valeurs de partition

```sql
-- Compatible : m√™me partitionnement
CREATE TABLE table_a (...) PARTITION BY RANGE (date_col);
CREATE TABLE table_b (...) PARTITION BY RANGE (date_col);

CREATE TABLE table_a_2024 PARTITION OF table_a
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
CREATE TABLE table_b_2024 PARTITION OF table_b
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
```

### ‚úÖ 2. Jointure sur la Colonne de Partitionnement

```sql
-- ‚úÖ Fonctionne
SELECT * FROM table_a a
JOIN table_b b ON a.date_col = b.date_col;

-- ‚ùå Ne fonctionne pas (join sur autre colonne)
SELECT * FROM table_a a
JOIN table_b b ON a.id = b.id;
```

### ‚úÖ 3. enable_partitionwise_join Activ√©

```sql
-- V√©rifier
SHOW enable_partitionwise_join;

-- Activer si n√©cessaire
SET enable_partitionwise_join = on;
```

**Note :** D√©sactiv√© par d√©faut pour des raisons de compatibilit√©, mais **recommand√© de l'activer** si vous utilisez le partitionnement.

---

## Avantages du Partition-wise Join

### 1. R√©duction de la M√©moire

**Sans partition-wise join :**
- La table compl√®te (toutes partitions) doit √™tre charg√©e en m√©moire pour la jointure
- Peut d√©passer la RAM disponible

**Avec partition-wise join :**
- Seule une partition √† la fois est trait√©e
- Empreinte m√©moire beaucoup plus faible

### 2. Parall√©lisation Possible

Chaque partition peut √™tre jointe en parall√®le :

```sql
-- Configuration
SET max_parallel_workers_per_gather = 4;
SET enable_partitionwise_join = on;

-- Jointure parall√®le sur partitions
EXPLAIN SELECT * FROM commandes c
JOIN paiements p ON c.date_commande = p.date_paiement;
```

**Plan d'ex√©cution :**
```
Gather
  Workers Planned: 4
  -> Parallel Append
       -> Parallel Hash Join
            -> Parallel Seq Scan on commandes_2024 c
            -> Parallel Hash
                 -> Parallel Seq Scan on paiements_2024 p
       -> Parallel Hash Join
            -> Parallel Seq Scan on commandes_2025 c_1
            -> Parallel Hash
                 -> Parallel Seq Scan on paiements_2025 p_1
```

Les partitions sont trait√©es **en parall√®le** par diff√©rents workers.

### 3. Am√©lioration des Performances

**Benchmark typique :**
```
Sans partition-wise join : 45 secondes
Avec partition-wise join : 12 secondes
Gain : ~73% plus rapide
```

---

## Partition-wise Aggregate

PostgreSQL supporte aussi les **agr√©gations par partition**.

### Concept

Au lieu d'agr√©ger toutes les donn√©es puis grouper, PostgreSQL agr√®ge chaque partition ind√©pendamment puis combine les r√©sultats.

### Exemple

```sql
-- Activer
SET enable_partitionwise_aggregate = on;

-- Agr√©gation
EXPLAIN SELECT
    DATE_TRUNC('month', date_vente) as mois,
    COUNT(*) as nb_ventes,
    SUM(montant) as total
FROM ventes
WHERE date_vente >= '2024-01-01' AND date_vente < '2025-01-01'
GROUP BY DATE_TRUNC('month', date_vente);
```

**Plan d'ex√©cution optimis√© :**
```
Finalize GroupAggregate
  Group Key: (date_trunc('month', date_vente))
  -> Gather Merge
       -> Partial GroupAggregate
            Group Key: (date_trunc('month', date_vente))
            -> Seq Scan on ventes_2024
```

Chaque partition calcule ses agr√©gats localement, puis ils sont fusionn√©s.

---

## Configuration Optimale

### Param√®tres √† Activer

```sql
-- Dans postgresql.conf ou via SET

-- Partition pruning (activ√© par d√©faut)
enable_partition_pruning = on

-- Partition-wise join (d√©sactiv√© par d√©faut)
enable_partitionwise_join = on

-- Partition-wise aggregate (d√©sactiv√© par d√©faut)
enable_partitionwise_aggregate = on

-- Constraint exclusion (pour compatibilit√© legacy)
constraint_exclusion = partition
```

### Configuration Recommand√©e pour Production

```sql
-- postgresql.conf
enable_partition_pruning = on
enable_partitionwise_join = on
enable_partitionwise_aggregate = on
constraint_exclusion = partition

-- Parall√©lisme (ajuster selon votre hardware)
max_parallel_workers_per_gather = 4
max_parallel_workers = 8
```

---

## Exemples Pratiques Complets

### Exemple 1 : E-Commerce avec Commandes et Lignes

```sql
-- Tables partitionn√©es
CREATE TABLE commandes (
    commande_id BIGSERIAL,
    date_commande DATE NOT NULL,
    client_id INTEGER
) PARTITION BY RANGE (date_commande);

CREATE TABLE lignes_commande (
    ligne_id BIGSERIAL,
    commande_id BIGINT,
    date_commande DATE NOT NULL,  -- D√©normalis√© pour partitionnement
    produit_id INTEGER,
    quantite INTEGER
) PARTITION BY RANGE (date_commande);

-- Partitions 2024
CREATE TABLE commandes_2024 PARTITION OF commandes
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE lignes_commande_2024 PARTITION OF lignes_commande
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

-- Partitions 2025
CREATE TABLE commandes_2025 PARTITION OF commandes
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');

CREATE TABLE lignes_commande_2025 PARTITION OF lignes_commande
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');

-- Activer les optimisations
SET enable_partition_pruning = on;
SET enable_partitionwise_join = on;

-- Requ√™te optimis√©e
EXPLAIN ANALYZE
SELECT
    c.commande_id,
    c.client_id,
    COUNT(l.ligne_id) as nb_produits,
    SUM(l.quantite) as quantite_totale
FROM commandes c
JOIN lignes_commande l ON c.commande_id = l.commande_id
    AND c.date_commande = l.date_commande  -- Important pour partition-wise join
WHERE c.date_commande >= '2024-06-01' AND c.date_commande < '2024-07-01'
GROUP BY c.commande_id, c.client_id;
```

**Optimisations appliqu√©es :**
1. ‚úÖ Partition pruning √©limine toutes les partitions sauf `commandes_2024` et `lignes_2024`
2. ‚úÖ Partition-wise join entre les deux partitions 2024
3. ‚úÖ Agr√©gation sur partition unique

### Exemple 2 : Logs avec M√©triques

```sql
-- Table de logs partitionn√©e
CREATE TABLE logs_app (
    log_id BIGSERIAL,
    timestamp TIMESTAMPTZ NOT NULL,
    user_id INTEGER,
    action VARCHAR(50),
    duree_ms INTEGER
) PARTITION BY RANGE (timestamp);

-- Partitions par semaine
CREATE TABLE logs_2025_w46 PARTITION OF logs_app
    FOR VALUES FROM ('2025-11-10') TO ('2025-11-17');

CREATE TABLE logs_2025_w47 PARTITION OF logs_app
    FOR VALUES FROM ('2025-11-17') TO ('2025-11-24');

-- Table m√©triques partitionn√©e pareil
CREATE TABLE metriques_app (
    metrique_id BIGSERIAL,
    timestamp TIMESTAMPTZ NOT NULL,
    cpu_percent NUMERIC(5,2),
    memory_mb INTEGER
) PARTITION BY RANGE (timestamp);

CREATE TABLE metriques_2025_w46 PARTITION OF metriques_app
    FOR VALUES FROM ('2025-11-10') TO ('2025-11-17');

CREATE TABLE metriques_2025_w47 PARTITION OF metriques_app
    FOR VALUES FROM ('2025-11-17') TO ('2025-11-24');

-- Requ√™te corr√©l√©e
SET enable_partition_pruning = on;
SET enable_partitionwise_join = on;

EXPLAIN ANALYZE
SELECT
    DATE_TRUNC('hour', l.timestamp) as heure,
    COUNT(l.log_id) as nb_actions,
    AVG(m.cpu_percent) as cpu_moyen
FROM logs_app l
JOIN metriques_app m ON DATE_TRUNC('minute', l.timestamp) = DATE_TRUNC('minute', m.timestamp)
WHERE l.timestamp >= '2025-11-15' AND l.timestamp < '2025-11-16'
GROUP BY DATE_TRUNC('hour', l.timestamp)
ORDER BY heure;
```

---

## Diagnostic et Troubleshooting

### Probl√®me 1 : Partition Pruning Ne Fonctionne Pas

**Sympt√¥mes :**
```sql
EXPLAIN SELECT * FROM ventes WHERE date_vente = '2024-05-15';
-- Affiche Append avec toutes les partitions
```

**Solutions :**

1. V√©rifier que `enable_partition_pruning` est ON :
```sql
SHOW enable_partition_pruning;
SET enable_partition_pruning = on;
```

2. V√©rifier la requ√™te (fonctions sur la colonne) :
```sql
-- ‚ùå Mauvais
WHERE EXTRACT(YEAR FROM date_vente) = 2024

-- ‚úÖ Bon
WHERE date_vente >= '2024-01-01' AND date_vente < '2025-01-01'
```

3. V√©rifier les statistiques :
```sql
ANALYZE ventes;
ANALYZE ventes_2024;
```

### Probl√®me 2 : Partition-wise Join Ne S'Active Pas

**Sympt√¥mes :**
```sql
EXPLAIN montre un Hash Join global au lieu de joins par partition
```

**Solutions :**

1. Activer le param√®tre :
```sql
SET enable_partitionwise_join = on;
```

2. V√©rifier que les partitions correspondent :
```sql
-- Lister les partitions de chaque table
SELECT
    parent.relname as table_parent,
    child.relname as partition,
    pg_get_expr(child.relpartbound, child.oid) as partition_bounds
FROM pg_inherits
JOIN pg_class parent ON pg_inherits.inhparent = parent.oid
JOIN pg_class child ON pg_inherits.inhrelid = child.oid
WHERE parent.relname IN ('commandes', 'paiements')
ORDER BY parent.relname, partition_bounds;
```

3. V√©rifier la jointure sur colonne de partitionnement :
```sql
-- ‚úÖ Bon
ON table_a.date_col = table_b.date_col

-- ‚ùå Mauvais (pas la colonne de partitionnement)
ON table_a.id = table_b.id
```

### Probl√®me 3 : Performances D√©grad√©es

**Sympt√¥mes :**
```
Les requ√™tes sont lentes malgr√© le partitionnement
```

**Checklist :**

1. Les index existent-ils sur chaque partition ?
```sql
-- Cr√©er index sur table parent (propage aux enfants)
CREATE INDEX idx_ventes_date ON ventes(date_vente);
```

2. Les statistiques sont-elles √† jour ?
```sql
ANALYZE ventes;
```

3. Y a-t-il trop de partitions ?
```sql
-- Compter les partitions
SELECT COUNT(*)
FROM pg_inherits i
JOIN pg_class c ON i.inhparent = c.oid
WHERE c.relname = 'ventes';

-- Si > 500 : probl√®me probable
```

4. La m√©moire est-elle suffisante ?
```sql
SHOW shared_buffers;
SHOW work_mem;
-- Augmenter si n√©cessaire
```

---

## Monitoring du Partition Pruning

### Requ√™te pour V√©rifier l'Utilisation des Partitions

```sql
-- Nombre de lignes par partition
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as taille,
    n_live_tup as lignes_actives,
    n_dead_tup as lignes_mortes,
    last_vacuum,
    last_autovacuum
FROM pg_stat_user_tables
WHERE tablename LIKE 'ventes_%'
ORDER BY tablename;
```

### Statistiques de Scan

```sql
-- Identifier les partitions les plus scann√©es
SELECT
    schemaname,
    tablename,
    seq_scan,
    seq_tup_read,
    idx_scan,
    idx_tup_fetch
FROM pg_stat_user_tables
WHERE tablename LIKE 'ventes_%'
ORDER BY seq_scan DESC;
```

**Interpr√©tation :**
- Partitions anciennes peu scann√©es ‚Üí Bon signe (donn√©es archiv√©es)
- Partition r√©cente tr√®s scann√©e ‚Üí Normal (donn√©es actives)
- Toutes les partitions √©galement scann√©es ‚Üí Probl√®me de pruning

---

## Bonnes Pratiques

### 1. Toujours Utiliser la Colonne de Partitionnement dans WHERE

```sql
-- ‚úÖ Bon
SELECT * FROM ventes
WHERE date_vente >= '2024-01-01'
  AND client_id = 1001;

-- ‚ö†Ô∏è Moins bon (pruning impossible)
SELECT * FROM ventes WHERE client_id = 1001;
```

### 2. Activer les Optimisations Partition-wise

```sql
-- Mettre dans postgresql.conf
enable_partitionwise_join = on
enable_partitionwise_aggregate = on
```

### 3. Cr√©er des Index sur Chaque Partition

```sql
-- Index sur table parent = index sur toutes les partitions
CREATE INDEX idx_ventes_client ON ventes(client_id);
CREATE INDEX idx_ventes_montant ON ventes(montant);
```

### 4. Maintenir les Statistiques

```sql
-- Apr√®s insertions massives
ANALYZE ventes;

-- Ou configurer autovacuum agressif
ALTER TABLE ventes SET (autovacuum_analyze_scale_factor = 0.05);
```

### 5. Documenter la Strat√©gie

```sql
COMMENT ON TABLE ventes IS
'Table partitionn√©e par RANGE sur date_vente.
Partitions mensuelles avec r√©tention de 2 ans.
Partition pruning actif pour requ√™tes avec filtre sur date_vente.
Partition-wise join disponible avec table paiements.';
```

### 6. Surveiller les Plans d'Ex√©cution

```sql
-- Cr√©er une fonction de monitoring
CREATE OR REPLACE FUNCTION check_partition_usage(table_name TEXT)
RETURNS TABLE(
    partition_name TEXT,
    scan_count BIGINT,
    rows_scanned BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        tablename::TEXT,
        seq_scan + idx_scan as scan_count,
        seq_tup_read + idx_tup_fetch as rows_scanned
    FROM pg_stat_user_tables
    WHERE tablename LIKE table_name || '_%'
    ORDER BY scan_count DESC;
END;
$$ LANGUAGE plpgsql;

-- Utilisation
SELECT * FROM check_partition_usage('ventes');
```

---

## Comparaison de Performances

### Benchmark : Avec vs Sans Partition Pruning

```sql
-- D√©sactiver pruning
SET enable_partition_pruning = off;

-- Requ√™te test
EXPLAIN ANALYZE
SELECT COUNT(*), AVG(montant)
FROM ventes
WHERE date_vente = '2024-06-15';

-- R√©sultat typique sans pruning:
-- Execution Time: 852.345 ms (scan de 3 partitions)

-- R√©activer pruning
SET enable_partition_pruning = on;

-- M√™me requ√™te
EXPLAIN ANALYZE
SELECT COUNT(*), AVG(montant)
FROM ventes
WHERE date_vente = '2024-06-15';

-- R√©sultat typique avec pruning:
-- Execution Time: 287.123 ms (scan de 1 partition)
-- Gain: 66% plus rapide
```

### Benchmark : Avec vs Sans Partition-wise Join

```sql
-- Sans partition-wise join
SET enable_partitionwise_join = off;

EXPLAIN ANALYZE
SELECT COUNT(*)
FROM commandes c
JOIN paiements p ON c.date_commande = p.date_paiement
WHERE c.date_commande >= '2024-01-01';

-- R√©sultat typique:
-- Execution Time: 1523.456 ms

-- Avec partition-wise join
SET enable_partitionwise_join = on;

EXPLAIN ANALYZE
SELECT COUNT(*)
FROM commandes c
JOIN paiements p ON c.date_commande = p.date_paiement
WHERE c.date_commande >= '2024-01-01';

-- R√©sultat typique:
-- Execution Time: 456.789 ms
-- Gain: 70% plus rapide
```

---

## Cas d'Usage Avanc√©s

### 1. Partition Pruning avec Sous-requ√™tes

```sql
-- Pruning fonctionne aussi dans les sous-requ√™tes
SELECT client_id, SUM(montant) as total
FROM ventes
WHERE date_vente IN (
    SELECT DISTINCT date_commande
    FROM commandes
    WHERE statut = 'validee'
    AND date_commande >= '2024-01-01'
)
GROUP BY client_id;
```

Le pruning s'applique √† la fois sur `ventes` et `commandes`.

### 2. Partition-wise Join avec Agr√©gation

```sql
SET enable_partitionwise_join = on;
SET enable_partitionwise_aggregate = on;

EXPLAIN ANALYZE
SELECT
    c.client_id,
    DATE_TRUNC('month', c.date_commande) as mois,
    COUNT(DISTINCT c.commande_id) as nb_commandes,
    SUM(l.quantite) as quantite_totale
FROM commandes c
JOIN lignes_commande l ON c.commande_id = l.commande_id
    AND c.date_commande = l.date_commande
WHERE c.date_commande >= '2024-01-01'
GROUP BY c.client_id, DATE_TRUNC('month', c.date_commande);
```

**Optimisations combin√©es :**
1. Partition pruning sur la p√©riode
2. Partition-wise join
3. Partition-wise aggregate
4. Possibilit√© de parall√©lisation

### 3. CTEs avec Partitionnement

```sql
WITH ventes_recentes AS (
    SELECT * FROM ventes
    WHERE date_vente >= CURRENT_DATE - INTERVAL '30 days'
)
SELECT
    DATE_TRUNC('day', date_vente) as jour,
    COUNT(*) as nb_ventes,
    SUM(montant) as total
FROM ventes_recentes
GROUP BY DATE_TRUNC('day', date_vente)
ORDER BY jour;
```

Le pruning fonctionne dans la CTE.

---

## Conclusion

### Points Cl√©s √† Retenir

1. **Partition Pruning** : PostgreSQL √©limine automatiquement les partitions inutiles
   - ‚úÖ Activ√© par d√©faut depuis PostgreSQL 11
   - ‚úÖ Fonctionne avec √©galit√©, plages, IN
   - ‚ö†Ô∏è √âviter les fonctions sur la colonne de partitionnement

2. **Partition-wise Join** : Jointures partition par partition
   - ‚ö†Ô∏è D√©sactiv√© par d√©faut ‚Üí Activer avec `enable_partitionwise_join = on`
   - ‚úÖ Requiert des partitions compatibles
   - ‚úÖ Gains majeurs sur grandes tables

3. **Partition-wise Aggregate** : Agr√©gations par partition
   - ‚ö†Ô∏è D√©sactiv√© par d√©faut ‚Üí Activer avec `enable_partitionwise_aggregate = on`
   - ‚úÖ Permet la parall√©lisation
   - ‚úÖ R√©duit l'empreinte m√©moire

4. **Monitoring** : Utilisez `EXPLAIN ANALYZE` pour v√©rifier
   - Nombre de partitions scann√©es
   - Type de join utilis√©
   - Temps d'ex√©cution

### Configuration Recommand√©e

```sql
-- postgresql.conf pour production avec partitionnement
enable_partition_pruning = on            # ON par d√©faut
enable_partitionwise_join = on           # OFF par d√©faut ‚Üí ACTIVER
enable_partitionwise_aggregate = on      # OFF par d√©faut ‚Üí ACTIVER
constraint_exclusion = partition         # Compatibilit√©

# Parall√©lisme (ajuster selon CPU)
max_parallel_workers_per_gather = 4
max_parallel_workers = 8
```

### Prochaines √âtapes

Dans la section suivante (11.4.3), nous verrons :
- D√©tachement et attachement de partitions
- Gestion automatis√©e (cr√©ation, archivage)
- Strat√©gies de maintenance

---

**Fin du Chapitre 11.4.2**

Vous ma√Ætrisez maintenant les optimisations cl√©s du partitionnement : le partition pruning (automatique) et le partition-wise join (√† activer). Ces techniques transforment le partitionnement d'un simple d√©coupage de donn√©es en un v√©ritable outil de performance. N'oubliez pas d'utiliser `EXPLAIN ANALYZE` pour v√©rifier que ces optimisations s'appliquent correctement √† vos requ√™tes !

‚è≠Ô∏è [D√©tachement et attachement de partitions](/11-modelisation-avancee/04.3-detachement-attachement-partitions.md)
