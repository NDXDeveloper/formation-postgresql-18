üîù Retour au [Sommaire](/SOMMAIRE.md)

# 11.4.1. Strat√©gies de partitionnement

## Introduction

Le **partitionnement** est une technique qui consiste √† diviser une grande table en plusieurs tables plus petites appel√©es **partitions**. Chaque partition contient un sous-ensemble des donn√©es selon des crit√®res d√©finis. Pour l'utilisateur et l'application, la table partitionn√©e reste transparente : on continue d'interroger la table principale, et PostgreSQL se charge automatiquement de diriger les requ√™tes vers les bonnes partitions.

### Pourquoi Partitionner ?

Imaginez une table avec **100 millions de lignes**. Sans partitionnement :
- Les recherches scannent potentiellement toute la table
- Les index deviennent √©normes et moins efficaces
- La maintenance (VACUUM, ANALYZE) prend √©norm√©ment de temps
- Les sauvegardes et restaurations sont lentes

Avec le partitionnement :
- ‚úÖ Les requ√™tes ne scannent que les partitions pertinentes
- ‚úÖ Les index sont plus petits et plus efficaces
- ‚úÖ La maintenance peut √™tre faite partition par partition
- ‚úÖ On peut archiver ou supprimer des partitions enti√®res rapidement
- ‚úÖ Les performances d'insertion peuvent √™tre am√©lior√©es

### Exemple Visuel

```
Sans partitionnement :
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         ventes (100M lignes)            ‚îÇ
‚îÇ  Toutes les donn√©es m√©lang√©es           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Avec partitionnement par ann√©e :
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         ventes (table parent)           ‚îÇ  ‚Üê Interface unifi√©e
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚Üì partitionn√©e en
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚Üì              ‚Üì           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇventes   ‚îÇ  ‚îÇventes   ‚îÇ  ‚îÇventes   ‚îÇ
‚îÇ2023     ‚îÇ  ‚îÇ2024     ‚îÇ  ‚îÇ2025     ‚îÇ
‚îÇ(30M)    ‚îÇ  ‚îÇ(35M)    ‚îÇ  ‚îÇ(35M)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Avantage :** Une requ√™te sur 2025 ne touche qu'une partition de 35M lignes au lieu de 100M.

---

## Les Trois Strat√©gies de Partitionnement

PostgreSQL propose trois strat√©gies principales de partitionnement, chacune adapt√©e √† des cas d'usage sp√©cifiques :

| Strat√©gie | Description | Cas d'usage typique |
|-----------|-------------|---------------------|
| **RANGE** | Partitionner par plage de valeurs | Dates, timestamps, s√©quences num√©riques |
| **LIST** | Partitionner par valeurs discr√®tes | Pays, statuts, cat√©gories fixes |
| **HASH** | Partitionner par hash de la cl√© | Distribution uniforme, pas de crit√®re naturel |

Chaque strat√©gie a ses forces et ses cas d'usage optimaux. Voyons-les en d√©tail.

---

## 1. Partitionnement par RANGE (Plage)

### Principe

Le partitionnement **RANGE** divise les donn√©es en fonction de **plages de valeurs** d'une colonne. C'est la strat√©gie la plus courante et la plus intuitive.

**Exemple conceptuel :**
```
Colonne date_commande :
‚îú‚îÄ Partition 1 : [2023-01-01 ‚Üí 2024-01-01)
‚îú‚îÄ Partition 2 : [2024-01-01 ‚Üí 2025-01-01)
‚îî‚îÄ Partition 3 : [2025-01-01 ‚Üí 2026-01-01)
```

Chaque ligne est dirig√©e vers la partition dont la plage contient sa valeur de date.

### Syntaxe

```sql
-- Cr√©er la table parent partitionn√©e
CREATE TABLE ventes (
    vente_id BIGSERIAL,
    date_vente DATE NOT NULL,
    client_id INTEGER,
    montant NUMERIC(10,2),
    produit_id INTEGER
) PARTITION BY RANGE (date_vente);
```

**Explication :**
- `PARTITION BY RANGE (date_vente)` : On partitionne selon la colonne `date_vente`
- La table `ventes` devient une table "parent" virtuelle
- Elle ne contient pas de donn√©es elle-m√™me
- Les donn√©es seront stock√©es dans les partitions

### Cr√©er les Partitions

```sql
-- Partition pour 2023
CREATE TABLE ventes_2023 PARTITION OF ventes
    FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');

-- Partition pour 2024
CREATE TABLE ventes_2024 PARTITION OF ventes
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

-- Partition pour 2025
CREATE TABLE ventes_2025 PARTITION OF ventes
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```

**Points importants :**
- `FOR VALUES FROM (min) TO (max)` d√©finit la plage **[min, max)**
- La borne inf√©rieure est **inclusive** (>=)
- La borne sup√©rieure est **exclusive** (<)
- Les plages **ne doivent pas se chevaucher**
- Il peut y avoir des "trous" (plages non couvertes)

### Insertion et Routage Automatique

```sql
-- Insertion : PostgreSQL route automatiquement vers la bonne partition
INSERT INTO ventes (date_vente, client_id, montant, produit_id) VALUES
    ('2023-06-15', 1001, 150.00, 5),   -- ‚Üí ventes_2023
    ('2024-03-20', 1002, 200.00, 8),   -- ‚Üí ventes_2024
    ('2025-11-10', 1003, 75.50, 12);   -- ‚Üí ventes_2025

-- V√©rification : les donn√©es sont bien dans les bonnes partitions
SELECT COUNT(*) FROM ventes_2023;  -- 1
SELECT COUNT(*) FROM ventes_2024;  -- 1
SELECT COUNT(*) FROM ventes_2025;  -- 1
```

**Magie :** Vous ins√©rez dans `ventes`, PostgreSQL d√©termine automatiquement la partition cible.

### Requ√™tes et Partition Pruning

Le **partition pruning** (√©lagage de partitions) est l'optimisation cl√© du partitionnement.

```sql
-- Requ√™te avec filtre sur la colonne de partitionnement
SELECT * FROM ventes WHERE date_vente = '2024-05-10';
```

**Plan d'ex√©cution :**
```
Seq Scan on ventes_2024
  Filter: (date_vente = '2024-05-10'::date)
```

PostgreSQL **scanne uniquement** `ventes_2024`, ignorant compl√®tement les autres partitions. Pas besoin de toucher aux 100M de lignes totales, juste aux 35M de 2024.

```sql
-- Requ√™te sur une plage
EXPLAIN SELECT * FROM ventes
WHERE date_vente >= '2024-01-01' AND date_vente < '2024-07-01';
```

**Plan d'ex√©cution :**
```
Append
  ->  Seq Scan on ventes_2024
        Filter: (date_vente >= '2024-01-01' AND date_vente < '2024-07-01')
```

Encore une fois, seule `ventes_2024` est scann√©e.

### Cas d'Usage Typiques de RANGE

#### 1. Partitionnement par Date/Timestamp

**Le cas le plus fr√©quent** : donn√©es chronologiques.

```sql
-- Logs d'application par mois
CREATE TABLE logs (
    log_id BIGSERIAL,
    timestamp TIMESTAMPTZ NOT NULL,
    niveau VARCHAR(10),
    message TEXT
) PARTITION BY RANGE (timestamp);

-- Cr√©er une partition par mois
CREATE TABLE logs_2025_01 PARTITION OF logs
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE TABLE logs_2025_02 PARTITION OF logs
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');

-- Et ainsi de suite...
```

**Avantages :**
- Archivage facile : supprimer `logs_2024_01` supprime janvier 2024 instantan√©ment
- Maintenance par partition : `VACUUM logs_2025_11` pour novembre seulement
- Requ√™tes temporelles ultra-rapides

#### 2. Partitionnement par S√©quence Num√©rique

```sql
-- Donn√©es IoT avec ID s√©quentiel
CREATE TABLE mesures_capteurs (
    mesure_id BIGSERIAL,
    capteur_id INTEGER,
    valeur NUMERIC(10,2),
    timestamp TIMESTAMPTZ
) PARTITION BY RANGE (mesure_id);

-- Partitions de 10 millions d'enregistrements
CREATE TABLE mesures_0_10m PARTITION OF mesures_capteurs
    FOR VALUES FROM (0) TO (10000000);

CREATE TABLE mesures_10m_20m PARTITION OF mesures_capteurs
    FOR VALUES FROM (10000000) TO (20000000);

CREATE TABLE mesures_20m_30m PARTITION OF mesures_capteurs
    FOR VALUES FROM (20000000) TO (30000000);
```

#### 3. Partitionnement par Score ou Valeur

```sql
-- Donn√©es de scoring client
CREATE TABLE clients (
    client_id SERIAL,
    nom VARCHAR(100),
    score_credit INTEGER CHECK (score_credit BETWEEN 300 AND 850)
) PARTITION BY RANGE (score_credit);

-- Partitions par cat√©gorie de score
CREATE TABLE clients_risque_eleve PARTITION OF clients
    FOR VALUES FROM (300) TO (580);  -- Mauvais score

CREATE TABLE clients_risque_moyen PARTITION OF clients
    FOR VALUES FROM (580) TO (670);  -- Score moyen

CREATE TABLE clients_risque_faible PARTITION OF clients
    FOR VALUES FROM (670) TO (850);  -- Bon score
```

### Gestion de la Partition par D√©faut

Que se passe-t-il si vous ins√©rez une valeur hors de toutes les plages d√©finies ?

```sql
-- Sans partition par d√©faut
INSERT INTO ventes (date_vente, montant) VALUES ('2026-05-10', 100.00);
-- ERREUR : no partition of relation "ventes" found for row
```

**Solution : Cr√©er une partition DEFAULT**

```sql
-- Partition fourre-tout pour les valeurs non couvertes
CREATE TABLE ventes_default PARTITION OF ventes DEFAULT;

-- Maintenant √ßa fonctionne
INSERT INTO ventes (date_vente, montant) VALUES ('2026-05-10', 100.00);
-- ‚Üí Ira dans ventes_default

INSERT INTO ventes (date_vente, montant) VALUES ('2022-03-15', 50.00);
-- ‚Üí Ira aussi dans ventes_default
```

**Usage :** Utile en d√©veloppement ou pour capturer les donn√©es inattendues, mais **√† √©viter en production** car elle peut devenir un goulot d'√©tranglement.

---

## 2. Partitionnement par LIST (Liste)

### Principe

Le partitionnement **LIST** divise les donn√©es en fonction de **valeurs discr√®tes sp√©cifiques** d'une colonne. Chaque partition contient un ensemble explicite de valeurs.

**Exemple conceptuel :**
```
Colonne pays :
‚îú‚îÄ Partition Europe : ['FR', 'DE', 'IT', 'ES', 'UK']
‚îú‚îÄ Partition Am√©rique : ['US', 'CA', 'MX', 'BR']
‚îî‚îÄ Partition Asie : ['JP', 'CN', 'IN', 'KR']
```

### Syntaxe

```sql
-- Table parent
CREATE TABLE commandes (
    commande_id BIGSERIAL,
    client_id INTEGER,
    pays_livraison VARCHAR(2),  -- Code pays ISO
    montant NUMERIC(10,2),
    date_commande DATE
) PARTITION BY LIST (pays_livraison);
```

### Cr√©er les Partitions

```sql
-- Partition pour l'Europe
CREATE TABLE commandes_europe PARTITION OF commandes
    FOR VALUES IN ('FR', 'DE', 'IT', 'ES', 'UK', 'BE', 'NL', 'PT');

-- Partition pour l'Am√©rique du Nord
CREATE TABLE commandes_amerique_nord PARTITION OF commandes
    FOR VALUES IN ('US', 'CA', 'MX');

-- Partition pour l'Asie
CREATE TABLE commandes_asie PARTITION OF commandes
    FOR VALUES IN ('JP', 'CN', 'IN', 'KR', 'TH', 'VN');

-- Partition pour l'Oc√©anie
CREATE TABLE commandes_oceanie PARTITION OF commandes
    FOR VALUES IN ('AU', 'NZ');
```

**Points cl√©s :**
- `FOR VALUES IN (...)` : Liste explicite des valeurs
- Une valeur ne peut appartenir qu'√† **une seule partition**
- Les valeurs peuvent √™tre des cha√Ænes, entiers, etc.

### Insertion et Routage

```sql
-- Insertions automatiquement rout√©es
INSERT INTO commandes (client_id, pays_livraison, montant) VALUES
    (1001, 'FR', 150.00),  -- ‚Üí commandes_europe
    (1002, 'US', 200.00),  -- ‚Üí commandes_amerique_nord
    (1003, 'JP', 350.00),  -- ‚Üí commandes_asie
    (1004, 'AU', 125.00);  -- ‚Üí commandes_oceanie
```

### Requ√™tes avec Partition Pruning

```sql
-- Requ√™te sur la France
SELECT * FROM commandes WHERE pays_livraison = 'FR';
-- Scanne UNIQUEMENT commandes_europe

-- Requ√™te sur l'Am√©rique du Nord
SELECT * FROM commandes WHERE pays_livraison IN ('US', 'CA');
-- Scanne UNIQUEMENT commandes_amerique_nord
```

### Cas d'Usage Typiques de LIST

#### 1. Partitionnement G√©ographique

```sql
-- Donn√©es utilisateurs par r√©gion
CREATE TABLE utilisateurs (
    utilisateur_id SERIAL,
    nom VARCHAR(100),
    email VARCHAR(255),
    region VARCHAR(20)
) PARTITION BY LIST (region);

CREATE TABLE utilisateurs_emea PARTITION OF utilisateurs
    FOR VALUES IN ('Europe', 'Moyen-Orient', 'Afrique');

CREATE TABLE utilisateurs_americas PARTITION OF utilisateurs
    FOR VALUES IN ('Amerique_Nord', 'Amerique_Sud');

CREATE TABLE utilisateurs_apac PARTITION OF utilisateurs
    FOR VALUES IN ('Asie_Pacifique');
```

**Avantages :**
- Conformit√© RGPD : donn√©es europ√©ennes physiquement s√©par√©es
- Backup par r√©gion
- Performance : queries r√©gionales ultra-rapides

#### 2. Partitionnement par Statut

```sql
-- Commandes par statut
CREATE TABLE commandes (
    commande_id BIGSERIAL,
    statut VARCHAR(20),
    montant NUMERIC(10,2),
    date_creation TIMESTAMPTZ
) PARTITION BY LIST (statut);

CREATE TABLE commandes_en_cours PARTITION OF commandes
    FOR VALUES IN ('en_attente', 'en_preparation', 'en_livraison');

CREATE TABLE commandes_terminees PARTITION OF commandes
    FOR VALUES IN ('livree', 'completee');

CREATE TABLE commandes_problemes PARTITION OF commandes
    FOR VALUES IN ('annulee', 'retournee', 'remboursee');
```

**Avantages :**
- Hot data (en cours) vs Cold data (termin√©es) s√©par√©es
- Index optimis√©s par type de statut
- Archivage facile des commandes termin√©es

#### 3. Partitionnement par Cat√©gorie

```sql
-- Produits par cat√©gorie
CREATE TABLE produits (
    produit_id SERIAL,
    nom VARCHAR(255),
    categorie VARCHAR(50),
    prix NUMERIC(10,2)
) PARTITION BY LIST (categorie);

CREATE TABLE produits_electronique PARTITION OF produits
    FOR VALUES IN ('ordinateurs', 'smartphones', 'tablettes', 'accessoires_tech');

CREATE TABLE produits_mode PARTITION OF produits
    FOR VALUES IN ('vetements', 'chaussures', 'accessoires_mode');

CREATE TABLE produits_maison PARTITION OF produits
    FOR VALUES IN ('meubles', 'decoration', 'electromenager');
```

#### 4. Partitionnement par Type de Client

```sql
-- Transactions par type de client
CREATE TABLE transactions (
    transaction_id BIGSERIAL,
    client_id INTEGER,
    type_client VARCHAR(20),
    montant NUMERIC(10,2)
) PARTITION BY LIST (type_client);

CREATE TABLE transactions_particuliers PARTITION OF transactions
    FOR VALUES IN ('particulier', 'individuel');

CREATE TABLE transactions_professionnels PARTITION OF transactions
    FOR VALUES IN ('pme', 'entreprise', 'grand_compte');

CREATE TABLE transactions_associations PARTITION OF transactions
    FOR VALUES IN ('association', 'ong', 'collectivite');
```

### Partition DEFAULT pour LIST

Comme avec RANGE, vous pouvez cr√©er une partition par d√©faut :

```sql
CREATE TABLE commandes_autres PARTITION OF commandes DEFAULT;

-- Toute commande avec un pays non list√© ira dans commandes_autres
INSERT INTO commandes (client_id, pays_livraison, montant) VALUES
    (1005, 'BR', 75.00);  -- ‚Üí commandes_autres (Br√©sil non list√©)
```

---

## 3. Partitionnement par HASH

### Principe

Le partitionnement **HASH** utilise une fonction de hachage sur une colonne pour distribuer les donn√©es **uniform√©ment** entre les partitions. Contrairement √† RANGE et LIST, la distribution n'est pas bas√©e sur la valeur r√©elle mais sur son hash.

**Exemple conceptuel :**
```
Colonne user_id :
Hash(user_id) modulo 4 :
‚îú‚îÄ Partition 0 : hash % 4 = 0
‚îú‚îÄ Partition 1 : hash % 4 = 1
‚îú‚îÄ Partition 2 : hash % 4 = 2
‚îî‚îÄ Partition 3 : hash % 4 = 3
```

### Syntaxe

```sql
-- Table parent
CREATE TABLE evenements (
    evenement_id BIGSERIAL,
    utilisateur_id INTEGER,
    type_evenement VARCHAR(50),
    timestamp TIMESTAMPTZ,
    donnees JSONB
) PARTITION BY HASH (utilisateur_id);
```

### Cr√©er les Partitions

```sql
-- 4 partitions avec distribution hash
CREATE TABLE evenements_p0 PARTITION OF evenements
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);

CREATE TABLE evenements_p1 PARTITION OF evenements
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);

CREATE TABLE evenements_p2 PARTITION OF evenements
    FOR VALUES WITH (MODULUS 4, REMAINDER 2);

CREATE TABLE evenements_p3 PARTITION OF evenements
    FOR VALUES WITH (MODULUS 4, REMAINDER 3);
```

**Explication :**
- `MODULUS 4` : Nombre total de partitions
- `REMAINDER 0,1,2,3` : Reste de la division du hash par 4
- Chaque partition re√ßoit environ 25% des donn√©es

### Distribution Automatique

```sql
-- Insertions distribu√©es automatiquement par hash
INSERT INTO evenements (utilisateur_id, type_evenement) VALUES
    (1001, 'connexion'),    -- Hash(1001) % 4 ‚Üí Partition X
    (1002, 'achat'),        -- Hash(1002) % 4 ‚Üí Partition Y
    (1003, 'deconnexion'),  -- Hash(1003) % 4 ‚Üí Partition Z
    (1004, 'consultation'); -- Hash(1004) % 4 ‚Üí Partition W
```

La distribution est **impr√©visible** pour l'humain mais **uniforme** statistiquement.

### Caract√©ristiques Importantes

#### 1. Distribution Uniforme

```sql
-- V√©rifier la distribution
SELECT
    tableoid::regclass AS partition,
    COUNT(*) AS nb_lignes
FROM evenements
GROUP BY tableoid::regclass
ORDER BY partition;
```

**R√©sultat typique (apr√®s insertion de beaucoup de donn√©es) :**
```
partition        | nb_lignes
-----------------+-----------
evenements_p0    | 251234
evenements_p1    | 249876
evenements_p2    | 250555
evenements_p3    | 248335
```

La distribution est √©quilibr√©e (~25% chacune).

#### 2. Pas de Partition Pruning par Plage

```sql
-- Cette requ√™te scanne TOUTES les partitions
SELECT * FROM evenements WHERE utilisateur_id = 1001;
```

PostgreSQL doit calculer le hash de 1001 et ne peut pas √©liminer de partitions par plage. Seule la partition contenant hash(1001) % 4 est scann√©e, mais il faut d'abord d√©terminer laquelle.

**Limitation :** Les requ√™tes par plage (`utilisateur_id BETWEEN 1000 AND 2000`) scannent toutes les partitions.

#### 3. Avantage : Parall√©lisation

Avec HASH, les donn√©es sont **naturellement distribu√©es**, ce qui permet :
- Parall√©lisation des √©critures (chaque partition est ind√©pendante)
- Load balancing entre partitions
- Pas de "hot partition" (partition surcharg√©e)

### Cas d'Usage Typiques de HASH

#### 1. Distribution de Charge (Load Balancing)

```sql
-- Sessions utilisateur avec forte concurrence
CREATE TABLE sessions (
    session_id UUID PRIMARY KEY,
    utilisateur_id INTEGER,
    data JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
) PARTITION BY HASH (utilisateur_id);

-- 8 partitions pour distribuer la charge
CREATE TABLE sessions_p0 PARTITION OF sessions
    FOR VALUES WITH (MODULUS 8, REMAINDER 0);
-- ... jusqu'√† p7
```

**Avantage :** Les √©critures sont distribu√©es uniform√©ment, r√©duisant la contention sur les index.

#### 2. Pas de Crit√®re de Partitionnement Naturel

```sql
-- Donn√©es sans dimension temporelle ou g√©ographique claire
CREATE TABLE metrics (
    metric_id BIGSERIAL,
    device_id VARCHAR(100),
    metric_name VARCHAR(50),
    value NUMERIC,
    timestamp TIMESTAMPTZ
) PARTITION BY HASH (device_id);

-- 16 partitions
CREATE TABLE metrics_p0 PARTITION OF metrics
    FOR VALUES WITH (MODULUS 16, REMAINDER 0);
-- ... jusqu'√† p15
```

**Cas d'usage :** IoT avec des milliards de devices sans structure pr√©visible.

#### 3. √âviter les Hot Spots

Dans certains syst√®mes, certaines valeurs (ex: user_id=1 pour l'admin) sont beaucoup plus fr√©quentes. HASH distribue ces "hot values" de mani√®re √©quilibr√©e.

```sql
-- Audit trail avec beaucoup d'actions de certains utilisateurs
CREATE TABLE audit_logs (
    log_id BIGSERIAL,
    user_id INTEGER,
    action VARCHAR(100),
    timestamp TIMESTAMPTZ
) PARTITION BY HASH (user_id);

-- Distribution hash emp√™che qu'un user_id populaire surcharge une partition
```

### Inconv√©nients de HASH

‚ùå **Pas de partition pruning par plage** : `WHERE user_id BETWEEN x AND y` scanne tout
‚ùå **Distribution opaque** : Difficile de savoir quelle partition contient quoi
‚ùå **Archivage complexe** : Pas de notion temporelle directe

---

## Comparaison des Strat√©gies

### Tableau R√©capitulatif

| Crit√®re | RANGE | LIST | HASH |
|---------|-------|------|------|
| **Cas d'usage principal** | Dates, s√©quences | Cat√©gories, r√©gions | Distribution uniforme |
| **Partition pruning** | ‚úÖ Excellent | ‚úÖ Excellent | ‚ö†Ô∏è Limit√© |
| **Distribution des donn√©es** | ‚ö†Ô∏è Variable | ‚ö†Ô∏è Variable | ‚úÖ Uniforme |
| **Archivage** | ‚úÖ Facile (par p√©riode) | ‚úÖ Facile (par cat√©gorie) | ‚ùå Difficile |
| **Maintenance** | ‚úÖ Par p√©riode | ‚úÖ Par cat√©gorie | ‚ö†Ô∏è Toutes partitions |
| **Ajout de partitions** | ‚úÖ Simple | ‚úÖ Simple | ‚ö†Ô∏è Complexe |
| **Requ√™tes par plage** | ‚úÖ Optimales | ‚ùå Scan complet | ‚ùå Scan complet |
| **Requ√™tes par √©galit√©** | ‚úÖ Rapide | ‚úÖ Tr√®s rapide | ‚úÖ Rapide |
| **Hot spots** | ‚ö†Ô∏è Possible | ‚ö†Ô∏è Possible | ‚úÖ √âvit√©s |
| **Complexit√©** | ‚≠ê‚≠ê Moyenne | ‚≠ê Simple | ‚≠ê‚≠ê‚≠ê Complexe |

### Arbre de D√©cision

```
Quel type de colonne utilisez-vous ?
‚îÇ
‚îú‚îÄ Date ou Timestamp ?
‚îÇ  ‚îî‚îÄ‚Üí RANGE (par jour/mois/ann√©e)
‚îÇ
‚îú‚îÄ Cat√©gories fixes (pays, statut, type) ?
‚îÇ  ‚îî‚îÄ‚Üí LIST
‚îÇ
‚îú‚îÄ Valeurs num√©riques s√©quentielles (ID, score) ?
‚îÇ  ‚îî‚îÄ‚Üí RANGE
‚îÇ
‚îú‚îÄ Pas de crit√®re naturel, besoin de distribution uniforme ?
‚îÇ  ‚îî‚îÄ‚Üí HASH
‚îÇ
‚îî‚îÄ Donn√©es √† forte concurrence ?
   ‚îî‚îÄ‚Üí HASH
```

---

## Sous-Partitionnement (Partitionnement Multi-Niveaux)

PostgreSQL permet de **combiner** les strat√©gies en cr√©ant des **sous-partitions**.

### Exemple : RANGE puis LIST

**Cas d'usage :** Commandes partitionn√©es par ann√©e, puis par r√©gion dans chaque ann√©e.

```sql
-- Table parent : partitionnement par RANGE sur l'ann√©e
CREATE TABLE commandes (
    commande_id BIGSERIAL,
    date_commande DATE NOT NULL,
    pays VARCHAR(2),
    montant NUMERIC(10,2)
) PARTITION BY RANGE (date_commande);

-- Partition 2024 (elle-m√™me partitionn√©e)
CREATE TABLE commandes_2024 PARTITION OF commandes
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01')
    PARTITION BY LIST (pays);

-- Sous-partitions de 2024 par r√©gion
CREATE TABLE commandes_2024_europe PARTITION OF commandes_2024
    FOR VALUES IN ('FR', 'DE', 'IT', 'ES', 'UK');

CREATE TABLE commandes_2024_amerique PARTITION OF commandes_2024
    FOR VALUES IN ('US', 'CA', 'MX');

CREATE TABLE commandes_2024_asie PARTITION OF commandes_2024
    FOR VALUES IN ('JP', 'CN', 'IN', 'KR');

-- Partition 2025 (pareil)
CREATE TABLE commandes_2025 PARTITION OF commandes
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01')
    PARTITION BY LIST (pays);

CREATE TABLE commandes_2025_europe PARTITION OF commandes_2025
    FOR VALUES IN ('FR', 'DE', 'IT', 'ES', 'UK');

CREATE TABLE commandes_2025_amerique PARTITION OF commandes_2025
    FOR VALUES IN ('US', 'CA', 'MX');

CREATE TABLE commandes_2025_asie PARTITION OF commandes_2025
    FOR VALUES IN ('JP', 'CN', 'IN', 'KR');
```

**Hi√©rarchie r√©sultante :**
```
commandes (parent)
‚îú‚îÄ commandes_2024
‚îÇ  ‚îú‚îÄ commandes_2024_europe
‚îÇ  ‚îú‚îÄ commandes_2024_amerique
‚îÇ  ‚îî‚îÄ commandes_2024_asie
‚îî‚îÄ commandes_2025
   ‚îú‚îÄ commandes_2025_europe
   ‚îú‚îÄ commandes_2025_amerique
   ‚îî‚îÄ commandes_2025_asie
```

### Requ√™tes avec Sous-Partitionnement

```sql
-- Requ√™te sur 2024 en Europe
SELECT * FROM commandes
WHERE date_commande >= '2024-01-01'
  AND date_commande < '2025-01-01'
  AND pays = 'FR';
```

**Partition pruning :**
- √âlimine commandes_2025 (date hors plage)
- Dans commandes_2024, √©limine amerique et asie (pays hors liste)
- Scanne UNIQUEMENT commandes_2024_europe

**Performance optimale !**

### Exemple : RANGE puis HASH

**Cas d'usage :** Logs partitionn√©s par mois, puis distribu√©s par hash pour √©quilibrer.

```sql
-- Table parent : RANGE sur le mois
CREATE TABLE logs (
    log_id BIGSERIAL,
    timestamp TIMESTAMPTZ NOT NULL,
    user_id INTEGER,
    message TEXT
) PARTITION BY RANGE (timestamp);

-- Partition novembre 2025 (sous-partitionn√©e par HASH)
CREATE TABLE logs_2025_11 PARTITION OF logs
    FOR VALUES FROM ('2025-11-01') TO ('2025-12-01')
    PARTITION BY HASH (user_id);

-- Sous-partitions hash dans novembre 2025
CREATE TABLE logs_2025_11_h0 PARTITION OF logs_2025_11
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);

CREATE TABLE logs_2025_11_h1 PARTITION OF logs_2025_11
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);

CREATE TABLE logs_2025_11_h2 PARTITION OF logs_2025_11
    FOR VALUES WITH (MODULUS 4, REMAINDER 2);

CREATE TABLE logs_2025_11_h3 PARTITION OF logs_2025_11
    FOR VALUES WITH (MODULUS 4, REMAINDER 3);
```

**Avantages :**
- Archivage facile par mois (RANGE)
- Distribution uniforme dans chaque mois (HASH)
- Parall√©lisation des √©critures

---

## Strat√©gies Avanc√©es et Consid√©rations

### 1. Taille Optimale des Partitions

**R√®gle g√©n√©rale :** Visez des partitions de **quelques gigaoctets √† quelques dizaines de gigaoctets**.

‚ùå **Trop petites** (< 1 GB) :
- Trop de partitions ‚Üí overhead du planificateur
- Gestion complexe
- B√©n√©fices limit√©s

‚ùå **Trop grandes** (> 100 GB) :
- Maintenance longue
- Peu de b√©n√©fice du partitionnement

‚úÖ **Id√©al** (5-50 GB) :
- Bon √©quilibre performance/gestion
- Index de taille raisonnable
- Maintenance rapide

### 2. Nombre de Partitions

**RANGE et LIST :**
- Quelques dizaines √† quelques centaines : OK
- Au-del√† de 1000 partitions : attention aux performances du planificateur

**HASH :**
- Choisir un nombre qui divise bien votre charge
- Puissances de 2 recommand√©es : 4, 8, 16, 32, 64
- Ne pas d√©passer 256 partitions sauf cas extr√™me

### 3. Choix de la Colonne de Partitionnement

‚úÖ **Bonne colonne :**
- Utilis√©e fr√©quemment dans les WHERE
- Distribution √©quilibr√©e (pour RANGE/LIST)
- Immuable (ne change pas apr√®s insertion)

‚ùå **Mauvaise colonne :**
- Rarement utilis√©e dans les filtres
- Distribution tr√®s d√©s√©quilibr√©e
- Peut changer (ex: statut qui √©volue)

### 4. Partitionnement et Performance d'√âcriture

**Impact positif :**
- ‚úÖ R√©duction de la contention sur les index
- ‚úÖ Parall√©lisation possible

**Impact n√©gatif potentiel :**
- ‚ö†Ô∏è Overhead de routage (g√©n√©ralement n√©gligeable)
- ‚ö†Ô∏è Plus d'index √† maintenir globalement

**En pratique :** L'impact sur les √©critures est g√©n√©ralement neutre ou l√©g√®rement positif.

---

## Exemples Pratiques par Secteur

### E-Commerce

```sql
-- Commandes : RANGE par date
CREATE TABLE commandes (
    commande_id BIGSERIAL,
    date_commande TIMESTAMPTZ NOT NULL,
    client_id INTEGER,
    montant NUMERIC(10,2)
) PARTITION BY RANGE (date_commande);

-- Partition par mois (conservation 2 ans)
CREATE TABLE commandes_2025_11 PARTITION OF commandes
    FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');
```

### Finance

```sql
-- Transactions : RANGE par date avec sous-partitionnement LIST par type
CREATE TABLE transactions (
    transaction_id BIGSERIAL,
    date_transaction DATE NOT NULL,
    type_transaction VARCHAR(20),
    montant NUMERIC(15,2)
) PARTITION BY RANGE (date_transaction);

CREATE TABLE transactions_2025_q4 PARTITION OF transactions
    FOR VALUES FROM ('2025-10-01') TO ('2026-01-01')
    PARTITION BY LIST (type_transaction);

CREATE TABLE transactions_2025_q4_debit PARTITION OF transactions_2025_q4
    FOR VALUES IN ('debit', 'retrait');

CREATE TABLE transactions_2025_q4_credit PARTITION OF transactions_2025_q4
    FOR VALUES IN ('credit', 'depot');
```

### T√©l√©communications

```sql
-- CDR (Call Detail Records) : HASH pour distribution
CREATE TABLE cdr (
    cdr_id BIGSERIAL,
    phone_number VARCHAR(20),
    call_timestamp TIMESTAMPTZ,
    duration INTEGER,
    cost NUMERIC(8,4)
) PARTITION BY HASH (phone_number);

-- 32 partitions pour 100M+ appels/jour
CREATE TABLE cdr_p0 PARTITION OF cdr
    FOR VALUES WITH (MODULUS 32, REMAINDER 0);
-- ... jusqu'√† p31
```

### IoT / Capteurs

```sql
-- Mesures : RANGE par timestamp
CREATE TABLE mesures (
    mesure_id BIGSERIAL,
    capteur_id INTEGER,
    timestamp TIMESTAMPTZ NOT NULL,
    valeur NUMERIC(10,4)
) PARTITION BY RANGE (timestamp);

-- Partition par jour avec r√©tention 90 jours
CREATE TABLE mesures_2025_11_20 PARTITION OF mesures
    FOR VALUES FROM ('2025-11-20 00:00:00') TO ('2025-11-21 00:00:00');
```

### SaaS Multi-Tenant

```sql
-- Donn√©es tenant : LIST par tenant_id ou HASH
CREATE TABLE tenant_data (
    data_id BIGSERIAL,
    tenant_id INTEGER,
    data JSONB,
    created_at TIMESTAMPTZ
) PARTITION BY LIST (tenant_id);

-- Un tenant important dans sa propre partition
CREATE TABLE tenant_data_1001 PARTITION OF tenant_data
    FOR VALUES IN (1001);

-- Petits tenants group√©s
CREATE TABLE tenant_data_small PARTITION OF tenant_data
    FOR VALUES IN (2001, 2002, 2003, 2004, 2005);
```

---

## Checklist de D√©cision

Avant de partitionner, r√©pondez √† ces questions :

### 1. Ai-je Besoin de Partitionner ?

- [ ] Ma table d√©passe 10 GB ?
- [ ] J'ai des probl√®mes de performance mesur√©s ?
- [ ] Je veux archiver/supprimer des donn√©es r√©guli√®rement ?
- [ ] J'ai besoin de maintenance granulaire ?

Si **NON** √† tout ‚Üí Pas besoin de partitionner

### 2. Quelle Strat√©gie ?

- [ ] Mes donn√©es ont une dimension temporelle ? ‚Üí **RANGE**
- [ ] Mes donn√©es ont des cat√©gories fixes ? ‚Üí **LIST**
- [ ] Je veux distribuer la charge uniform√©ment ? ‚Üí **HASH**
- [ ] J'ai deux dimensions (temps + r√©gion) ? ‚Üí **Sous-partitionnement**

### 3. Configuration

- [ ] Taille cible par partition : 5-50 GB
- [ ] Nombre de partitions : < 500 id√©alement
- [ ] Colonne immuable et fr√©quemment filtr√©e
- [ ] Plan de cr√©ation/archivage des partitions

---

## Conclusion

### Points Cl√©s √† Retenir

1. **RANGE** : Pour les donn√©es temporelles ou s√©quentielles
   - ‚úÖ Cas le plus fr√©quent
   - ‚úÖ Archivage facile
   - ‚úÖ Partition pruning excellent

2. **LIST** : Pour les cat√©gories et valeurs discr√®tes
   - ‚úÖ Distribution par r√©gion, statut, type
   - ‚úÖ S√©paration logique claire
   - ‚úÖ Gestion par m√©tier

3. **HASH** : Pour la distribution uniforme
   - ‚úÖ Pas de crit√®re naturel
   - ‚úÖ √âquilibrage de charge
   - ‚ö†Ô∏è Moins de partition pruning

4. **Sous-partitionnement** : Combiner les strat√©gies
   - ‚úÖ Maximum de flexibilit√©
   - ‚ö†Ô∏è Complexit√© accrue

### Recommandations G√©n√©rales

**Pour d√©buter :**
- Commencez par **RANGE sur une date** (le plus simple et fr√©quent)
- Cr√©ez vos partitions au fur et √† mesure (pas besoin de toutes les cr√©er d'avance)
- Testez avec des donn√©es r√©elles avant la production

**Pour optimiser :**
- Mesurez l'impact avec `EXPLAIN ANALYZE`
- Surveillez la distribution des donn√©es
- Ajustez la granularit√© des partitions selon les besoins

**Pour maintenir :**
- Automatisez la cr√©ation de partitions (voir chapitre 11.4.3)
- Planifiez l'archivage/suppression
- Documentez votre strat√©gie

### Prochaines √âtapes

Dans les sections suivantes du chapitre 11.4, nous verrons :
- **11.4.2** : Partition Pruning et optimisations
- **11.4.3** : D√©tachement et attachement de partitions
- Gestion automatis√©e du partitionnement

---

**Fin du Chapitre 11.4.1**

Vous ma√Ætrisez maintenant les trois strat√©gies de partitionnement de PostgreSQL. Choisissez celle qui correspond le mieux √† votre cas d'usage, et n'h√©sitez pas √† exp√©rimenter en environnement de d√©veloppement avant de d√©ployer en production.

‚è≠Ô∏è [Partition Pruning et Partition-wise Join](/11-modelisation-avancee/04.2-partition-pruning-wise-join.md)
