üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20bis.1.3 ‚Äî Foreign Data Wrappers pour la F√©d√©ration

## Introduction

Dans les chapitres pr√©c√©dents, nous avons vu que l'approche **Database per Service** isole les donn√©es de chaque microservice. Cette isolation apporte autonomie et scalabilit√©, mais cr√©e un nouveau d√©fi : **comment interroger des donn√©es r√©parties sur plusieurs bases de donn√©es ?**

Imaginons un responsable commercial qui souhaite un rapport croisant les donn√©es clients (base `users_db`), les commandes (base `orders_db`) et les produits (base `catalog_db`). Avec des bases s√©par√©es, impossible d'√©crire une simple jointure SQL.

C'est ici qu'interviennent les **Foreign Data Wrappers (FDW)** de PostgreSQL. Cette fonctionnalit√© puissante permet d'acc√©der √† des donn√©es externes ‚Äî qu'elles soient dans une autre base PostgreSQL, un fichier CSV, MySQL, Oracle, ou m√™me une API REST ‚Äî **comme s'il s'agissait de tables locales**.

Ce chapitre vous apprendra √† utiliser les FDW pour cr√©er une **f√©d√©ration de donn√©es** et r√©pondre aux besoins de reporting et d'int√©gration dans une architecture microservices.

---

## Qu'est-ce qu'un Foreign Data Wrapper ?

### D√©finition

Un **Foreign Data Wrapper** (litt√©ralement "enveloppe de donn√©es √©trang√®res") est un m√©canisme PostgreSQL qui permet de :

- Se connecter √† des sources de donn√©es externes
- Cr√©er des **tables √©trang√®res** (foreign tables) qui repr√©sentent ces donn√©es
- Interroger ces tables avec du SQL standard
- Dans certains cas, modifier les donn√©es distantes

### Analogie Simple

Pensez aux FDW comme √† des **traducteurs universels**. Vous parlez SQL √† PostgreSQL, et le FDW traduit vos requ√™tes dans le langage compris par la source externe (protocole PostgreSQL, MySQL, fichier CSV, API HTTP, etc.).

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    PostgreSQL Local                         ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ   SELECT * FROM foreign_users                               ‚îÇ
‚îÇ         ‚îÇ                                                   ‚îÇ
‚îÇ         ‚ñº                                                   ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                         ‚îÇ
‚îÇ   ‚îÇ Foreign Data  ‚îÇ                                         ‚îÇ
‚îÇ   ‚îÇ   Wrapper     ‚îÇ  ‚óÑ‚îÄ‚îÄ Traduit SQL vers protocole cible   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ
            ‚îÇ  Connexion r√©seau
            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Source de Donn√©es Externe                      ‚îÇ
‚îÇ         (PostgreSQL, MySQL, fichier, API, etc.)             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Le Standard SQL/MED

Les FDW impl√©mentent le standard **SQL/MED** (Management of External Data), une extension du standard SQL qui d√©finit comment acc√©der √† des donn√©es externes. PostgreSQL a √©t√© un pionnier dans l'impl√©mentation de ce standard.

---

## Architecture des Foreign Data Wrappers

### Les Composants

L'utilisation des FDW implique plusieurs objets PostgreSQL :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Hi√©rarchie FDW                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                             ‚îÇ
‚îÇ  1. EXTENSION          ‚îÄ‚îÄ‚ñ∫ Le code du wrapper               ‚îÇ
‚îÇ        ‚îÇ                   (postgres_fdw, file_fdw, etc.)   ‚îÇ
‚îÇ        ‚ñº                                                    ‚îÇ
‚îÇ  2. FOREIGN DATA       ‚îÄ‚îÄ‚ñ∫ Instance du wrapper configur√©e   ‚îÇ
‚îÇ     WRAPPER                                                 ‚îÇ
‚îÇ        ‚îÇ                                                    ‚îÇ
‚îÇ        ‚ñº                                                    ‚îÇ
‚îÇ  3. FOREIGN SERVER     ‚îÄ‚îÄ‚ñ∫ Connexion vers une source        ‚îÇ
‚îÇ        ‚îÇ                   (h√¥te, port, base de donn√©es)    ‚îÇ
‚îÇ        ‚ñº                                                    ‚îÇ
‚îÇ  4. USER MAPPING       ‚îÄ‚îÄ‚ñ∫ Credentials pour se connecter    ‚îÇ
‚îÇ        ‚îÇ                   (utilisateur/mot de passe)       ‚îÇ
‚îÇ        ‚ñº                                                    ‚îÇ
‚îÇ  5. FOREIGN TABLE      ‚îÄ‚îÄ‚ñ∫ Repr√©sentation locale d'une      ‚îÇ
‚îÇ                            table distante                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Explication de Chaque Composant

| Composant | R√¥le | Analogie |
|-----------|------|----------|
| **Extension** | Code qui sait communiquer avec un type de source | Le pilote d'imprimante |
| **Foreign Data Wrapper** | Instance configur√©e de l'extension | L'imprimante install√©e |
| **Foreign Server** | Adresse et param√®tres de la source | L'adresse IP de l'imprimante |
| **User Mapping** | Identifiants de connexion | Login/mot de passe pour l'imprimante |
| **Foreign Table** | Vue locale sur les donn√©es distantes | Le document √† imprimer |

---

## postgres_fdw : F√©d√©ration entre Bases PostgreSQL

Le cas d'usage le plus courant dans une architecture microservices est la f√©d√©ration entre plusieurs bases PostgreSQL. L'extension **postgres_fdw** est incluse dans PostgreSQL et optimis√©e pour ce sc√©nario.

### Sc√©nario : Base de Reporting Centralis√©e

Imaginons trois microservices avec leurs bases d√©di√©es :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  users_db   ‚îÇ     ‚îÇ  orders_db  ‚îÇ     ‚îÇ catalog_db   ‚îÇ
‚îÇ             ‚îÇ     ‚îÇ             ‚îÇ     ‚îÇ              ‚îÇ
‚îÇ - users     ‚îÇ     ‚îÇ - orders    ‚îÇ     ‚îÇ - products   ‚îÇ
‚îÇ - profiles  ‚îÇ     ‚îÇ - items     ‚îÇ     ‚îÇ - categories ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                   ‚îÇ                   ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ  reporting_db   ‚îÇ
                  ‚îÇ                 ‚îÇ
                  ‚îÇ Tables locales: ‚îÇ
                  ‚îÇ - reports       ‚îÇ
                  ‚îÇ - dashboards    ‚îÇ
                  ‚îÇ                 ‚îÇ
                  ‚îÇ Tables foreign: ‚îÇ
                  ‚îÇ - fdw_users     ‚îÇ
                  ‚îÇ - fdw_orders    ‚îÇ
                  ‚îÇ - fdw_products  ‚îÇ
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### √âtape 1 : Installer l'Extension

Connectez-vous √† la base de reporting et installez l'extension :

```sql
-- Sur la base reporting_db
CREATE EXTENSION IF NOT EXISTS postgres_fdw;
```

Cette commande charge le code n√©cessaire pour communiquer avec d'autres bases PostgreSQL.

### √âtape 2 : Cr√©er le Foreign Data Wrapper

```sql
-- G√©n√©ralement cr√©√© automatiquement avec l'extension,
-- mais on peut le faire explicitement :
CREATE FOREIGN DATA WRAPPER postgres_fdw_wrapper
    HANDLER postgres_fdw_handler
    VALIDATOR postgres_fdw_validator;
```

En pratique, l'extension `postgres_fdw` cr√©e automatiquement un wrapper nomm√© `postgres_fdw`, donc cette √©tape est souvent implicite.

### √âtape 3 : D√©finir les Serveurs Distants

Cr√©ez un serveur pour chaque base de donn√©es source :

```sql
-- Serveur pour la base users_db
CREATE SERVER users_server
    FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (
        host 'users-db.internal',      -- Hostname ou IP
        port '5432',                    -- Port PostgreSQL
        dbname 'users_db'               -- Nom de la base
    );

-- Serveur pour la base orders_db
CREATE SERVER orders_server
    FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (
        host 'orders-db.internal',
        port '5432',
        dbname 'orders_db'
    );

-- Serveur pour la base catalog_db
CREATE SERVER catalog_server
    FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (
        host 'catalog-db.internal',
        port '5432',
        dbname 'catalog_db'
    );
```

### √âtape 4 : Configurer les User Mappings

Les user mappings associent un utilisateur local √† des credentials sur le serveur distant :

```sql
-- Mapping pour l'utilisateur reporting_user vers users_server
CREATE USER MAPPING FOR reporting_user
    SERVER users_server
    OPTIONS (
        user 'readonly_user',           -- Utilisateur sur la base distante
        password 'secure_password_123'  -- Mot de passe
    );

-- Mapping pour orders_server
CREATE USER MAPPING FOR reporting_user
    SERVER orders_server
    OPTIONS (
        user 'readonly_user',
        password 'secure_password_456'
    );

-- Mapping pour catalog_server
CREATE USER MAPPING FOR reporting_user
    SERVER catalog_server
    OPTIONS (
        user 'readonly_user',
        password 'secure_password_789'
    );
```

**Bonne pratique de s√©curit√©** : Utilisez des comptes en lecture seule (`readonly_user`) sur les bases sources pour √©viter toute modification accidentelle.

### √âtape 5 : Cr√©er les Tables √âtrang√®res

#### M√©thode Manuelle

D√©finissez chaque table √©trang√®re explicitement :

```sql
-- Table √©trang√®re pour les utilisateurs
CREATE FOREIGN TABLE fdw_users (
    id              INTEGER,
    email           VARCHAR(255),
    name            VARCHAR(100),
    created_at      TIMESTAMPTZ,
    country         VARCHAR(2)
)
SERVER users_server
OPTIONS (
    schema_name 'public',      -- Sch√©ma sur la base distante
    table_name 'users'         -- Nom de la table distante
);

-- Table √©trang√®re pour les commandes
CREATE FOREIGN TABLE fdw_orders (
    id              INTEGER,
    user_id         INTEGER,
    total           NUMERIC(10,2),
    status          VARCHAR(20),
    created_at      TIMESTAMPTZ
)
SERVER orders_server
OPTIONS (
    schema_name 'public',
    table_name 'orders'
);

-- Table √©trang√®re pour les produits
CREATE FOREIGN TABLE fdw_products (
    id              INTEGER,
    name            VARCHAR(255),
    category_id     INTEGER,
    price           NUMERIC(10,2),
    stock           INTEGER
)
SERVER catalog_server
OPTIONS (
    schema_name 'public',
    table_name 'products'
);
```

#### M√©thode Automatique : IMPORT FOREIGN SCHEMA

Pour importer automatiquement toutes les tables d'un sch√©ma distant :

```sql
-- Cr√©er un sch√©ma local pour organiser les tables import√©es
CREATE SCHEMA users_remote;

-- Importer toutes les tables du sch√©ma public distant
IMPORT FOREIGN SCHEMA public
    FROM SERVER users_server
    INTO users_remote;

-- Importer seulement certaines tables
IMPORT FOREIGN SCHEMA public
    LIMIT TO (orders, order_items)
    FROM SERVER orders_server
    INTO orders_remote;

-- Exclure certaines tables
IMPORT FOREIGN SCHEMA public
    EXCEPT (internal_logs, temp_data)
    FROM SERVER catalog_server
    INTO catalog_remote;
```

### √âtape 6 : Interroger les Donn√©es F√©d√©r√©es

Une fois configur√©es, les tables √©trang√®res s'utilisent comme des tables normales :

```sql
-- Requ√™te simple sur une table distante
SELECT id, email, name
FROM fdw_users
WHERE country = 'FR';

-- Jointure entre tables de diff√©rentes bases !
SELECT
    u.name AS customer_name,
    u.email,
    o.id AS order_id,
    o.total,
    o.created_at AS order_date
FROM fdw_users u
JOIN fdw_orders o ON o.user_id = u.id
WHERE o.created_at > NOW() - INTERVAL '30 days'
ORDER BY o.total DESC
LIMIT 100;

-- Jointure complexe avec trois sources
SELECT
    u.name AS customer,
    p.name AS product,
    oi.quantity,
    oi.unit_price,
    o.created_at
FROM fdw_users u
JOIN fdw_orders o ON o.user_id = u.id
JOIN fdw_order_items oi ON oi.order_id = o.id
JOIN fdw_products p ON p.id = oi.product_id
WHERE o.status = 'completed'
AND o.created_at BETWEEN '2025-01-01' AND '2025-03-31';
```

---

## Optimisation des Performances

### Le Pushdown : D√©l√©guer le Travail

L'un des avantages majeurs de `postgres_fdw` est le **pushdown** : PostgreSQL envoie certaines op√©rations au serveur distant au lieu de tout rapatrier localement.

#### Types de Pushdown Support√©s

| Op√©ration | Pushdown | Description |
|-----------|----------|-------------|
| **WHERE** | ‚úÖ Oui | Les filtres sont envoy√©s au serveur distant |
| **ORDER BY** | ‚úÖ Oui | Le tri est effectu√© √† distance |
| **LIMIT** | ‚úÖ Oui | Seules les lignes n√©cessaires sont transf√©r√©es |
| **JOIN** | ‚ö†Ô∏è Partiel | Jointures entre tables du m√™me serveur |
| **Agr√©gations** | ‚úÖ Oui (PG 10+) | COUNT, SUM, AVG ex√©cut√©s √† distance |
| **UPDATE/DELETE** | ‚úÖ Oui | Modifications possibles si configur√© |

#### Exemple de Pushdown

```sql
-- Cette requ√™te...
SELECT * FROM fdw_orders
WHERE status = 'pending'
AND created_at > '2025-01-01'
ORDER BY created_at DESC
LIMIT 10;

-- ...est transform√©e et envoy√©e au serveur distant comme :
-- SELECT * FROM orders
-- WHERE status = 'pending'
-- AND created_at > '2025-01-01'
-- ORDER BY created_at DESC
-- LIMIT 10;

-- Seules 10 lignes traversent le r√©seau !
```

### V√©rifier le Pushdown avec EXPLAIN

Utilisez `EXPLAIN VERBOSE` pour voir ce qui est envoy√© au serveur distant :

```sql
EXPLAIN VERBOSE
SELECT * FROM fdw_orders
WHERE status = 'pending'
LIMIT 10;
```

R√©sultat (simplifi√©) :

```
Foreign Scan on fdw_orders
  Output: id, user_id, total, status, created_at
  Remote SQL: SELECT id, user_id, total, status, created_at
              FROM public.orders
              WHERE (status = 'pending')
              LIMIT 10
```

La ligne `Remote SQL` montre exactement la requ√™te envoy√©e au serveur distant.

### Options d'Optimisation du Serveur

```sql
-- Activer le pushdown des agr√©gations et jointures
ALTER SERVER orders_server OPTIONS (
    ADD fetch_size '1000',           -- Lignes par batch (d√©faut: 100)
    ADD use_remote_estimate 'true',  -- Utiliser les stats distantes
    ADD fdw_startup_cost '100',      -- Co√ªt de d√©marrage estim√©
    ADD fdw_tuple_cost '0.01'        -- Co√ªt par ligne estim√©
);
```

| Option | Description |
|--------|-------------|
| `fetch_size` | Nombre de lignes r√©cup√©r√©es par batch r√©seau |
| `use_remote_estimate` | Utilise `EXPLAIN` distant pour estimer les co√ªts |
| `fdw_startup_cost` | Co√ªt fixe d'initialisation de la connexion |
| `fdw_tuple_cost` | Co√ªt par ligne transf√©r√©e |

### Strat√©gies pour Am√©liorer les Performances

#### 1. Cr√©er des Index sur les Tables Sources

Les FDW b√©n√©ficient des index sur les bases distantes :

```sql
-- Sur la base orders_db (source)
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_created_at ON orders(created_at);
```

#### 2. Utiliser des Vues Mat√©rialis√©es pour le Cache

Pour les donn√©es qui ne changent pas souvent :

```sql
-- Cr√©er une vue mat√©rialis√©e des donn√©es f√©d√©r√©es
CREATE MATERIALIZED VIEW mv_sales_summary AS
SELECT
    date_trunc('day', o.created_at) AS day,
    COUNT(*) AS order_count,
    SUM(o.total) AS revenue,
    COUNT(DISTINCT o.user_id) AS unique_customers
FROM fdw_orders o
WHERE o.status = 'completed'
GROUP BY date_trunc('day', o.created_at);

-- Index pour acc√©l√©rer les requ√™tes sur la vue
CREATE INDEX idx_mv_sales_day ON mv_sales_summary(day);

-- Rafra√Æchir p√©riodiquement (via pg_cron par exemple)
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_sales_summary;
```

#### 3. Limiter les Colonnes S√©lectionn√©es

```sql
-- ‚ùå √âviter : transf√®re toutes les colonnes
SELECT * FROM fdw_orders WHERE status = 'pending';

-- ‚úÖ Pr√©f√©rer : ne transf√®re que le n√©cessaire
SELECT id, user_id, total
FROM fdw_orders
WHERE status = 'pending';
```

#### 4. Filtrer au Maximum

```sql
-- ‚ùå Filtre c√¥t√© local (apr√®s transfert)
SELECT * FROM fdw_orders o
WHERE o.id IN (SELECT order_id FROM local_flagged_orders);

-- ‚úÖ Filtre push√© vers le distant si possible
SELECT * FROM fdw_orders o
WHERE o.status = 'pending'
AND o.created_at > NOW() - INTERVAL '7 days';
```

---

## Autres Foreign Data Wrappers Utiles

PostgreSQL dispose d'un √©cosyst√®me riche de FDW pour se connecter √† diverses sources.

### file_fdw : Fichiers CSV et Texte

Inclus dans PostgreSQL, permet de lire des fichiers comme des tables.

```sql
-- Installer l'extension
CREATE EXTENSION file_fdw;

-- Cr√©er le serveur (local)
CREATE SERVER file_server FOREIGN DATA WRAPPER file_fdw;

-- Table √©trang√®re pour un fichier CSV
CREATE FOREIGN TABLE import_products (
    sku         VARCHAR(50),
    name        VARCHAR(255),
    price       NUMERIC(10,2),
    category    VARCHAR(100)
)
SERVER file_server
OPTIONS (
    filename '/data/imports/products.csv',
    format 'csv',
    header 'true',
    delimiter ','
);

-- Interroger le fichier comme une table
SELECT * FROM import_products WHERE price > 100;
```

**Cas d'usage** : Import de donn√©es, int√©gration de fichiers de configuration, logs.

### mysql_fdw : Connexion √† MySQL/MariaDB

Extension communautaire pour acc√©der √† des bases MySQL.

```sql
-- Installer (n√©cessite compilation ou package)
CREATE EXTENSION mysql_fdw;

-- Serveur MySQL
CREATE SERVER mysql_server
    FOREIGN DATA WRAPPER mysql_fdw
    OPTIONS (
        host 'mysql.internal',
        port '3306'
    );

-- User mapping
CREATE USER MAPPING FOR reporting_user
    SERVER mysql_server
    OPTIONS (
        username 'mysql_readonly',
        password 'mysql_password'
    );

-- Table √©trang√®re
CREATE FOREIGN TABLE legacy_customers (
    id          INTEGER,
    name        VARCHAR(255),
    email       VARCHAR(255)
)
SERVER mysql_server
OPTIONS (
    dbname 'legacy_db',
    table_name 'customers'
);
```

**Cas d'usage** : Migration progressive de MySQL vers PostgreSQL, f√©d√©ration avec syst√®mes legacy.

### oracle_fdw : Connexion √† Oracle

Pour les entreprises ayant des syst√®mes Oracle existants.

```sql
CREATE EXTENSION oracle_fdw;

CREATE SERVER oracle_server
    FOREIGN DATA WRAPPER oracle_fdw
    OPTIONS (dbserver '//oracle.internal:1521/ORCL');

CREATE USER MAPPING FOR reporting_user
    SERVER oracle_server
    OPTIONS (user 'oracle_user', password 'oracle_pwd');

CREATE FOREIGN TABLE oracle_invoices (
    invoice_id      INTEGER,
    customer_id     INTEGER,
    amount          NUMERIC(15,2),
    invoice_date    DATE
)
SERVER oracle_server
OPTIONS (schema 'BILLING', table 'INVOICES');
```

### mongo_fdw : Connexion √† MongoDB

Pour int√©grer des donn√©es NoSQL.

```sql
CREATE EXTENSION mongo_fdw;

CREATE SERVER mongo_server
    FOREIGN DATA WRAPPER mongo_fdw
    OPTIONS (address 'mongo.internal', port '27017');

CREATE USER MAPPING FOR reporting_user
    SERVER mongo_server
    OPTIONS (username 'mongo_user', password 'mongo_pwd');

CREATE FOREIGN TABLE mongo_events (
    _id             NAME,
    event_type      TEXT,
    payload         JSONB,
    timestamp       TIMESTAMPTZ
)
SERVER mongo_server
OPTIONS (database 'events_db', collection 'events');
```

### Tableau R√©capitulatif des FDW

| FDW | Source | Inclus | Cas d'usage |
|-----|--------|--------|-------------|
| `postgres_fdw` | PostgreSQL | ‚úÖ Oui | F√©d√©ration microservices |
| `file_fdw` | CSV, texte | ‚úÖ Oui | Import fichiers |
| `mysql_fdw` | MySQL/MariaDB | ‚ùå Non | Migration, legacy |
| `oracle_fdw` | Oracle | ‚ùå Non | Int√©gration enterprise |
| `mongo_fdw` | MongoDB | ‚ùå Non | Donn√©es NoSQL |
| `redis_fdw` | Redis | ‚ùå Non | Cache, sessions |
| `sqlite_fdw` | SQLite | ‚ùå Non | Bases embarqu√©es |
| `multicorn` | Python (custom) | ‚ùå Non | APIs, sources custom |

---

## Gestion des √âcritures Distantes

Par d√©faut, les tables √©trang√®res sont en lecture seule. Mais `postgres_fdw` supporte les √©critures si configur√©.

### Activer les √âcritures

```sql
-- Sur la table √©trang√®re
ALTER FOREIGN TABLE fdw_orders
    OPTIONS (ADD updatable 'true');
```

### Exemples d'√âcritures

```sql
-- Insertion
INSERT INTO fdw_orders (user_id, total, status)
VALUES (42, 99.99, 'pending');

-- Mise √† jour
UPDATE fdw_orders
SET status = 'shipped'
WHERE id = 1001;

-- Suppression
DELETE FROM fdw_orders
WHERE status = 'cancelled'
AND created_at < NOW() - INTERVAL '1 year';
```

### Avertissements sur les √âcritures

| Risque | Description |
|--------|-------------|
| **Pas de transaction distribu√©e** | L'√©criture locale et distante ne sont pas atomiques |
| **Performance** | Les √©critures distantes sont plus lentes |
| **Couplage** | Cr√©e une d√©pendance directe vers le service distant |
| **S√©curit√©** | N√©cessite des droits d'√©criture sur la base source |

**Recommandation** : Dans une architecture microservices, pr√©f√©rez les **APIs ou √©v√©nements** pour modifier les donn√©es d'un autre service. R√©servez les FDW √† la **lecture** pour le reporting.

---

## Patterns d'Architecture avec FDW

### Pattern 1 : Base de Reporting D√©di√©e

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇService A ‚îÇ ‚îÇService B ‚îÇ ‚îÇService C ‚îÇ
‚îÇ  (OLTP)  ‚îÇ ‚îÇ  (OLTP)  ‚îÇ ‚îÇ  (OLTP)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ            ‚îÇ            ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ FDW (lecture seule)
                  ‚ñº
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ  Reporting DB  ‚îÇ
         ‚îÇ    (OLAP)      ‚îÇ
         ‚îÇ                ‚îÇ
         ‚îÇ - Vues mat√©r.  ‚îÇ
         ‚îÇ - Agr√©gations  ‚îÇ
         ‚îÇ - Dashboards   ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Avantages** :
- Isolation des requ√™tes analytiques lourdes
- Pas d'impact sur les bases OLTP
- Consolidation des donn√©es pour BI

### Pattern 2 : Migration Progressive

Lors d'une migration de monolithe vers microservices :

```
Phase 1: Monolithe avec toutes les donn√©es
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ        monolith_db          ‚îÇ
         ‚îÇ  users | orders | products  ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Phase 2: Extraction du service Users
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ  users_db   ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ Nouveau service
         ‚îÇ   (users)   ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚îÇ FDW
                ‚ñº
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ        monolith_db             ‚îÇ
         ‚îÇ  fdw_users | orders | products ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         Le monolithe acc√®de aux users via FDW

Phase 3: Tous les services extraits
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇusers_db ‚îÇ ‚îÇorders_db ‚îÇ ‚îÇcatalog_ ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ   db    ‚îÇ
                                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Pattern 3 : F√©d√©ration Multi-Cloud

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         AWS                                 ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                           ‚îÇ
‚îÇ   ‚îÇ PostgreSQL  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                 ‚îÇ
‚îÇ   ‚îÇ   (RDS)     ‚îÇ         ‚îÇ                                 ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ FDW
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        GCP‚îÇ                                ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ                                 ‚îÇ
‚îÇ   ‚îÇ PostgreSQL  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                                 ‚îÇ
‚îÇ   ‚îÇ (Cloud SQL) ‚îÇ         ‚îÇ                                 ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ Reporting Hub ‚îÇ
                    ‚îÇ  (On-premise) ‚îÇ
                    ‚îÇ               ‚îÇ
                    ‚îÇ Consolide les ‚îÇ
                    ‚îÇ donn√©es des   ‚îÇ
                    ‚îÇ deux clouds   ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## S√©curit√© des Foreign Data Wrappers

### Bonnes Pratiques

#### 1. Utilisateurs en Lecture Seule

Cr√©ez des comptes d√©di√©s sur les bases sources :

```sql
-- Sur la base source (orders_db)
CREATE ROLE fdw_readonly WITH LOGIN PASSWORD 'strong_password';

-- Donner uniquement les droits SELECT
GRANT CONNECT ON DATABASE orders_db TO fdw_readonly;
GRANT USAGE ON SCHEMA public TO fdw_readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO fdw_readonly;

-- Pour les futures tables
ALTER DEFAULT PRIVILEGES IN SCHEMA public
    GRANT SELECT ON TABLES TO fdw_readonly;
```

#### 2. Chiffrement des Connexions

Activez SSL pour les connexions FDW :

```sql
CREATE SERVER secure_server
    FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (
        host 'secure-db.internal',
        port '5432',
        dbname 'secure_db',
        sslmode 'require',           -- Force SSL
        sslrootcert '/path/to/ca.crt'
    );
```

#### 3. Limiter les Tables Expos√©es

Ne cr√©ez des tables √©trang√®res que pour les donn√©es n√©cessaires :

```sql
-- ‚úÖ Cr√©er uniquement les tables n√©cessaires au reporting
CREATE FOREIGN TABLE fdw_orders_summary (
    id          INTEGER,
    total       NUMERIC,
    status      VARCHAR,
    created_at  TIMESTAMPTZ
    -- Pas de colonnes sensibles comme payment_details
)
SERVER orders_server
OPTIONS (schema_name 'public', table_name 'orders');
```

#### 4. Stocker les Mots de Passe de Fa√ßon S√©curis√©e

Les mots de passe des user mappings sont stock√©s dans `pg_user_mappings`. Limitez l'acc√®s :

```sql
-- Seul le superuser peut voir les mots de passe
REVOKE ALL ON pg_user_mappings FROM PUBLIC;
```

Pour des environnements tr√®s sensibles, utilisez l'authentification par certificat ou des solutions comme **HashiCorp Vault** pour la rotation des credentials.

---

## Limitations et Consid√©rations

### Limitations Techniques

| Limitation | Description |
|------------|-------------|
| **Pas de transactions distribu√©es** | Chaque op√©ration distante est une transaction s√©par√©e |
| **Latence r√©seau** | Les requ√™tes impliquent des allers-retours r√©seau |
| **Jointures cross-server** | Jointures entre tables de serveurs diff√©rents = tout rapatri√© localement |
| **Pas de triggers distants** | Les triggers de la table source ne sont pas visibles |
| **Stats limit√©es** | `ANALYZE` sur tables √©trang√®res moins pr√©cis |

### Quand NE PAS Utiliser les FDW

| Sc√©nario | Alternative recommand√©e |
|----------|------------------------|
| Requ√™tes temps r√©el haute fr√©quence | API directe ou cache Redis |
| √âcritures massives | API du service ou √©v√©nements |
| Donn√©es tr√®s volumineuses | ETL vers data warehouse |
| Jointures complexes multi-serveurs | Data warehouse consolid√© |
| Haute disponibilit√© critique | R√©plication native |

### D√©pannage Courant

#### Erreur de Connexion

```
ERROR: could not connect to server "orders_server"
DETAIL: connection to server at "orders-db.internal", port 5432 failed
```

**Solutions** :
- V√©rifier que le serveur distant est accessible (ping, telnet)
- V√©rifier les r√®gles firewall
- V√©rifier `pg_hba.conf` sur le serveur distant

#### Performances D√©grad√©es

```sql
-- Analyser les tables √©trang√®res
ANALYZE fdw_orders;

-- V√©rifier le plan d'ex√©cution
EXPLAIN (ANALYZE, VERBOSE, BUFFERS)
SELECT * FROM fdw_orders WHERE status = 'pending';
```

#### Timeout sur Requ√™tes Longues

```sql
-- Augmenter le timeout pour les connexions FDW
ALTER SERVER orders_server OPTIONS (
    ADD connect_timeout '30',
    ADD statement_timeout '300000'  -- 5 minutes en ms
);
```

---

## Exemple Complet : Dashboard de Ventes

Voici un exemple complet de mise en place d'un syst√®me de reporting f√©d√©r√©.

### Configuration Initiale

```sql
-- ========================================
-- Base de reporting : reporting_db
-- ========================================

-- 1. Extensions
CREATE EXTENSION IF NOT EXISTS postgres_fdw;

-- 2. Sch√©ma d√©di√© pour les tables √©trang√®res
CREATE SCHEMA fdw;

-- 3. Serveurs distants
CREATE SERVER users_srv FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (host 'users-db', port '5432', dbname 'users_db');

CREATE SERVER orders_srv FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (host 'orders-db', port '5432', dbname 'orders_db');

CREATE SERVER catalog_srv FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (host 'catalog-db', port '5432', dbname 'catalog_db');

-- 4. User mappings (pour l'utilisateur reporting_app)
CREATE USER MAPPING FOR reporting_app SERVER users_srv
    OPTIONS (user 'fdw_reader', password 'pwd_users');

CREATE USER MAPPING FOR reporting_app SERVER orders_srv
    OPTIONS (user 'fdw_reader', password 'pwd_orders');

CREATE USER MAPPING FOR reporting_app SERVER catalog_srv
    OPTIONS (user 'fdw_reader', password 'pwd_catalog');

-- 5. Import des sch√©mas distants
IMPORT FOREIGN SCHEMA public
    LIMIT TO (users)
    FROM SERVER users_srv INTO fdw;

IMPORT FOREIGN SCHEMA public
    LIMIT TO (orders, order_items)
    FROM SERVER orders_srv INTO fdw;

IMPORT FOREIGN SCHEMA public
    LIMIT TO (products, categories)
    FROM SERVER catalog_srv INTO fdw;
```

### Vue Consolid√©e pour le Dashboard

```sql
-- Vue de synth√®se des ventes
CREATE VIEW v_sales_dashboard AS
SELECT
    date_trunc('day', o.created_at) AS sale_date,
    cat.name AS category,
    u.country,
    COUNT(DISTINCT o.id) AS orders_count,
    COUNT(DISTINCT o.user_id) AS customers_count,
    SUM(oi.quantity) AS items_sold,
    SUM(oi.quantity * oi.unit_price) AS revenue
FROM fdw.orders o
JOIN fdw.order_items oi ON oi.order_id = o.id
JOIN fdw.products p ON p.id = oi.product_id
JOIN fdw.categories cat ON cat.id = p.category_id
JOIN fdw.users u ON u.id = o.user_id
WHERE o.status = 'completed'
GROUP BY
    date_trunc('day', o.created_at),
    cat.name,
    u.country;

-- Vue mat√©rialis√©e pour performances
CREATE MATERIALIZED VIEW mv_daily_sales AS
SELECT * FROM v_sales_dashboard
WHERE sale_date >= NOW() - INTERVAL '90 days';

CREATE INDEX idx_mv_daily_sales_date ON mv_daily_sales(sale_date);
CREATE INDEX idx_mv_daily_sales_category ON mv_daily_sales(category);

-- Rafra√Æchissement automatique (avec pg_cron)
-- SELECT cron.schedule('refresh-sales', '0 * * * *',
--     'REFRESH MATERIALIZED VIEW CONCURRENTLY mv_daily_sales');
```

### Requ√™tes de Reporting

```sql
-- Top 10 des cat√©gories ce mois
SELECT
    category,
    SUM(revenue) AS total_revenue,
    SUM(orders_count) AS total_orders
FROM mv_daily_sales
WHERE sale_date >= date_trunc('month', CURRENT_DATE)
GROUP BY category
ORDER BY total_revenue DESC
LIMIT 10;

-- √âvolution par pays
SELECT
    country,
    sale_date,
    SUM(revenue) AS daily_revenue
FROM mv_daily_sales
WHERE sale_date >= NOW() - INTERVAL '30 days'
GROUP BY country, sale_date
ORDER BY country, sale_date;
```

---

## Conclusion

Les **Foreign Data Wrappers** sont un outil puissant pour cr√©er une **f√©d√©ration de donn√©es** dans une architecture microservices. Ils permettent d'interroger des sources h√©t√©rog√®nes avec du SQL standard, sans dupliquer les donn√©es ni cr√©er de couplage fort entre les services.

Cependant, ils ne sont pas une solution miracle. Les FDW sont id√©aux pour le **reporting et l'analyse**, mais moins adapt√©s aux requ√™tes temps r√©el √† haute fr√©quence ou aux √©critures distribu√©es.

PostgreSQL, gr√¢ce √† `postgres_fdw` et son √©cosyst√®me de wrappers communautaires, offre une flexibilit√© remarquable pour int√©grer des donn√©es de multiples sources dans une vue unifi√©e.

---

## Points Cl√©s √† Retenir

- **FDW** = m√©canisme PostgreSQL pour acc√©der √† des donn√©es externes comme des tables locales
- **postgres_fdw** : wrapper optimis√© pour la f√©d√©ration entre bases PostgreSQL
- **Pushdown** : PostgreSQL d√©l√®gue filtres, tris et agr√©gations au serveur distant
- **Architecture recommand√©e** : Base de reporting d√©di√©e avec FDW en lecture seule
- **S√©curit√©** : Utilisez des comptes readonly et SSL pour les connexions
- **Performance** : Vues mat√©rialis√©es pour cacher les r√©sultats f√©d√©r√©s
- **Limitations** : Pas de transactions distribu√©es, latence r√©seau, jointures cross-server co√ªteuses
- **Cas d'usage** : Reporting, migration progressive, f√©d√©ration multi-cloud

---


‚è≠Ô∏è [Event Sourcing et CQRS avec PostgreSQL](/20bis-postgresql-et-architectures-modernes/02-event-sourcing-cqrs.md)
