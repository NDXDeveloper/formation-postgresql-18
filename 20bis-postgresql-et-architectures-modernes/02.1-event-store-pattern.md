üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20bis.2.1 ‚Äî Event Store Pattern

## Introduction

Dans les architectures traditionnelles, nous stockons l'**√©tat actuel** des donn√©es. Une table `accounts` contient le solde actuel de chaque compte bancaire. Quand un client effectue un retrait, nous mettons √† jour ce solde. L'historique ? Perdu, ou stock√© s√©par√©ment dans des logs difficiles √† exploiter.

L'**Event Sourcing** propose une approche radicalement diff√©rente : au lieu de stocker l'√©tat actuel, nous stockons **tous les √©v√©nements** qui ont conduit √† cet √©tat. Le solde d'un compte n'est plus une donn√©e stock√©e, mais une donn√©e **calcul√©e** √† partir de la s√©quence de d√©p√¥ts et retraits.

L'**Event Store** est la base de donn√©es sp√©cialis√©e qui stocke ces √©v√©nements. Dans ce chapitre, nous allons d√©couvrir comment impl√©menter un Event Store robuste avec PostgreSQL.

---

## Du CRUD √† l'Event Sourcing

### L'Approche Traditionnelle : CRUD

Dans une application classique, nous manipulons les donn√©es avec les op√©rations **CRUD** (Create, Read, Update, Delete) :

```sql
-- Cr√©er un compte
INSERT INTO accounts (id, owner, balance)
VALUES ('acc-001', 'Alice', 1000.00);

-- Effectuer un retrait : MISE √Ä JOUR destructive
UPDATE accounts SET balance = balance - 200 WHERE id = 'acc-001';

-- √âtat actuel : balance = 800
-- Question : Pourquoi 800 ? Quand le retrait a-t-il eu lieu ?
-- R√©ponse : On ne sait pas, l'information est perdue.
```

```
√âtat dans le temps (CRUD) :

    t0              t1              t2              t3
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ balance ‚îÇ    ‚îÇ balance ‚îÇ    ‚îÇ balance ‚îÇ    ‚îÇ balance ‚îÇ
‚îÇ  1000   ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ   800   ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  1300   ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  1100   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ              ‚îÇ              ‚îÇ
              Retrait ?      D√©p√¥t ?        Retrait ?
              Quand ?        Combien ?      Pourquoi ?
              Par qui ?      D'o√π ?         Autoris√© ?

         ‚ñ≤
         ‚îÇ
    L'historique est PERDU √† chaque UPDATE
```

### L'Approche Event Sourcing

Avec l'Event Sourcing, nous ne stockons jamais l'√©tat directement. Nous stockons les **faits** (√©v√©nements) qui se sont produits :

```sql
-- Au lieu de UPDATE, nous INS√âRONS des √©v√©nements
INSERT INTO events (stream_id, event_type, data, occurred_at) VALUES
('acc-001', 'AccountOpened',   '{"owner": "Alice", "initial_balance": 1000}', '2025-01-01 10:00:00'),
('acc-001', 'MoneyWithdrawn',  '{"amount": 200, "reason": "ATM"}',            '2025-01-01 14:30:00'),
('acc-001', 'MoneyDeposited',  '{"amount": 500, "source": "salary"}',         '2025-01-15 09:00:00'),
('acc-001', 'MoneyWithdrawn',  '{"amount": 200, "reason": "transfer"}',       '2025-01-20 16:45:00');

-- L'√©tat actuel (balance = 1100) se CALCULE √† partir des √©v√©nements
```

```
√âtat dans le temps (Event Sourcing) :

    Event 1           Event 2           Event 3           Event 4
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇAccountOpened‚îÇ   ‚îÇMoneyWithdrawn‚îÇ   ‚îÇMoneyDeposited‚îÇ   ‚îÇMoneyWithdrawn‚îÇ
‚îÇ +1000       ‚îÇ‚îÄ‚îÄ‚ñ∫‚îÇ -200         ‚îÇ‚îÄ‚îÄ‚ñ∫‚îÇ +500         ‚îÇ‚îÄ‚îÄ‚ñ∫‚îÇ -200         ‚îÇ
‚îÇ 01/01 10:00 ‚îÇ   ‚îÇ 01/01 14:30  ‚îÇ   ‚îÇ 15/01 09:00  ‚îÇ   ‚îÇ 20/01 16:45  ‚îÇ
‚îÇ initial     ‚îÇ   ‚îÇ ATM          ‚îÇ   ‚îÇ salary       ‚îÇ   ‚îÇ transfer     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚îÇ                 ‚îÇ                 ‚îÇ                 ‚îÇ
      ‚ñº                 ‚ñº                 ‚ñº                 ‚ñº
   balance           balance           balance           balance
    =1000             =800             =1300             =1100

         ‚ñ≤
         ‚îÇ
    L'historique COMPLET est pr√©serv√©, RIEN n'est perdu
```

---

## Qu'est-ce qu'un Event Store ?

### D√©finition

Un **Event Store** est un syst√®me de stockage optimis√© pour l'Event Sourcing. Il s'agit d'une base de donn√©es o√π :

- Les donn√©es sont **immutables** (append-only) : on ajoute, on ne modifie jamais
- Les √©v√©nements sont ordonn√©s chronologiquement
- Chaque √©v√©nement appartient √† un **stream** (flux) identifiant une entit√©
- L'√©tat d'une entit√© se reconstruit en "rejouant" ses √©v√©nements

### Analogie : Le Grand Livre Comptable

L'Event Store fonctionne comme un **grand livre comptable** (ledger) :

- Chaque transaction est inscrite d√©finitivement
- On ne "gomme" jamais une √©criture
- Pour corriger une erreur, on ajoute une √©criture inverse
- Le solde se calcule en additionnant toutes les √©critures

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    GRAND LIVRE - Compte ACC-001                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Date   ‚îÇ    Libell√©       ‚îÇ   D√©bit   ‚îÇ   Cr√©dit  ‚îÇ   Solde    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 01/01/25 ‚îÇ Ouverture        ‚îÇ           ‚îÇ  1000.00  ‚îÇ   1000.00  ‚îÇ
‚îÇ 01/01/25 ‚îÇ Retrait DAB      ‚îÇ   200.00  ‚îÇ           ‚îÇ    800.00  ‚îÇ
‚îÇ 15/01/25 ‚îÇ Virement salaire ‚îÇ           ‚îÇ   500.00  ‚îÇ   1300.00  ‚îÇ
‚îÇ 20/01/25 ‚îÇ Virement √©mis    ‚îÇ   200.00  ‚îÇ           ‚îÇ   1100.00  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚ö†Ô∏è  Aucune ligne ne peut √™tre modifi√©e ou supprim√©e              ‚îÇ
‚îÇ ‚úÖ  Pour corriger : ajouter une √©criture de r√©gularisation       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Concepts Cl√©s

| Concept | Description |
|---------|-------------|
| **Event** | Fait immutable qui s'est produit (pass√©) |
| **Stream** | S√©quence ordonn√©e d'√©v√©nements pour une entit√© |
| **Stream ID** | Identifiant unique du stream (ex: `account-123`) |
| **Event Type** | Nature de l'√©v√©nement (ex: `MoneyDeposited`) |
| **Payload** | Donn√©es associ√©es √† l'√©v√©nement (JSON) |
| **Version** | Num√©ro de s√©quence dans le stream |
| **Timestamp** | Moment o√π l'√©v√©nement s'est produit |
| **Metadata** | Informations contextuelles (user, correlation ID) |

---

## Impl√©mentation d'un Event Store avec PostgreSQL

PostgreSQL est parfaitement adapt√© pour construire un Event Store gr√¢ce √† :

- Son support JSONB pour les payloads flexibles
- Ses s√©quences pour le versioning
- Ses index performants
- Ses transactions ACID
- Son m√©canisme LISTEN/NOTIFY pour les notifications

### Structure de Base

#### Table des √âv√©nements

```sql
-- Table principale des √©v√©nements
CREATE TABLE events (
    -- Identifiant global unique de l'√©v√©nement
    event_id        UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Identifiant du stream (entit√© concern√©e)
    stream_id       VARCHAR(255) NOT NULL,

    -- Type de stream (pour filtrage par cat√©gorie)
    stream_type     VARCHAR(100) NOT NULL,

    -- Version de l'√©v√©nement dans le stream (1, 2, 3...)
    stream_version  INTEGER NOT NULL,

    -- Type d'√©v√©nement
    event_type      VARCHAR(100) NOT NULL,

    -- Donn√©es de l'√©v√©nement (payload)
    data            JSONB NOT NULL,

    -- M√©tadonn√©es (user, correlation, causation)
    metadata        JSONB DEFAULT '{}',

    -- Horodatage
    occurred_at     TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    recorded_at     TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Contrainte d'unicit√© : un seul √©v√©nement par version dans un stream
    CONSTRAINT uq_stream_version UNIQUE (stream_id, stream_version)
);

-- Index pour les lectures fr√©quentes
CREATE INDEX idx_events_stream_id ON events(stream_id, stream_version);
CREATE INDEX idx_events_stream_type ON events(stream_type, recorded_at);
CREATE INDEX idx_events_event_type ON events(event_type, recorded_at);
CREATE INDEX idx_events_occurred_at ON events(occurred_at);

-- Index GIN pour recherche dans le payload JSON
CREATE INDEX idx_events_data ON events USING GIN(data);
```

#### S√©quence Globale pour l'Ordre Total

```sql
-- Position globale pour garantir l'ordre total des √©v√©nements
CREATE SEQUENCE events_global_position_seq;

-- Ajouter la colonne de position globale
ALTER TABLE events
    ADD COLUMN global_position BIGINT
    DEFAULT nextval('events_global_position_seq');

CREATE INDEX idx_events_global_position ON events(global_position);
```

### Explication des Colonnes

| Colonne | R√¥le |
|---------|------|
| `event_id` | Identifiant unique universel de l'√©v√©nement |
| `stream_id` | Identifie l'entit√© (ex: `order-12345`) |
| `stream_type` | Cat√©gorie du stream (ex: `Order`, `Account`) |
| `stream_version` | Position dans le stream (contr√¥le de concurrence) |
| `event_type` | Type m√©tier de l'√©v√©nement |
| `data` | Payload JSON avec les d√©tails |
| `metadata` | Contexte : qui, quand, pourquoi, correlation |
| `occurred_at` | Quand l'√©v√©nement s'est r√©ellement produit |
| `recorded_at` | Quand il a √©t√© enregistr√© dans le store |
| `global_position` | Ordre total pour la projection |

---

## Op√©rations Fondamentales

### 1. Append : Ajouter des √âv√©nements

L'op√©ration principale est l'**append** (ajout) d'√©v√©nements √† un stream.

```sql
-- Fonction pour ajouter un √©v√©nement avec contr√¥le de version
CREATE OR REPLACE FUNCTION append_event(
    p_stream_id VARCHAR(255),
    p_stream_type VARCHAR(100),
    p_expected_version INTEGER,  -- Version attendue (pour optimistic locking)
    p_event_type VARCHAR(100),
    p_data JSONB,
    p_metadata JSONB DEFAULT '{}'
) RETURNS UUID AS $$
DECLARE
    v_current_version INTEGER;
    v_new_event_id UUID;
BEGIN
    -- Obtenir la version actuelle du stream (avec verrou)
    SELECT COALESCE(MAX(stream_version), 0) INTO v_current_version
    FROM events
    WHERE stream_id = p_stream_id
    FOR UPDATE;

    -- V√©rifier la version attendue (optimistic concurrency)
    IF p_expected_version != -1 AND v_current_version != p_expected_version THEN
        RAISE EXCEPTION 'Concurrency conflict: expected version %, got %',
            p_expected_version, v_current_version
            USING ERRCODE = 'serialization_failure';
    END IF;

    -- Ins√©rer le nouvel √©v√©nement
    INSERT INTO events (
        stream_id,
        stream_type,
        stream_version,
        event_type,
        data,
        metadata
    ) VALUES (
        p_stream_id,
        p_stream_type,
        v_current_version + 1,
        p_event_type,
        p_data,
        p_metadata
    )
    RETURNING event_id INTO v_new_event_id;

    RETURN v_new_event_id;
END;
$$ LANGUAGE plpgsql;
```

#### Utilisation

```sql
-- Cr√©er un nouveau compte (premier √©v√©nement du stream)
SELECT append_event(
    'account-001',                              -- stream_id
    'Account',                                  -- stream_type
    0,                                          -- expected_version (0 = nouveau stream)
    'AccountOpened',                            -- event_type
    '{"owner": "Alice", "initial_balance": 1000, "currency": "EUR"}'::jsonb,
    '{"user_id": "user-42", "ip": "192.168.1.1"}'::jsonb
);

-- Ajouter un retrait (apr√®s le premier √©v√©nement)
SELECT append_event(
    'account-001',
    'Account',
    1,                                          -- expected_version = 1
    'MoneyWithdrawn',
    '{"amount": 200, "reason": "ATM withdrawal", "atm_id": "ATM-789"}'::jsonb,
    '{"user_id": "user-42", "correlation_id": "tx-abc123"}'::jsonb
);

-- Ajouter un d√©p√¥t
SELECT append_event(
    'account-001',
    'Account',
    2,                                          -- expected_version = 2
    'MoneyDeposited',
    '{"amount": 500, "source": "salary", "reference": "SAL-2025-01"}'::jsonb,
    '{"user_id": "system", "correlation_id": "payroll-001"}'::jsonb
);
```

### 2. Load : Charger un Stream

Pour reconstruire l'√©tat d'une entit√©, nous chargeons tous ses √©v√©nements.

```sql
-- Fonction pour charger tous les √©v√©nements d'un stream
CREATE OR REPLACE FUNCTION load_stream(
    p_stream_id VARCHAR(255),
    p_from_version INTEGER DEFAULT 0,
    p_to_version INTEGER DEFAULT NULL
) RETURNS TABLE (
    event_id UUID,
    stream_version INTEGER,
    event_type VARCHAR(100),
    data JSONB,
    metadata JSONB,
    occurred_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        e.event_id,
        e.stream_version,
        e.event_type,
        e.data,
        e.metadata,
        e.occurred_at
    FROM events e
    WHERE e.stream_id = p_stream_id
    AND e.stream_version > p_from_version
    AND (p_to_version IS NULL OR e.stream_version <= p_to_version)
    ORDER BY e.stream_version ASC;
END;
$$ LANGUAGE plpgsql;
```

#### Utilisation

```sql
-- Charger tous les √©v√©nements du compte
SELECT * FROM load_stream('account-001');

-- R√©sultat :
-- event_id | stream_version | event_type      | data                          | ...
-- ---------|----------------|-----------------|-------------------------------|----
-- uuid-1   | 1              | AccountOpened   | {"owner": "Alice", ...}       | ...
-- uuid-2   | 2              | MoneyWithdrawn  | {"amount": 200, ...}          | ...
-- uuid-3   | 3              | MoneyDeposited  | {"amount": 500, ...}          | ...
```

### 3. Reconstruire l'√âtat (Rehydration)

L'√©tat actuel se calcule en "rejouant" les √©v√©nements.

```sql
-- Vue pour calculer le solde actuel de chaque compte
CREATE OR REPLACE VIEW account_balances AS
SELECT
    stream_id AS account_id,
    -- Extraire le propri√©taire du premier √©v√©nement
    (SELECT data->>'owner'
     FROM events e2
     WHERE e2.stream_id = e.stream_id
     AND e2.event_type = 'AccountOpened'
     LIMIT 1) AS owner,
    -- Calculer le solde en sommant les mouvements
    SUM(
        CASE
            WHEN event_type = 'AccountOpened' THEN (data->>'initial_balance')::numeric
            WHEN event_type = 'MoneyDeposited' THEN (data->>'amount')::numeric
            WHEN event_type = 'MoneyWithdrawn' THEN -(data->>'amount')::numeric
            ELSE 0
        END
    ) AS balance,
    -- Derni√®re activit√©
    MAX(occurred_at) AS last_activity,
    -- Nombre de transactions
    COUNT(*) FILTER (WHERE event_type IN ('MoneyDeposited', 'MoneyWithdrawn')) AS transaction_count
FROM events e
WHERE stream_type = 'Account'
GROUP BY stream_id;
```

```sql
-- Consulter l'√©tat actuel
SELECT * FROM account_balances WHERE account_id = 'account-001';

-- R√©sultat :
-- account_id   | owner | balance | last_activity       | transaction_count
-- -------------|-------|---------|---------------------|------------------
-- account-001  | Alice | 1300.00 | 2025-01-15 09:00:00 | 2
```

### 4. Fonction de Reconstruction Compl√®te

Pour une logique m√©tier plus complexe, une fonction PL/pgSQL :

```sql
-- Type pour repr√©senter l'√©tat d'un compte
CREATE TYPE account_state AS (
    account_id VARCHAR(255),
    owner VARCHAR(255),
    balance NUMERIC(15,2),
    currency VARCHAR(3),
    status VARCHAR(20),
    opened_at TIMESTAMPTZ,
    version INTEGER
);

-- Fonction pour reconstruire l'√©tat d'un compte
CREATE OR REPLACE FUNCTION get_account_state(p_account_id VARCHAR(255))
RETURNS account_state AS $$
DECLARE
    v_state account_state;
    v_event RECORD;
BEGIN
    -- Initialiser l'√©tat
    v_state.account_id := p_account_id;
    v_state.balance := 0;
    v_state.status := 'unknown';
    v_state.version := 0;

    -- Rejouer chaque √©v√©nement
    FOR v_event IN (SELECT * FROM load_stream(p_account_id)) LOOP
        v_state.version := v_event.stream_version;

        CASE v_event.event_type
            WHEN 'AccountOpened' THEN
                v_state.owner := v_event.data->>'owner';
                v_state.balance := (v_event.data->>'initial_balance')::numeric;
                v_state.currency := COALESCE(v_event.data->>'currency', 'EUR');
                v_state.status := 'active';
                v_state.opened_at := v_event.occurred_at;

            WHEN 'MoneyDeposited' THEN
                v_state.balance := v_state.balance + (v_event.data->>'amount')::numeric;

            WHEN 'MoneyWithdrawn' THEN
                v_state.balance := v_state.balance - (v_event.data->>'amount')::numeric;

            WHEN 'AccountClosed' THEN
                v_state.status := 'closed';

            WHEN 'AccountFrozen' THEN
                v_state.status := 'frozen';

            ELSE
                -- √âv√©nement inconnu, ignorer silencieusement
                NULL;
        END CASE;
    END LOOP;

    RETURN v_state;
END;
$$ LANGUAGE plpgsql;
```

```sql
-- Utilisation
SELECT * FROM get_account_state('account-001');

-- R√©sultat :
-- account_id  | owner | balance | currency | status | opened_at           | version
-- ------------|-------|---------|----------|--------|---------------------|--------
-- account-001 | Alice | 1300.00 | EUR      | active | 2025-01-01 10:00:00 | 3
```

---

## Contr√¥le de Concurrence Optimiste

### Le Probl√®me

Que se passe-t-il si deux processus tentent de modifier le m√™me compte simultan√©ment ?

```
Processus A                    Processus B
    ‚îÇ                              ‚îÇ
    ‚ñº                              ‚ñº
Lire account-001               Lire account-001
(version 3, solde 1300)        (version 3, solde 1300)
    ‚îÇ                              ‚îÇ
    ‚ñº                              ‚ñº
Retrait de 500                 D√©p√¥t de 200
Nouveau solde: 800             Nouveau solde: 1500
    ‚îÇ                              ‚îÇ
    ‚ñº                              ‚ñº
Append (expected=3)            Append (expected=3)
    ‚îÇ                              ‚îÇ
    ‚ñº                              ‚ñº
Succ√®s (version 4)             ???

Probl√®me : B a travaill√© sur un √©tat obsol√®te !
```

### La Solution : Expected Version

Le param√®tre `expected_version` r√©sout ce probl√®me :

```sql
-- Processus A r√©ussit
SELECT append_event('account-001', 'Account', 3, 'MoneyWithdrawn',
    '{"amount": 500}'::jsonb);
-- OK, version devient 4

-- Processus B √©choue
SELECT append_event('account-001', 'Account', 3, 'MoneyDeposited',
    '{"amount": 200}'::jsonb);
-- ERREUR: Concurrency conflict: expected version 3, got 4

-- Processus B doit recharger l'√©tat et r√©essayer
SELECT * FROM load_stream('account-001');  -- Recharger
-- Recalculer avec le nouveau solde
SELECT append_event('account-001', 'Account', 4, 'MoneyDeposited',
    '{"amount": 200}'::jsonb);
-- OK, version devient 5
```

### Modes de V√©rification

| Mode | Valeur | Comportement |
|------|--------|--------------|
| **Strict** | `expected_version = N` | √âchoue si version actuelle ‚â† N |
| **Any** | `expected_version = -1` | Accepte quelle que soit la version |
| **No Stream** | `expected_version = 0` | √âchoue si le stream existe d√©j√† |

---

## Snapshots : Optimiser la Reconstruction

### Le Probl√®me des Longs Streams

Si un compte a 10 000 √©v√©nements, reconstruire son √©tat √† chaque lecture devient co√ªteux.

```
Stream avec 10 000 √©v√©nements :

‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1 ‚îÇ‚îÄ‚îÇ 2 ‚îÇ‚îÄ‚îÇ 3 ‚îÇ‚îÄ‚îÇ 4 ‚îÇ‚îÄ ... ‚îÄ‚îÄ‚îÄ‚îÇ9999‚îÇ‚îÄ‚îÇ10K‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îò
  ‚îÇ                                       ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        Rejouer 10 000 √©v√©nements ?
                  üò∞
```

### La Solution : Snapshots

Un **snapshot** capture l'√©tat √† un instant donn√©. On ne rejoue que les √©v√©nements apr√®s le snapshot.

```
Avec snapshot √† la version 9000 :

‚îå‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1 ‚îÇ‚îÄ...‚îÄ‚îÇ9000‚îÇ‚îÄ‚îÇ9001‚îÇ‚îÄ ... ‚îÄ‚îÄ ‚îÇ9999‚îÇ‚îÄ‚îÇ10K‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ   SNAPSHOT    ‚îÇ
    ‚îÇ version: 9000 ‚îÇ
    ‚îÇ balance: 5000 ‚îÇ
    ‚îÇ owner: Alice  ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ
            ‚îî‚îÄ‚îÄ‚ñ∫ Rejouer seulement 1000 √©v√©nements
                         üòä
```

### Impl√©mentation des Snapshots

```sql
-- Table des snapshots
CREATE TABLE snapshots (
    stream_id       VARCHAR(255) NOT NULL,
    stream_type     VARCHAR(100) NOT NULL,
    stream_version  INTEGER NOT NULL,
    state           JSONB NOT NULL,
    created_at      TIMESTAMPTZ DEFAULT NOW(),

    PRIMARY KEY (stream_id, stream_version)
);

-- Index pour r√©cup√©rer le dernier snapshot
CREATE INDEX idx_snapshots_latest
ON snapshots(stream_id, stream_version DESC);
```

```sql
-- Fonction pour sauvegarder un snapshot
CREATE OR REPLACE FUNCTION save_snapshot(
    p_stream_id VARCHAR(255),
    p_stream_type VARCHAR(100),
    p_version INTEGER,
    p_state JSONB
) RETURNS VOID AS $$
BEGIN
    INSERT INTO snapshots (stream_id, stream_type, stream_version, state)
    VALUES (p_stream_id, p_stream_type, p_version, p_state)
    ON CONFLICT (stream_id, stream_version)
    DO UPDATE SET state = p_state, created_at = NOW();
END;
$$ LANGUAGE plpgsql;

-- Fonction pour charger l'√©tat avec snapshot
CREATE OR REPLACE FUNCTION get_account_state_with_snapshot(p_account_id VARCHAR(255))
RETURNS account_state AS $$
DECLARE
    v_snapshot RECORD;
    v_state account_state;
    v_event RECORD;
    v_from_version INTEGER := 0;
BEGIN
    -- Chercher le dernier snapshot
    SELECT * INTO v_snapshot
    FROM snapshots
    WHERE stream_id = p_account_id
    ORDER BY stream_version DESC
    LIMIT 1;

    IF FOUND THEN
        -- Initialiser depuis le snapshot
        v_state.account_id := p_account_id;
        v_state.owner := v_snapshot.state->>'owner';
        v_state.balance := (v_snapshot.state->>'balance')::numeric;
        v_state.currency := v_snapshot.state->>'currency';
        v_state.status := v_snapshot.state->>'status';
        v_state.opened_at := (v_snapshot.state->>'opened_at')::timestamptz;
        v_state.version := v_snapshot.stream_version;
        v_from_version := v_snapshot.stream_version;
    ELSE
        -- Pas de snapshot, initialiser √† vide
        v_state.account_id := p_account_id;
        v_state.balance := 0;
        v_state.status := 'unknown';
        v_state.version := 0;
    END IF;

    -- Rejouer les √©v√©nements APR√àS le snapshot
    FOR v_event IN (SELECT * FROM load_stream(p_account_id, v_from_version)) LOOP
        v_state.version := v_event.stream_version;

        CASE v_event.event_type
            WHEN 'AccountOpened' THEN
                v_state.owner := v_event.data->>'owner';
                v_state.balance := (v_event.data->>'initial_balance')::numeric;
                v_state.currency := COALESCE(v_event.data->>'currency', 'EUR');
                v_state.status := 'active';
                v_state.opened_at := v_event.occurred_at;
            WHEN 'MoneyDeposited' THEN
                v_state.balance := v_state.balance + (v_event.data->>'amount')::numeric;
            WHEN 'MoneyWithdrawn' THEN
                v_state.balance := v_state.balance - (v_event.data->>'amount')::numeric;
            WHEN 'AccountClosed' THEN
                v_state.status := 'closed';
            WHEN 'AccountFrozen' THEN
                v_state.status := 'frozen';
            ELSE
                NULL;
        END CASE;
    END LOOP;

    RETURN v_state;
END;
$$ LANGUAGE plpgsql;
```

### Strat√©gies de Cr√©ation de Snapshots

| Strat√©gie | Description |
|-----------|-------------|
| **P√©riodique** | Toutes les N versions (ex: tous les 100 √©v√©nements) |
| **Temporelle** | Toutes les N heures/jours |
| **√Ä la demande** | Lors d'op√©rations de maintenance |
| **Conditionnelle** | Apr√®s certains types d'√©v√©nements importants |

```sql
-- Exemple : Cr√©er un snapshot si > 100 √©v√©nements depuis le dernier
CREATE OR REPLACE FUNCTION maybe_create_snapshot(p_account_id VARCHAR(255))
RETURNS VOID AS $$
DECLARE
    v_state account_state;
    v_last_snapshot_version INTEGER;
    v_current_version INTEGER;
BEGIN
    -- Version du dernier snapshot
    SELECT COALESCE(MAX(stream_version), 0) INTO v_last_snapshot_version
    FROM snapshots WHERE stream_id = p_account_id;

    -- Version actuelle du stream
    SELECT COALESCE(MAX(stream_version), 0) INTO v_current_version
    FROM events WHERE stream_id = p_account_id;

    -- Cr√©er snapshot si > 100 √©v√©nements d'√©cart
    IF v_current_version - v_last_snapshot_version > 100 THEN
        v_state := get_account_state_with_snapshot(p_account_id);

        PERFORM save_snapshot(
            p_account_id,
            'Account',
            v_state.version,
            jsonb_build_object(
                'owner', v_state.owner,
                'balance', v_state.balance,
                'currency', v_state.currency,
                'status', v_state.status,
                'opened_at', v_state.opened_at
            )
        );
    END IF;
END;
$$ LANGUAGE plpgsql;
```

---

## Notifications en Temps R√©el

PostgreSQL permet de notifier les applications quand de nouveaux √©v√©nements sont ajout√©s.

### Avec LISTEN/NOTIFY

```sql
-- Trigger pour notifier les nouveaux √©v√©nements
CREATE OR REPLACE FUNCTION notify_new_event()
RETURNS TRIGGER AS $$
BEGIN
    -- Notifier sur un canal par type de stream
    PERFORM pg_notify(
        'events_' || NEW.stream_type,
        json_build_object(
            'event_id', NEW.event_id,
            'stream_id', NEW.stream_id,
            'stream_version', NEW.stream_version,
            'event_type', NEW.event_type,
            'global_position', NEW.global_position
        )::text
    );

    -- Notifier aussi sur un canal global
    PERFORM pg_notify(
        'all_events',
        json_build_object(
            'event_id', NEW.event_id,
            'stream_type', NEW.stream_type,
            'event_type', NEW.event_type,
            'global_position', NEW.global_position
        )::text
    );

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_notify_new_event
AFTER INSERT ON events
FOR EACH ROW
EXECUTE FUNCTION notify_new_event();
```

### √âcoute C√¥t√© Application

```sql
-- Dans psql ou une application
LISTEN events_Account;
LISTEN all_events;

-- Quand un √©v√©nement est ajout√©, vous recevez :
-- Asynchronous notification "events_Account" with payload
-- "{"event_id":"uuid-123","stream_id":"account-001",...}"
```

---

## Requ√™tes Utiles pour l'Event Store

### Statistiques Globales

```sql
-- Nombre d'√©v√©nements par type
SELECT
    event_type,
    COUNT(*) as count,
    MIN(occurred_at) as first_occurrence,
    MAX(occurred_at) as last_occurrence
FROM events
GROUP BY event_type
ORDER BY count DESC;

-- Activit√© par jour
SELECT
    DATE(occurred_at) as day,
    COUNT(*) as events_count,
    COUNT(DISTINCT stream_id) as active_streams
FROM events
GROUP BY DATE(occurred_at)
ORDER BY day DESC
LIMIT 30;
```

### Recherche dans les √âv√©nements

```sql
-- Trouver tous les gros d√©p√¥ts
SELECT
    stream_id,
    event_type,
    data->>'amount' as amount,
    occurred_at
FROM events
WHERE event_type = 'MoneyDeposited'
AND (data->>'amount')::numeric > 10000
ORDER BY occurred_at DESC;

-- Historique complet d'un compte
SELECT
    occurred_at,
    event_type,
    CASE event_type
        WHEN 'AccountOpened' THEN '+'||(data->>'initial_balance')
        WHEN 'MoneyDeposited' THEN '+'||(data->>'amount')
        WHEN 'MoneyWithdrawn' THEN '-'||(data->>'amount')
        ELSE NULL
    END as movement,
    data->>'reason' as reason,
    metadata->>'user_id' as performed_by
FROM events
WHERE stream_id = 'account-001'
ORDER BY stream_version;
```

### Audit et Tra√ßabilit√©

```sql
-- Toutes les actions d'un utilisateur
SELECT
    e.occurred_at,
    e.stream_type,
    e.stream_id,
    e.event_type,
    e.data
FROM events e
WHERE e.metadata->>'user_id' = 'user-42'
ORDER BY e.occurred_at DESC
LIMIT 100;

-- Corr√©lation : suivre une transaction √† travers les services
SELECT
    e.stream_type,
    e.stream_id,
    e.event_type,
    e.occurred_at
FROM events e
WHERE e.metadata->>'correlation_id' = 'order-tx-abc123'
ORDER BY e.global_position;
```

---

## Avantages de l'Event Store

| Avantage | Description |
|----------|-------------|
| **Audit complet** | Historique int√©gral de toutes les modifications |
| **Debugging facilit√©** | Rejouer les √©v√©nements pour comprendre un bug |
| **Voyage dans le temps** | Reconstruire l'√©tat √† n'importe quel moment |
| **Int√©gration** | Publier les √©v√©nements vers d'autres syst√®mes |
| **Analytics** | Analyser les patterns et comportements |
| **Correction d'erreurs** | Ajouter des √©v√©nements compensatoires |
| **√âvolutivit√© du sch√©ma** | Ajouter de nouveaux champs sans migration |

---

## Inconv√©nients et D√©fis

| D√©fi | Solution |
|------|----------|
| **Complexit√©** | Formation des √©quipes, bonnes pratiques |
| **Performance lecture** | Snapshots, projections (voir CQRS) |
| **Stockage croissant** | Archivage, compression, purge des vieux snapshots |
| **Requ√™tes complexes** | Projections d√©normalis√©es |
| **Versioning des √©v√©nements** | Upcasters pour transformer les anciens formats |
| **Changement de paradigme** | Penser en √©v√©nements, pas en √©tat |

---

## Bonnes Pratiques

### 1. Nommer les √âv√©nements au Pass√©

```sql
-- ‚úÖ Bon : d√©crit ce qui S'EST pass√©
'OrderPlaced', 'PaymentReceived', 'ItemShipped'

-- ‚ùå Mauvais : d√©crit une intention
'PlaceOrder', 'ReceivePayment', 'ShipItem'
```

### 2. √âv√©nements Autonomes et Complets

```sql
-- ‚úÖ Bon : contient toutes les infos n√©cessaires
{"event_type": "OrderPlaced", "data": {
    "order_id": "ord-123",
    "customer_id": "cust-456",
    "customer_name": "Alice",        -- D√©normalis√©
    "items": [...],
    "total": 150.00,
    "currency": "EUR"
}}

-- ‚ùå Mauvais : n√©cessite des lookups
{"event_type": "OrderPlaced", "data": {
    "order_id": "ord-123",
    "customer_id": "cust-456"        -- Juste l'ID, pas le nom
}}
```

### 3. Ne Jamais Modifier un √âv√©nement

```sql
-- ‚ùå INTERDIT : UPDATE sur la table events
UPDATE events SET data = '...' WHERE event_id = 'xxx';

-- ‚úÖ Correct : ajouter un √©v√©nement de correction
INSERT INTO events (...) VALUES (
    ..., 'OrderCorrected', '{"reason": "prix incorrect", "old_total": 150, "new_total": 140}'
);
```

### 4. Utiliser des M√©tadonn√©es Riches

```sql
-- M√©tadonn√©es utiles pour audit et debugging
{
    "user_id": "user-42",
    "correlation_id": "tx-abc123",      -- Lier les √©v√©nements d'une m√™me transaction
    "causation_id": "evt-xyz",          -- Quel √©v√©nement a caus√© celui-ci
    "timestamp": "2025-01-15T10:30:00Z",
    "source": "web-app",
    "ip_address": "192.168.1.100",
    "user_agent": "Mozilla/5.0..."
}
```

---

## Conclusion

L'**Event Store** est le fondement de l'Event Sourcing. En stockant les √©v√©nements plut√¥t que l'√©tat, nous obtenons un syst√®me avec :

- Un **historique complet** et immutable
- Une **tra√ßabilit√© parfaite** pour l'audit
- La capacit√© de **reconstruire l'√©tat** √† n'importe quel moment
- Une **int√©gration naturelle** avec d'autres syst√®mes via les √©v√©nements

PostgreSQL, avec son support JSONB, ses transactions ACID et son m√©canisme LISTEN/NOTIFY, constitue une excellente plateforme pour construire un Event Store robuste et performant.

Dans les prochaines sections, nous verrons comment exploiter ces √©v√©nements avec **NOTIFY/LISTEN** pour le temps r√©el, et comment construire des **projections optimis√©es** avec le pattern **CQRS**.

---

## Points Cl√©s √† Retenir

- **Event Sourcing** : Stocker les √©v√©nements, pas l'√©tat
- **Event Store** : Base de donn√©es append-only pour les √©v√©nements
- **Stream** : S√©quence d'√©v√©nements pour une entit√©
- **Reconstruction** : L'√©tat se calcule en rejouant les √©v√©nements
- **Optimistic Locking** : `expected_version` pour la concurrence
- **Snapshots** : Caches d'√©tat pour optimiser la reconstruction
- **Immutabilit√©** : Ne jamais modifier ou supprimer un √©v√©nement
- **LISTEN/NOTIFY** : Notifications temps r√©el avec PostgreSQL

---


‚è≠Ô∏è [NOTIFY/LISTEN pour √©v√©nements temps r√©el](/20bis-postgresql-et-architectures-modernes/02.2-notify-listen.md)
