üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20bis.2.2 ‚Äî NOTIFY/LISTEN pour √âv√©nements Temps R√©el

## Introduction

Dans le chapitre pr√©c√©dent, nous avons construit un Event Store qui stocke tous les √©v√©nements de notre syst√®me. Mais stocker ne suffit pas : nous devons aussi **r√©agir** √† ces √©v√©nements en temps r√©el.

Imaginez un tableau de bord qui affiche les commandes en cours. Avec une approche traditionnelle, l'interface doit interroger la base de donn√©es toutes les quelques secondes (polling) pour d√©tecter les nouvelles commandes. C'est inefficace et cr√©e une latence perceptible.

PostgreSQL offre une solution √©l√©gante : le m√©canisme **NOTIFY/LISTEN**. Il permet aux applications de recevoir des notifications instantan√©es quand des √©v√©nements se produisent, sans polling constant.

Ce chapitre vous apprendra √† utiliser NOTIFY/LISTEN pour construire des syst√®mes r√©actifs et temps r√©el avec PostgreSQL.

---

## Le Probl√®me du Polling

### L'Approche Traditionnelle

Sans m√©canisme de notification, les applications doivent "interroger" r√©guli√®rement la base de donn√©es :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Application   ‚îÇ                    ‚îÇ   PostgreSQL    ‚îÇ
‚îÇ   (Dashboard)   ‚îÇ                    ‚îÇ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                                      ‚îÇ
         ‚îÇ  "Y a-t-il de nouvelles commandes?"  ‚îÇ
         ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ
         ‚îÇ                                      ‚îÇ
         ‚îÇ  "Non, rien de nouveau"              ‚îÇ
         ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
         ‚îÇ                                      ‚îÇ
         ‚îÇ  ... attendre 5 secondes ...         ‚îÇ
         ‚îÇ                                      ‚îÇ
         ‚îÇ  "Y a-t-il de nouvelles commandes?"  ‚îÇ
         ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ
         ‚îÇ                                      ‚îÇ
         ‚îÇ  "Non, rien de nouveau"              ‚îÇ
         ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
         ‚îÇ                                      ‚îÇ
         ‚îÇ  ... attendre 5 secondes ...         ‚îÇ
         ‚îÇ                                      ‚îÇ
         ‚îÇ  "Y a-t-il de nouvelles commandes?"  ‚îÇ
         ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ
         ‚îÇ                                      ‚îÇ
         ‚îÇ  "Oui ! Une nouvelle commande"       ‚îÇ
         ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
         ‚îÇ                                      ‚îÇ
         ‚ñº                                      ‚ñº
```

### Les Inconv√©nients du Polling

| Probl√®me | Impact |
|----------|--------|
| **Latence** | D√©lai entre l'√©v√©nement et sa d√©tection (jusqu'√† l'intervalle de polling) |
| **Charge inutile** | Requ√™tes constantes m√™me sans nouveaux √©v√©nements |
| **Gaspillage de ressources** | CPU, m√©moire, connexions utilis√©es pour rien |
| **Difficult√© √† scaler** | Plus de clients = plus de requ√™tes de polling |
| **Complexit√©** | G√©rer les intervalles, les erreurs, la synchronisation |

---

## La Solution : NOTIFY/LISTEN

### Principe

PostgreSQL impl√©mente un syst√®me de **publication/souscription** (pub/sub) int√©gr√© :

- **NOTIFY** : Envoie un message sur un canal nomm√©
- **LISTEN** : S'abonne √† un canal pour recevoir les messages
- **UNLISTEN** : Se d√©sabonne d'un canal

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Application   ‚îÇ                    ‚îÇ   PostgreSQL    ‚îÇ
‚îÇ   (Dashboard)   ‚îÇ                    ‚îÇ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                                      ‚îÇ
         ‚îÇ  LISTEN orders_channel               ‚îÇ
         ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ
         ‚îÇ                                      ‚îÇ
         ‚îÇ  "OK, vous √™tes abonn√©"              ‚îÇ
         ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
         ‚îÇ                                      ‚îÇ
         ‚îÇ  ... connexion maintenue ouverte ... ‚îÇ
         ‚îÇ  ... aucune requ√™te n√©cessaire ...   ‚îÇ
         ‚îÇ                                      ‚îÇ
         ‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
         ‚îÇ                    ‚îÇ Nouvelle        ‚îÇ
         ‚îÇ                    ‚îÇ commande !      ‚îÇ
         ‚îÇ                    ‚îÇ NOTIFY envoy√©   ‚îÇ
         ‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
         ‚îÇ                                      ‚îÇ
         ‚îÇ  üì¢ Notification: "order-123 cr√©√©e"  ‚îÇ
         ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
         ‚îÇ                                      ‚îÇ
         ‚îÇ  Mise √† jour imm√©diate du dashboard  ‚îÇ
         ‚îÇ                                      ‚îÇ
         ‚ñº                                      ‚ñº
```

### Avantages

| Avantage | Description |
|----------|-------------|
| **Temps r√©el** | Notification instantan√©e (millisecondes) |
| **Efficacit√©** | Aucune requ√™te tant qu'il n'y a pas d'√©v√©nement |
| **Scalabilit√©** | Un NOTIFY atteint tous les listeners simultan√©ment |
| **Simplicit√©** | Int√©gr√© √† PostgreSQL, pas de middleware externe |
| **Transactionnel** | Les notifications respectent les transactions |

---

## Syntaxe de Base

### LISTEN : S'abonner √† un Canal

```sql
-- S'abonner au canal "orders"
LISTEN orders;

-- S'abonner √† plusieurs canaux
LISTEN orders;
LISTEN payments;
LISTEN inventory;

-- Les noms de canaux sont insensibles √† la casse
LISTEN Orders;  -- √âquivalent √† LISTEN orders
```

### NOTIFY : Envoyer une Notification

```sql
-- Notification simple (sans payload)
NOTIFY orders;

-- Notification avec payload (message)
NOTIFY orders, 'order-123 created';

-- Le payload est limit√© √† 8000 caract√®res
NOTIFY orders, '{"order_id": "order-123", "total": 99.99}';
```

### UNLISTEN : Se D√©sabonner

```sql
-- Se d√©sabonner d'un canal sp√©cifique
UNLISTEN orders;

-- Se d√©sabonner de TOUS les canaux
UNLISTEN *;
```

### pg_notify() : Version Fonctionnelle

La fonction `pg_notify()` permet d'utiliser des variables et expressions :

```sql
-- √âquivalent √† NOTIFY orders, 'message'
SELECT pg_notify('orders', 'order-123 created');

-- Avec des variables (utile dans les fonctions PL/pgSQL)
DO $$
DECLARE
    v_channel TEXT := 'orders';
    v_payload TEXT := 'order-456 shipped';
BEGIN
    PERFORM pg_notify(v_channel, v_payload);
END $$;
```

---

## Comportement Transactionnel

### Les Notifications Respectent les Transactions

C'est un point crucial : les notifications ne sont envoy√©es **qu'apr√®s le COMMIT** de la transaction.

```sql
BEGIN;
    INSERT INTO orders (id, total) VALUES ('order-789', 150.00);
    NOTIFY orders, 'order-789 created';
    -- La notification est EN ATTENTE, pas encore envoy√©e
COMMIT;
-- Maintenant la notification est envoy√©e !
```

Si la transaction est annul√©e :

```sql
BEGIN;
    INSERT INTO orders (id, total) VALUES ('order-999', 200.00);
    NOTIFY orders, 'order-999 created';
ROLLBACK;
-- La notification n'est JAMAIS envoy√©e !
```

### Pourquoi C'est Important

Ce comportement garantit la **coh√©rence** :

- Les listeners ne re√ßoivent jamais de notification pour des donn√©es non commit√©es
- Pas de "faux positifs" dus √† des transactions annul√©es
- L'ordre des notifications refl√®te l'ordre des commits

```
Transaction A                    Transaction B
    ‚îÇ                                ‚îÇ
BEGIN                            BEGIN
    ‚îÇ                                ‚îÇ
INSERT order-1                   INSERT order-2
NOTIFY 'order-1'                 NOTIFY 'order-2'
    ‚îÇ                                ‚îÇ
    ‚îÇ                            COMMIT  ‚îÄ‚îÄ‚ñ∫ Notification 'order-2' envoy√©e
    ‚îÇ                                ‚îÇ
COMMIT  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Notification 'order-1' envoy√©e
    ‚îÇ
    ‚ñº

Les listeners re√ßoivent : 'order-2' puis 'order-1'
(L'ordre des COMMIT, pas l'ordre des INSERT)
```

---

## Int√©gration avec les Triggers

La puissance de NOTIFY/LISTEN se r√©v√®le vraiment avec les **triggers**. Chaque modification de donn√©es peut automatiquement d√©clencher une notification.

### Trigger Basique

```sql
-- Fonction trigger pour notifier les nouvelles commandes
CREATE OR REPLACE FUNCTION notify_order_changes()
RETURNS TRIGGER AS $$
BEGIN
    -- Construire le payload JSON
    PERFORM pg_notify(
        'orders',
        json_build_object(
            'action', TG_OP,
            'order_id', NEW.id,
            'total', NEW.total,
            'status', NEW.status,
            'timestamp', NOW()
        )::text
    );

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Cr√©er le trigger sur la table orders
CREATE TRIGGER trg_order_notify
AFTER INSERT OR UPDATE ON orders
FOR EACH ROW
EXECUTE FUNCTION notify_order_changes();
```

### Trigger Avanc√© avec Canaux Dynamiques

```sql
-- Notification sur des canaux sp√©cifiques selon le contexte
CREATE OR REPLACE FUNCTION notify_order_changes_advanced()
RETURNS TRIGGER AS $$
DECLARE
    v_payload JSONB;
    v_channel TEXT;
BEGIN
    -- Construire le payload
    v_payload := jsonb_build_object(
        'action', TG_OP,
        'order_id', NEW.id,
        'old_status', CASE WHEN TG_OP = 'UPDATE' THEN OLD.status ELSE NULL END,
        'new_status', NEW.status,
        'total', NEW.total,
        'customer_id', NEW.customer_id,
        'timestamp', NOW()
    );

    -- Canal g√©n√©ral pour toutes les commandes
    PERFORM pg_notify('orders', v_payload::text);

    -- Canal sp√©cifique par statut
    v_channel := 'orders_' || NEW.status;
    PERFORM pg_notify(v_channel, v_payload::text);

    -- Canal sp√©cifique par client (pour notifications personnalis√©es)
    v_channel := 'customer_' || NEW.customer_id;
    PERFORM pg_notify(v_channel, v_payload::text);

    -- Notification sp√©ciale pour les grosses commandes
    IF NEW.total > 1000 THEN
        PERFORM pg_notify('high_value_orders', v_payload::text);
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_order_notify_advanced
AFTER INSERT OR UPDATE ON orders
FOR EACH ROW
EXECUTE FUNCTION notify_order_changes_advanced();
```

### Trigger pour l'Event Store

Reprenant notre Event Store du chapitre pr√©c√©dent :

```sql
-- Notifier chaque nouvel √©v√©nement dans l'Event Store
CREATE OR REPLACE FUNCTION notify_new_event()
RETURNS TRIGGER AS $$
DECLARE
    v_payload JSONB;
BEGIN
    -- Payload compact avec les infos essentielles
    v_payload := jsonb_build_object(
        'event_id', NEW.event_id,
        'stream_type', NEW.stream_type,
        'stream_id', NEW.stream_id,
        'stream_version', NEW.stream_version,
        'event_type', NEW.event_type,
        'global_position', NEW.global_position,
        'occurred_at', NEW.occurred_at
    );

    -- Canal global pour tous les √©v√©nements
    PERFORM pg_notify('events', v_payload::text);

    -- Canal par type de stream (ex: 'events_Order', 'events_Account')
    PERFORM pg_notify('events_' || NEW.stream_type, v_payload::text);

    -- Canal par type d'√©v√©nement (ex: 'event_OrderPlaced')
    PERFORM pg_notify('event_' || NEW.event_type, v_payload::text);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_event_store_notify
AFTER INSERT ON events
FOR EACH ROW
EXECUTE FUNCTION notify_new_event();
```

---

## R√©ception des Notifications

### Dans psql (pour tester)

```sql
-- Terminal 1 : √âcouter
LISTEN orders;

-- Terminal 2 : Envoyer
NOTIFY orders, 'test message';

-- Terminal 1 : Recevoir
-- Asynchronous notification "orders" with payload "test message"
-- received from server process with PID 12345.
```

### V√©rifier les Notifications en Attente

```sql
-- Dans une session, apr√®s LISTEN
SELECT pg_notification_queue_usage();
-- Retourne le pourcentage d'utilisation de la queue (0.0 √† 1.0)
```

---

## Int√©gration avec les Langages de Programmation

### Python avec psycopg

```python
import psycopg
import select
import json

def listen_for_orders():
    # Connexion √† PostgreSQL
    conn = psycopg.connect(
        "host=localhost dbname=myapp user=myuser password=secret",
        autocommit=True  # Important pour LISTEN
    )

    # S'abonner au canal
    conn.execute("LISTEN orders")
    print("En √©coute sur le canal 'orders'...")

    # Boucle d'√©coute
    while True:
        # Attendre une notification (timeout de 5 secondes)
        if select.select([conn], [], [], 5) == ([], [], []):
            # Timeout, aucune notification
            print(".", end="", flush=True)
        else:
            # Notification re√ßue
            conn.poll()
            while conn.notifies:
                notify = conn.notifies.pop(0)

                print(f"\nNotification re√ßue !")
                print(f"  Canal: {notify.channel}")
                print(f"  Payload: {notify.payload}")
                print(f"  PID: {notify.pid}")

                # Parser le JSON si applicable
                try:
                    data = json.loads(notify.payload)
                    print(f"  Donn√©es: {data}")
                except json.JSONDecodeError:
                    pass

if __name__ == "__main__":
    listen_for_orders()
```

### Python avec asyncio (psycopg 3)

```python
import asyncio
import psycopg
import json

async def listen_for_events():
    # Connexion asynchrone
    aconn = await psycopg.AsyncConnection.connect(
        "host=localhost dbname=myapp user=myuser password=secret",
        autocommit=True
    )

    # S'abonner aux canaux
    await aconn.execute("LISTEN events")
    await aconn.execute("LISTEN high_value_orders")

    print("√âcoute asynchrone d√©marr√©e...")

    # G√©n√©rateur asynchrone de notifications
    async for notify in aconn.notifies():
        print(f"[{notify.channel}] {notify.payload}")

        # Traiter selon le canal
        if notify.channel == "high_value_orders":
            data = json.loads(notify.payload)
            await handle_high_value_order(data)
        elif notify.channel == "events":
            data = json.loads(notify.payload)
            await process_event(data)

async def handle_high_value_order(data):
    print(f"  üîî Alerte: Grosse commande #{data['order_id']} !")
    # Envoyer notification Slack, email, etc.

async def process_event(data):
    print(f"  üìù √âv√©nement: {data['event_type']} sur {data['stream_id']}")

if __name__ == "__main__":
    asyncio.run(listen_for_events())
```

### Node.js avec pg

```javascript
const { Client } = require('pg');

async function listenForOrders() {
    const client = new Client({
        host: 'localhost',
        database: 'myapp',
        user: 'myuser',
        password: 'secret'
    });

    await client.connect();

    // Gestionnaire de notifications
    client.on('notification', (msg) => {
        console.log('Notification re√ßue !');
        console.log('  Canal:', msg.channel);
        console.log('  Payload:', msg.payload);

        try {
            const data = JSON.parse(msg.payload);
            console.log('  Donn√©es:', data);

            // Traiter l'√©v√©nement
            handleOrderEvent(data);
        } catch (e) {
            console.log('  (payload non-JSON)');
        }
    });

    // S'abonner aux canaux
    await client.query('LISTEN orders');
    await client.query('LISTEN high_value_orders');

    console.log('En √©coute sur les canaux orders et high_value_orders...');
}

function handleOrderEvent(data) {
    switch (data.action) {
        case 'INSERT':
            console.log(`  ‚ûï Nouvelle commande: ${data.order_id}`);
            break;
        case 'UPDATE':
            console.log(`  üîÑ Commande mise √† jour: ${data.order_id}`);
            break;
    }
}

listenForOrders().catch(console.error);
```

### Go avec pgx

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"

    "github.com/jackc/pgx/v5/pgxpool"
)

type OrderNotification struct {
    Action    string  `json:"action"`
    OrderID   string  `json:"order_id"`
    Total     float64 `json:"total"`
    Status    string  `json:"status"`
    Timestamp string  `json:"timestamp"`
}

func main() {
    ctx := context.Background()

    // Pool de connexions
    pool, err := pgxpool.New(ctx,
        "postgres://myuser:secret@localhost/myapp")
    if err != nil {
        log.Fatal(err)
    }
    defer pool.Close()

    // Acqu√©rir une connexion d√©di√©e pour LISTEN
    conn, err := pool.Acquire(ctx)
    if err != nil {
        log.Fatal(err)
    }
    defer conn.Release()

    // S'abonner
    _, err = conn.Exec(ctx, "LISTEN orders")
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println("En √©coute sur le canal 'orders'...")

    // Boucle d'√©coute
    for {
        notification, err := conn.Conn().WaitForNotification(ctx)
        if err != nil {
            log.Fatal(err)
        }

        fmt.Printf("Notification sur '%s'\n", notification.Channel)

        var order OrderNotification
        if err := json.Unmarshal(
            []byte(notification.Payload), &order); err == nil {
            fmt.Printf("  Commande: %s, Total: %.2f, Status: %s\n",
                order.OrderID, order.Total, order.Status)
        }
    }
}
```

---

## Patterns d'Utilisation

### Pattern 1 : Mise √† Jour de Cache

Invalider ou mettre √† jour un cache quand les donn√©es changent :

```sql
-- Trigger pour notifier les changements de produits
CREATE OR REPLACE FUNCTION notify_product_change()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM pg_notify(
        'cache_invalidation',
        json_build_object(
            'type', 'product',
            'action', TG_OP,
            'id', COALESCE(NEW.id, OLD.id),
            'cache_key', 'product:' || COALESCE(NEW.id, OLD.id)
        )::text
    );
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_product_cache
AFTER INSERT OR UPDATE OR DELETE ON products
FOR EACH ROW
EXECUTE FUNCTION notify_product_change();
```

```python
# Application : √âcouter et invalider le cache Redis
async def cache_invalidation_listener():
    async for notify in conn.notifies():
        if notify.channel == "cache_invalidation":
            data = json.loads(notify.payload)
            cache_key = data['cache_key']

            # Invalider dans Redis
            await redis.delete(cache_key)
            print(f"Cache invalid√©: {cache_key}")
```

### Pattern 2 : Dashboard Temps R√©el

```sql
-- Trigger pour les m√©triques en temps r√©el
CREATE OR REPLACE FUNCTION notify_metrics()
RETURNS TRIGGER AS $$
BEGIN
    -- Calculer les m√©triques agr√©g√©es
    PERFORM pg_notify(
        'dashboard_metrics',
        (SELECT json_build_object(
            'timestamp', NOW(),
            'orders_today', COUNT(*) FILTER (
                WHERE created_at::date = CURRENT_DATE
            ),
            'revenue_today', SUM(total) FILTER (
                WHERE created_at::date = CURRENT_DATE
            ),
            'pending_orders', COUNT(*) FILTER (
                WHERE status = 'pending'
            )
        ) FROM orders)::text
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- D√©clencher √† chaque changement de commande
CREATE TRIGGER trg_dashboard_metrics
AFTER INSERT OR UPDATE ON orders
FOR EACH STATEMENT  -- Une seule notification par statement
EXECUTE FUNCTION notify_metrics();
```

### Pattern 3 : Synchronisation Multi-Instances

Quand plusieurs instances d'une application doivent rester synchronis√©es :

```sql
-- Notifier toutes les instances d'un changement de configuration
CREATE OR REPLACE FUNCTION notify_config_change()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM pg_notify(
        'app_config',
        json_build_object(
            'action', 'reload',
            'key', NEW.key,
            'value', NEW.value,
            'updated_at', NOW()
        )::text
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_config_notify
AFTER INSERT OR UPDATE ON app_configuration
FOR EACH ROW
EXECUTE FUNCTION notify_config_change();
```

### Pattern 4 : File d'Attente Simple (Job Queue)

```sql
-- Table de jobs
CREATE TABLE jobs (
    id SERIAL PRIMARY KEY,
    job_type VARCHAR(100) NOT NULL,
    payload JSONB NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ
);

-- Notifier les workers quand un nouveau job arrive
CREATE OR REPLACE FUNCTION notify_new_job()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM pg_notify(
        'jobs_' || NEW.job_type,
        json_build_object(
            'job_id', NEW.id,
            'job_type', NEW.job_type,
            'created_at', NEW.created_at
        )::text
    );

    -- Aussi sur un canal g√©n√©ral
    PERFORM pg_notify('jobs', NEW.id::text);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_job_notify
AFTER INSERT ON jobs
FOR EACH ROW
WHEN (NEW.status = 'pending')
EXECUTE FUNCTION notify_new_job();
```

```python
# Worker qui traite les jobs
async def job_worker(job_type: str):
    await conn.execute(f"LISTEN jobs_{job_type}")

    async for notify in conn.notifies():
        data = json.loads(notify.payload)
        job_id = data['job_id']

        # R√©clamer le job (avec verrouillage)
        result = await conn.fetchrow("""
            UPDATE jobs
            SET status = 'processing', started_at = NOW()
            WHERE id = $1 AND status = 'pending'
            RETURNING *
        """, job_id)

        if result:
            print(f"Traitement du job {job_id}...")
            await process_job(result)

            await conn.execute("""
                UPDATE jobs
                SET status = 'completed', completed_at = NOW()
                WHERE id = $1
            """, job_id)
```

---

## Architecture WebSocket avec NOTIFY/LISTEN

Un cas d'usage courant est de pousser les notifications PostgreSQL vers des clients web via WebSocket.

### Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê               ‚îÇ
‚îÇ  ‚îÇ Browser ‚îÇ    ‚îÇ Browser ‚îÇ    ‚îÇ Browser ‚îÇ    ‚îÇ Browser ‚îÇ   Clients     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò   Web         ‚îÇ
‚îÇ       ‚îÇ              ‚îÇ              ‚îÇ              ‚îÇ                    ‚îÇ
‚îÇ       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îÇ
‚îÇ                              ‚îÇ                                          ‚îÇ
‚îÇ                              ‚îÇ WebSocket                                ‚îÇ
‚îÇ                              ‚ñº                                          ‚îÇ
‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                 ‚îÇ
‚îÇ                    ‚îÇ   WebSocket      ‚îÇ                                 ‚îÇ
‚îÇ                    ‚îÇ   Server         ‚îÇ   Application                   ‚îÇ
‚îÇ                    ‚îÇ   (Node/Python)  ‚îÇ   Backend                       ‚îÇ
‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                 ‚îÇ
‚îÇ                             ‚îÇ                                           ‚îÇ
‚îÇ                             ‚îÇ LISTEN                                    ‚îÇ
‚îÇ                             ‚ñº                                           ‚îÇ
‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                 ‚îÇ
‚îÇ                    ‚îÇ   PostgreSQL     ‚îÇ                                 ‚îÇ
‚îÇ                    ‚îÇ   NOTIFY/LISTEN  ‚îÇ                                 ‚îÇ
‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                 ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Exemple avec Node.js et Socket.io

```javascript
const { Server } = require('socket.io');
const { Client } = require('pg');
const http = require('http');

// Serveur HTTP et WebSocket
const server = http.createServer();
const io = new Server(server, {
    cors: { origin: "*" }
});

// Connexion PostgreSQL pour LISTEN
const pgClient = new Client({
    connectionString: 'postgres://user:pass@localhost/myapp'
});

async function start() {
    // Connecter √† PostgreSQL
    await pgClient.connect();

    // S'abonner aux canaux
    await pgClient.query('LISTEN orders');
    await pgClient.query('LISTEN events');

    // Relayer les notifications vers les WebSockets
    pgClient.on('notification', (msg) => {
        const data = JSON.parse(msg.payload);

        // √âmettre √† tous les clients connect√©s
        io.emit(msg.channel, data);

        // Ou √† une room sp√©cifique (ex: par customer_id)
        if (data.customer_id) {
            io.to(`customer:${data.customer_id}`).emit(msg.channel, data);
        }
    });

    // Gestion des connexions WebSocket
    io.on('connection', (socket) => {
        console.log('Client connect√©:', socket.id);

        // Permettre aux clients de rejoindre des rooms
        socket.on('subscribe', (room) => {
            socket.join(room);
            console.log(`${socket.id} a rejoint ${room}`);
        });

        socket.on('disconnect', () => {
            console.log('Client d√©connect√©:', socket.id);
        });
    });

    server.listen(3000, () => {
        console.log('WebSocket server sur le port 3000');
    });
}

start().catch(console.error);
```

### C√¥t√© Client (JavaScript)

```javascript
// Connexion WebSocket
const socket = io('http://localhost:3000');

// S'abonner √† ses propres notifications
socket.emit('subscribe', `customer:${customerId}`);

// √âcouter les √©v√©nements
socket.on('orders', (data) => {
    console.log('Nouvelle activit√© commande:', data);

    if (data.action === 'INSERT') {
        addOrderToUI(data);
    } else if (data.action === 'UPDATE') {
        updateOrderInUI(data);
    }
});

socket.on('events', (data) => {
    console.log('Nouvel √©v√©nement:', data);
    appendToEventLog(data);
});

// Mise √† jour de l'UI
function addOrderToUI(order) {
    const list = document.getElementById('orders-list');
    const item = document.createElement('li');
    item.textContent = `Commande #${order.order_id} - ${order.total}‚Ç¨`;
    list.prepend(item);
}
```

---

## Limites et Consid√©rations

### Limites Techniques

| Limite | Description |
|--------|-------------|
| **Taille du payload** | Maximum 8000 caract√®res par notification |
| **Pas de persistance** | Les notifications sont perdues si personne n'√©coute |
| **Pas de garantie de livraison** | Fire-and-forget, pas d'accus√© de r√©ception |
| **File d'attente limit√©e** | ~8GB par d√©faut, peut saturer sous forte charge |
| **M√™me serveur PostgreSQL** | LISTEN ne traverse pas les serveurs |

### Quand NE PAS Utiliser NOTIFY/LISTEN

| Situation | Alternative |
|-----------|-------------|
| Messages critiques ne devant pas √™tre perdus | RabbitMQ, Kafka, table Outbox |
| Tr√®s haute fr√©quence (10k+ msg/sec) | Message broker d√©di√© |
| Communication entre datacenters | Kafka, NATS, Redis Streams |
| Payloads volumineux (> 8KB) | Stocker en DB, notifier l'ID |
| Besoin de replay/historique | Event Store + LISTEN pour le temps r√©el |

### Bonnes Pratiques

#### 1. Garder les Payloads Petits

```sql
-- ‚úÖ Bon : Notifier seulement l'ID, charger les d√©tails s√©par√©ment
PERFORM pg_notify('orders', json_build_object(
    'action', 'INSERT',
    'id', NEW.id
)::text);

-- ‚ùå √âviter : Gros payload avec toutes les donn√©es
PERFORM pg_notify('orders', row_to_json(NEW)::text);  -- Peut d√©passer 8KB
```

#### 2. Nommer les Canaux de Fa√ßon Coh√©rente

```sql
-- Convention sugg√©r√©e
'entity_action'          -- ex: order_created, user_updated
'category.subcategory'   -- ex: events.orders, cache.products
'entity:id'              -- ex: customer:123 (pour ciblage pr√©cis)
```

#### 3. G√©rer les D√©connexions

```python
async def resilient_listener():
    while True:
        try:
            conn = await psycopg.AsyncConnection.connect(...)
            await conn.execute("LISTEN orders")

            async for notify in conn.notifies():
                await handle_notification(notify)

        except Exception as e:
            print(f"Erreur: {e}, reconnexion dans 5s...")
            await asyncio.sleep(5)
```

#### 4. Combiner avec l'Event Store

Pour les √©v√©nements critiques, utilisez l'Event Store comme source de v√©rit√© et NOTIFY/LISTEN comme acc√©l√©rateur :

```sql
-- L'√©v√©nement est TOUJOURS stock√© (source de v√©rit√©)
INSERT INTO events (...) VALUES (...);

-- La notification est un BONUS pour le temps r√©el
-- Si elle est perdue, l'√©v√©nement reste dans le store
```

---

## Monitoring des Notifications

### V√©rifier l'Utilisation de la Queue

```sql
-- Pourcentage d'utilisation de la queue de notifications
SELECT pg_notification_queue_usage();

-- Si > 0.5 (50%), risque de saturation
-- Alerter si > 0.8 (80%)
```

### Comptage des Listeners Actifs

```sql
-- Voir toutes les sessions en √©coute
SELECT
    pid,
    usename,
    application_name,
    client_addr,
    state,
    query
FROM pg_stat_activity
WHERE query LIKE '%LISTEN%'
   OR wait_event_type = 'Client';
```

### Logs des Notifications

Activer le logging pour d√©bugger :

```sql
-- Dans postgresql.conf
-- log_statement = 'all'  -- Attention, tr√®s verbeux

-- Ou pour une session
SET log_statement = 'all';
NOTIFY test_channel, 'debug message';
```

---

## Conclusion

Le m√©canisme **NOTIFY/LISTEN** de PostgreSQL est un outil puissant pour construire des applications r√©actives et temps r√©el. Il √©limine le besoin de polling constant et permet une communication instantan√©e entre la base de donn√©es et les applications.

Combin√© avec les triggers et l'Event Store, NOTIFY/LISTEN permet de :

- Mettre √† jour des dashboards en temps r√©el
- Invalider des caches instantan√©ment
- Synchroniser des applications distribu√©es
- Alimenter des WebSockets vers les navigateurs

Bien que limit√© pour les cas d'usage n√©cessitant une garantie de livraison ou une tr√®s haute fr√©quence, NOTIFY/LISTEN reste la solution id√©ale pour de nombreux sc√©narios temps r√©el, sans ajouter de d√©pendance externe √† votre stack PostgreSQL.

---

## Points Cl√©s √† Retenir

- **NOTIFY** : Envoie une notification sur un canal
- **LISTEN** : S'abonne pour recevoir les notifications d'un canal
- **Transactionnel** : Les notifications ne sont envoy√©es qu'apr√®s COMMIT
- **Triggers** : Automatisent les notifications lors des modifications de donn√©es
- **Payload** : Maximum 8000 caract√®res, pr√©f√©rer les IDs aux donn√©es compl√®tes
- **Pas de persistance** : Utilisez un Event Store pour les √©v√©nements critiques
- **WebSocket** : Id√©al pour pousser les notifications vers les navigateurs
- **Monitoring** : Surveillez `pg_notification_queue_usage()`

---


‚è≠Ô∏è [Logical Decoding et Change Data Capture (CDC)](/20bis-postgresql-et-architectures-modernes/02.3-logical-decoding-cdc.md)
