ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 20bis.3.3. Cold Starts et Gestion des Connexions

## Introduction

Dans le monde serverless, le terme **cold start** (dÃ©marrage Ã  froid) revient constamment. Ce phÃ©nomÃ¨ne, souvent perÃ§u comme un inconvÃ©nient, a des implications directes sur la faÃ§on dont vos applications interagissent avec PostgreSQL.

Ce chapitre explique ce qu'est un cold start, pourquoi il impacte les connexions Ã  la base de donnÃ©es, et quelles stratÃ©gies adopter pour minimiser ses effets. Nous verrons Ã©galement les meilleures pratiques pour gÃ©rer efficacement les connexions dans un contexte serverless.

---

## Qu'est-ce qu'un Cold Start ?

### DÃ©finition Simple

Un **cold start** se produit lorsqu'une fonction serverless doit Ãªtre initialisÃ©e avant de pouvoir traiter une requÃªte. C'est le temps nÃ©cessaire pour "rÃ©veiller" une fonction qui Ã©tait inactive.

### Le Cycle de Vie d'une Fonction Serverless

Pour comprendre les cold starts, observons comment fonctionne une fonction serverless :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 CYCLE DE VIE D'UNE FONCTION SERVERLESS                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  COLD START (DÃ©marrage Ã  froid)                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ 1. Provisioning    â”‚ 2. TÃ©lÃ©chargement â”‚ 3. Initialisation      â”‚    â”‚
â”‚  â”‚    du conteneur    â”‚    du code        â”‚    du runtime          â”‚    â”‚
â”‚  â”‚    (~100-500ms)    â”‚    (~50-200ms)    â”‚    (~50-500ms)         â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                    â”‚                                    â”‚
â”‚                                    â–¼                                    â”‚
â”‚  WARM STATE (Ã‰tat chaud)                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                                                                 â”‚    â”‚
â”‚  â”‚    RequÃªte 1 â”€â”€â–º ExÃ©cution rapide (~10-50ms)                    â”‚    â”‚
â”‚  â”‚    RequÃªte 2 â”€â”€â–º ExÃ©cution rapide (~10-50ms)                    â”‚    â”‚
â”‚  â”‚    RequÃªte 3 â”€â”€â–º ExÃ©cution rapide (~10-50ms)                    â”‚    â”‚
â”‚  â”‚         ...                                                     â”‚    â”‚
â”‚  â”‚                                                                 â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                    â”‚                                    â”‚
â”‚                            (InactivitÃ© ~5-15 min)                       â”‚
â”‚                                    â”‚                                    â”‚
â”‚                                    â–¼                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                    INSTANCE DÃ‰TRUITE                            â”‚    â”‚
â”‚  â”‚              (Retour Ã  l'Ã©tat froid)                            â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Les Phases d'un Cold Start

| Phase | Description | DurÃ©e typique |
|-------|-------------|---------------|
| **1. Provisioning** | Le cloud alloue un conteneur/micro-VM | 100-500 ms |
| **2. TÃ©lÃ©chargement** | Le code de la fonction est chargÃ© | 50-200 ms |
| **3. Initialisation runtime** | Node.js, Python, Java, etc. dÃ©marre | 50-500 ms |
| **4. Initialisation code** | Votre code d'init s'exÃ©cute | Variable |
| **5. Connexion DB** | Ã‰tablissement de la connexion PostgreSQL | 50-300 ms |

**Total cold start** : 300 ms Ã  2+ secondes selon la configuration.

### Warm Start vs Cold Start

```
COLD START (PremiÃ¨re requÃªte ou aprÃ¨s inactivitÃ©)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RequÃªte â”€â”€â–º [Provisioning][Init Runtime][Init Code][Connexion DB] â”€â”€â–º RÃ©ponse
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 500ms - 2s â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


WARM START (RequÃªtes suivantes)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RequÃªte â”€â”€â–º [ExÃ©cution] â”€â”€â–º RÃ©ponse
            â””â”€â”€ 10-50ms â”€â”€â”˜
```

La diffÃ©rence peut Ãªtre **10x Ã  100x** en termes de latence !

---

## Impact des Cold Starts sur PostgreSQL

### Le ProblÃ¨me de la Connexion Ã  la Base

Lors d'un cold start, la fonction doit Ã©tablir une nouvelle connexion Ã  PostgreSQL. Cette Ã©tape est souvent la plus coÃ»teuse de l'initialisation :

```
Anatomie d'une connexion PostgreSQL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Client                                      PostgreSQL
  â”‚                                              â”‚
  â”‚â”€â”€â”€â”€ 1. TCP Handshake (SYN/ACK) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚  ~10-30ms
  â”‚                                              â”‚
  â”‚â”€â”€â”€â”€ 2. SSL/TLS Handshake â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚  ~20-50ms
  â”‚                                              â”‚
  â”‚â”€â”€â”€â”€ 3. Authentification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚  ~10-30ms
  â”‚         (SCRAM-SHA-256)                      â”‚
  â”‚                                              â”‚
  â”‚â—„â”€â”€â”€ 4. ParamÃ¨tres de session â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚  ~5-10ms
  â”‚                                              â”‚
  â”‚         CONNEXION Ã‰TABLIE                    â”‚
  â”‚         Total: 50-150ms (local)              â”‚
  â”‚         Total: 100-300ms (distant/cloud)     â”‚
```

### Facteurs Aggravants

Plusieurs Ã©lÃ©ments peuvent augmenter le temps de connexion :

| Facteur | Impact | Explication |
|---------|--------|-------------|
| **Distance gÃ©ographique** | +50-200ms | Latence rÃ©seau entre rÃ©gions |
| **SSL/TLS** | +20-50ms | Handshake cryptographique |
| **DNS Resolution** | +10-50ms | RÃ©solution du hostname |
| **Authentification** | +10-30ms | SCRAM-SHA-256 vs md5 |
| **Charge du serveur** | Variable | Serveur occupÃ© = connexion lente |

### Le ScÃ©nario Catastrophe : Thundering Herd

Imaginez un pic de trafic aprÃ¨s une pÃ©riode d'inactivitÃ© :

```
                    THUNDERING HERD PROBLEM
                    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Temps 0: Toutes les fonctions sont "froides" (inactives)

Temps 1: Pic de trafic soudain (100 requÃªtes simultanÃ©es)

â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
â”‚Cold â”‚ â”‚Cold â”‚ â”‚Cold â”‚ â”‚Cold â”‚ â”‚ ... â”‚  100 cold starts
â”‚Startâ”‚ â”‚Startâ”‚ â”‚Startâ”‚ â”‚Startâ”‚ â”‚     â”‚  simultanÃ©s !
â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜
   â”‚       â”‚       â”‚       â”‚       â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚     PostgreSQL      â”‚
        â”‚                     â”‚
        â”‚  100 demandes de    â”‚  â† SURCHARGE !
        â”‚  connexion en       â”‚  â† Timeouts !
        â”‚  mÃªme temps         â”‚  â† Erreurs !
        â”‚                     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Ce phÃ©nomÃ¨ne, appelÃ© **"thundering herd"** (troupeau tonnant), peut :
- Saturer les connexions PostgreSQL
- Provoquer des timeouts
- Faire Ã©chouer des requÃªtes utilisateur
- DÃ©clencher un effet cascade de retries

---

## StratÃ©gies pour RÃ©duire les Cold Starts

### 1. Provisioned Concurrency (AWS Lambda)

AWS permet de garder des instances "chaudes" en permanence :

```
SANS Provisioned Concurrency
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Instances: 0 â”€â”€â–º Cold Start â”€â”€â–º 1 â”€â”€â–º Cold Start â”€â”€â–º 2 ...

AVEC Provisioned Concurrency (3 instances)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Instances: 3 (toujours prÃªtes)

RequÃªte 1 â”€â”€â–º Instance chaude #1 â”€â”€â–º RÃ©ponse immÃ©diate
RequÃªte 2 â”€â”€â–º Instance chaude #2 â”€â”€â–º RÃ©ponse immÃ©diate
RequÃªte 3 â”€â”€â–º Instance chaude #3 â”€â”€â–º RÃ©ponse immÃ©diate
RequÃªte 4 â”€â”€â–º Cold start (au-delÃ  du provisioned)
```

**Configuration AWS Lambda** :

```yaml
# serverless.yml (Serverless Framework)
functions:
  api:
    handler: handler.main
    provisionedConcurrency: 5  # 5 instances toujours chaudes
```

| Avantages | InconvÃ©nients |
|-----------|---------------|
| Latence constante et prÃ©visible | CoÃ»t fixe mÃªme sans trafic |
| Pas de cold start pour le trafic normal | Ne scale pas automatiquement |
| Connexions DB prÃ©-Ã©tablies | Dimensionnement Ã  estimer |

### 2. Warming (Keep-Alive)

Technique qui consiste Ã  "pinguer" rÃ©guliÃ¨rement les fonctions pour les maintenir chaudes :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    STRATÃ‰GIE DE WARMING                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                            â”‚
â”‚   CloudWatch Events (toutes les 5 minutes)                 â”‚
â”‚                         â”‚                                  â”‚
â”‚                         â–¼                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚   â”‚                  Lambda Warmer                       â”‚ â”‚
â”‚   â”‚                                                      â”‚ â”‚
â”‚   â”‚   â”€â”€â–º Ping Lambda API #1                             â”‚ â”‚
â”‚   â”‚   â”€â”€â–º Ping Lambda API #2                             â”‚ â”‚
â”‚   â”‚   â”€â”€â–º Ping Lambda API #3                             â”‚ â”‚
â”‚   â”‚                                                      â”‚ â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                            â”‚
â”‚   Les fonctions restent "chaudes" entre les pings          â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Exemple avec AWS EventBridge** :

```yaml
# serverless.yml
functions:
  api:
    handler: handler.main
    events:
      - http:
          path: /api
          method: any
      - schedule:
          rate: rate(5 minutes)  # Ping toutes les 5 min
          input:
            warmer: true
```

**Code de la fonction** :

```python
def handler(event, context):
    # DÃ©tecter les pings de warming
    if event.get('warmer'):
        print("Warming ping received")
        return {"statusCode": 200, "body": "warmed"}

    # Logique normale
    return process_request(event)
```

| Avantages | InconvÃ©nients |
|-----------|---------------|
| Simple Ã  implÃ©menter | CoÃ»t des invocations de warming |
| Pas de changement d'architecture | Ne garantit pas N instances chaudes |
| Fonctionne sur tous les clouds | Inefficace pour le scaling |

### 3. Optimiser le Code d'Initialisation

RÃ©duisez le temps de cold start en optimisant votre code :

#### Lazy Loading (Chargement Paresseux)

```python
# âŒ MAUVAIS : Import lourd au dÃ©marrage
import pandas as pd
import numpy as np
import tensorflow as tf

def handler(event, context):
    # pandas/numpy/tf chargÃ©s mÃªme si non utilisÃ©s
    return simple_operation()


# âœ… BON : Import uniquement si nÃ©cessaire
def handler(event, context):
    if needs_ml_processing(event):
        import tensorflow as tf
        return ml_operation(tf, event)

    return simple_operation()
```

#### Minimiser les DÃ©pendances

```
Taille du package vs Cold Start
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Package 1 MB   â”€â”€â–º Cold start ~200ms
Package 10 MB  â”€â”€â–º Cold start ~400ms
Package 50 MB  â”€â”€â–º Cold start ~800ms
Package 250 MB â”€â”€â–º Cold start ~2000ms+
```

**Conseils** :
- Utilisez des layers pour les dÃ©pendances partagÃ©es
- Excluez les fichiers inutiles (tests, docs)
- PrÃ©fÃ©rez les bibliothÃ¨ques lÃ©gÃ¨res

#### Choisir le Bon Runtime

| Runtime | Cold Start typique | Notes |
|---------|-------------------|-------|
| **Python** | 200-400ms | Bon Ã©quilibre |
| **Node.js** | 150-300ms | Parmi les plus rapides |
| **Go** | 50-150ms | Binaire compilÃ©, trÃ¨s rapide |
| **Rust** | 50-150ms | Excellent, mais courbe d'apprentissage |
| **Java** | 500ms-3s | JVM lourde, utiliser GraalVM |
| **.NET** | 300-600ms | AmÃ©lioration avec .NET 6+ |

### 4. Fonctions Plus Petites et SpÃ©cialisÃ©es

```
âŒ MAUVAIS : Une grosse fonction qui fait tout
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Mega Lambda (50 MB)               â”‚
â”‚  - Auth                                     â”‚
â”‚  - CRUD Users                               â”‚
â”‚  - CRUD Products                            â”‚
â”‚  - Reporting                                â”‚
â”‚  - ML Processing                            â”‚
â”‚  - File Processing                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Cold start: 2+ secondes


âœ… BON : Fonctions petites et spÃ©cialisÃ©es
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Auth     â”‚ â”‚ Users    â”‚ â”‚ Products â”‚
â”‚ (2 MB)   â”‚ â”‚ (3 MB)   â”‚ â”‚ (3 MB)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Cold start: ~300ms chacune
```

---

## Gestion Optimale des Connexions

### Le DÃ©fi : Connexions et Fonctions Serverless

Dans une architecture serverless, la gestion des connexions est complexe car :

1. **Chaque instance a sa propre connexion** (pas de partage entre instances)
2. **Les instances sont Ã©phÃ©mÃ¨res** (connexions abandonnÃ©es)
3. **Le nombre d'instances est imprÃ©visible** (scaling automatique)

### StratÃ©gie 1 : Connexion dans le Handler (Simple mais Inefficace)

```python
import psycopg2

def handler(event, context):
    # âŒ Nouvelle connexion Ã  chaque invocation
    conn = psycopg2.connect(
        host="db.example.com",
        database="mydb",
        user="user",
        password="password"
    )

    try:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM users WHERE id = %s", [event['user_id']])
        result = cursor.fetchone()
        return {"user": result}
    finally:
        conn.close()  # Connexion fermÃ©e Ã  chaque fois
```

**ProblÃ¨mes** :
- Nouvelle connexion Ã  CHAQUE requÃªte (~100-300ms)
- Gaspillage de ressources
- Pression sur PostgreSQL

### StratÃ©gie 2 : RÃ©utilisation de Connexion (RecommandÃ©e)

```python
import psycopg2

# Connexion crÃ©Ã©e UNE FOIS lors du cold start
# et rÃ©utilisÃ©e pour les invocations suivantes
connection = None

def get_connection():
    global connection

    if connection is None or connection.closed:
        connection = psycopg2.connect(
            host="db.example.com",
            database="mydb",
            user="user",
            password="password"
        )

    return connection

def handler(event, context):
    conn = get_connection()  # RÃ©utilise la connexion existante

    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users WHERE id = %s", [event['user_id']])
    result = cursor.fetchone()

    # NE PAS fermer la connexion !
    return {"user": result}
```

```
Comportement avec rÃ©utilisation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Cold Start:
  [Init Runtime] â”€â”€â–º [CrÃ©er Connexion] â”€â”€â–º [Handler] â”€â”€â–º RÃ©ponse
                         100-300ms

Warm Invocations:
  [Handler avec connexion existante] â”€â”€â–º RÃ©ponse
              ~10-50ms (pas de connexion Ã  crÃ©er)
```

### StratÃ©gie 3 : Gestion Robuste avec Retry et Reconnexion

```python
import psycopg2
from psycopg2 import OperationalError
import time

connection = None

def get_connection(max_retries=3, retry_delay=0.5):
    global connection

    # VÃ©rifier si la connexion existante est valide
    if connection is not None:
        try:
            # Test rapide de la connexion
            cursor = connection.cursor()
            cursor.execute("SELECT 1")
            cursor.close()
            return connection
        except OperationalError:
            # Connexion morte, on la rÃ©initialise
            print("Connection stale, reconnecting...")
            connection = None

    # CrÃ©er une nouvelle connexion avec retry
    for attempt in range(max_retries):
        try:
            connection = psycopg2.connect(
                host="db.example.com",
                database="mydb",
                user="user",
                password="password",
                connect_timeout=5,
                options="-c statement_timeout=30000"  # 30s max par requÃªte
            )
            print(f"Connection established (attempt {attempt + 1})")
            return connection

        except OperationalError as e:
            print(f"Connection attempt {attempt + 1} failed: {e}")
            if attempt < max_retries - 1:
                time.sleep(retry_delay * (attempt + 1))  # Backoff exponentiel
            else:
                raise

def handler(event, context):
    try:
        conn = get_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM users WHERE id = %s", [event['user_id']])
        result = cursor.fetchone()
        cursor.close()
        return {"statusCode": 200, "body": {"user": result}}

    except OperationalError as e:
        # RÃ©initialiser la connexion pour la prochaine invocation
        global connection
        connection = None
        return {"statusCode": 503, "body": "Database temporarily unavailable"}
```

### StratÃ©gie 4 : Avec Connection Pooler (Production)

En production, combinez la rÃ©utilisation avec un connection pooler :

```python
import psycopg2

connection = None

def get_connection():
    global connection

    if connection is None or connection.closed:
        # Connexion via PgBouncer ou RDS Proxy
        connection = psycopg2.connect(
            host="pgbouncer.internal",  # Ou RDS Proxy endpoint
            port=6432,                   # Port PgBouncer
            database="mydb",
            user="user",
            password="password",
            # Options importantes pour le pooling
            options="-c search_path=public"
        )

    return connection
```

```
Architecture recommandÃ©e
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Lambda #1  â”‚     â”‚  Lambda #2  â”‚     â”‚  Lambda #N  â”‚
â”‚ (1 conn/    â”‚     â”‚ (1 conn/    â”‚     â”‚ (1 conn/    â”‚
â”‚  instance)  â”‚     â”‚  instance)  â”‚     â”‚  instance)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                   â”‚                   â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   PgBouncer/RDS Proxy  â”‚
              â”‚   (Transaction mode)   â”‚
              â”‚                        â”‚
              â”‚   Max 1000 clients     â”‚
              â”‚   â†’ 20-50 connexions   â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚      PostgreSQL        â”‚
              â”‚   (20-50 connexions    â”‚
              â”‚    rÃ©elles)            â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### StratÃ©gie 5 : Context Manager pour Transactions

Pour les opÃ©rations nÃ©cessitant des transactions explicites :

```python
from contextlib import contextmanager
import psycopg2

connection = None

def get_connection():
    global connection
    if connection is None or connection.closed:
        connection = psycopg2.connect(...)
    return connection

@contextmanager
def transaction():
    """Context manager pour transactions avec commit/rollback automatique."""
    conn = get_connection()
    try:
        yield conn
        conn.commit()
    except Exception:
        conn.rollback()
        raise

def handler(event, context):
    with transaction() as conn:
        cursor = conn.cursor()

        # Plusieurs opÃ©rations dans une transaction
        cursor.execute("UPDATE accounts SET balance = balance - %s WHERE id = %s",
                      [event['amount'], event['from_account']])
        cursor.execute("UPDATE accounts SET balance = balance + %s WHERE id = %s",
                      [event['amount'], event['to_account']])
        cursor.execute("INSERT INTO transfers (from_id, to_id, amount) VALUES (%s, %s, %s)",
                      [event['from_account'], event['to_account'], event['amount']])

        # Commit automatique Ã  la sortie du with

    return {"statusCode": 200, "body": "Transfer completed"}
```

---

## Patterns AvancÃ©s

### Pattern 1 : Connexion avec Timeout Adaptatif

Adaptez le timeout selon le contexte (cold start vs warm) :

```python
import psycopg2
import os

connection = None
is_cold_start = True

def get_connection():
    global connection, is_cold_start

    if connection is None or connection.closed:
        # Timeout plus long pour cold start (connexion initiale)
        # Timeout court pour reconnexion (le serveur est probablement OK)
        timeout = 10 if is_cold_start else 3

        connection = psycopg2.connect(
            host=os.environ['DB_HOST'],
            database=os.environ['DB_NAME'],
            user=os.environ['DB_USER'],
            password=os.environ['DB_PASSWORD'],
            connect_timeout=timeout
        )

        is_cold_start = False

    return connection
```

### Pattern 2 : Health Check de Connexion

VÃ©rifiez pÃ©riodiquement la santÃ© de la connexion :

```python
import time

connection = None
last_health_check = 0
HEALTH_CHECK_INTERVAL = 60  # secondes

def get_healthy_connection():
    global connection, last_health_check

    current_time = time.time()

    # CrÃ©er connexion si nÃ©cessaire
    if connection is None:
        connection = create_connection()
        last_health_check = current_time
        return connection

    # Health check pÃ©riodique
    if current_time - last_health_check > HEALTH_CHECK_INTERVAL:
        try:
            cursor = connection.cursor()
            cursor.execute("SELECT 1")
            cursor.close()
            last_health_check = current_time
        except:
            # Connexion morte, recrÃ©er
            try:
                connection.close()
            except:
                pass
            connection = create_connection()
            last_health_check = current_time

    return connection
```

### Pattern 3 : MÃ©triques de Connexion

Instrumentez vos connexions pour le monitoring :

```python
import time
import logging

connection = None
metrics = {
    'connection_attempts': 0,
    'connection_failures': 0,
    'connection_reuses': 0,
    'total_connection_time_ms': 0
}

def get_connection_with_metrics():
    global connection, metrics

    if connection is not None and not connection.closed:
        metrics['connection_reuses'] += 1
        return connection

    metrics['connection_attempts'] += 1
    start_time = time.time()

    try:
        connection = psycopg2.connect(...)
        elapsed_ms = (time.time() - start_time) * 1000
        metrics['total_connection_time_ms'] += elapsed_ms

        logging.info(f"New connection established in {elapsed_ms:.2f}ms")
        return connection

    except Exception as e:
        metrics['connection_failures'] += 1
        logging.error(f"Connection failed: {e}")
        raise

def handler(event, context):
    # Ã€ la fin, loguer les mÃ©triques
    conn = get_connection_with_metrics()
    # ... logique

    # Log mÃ©triques (ou envoi vers CloudWatch/Datadog)
    if context.get_remaining_time_in_millis() > 1000:
        logging.info(f"Connection metrics: {metrics}")
```

---

## Gestion des Erreurs de Connexion

### Types d'Erreurs Courantes

| Erreur | Cause | Solution |
|--------|-------|----------|
| `connection refused` | PostgreSQL down ou mauvais port | VÃ©rifier l'endpoint et le port |
| `timeout expired` | RÃ©seau lent ou serveur surchargÃ© | Augmenter timeout, vÃ©rifier rÃ©seau |
| `too many connections` | Limite atteinte | Utiliser un pooler |
| `SSL SYSCALL error` | Connexion interrompue | Reconnexion automatique |
| `server closed connection` | Idle timeout cÃ´tÃ© serveur | RÃ©utiliser avec vÃ©rification |

### Gestion ComplÃ¨te des Erreurs

```python
import psycopg2
from psycopg2 import OperationalError, InterfaceError
import logging

connection = None

class DatabaseConnectionError(Exception):
    """Erreur de connexion Ã  la base de donnÃ©es."""
    pass

def get_connection():
    global connection

    # Cas 1: Pas de connexion existante
    if connection is None:
        return create_new_connection()

    # Cas 2: Connexion marquÃ©e comme fermÃ©e
    if connection.closed:
        logging.info("Connection was closed, creating new one")
        return create_new_connection()

    # Cas 3: VÃ©rifier que la connexion est vivante
    try:
        with connection.cursor() as cur:
            cur.execute("SELECT 1")
        return connection
    except (OperationalError, InterfaceError) as e:
        logging.warning(f"Connection check failed: {e}")
        return create_new_connection()

def create_new_connection(max_retries=3):
    global connection

    for attempt in range(max_retries):
        try:
            connection = psycopg2.connect(
                host="db.example.com",
                database="mydb",
                user="user",
                password="password",
                connect_timeout=5
            )
            connection.autocommit = False
            logging.info(f"Connection created (attempt {attempt + 1})")
            return connection

        except OperationalError as e:
            logging.error(f"Attempt {attempt + 1} failed: {e}")

            if "too many connections" in str(e):
                # Attendre avant de rÃ©essayer
                time.sleep(1)
            elif "connection refused" in str(e):
                # Le serveur est probablement down
                raise DatabaseConnectionError("Database server unavailable")

            if attempt == max_retries - 1:
                raise DatabaseConnectionError(f"Failed after {max_retries} attempts: {e}")

def handler(event, context):
    try:
        conn = get_connection()
        # ... logique mÃ©tier
        return {"statusCode": 200, "body": "Success"}

    except DatabaseConnectionError as e:
        logging.error(f"Database error: {e}")
        return {"statusCode": 503, "body": "Service temporarily unavailable"}

    except Exception as e:
        logging.error(f"Unexpected error: {e}")
        # Invalider la connexion pour la prochaine invocation
        global connection
        if connection:
            try:
                connection.rollback()
            except:
                pass
            connection = None
        return {"statusCode": 500, "body": "Internal error"}
```

---

## Bonnes Pratiques RÃ©capitulatives

### 1. RÃ©utilisez Toujours les Connexions

```python
# âœ… Connexion globale, rÃ©utilisÃ©e entre invocations
connection = None

def handler(event, context):
    conn = get_connection()  # RÃ©utilise l'existante
    # ...
```

### 2. Utilisez un Connection Pooler en Production

Ne connectez jamais directement Ã  PostgreSQL depuis des fonctions serverless Ã  fort trafic.

### 3. GÃ©rez les Connexions Mortes

```python
# âœ… Toujours vÃ©rifier et reconnecter si nÃ©cessaire
if connection is None or connection.closed:
    connection = create_connection()
```

### 4. Configurez des Timeouts AppropriÃ©s

```python
connection = psycopg2.connect(
    # ...
    connect_timeout=5,           # Max 5s pour Ã©tablir la connexion
    options="-c statement_timeout=30000"  # Max 30s par requÃªte
)
```

### 5. Ne Fermez Pas la Connexion dans le Handler

```python
# âŒ Ne pas faire
def handler(event, context):
    conn = get_connection()
    # ...
    conn.close()  # NON ! Garde-la pour la prochaine invocation

# âœ… Faire
def handler(event, context):
    conn = get_connection()
    # ...
    # Pas de close(), la connexion reste ouverte
```

### 6. Utilisez Provisioned Concurrency pour les APIs Critiques

Pour les endpoints sensibles Ã  la latence, le surcoÃ»t vaut le coup.

### 7. Monitorez les Connexions

Suivez ces mÃ©triques :
- Nombre de connexions actives
- Temps de crÃ©ation de connexion
- Taux d'Ã©chec de connexion
- Connexions rÃ©utilisÃ©es vs crÃ©Ã©es

### 8. Testez les ScÃ©narios de Panne

Simulez :
- PostgreSQL qui redÃ©marre
- Timeouts rÃ©seau
- Pic de charge (thundering herd)

---

## Tableau RÃ©capitulatif

| Aspect | Mauvaise Pratique | Bonne Pratique |
|--------|-------------------|----------------|
| **CrÃ©ation** | Nouvelle connexion par requÃªte | RÃ©utiliser la connexion globale |
| **Fermeture** | Fermer aprÃ¨s chaque handler | Ne jamais fermer (sauf erreur) |
| **VÃ©rification** | Aucune | Tester avant utilisation |
| **Erreurs** | Ignorer | Retry avec backoff + reconnexion |
| **Timeouts** | Par dÃ©faut (infini) | Explicites et courts |
| **Pooling** | Direct Ã  PostgreSQL | Via PgBouncer/RDS Proxy |
| **Cold starts** | Subir | Provisioned Concurrency + Warming |
| **Monitoring** | Aucun | MÃ©triques de connexion |

---

## Conclusion

Les cold starts et la gestion des connexions sont des dÃ©fis inhÃ©rents aux architectures serverless, mais ils sont loin d'Ãªtre insurmontables.

**Points clÃ©s Ã  retenir :**

1. **Les cold starts sont inÃ©vitables** mais peuvent Ãªtre minimisÃ©s via Provisioned Concurrency, warming, et optimisation du code.

2. **La connexion Ã  PostgreSQL est souvent le goulot d'Ã©tranglement** lors d'un cold start. RÃ©utilisez-la entre les invocations.

3. **Un connection pooler est indispensable** en production pour protÃ©ger PostgreSQL et amÃ©liorer les performances.

4. **La robustesse est essentielle** : gÃ©rez les erreurs, reconnectez automatiquement, et monitorez vos connexions.

5. **Mesurez et optimisez** : les mÃ©triques vous montreront oÃ¹ investir vos efforts.

En appliquant ces stratÃ©gies, vous pouvez construire des applications serverless performantes et fiables avec PostgreSQL, tout en gardant les avantages du modÃ¨le serverless : scaling automatique, facturation Ã  l'usage, et absence de gestion d'infrastructure.

---

## Ressources ComplÃ©mentaires

### Documentation

- AWS Lambda : Best Practices for Working with Databases
- Azure Functions : Database connections guidance
- Google Cloud Functions : Connecting to Cloud SQL

### Articles Techniques

- Analyse des cold starts par cloud provider
- Optimisation des connexions PostgreSQL en serverless
- Patterns de rÃ©silience pour bases de donnÃ©es

### Outils

- Lambda Power Tuning : Optimiser la mÃ©moire/CPU
- Artillery : Tests de charge serverless
- Datadog/New Relic : Monitoring des cold starts

---


â­ï¸ [IntÃ©gration avec Kubernetes](/20bis-postgresql-et-architectures-modernes/04-integration-kubernetes.md)
