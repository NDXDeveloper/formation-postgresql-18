ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 20bis.4.1. StatefulSets : Persistance et IdentitÃ©

## Introduction

DÃ©ployer PostgreSQL sur Kubernetes reprÃ©sente un dÃ©fi particulier. Contrairement Ã  une application web stateless (sans Ã©tat) qui peut Ãªtre rÃ©pliquÃ©e et dÃ©truite Ã  volontÃ©, une base de donnÃ©es a besoin de **persistance** et d'**identitÃ© stable**.

C'est exactement ce que les **StatefulSets** apportent Ã  Kubernetes. Dans ce chapitre, nous allons comprendre ce concept fondamental et voir comment il permet de faire fonctionner PostgreSQL de maniÃ¨re fiable dans un cluster Kubernetes.

---

## Kubernetes en Quelques Mots

Avant de plonger dans les StatefulSets, assurons-nous de comprendre les bases de Kubernetes.

### Qu'est-ce que Kubernetes ?

**Kubernetes** (souvent abrÃ©gÃ© "K8s") est une plateforme d'orchestration de conteneurs. Elle permet de :

- DÃ©ployer des applications conteneurisÃ©es
- Les faire Ã©voluer automatiquement (scaling)
- Les maintenir en bonne santÃ© (self-healing)
- GÃ©rer le rÃ©seau et le stockage

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        CLUSTER KUBERNETES                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚     Node 1      â”‚   â”‚     Node 2      â”‚   â”‚     Node 3      â”‚   â”‚
â”‚   â”‚   (Serveur)     â”‚   â”‚   (Serveur)     â”‚   â”‚   (Serveur)     â”‚   â”‚
â”‚   â”‚                 â”‚   â”‚                 â”‚   â”‚                 â”‚   â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â”    â”‚   â”‚  â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â”    â”‚   â”‚  â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â”    â”‚   â”‚
â”‚   â”‚  â”‚Podâ”‚ â”‚Podâ”‚    â”‚   â”‚  â”‚Podâ”‚ â”‚Podâ”‚    â”‚   â”‚  â”‚Podâ”‚ â”‚Podâ”‚    â”‚   â”‚
â”‚   â”‚  â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜    â”‚   â”‚  â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜    â”‚   â”‚  â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜    â”‚   â”‚
â”‚   â”‚                 â”‚   â”‚                 â”‚   â”‚                 â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                     â”‚
â”‚   Kubernetes distribue les Pods sur les Nodes disponibles           â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Les Concepts de Base

| Concept | Description |
|---------|-------------|
| **Cluster** | L'ensemble de l'infrastructure Kubernetes |
| **Node** | Une machine (physique ou virtuelle) dans le cluster |
| **Pod** | L'unitÃ© de base : un ou plusieurs conteneurs qui s'exÃ©cutent ensemble |
| **Service** | Un point d'accÃ¨s rÃ©seau stable vers des Pods |
| **Volume** | Du stockage attachÃ© aux Pods |

### Le ProblÃ¨me des Applications Stateless vs Stateful

Kubernetes a d'abord Ã©tÃ© conÃ§u pour les applications **stateless** (sans Ã©tat) :

```
APPLICATION STATELESS (ex: serveur web)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CaractÃ©ristiques :
â€¢ Chaque instance est identique et interchangeable
â€¢ Pas de donnÃ©es locales Ã  conserver
â€¢ Peut Ãªtre dÃ©truite et recrÃ©Ã©e n'importe oÃ¹
â€¢ Facile Ã  rÃ©pliquer

â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”
â”‚Web 1â”‚  â”‚Web 2â”‚  â”‚Web 3â”‚   â† Tous identiques
â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜     Interchangeables
    â”‚        â”‚        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Load Balancer  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
        Utilisateurs

Si Web 2 meurt â†’ Kubernetes le recrÃ©e ailleurs
Aucune perte de donnÃ©es car pas d'Ã©tat local
```

```
APPLICATION STATEFUL (ex: PostgreSQL)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CaractÃ©ristiques :
â€¢ Chaque instance a une identitÃ© unique
â€¢ Stocke des donnÃ©es qui doivent persister
â€¢ Ne peut PAS Ãªtre dÃ©truite sans prÃ©caution
â€¢ La rÃ©plication est complexe

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PG Primary  â”‚  â”‚PG Replica â”‚  â”‚PG Replica â”‚
â”‚  (Ã©criture) â”‚  â”‚ (lecture) â”‚  â”‚ (lecture) â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
      â”‚                â”‚              â”‚
â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
â”‚  Disque 1 â”‚    â”‚  Disque 2 â”‚  â”‚  Disque 3 â”‚
â”‚  (donnÃ©es)â”‚    â”‚  (donnÃ©es)â”‚  â”‚  (donnÃ©es)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Si PG Primary meurt â†’ Catastrophe si mal gÃ©rÃ© !
Les donnÃ©es doivent Ãªtre prÃ©servÃ©es
L'identitÃ© (primary vs replica) compte
```

---

## Le Deployment : InadaptÃ© pour les Bases de DonnÃ©es

### Comment Fonctionne un Deployment

Un **Deployment** est la ressource standard pour dÃ©ployer des applications sur Kubernetes :

```yaml
# Exemple de Deployment (pour une app stateless)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
      - name: nginx
        image: nginx:latest
```

Ce Deployment crÃ©e 3 Pods identiques avec des noms **alÃ©atoires** :

```
web-app-7d9f8b6c4d-x2k9p  â† Nom gÃ©nÃ©rÃ© alÃ©atoirement
web-app-7d9f8b6c4d-m3n7q  â† Nom gÃ©nÃ©rÃ© alÃ©atoirement
web-app-7d9f8b6c4d-h8j2w  â† Nom gÃ©nÃ©rÃ© alÃ©atoirement
```

### Pourquoi C'est ProblÃ©matique pour PostgreSQL

| Comportement du Deployment | ProblÃ¨me pour PostgreSQL |
|---------------------------|-------------------------|
| Noms de Pods alÃ©atoires | Impossible de savoir qui est primary/replica |
| Pas d'ordre de dÃ©marrage | Le replica pourrait dÃ©marrer avant le primary |
| Stockage partagÃ© ou Ã©phÃ©mÃ¨re | Les donnÃ©es seraient perdues ou corrompues |
| Remplacement arbitraire | Un nouveau Pod ne retrouverait pas ses donnÃ©es |

```
âŒ SCÃ‰NARIO CATASTROPHE AVEC DEPLOYMENT
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Deployment crÃ©e 3 Pods PostgreSQL
   pod-abc123 (primary ?)
   pod-def456 (replica ?)
   pod-ghi789 (replica ?)

2. pod-abc123 (primary) crashe

3. Kubernetes recrÃ©e un Pod...
   pod-xyz999 (nouveau, vide !)

4. ProblÃ¨mes :
   â€¢ OÃ¹ sont les donnÃ©es de l'ancien primary ?
   â€¢ Le nouveau Pod ne sait pas qu'il Ã©tait primary
   â€¢ Le disque de l'ancien Pod est peut-Ãªtre perdu

   â†’ PERTE DE DONNÃ‰ES POTENTIELLE
```

---

## StatefulSet : La Solution pour les Applications Stateful

### Qu'est-ce qu'un StatefulSet ?

Un **StatefulSet** est une ressource Kubernetes spÃ©cialement conÃ§ue pour les applications qui ont besoin de :

1. **IdentitÃ© stable** : Chaque Pod a un nom prÃ©visible et permanent
2. **Stockage persistant** : Chaque Pod a son propre volume de donnÃ©es
3. **Ordre de dÃ©ploiement** : Les Pods sont crÃ©Ã©s et supprimÃ©s dans un ordre dÃ©fini
4. **RÃ©seau stable** : Chaque Pod a un nom DNS prÃ©visible

### Les Garanties du StatefulSet

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    GARANTIES DU STATEFULSET                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  1. IDENTITÃ‰ STABLE                                                 â”‚
â”‚     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                               â”‚
â”‚     Noms prÃ©visibles : postgres-0, postgres-1, postgres-2           â”‚
â”‚     Pas de suffixes alÃ©atoires                                      â”‚
â”‚                                                                     â”‚
â”‚  2. STOCKAGE PERSISTANT                                             â”‚
â”‚     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                           â”‚
â”‚     Chaque Pod a son propre PersistentVolumeClaim                   â”‚
â”‚     Le volume survit Ã  la destruction du Pod                        â”‚
â”‚     postgres-0 retrouve toujours ses donnÃ©es                        â”‚
â”‚                                                                     â”‚
â”‚  3. DÃ‰PLOIEMENT ORDONNÃ‰                                             â”‚
â”‚     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                            â”‚
â”‚     CrÃ©ation : postgres-0, puis postgres-1, puis postgres-2         â”‚
â”‚     Suppression : postgres-2, puis postgres-1, puis postgres-0      â”‚
â”‚                                                                     â”‚
â”‚  4. RÃ‰SEAU STABLE                                                   â”‚
â”‚     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                               â”‚
â”‚     DNS : postgres-0.postgres-svc.namespace.svc.cluster.local       â”‚
â”‚     Toujours accessible Ã  la mÃªme adresse                           â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Comparaison Deployment vs StatefulSet

| Aspect | Deployment | StatefulSet |
|--------|------------|-------------|
| **Noms des Pods** | AlÃ©atoires (hash) | OrdonnÃ©s (0, 1, 2...) |
| **IdentitÃ©** | Interchangeable | Unique et stable |
| **Stockage** | PartagÃ© ou Ã©phÃ©mÃ¨re | DÃ©diÃ© et persistant |
| **Ordre de crÃ©ation** | ParallÃ¨le | SÃ©quentiel |
| **Ordre de suppression** | Arbitraire | Inverse de crÃ©ation |
| **DNS** | Via Service uniquement | Hostname individuel |
| **Cas d'usage** | Apps stateless | Bases de donnÃ©es, caches |

---

## Anatomie d'un StatefulSet

### Structure de Base

Voici la structure d'un StatefulSet pour PostgreSQL :

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
spec:
  serviceName: "postgres-svc"      # Service headless associÃ©
  replicas: 3                       # Nombre d'instances
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:16
        ports:
        - containerPort: 5432
        volumeMounts:
        - name: data
          mountPath: /var/lib/postgresql/data
  volumeClaimTemplates:             # Template pour les volumes
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi
```

### Les Composants ClÃ©s

#### 1. Le serviceName

```yaml
spec:
  serviceName: "postgres-svc"
```

Ce champ lie le StatefulSet Ã  un **Service Headless** qui permet la dÃ©couverte DNS des Pods individuels.

#### 2. Les replicas

```yaml
spec:
  replicas: 3
```

DÃ©finit le nombre d'instances. Les Pods seront nommÃ©s :
- `postgres-0`
- `postgres-1`
- `postgres-2`

#### 3. Le volumeClaimTemplates

```yaml
volumeClaimTemplates:
- metadata:
    name: data
  spec:
    accessModes: ["ReadWriteOnce"]
    resources:
      requests:
        storage: 10Gi
```

C'est la **fonctionnalitÃ© clÃ©** du StatefulSet. Pour chaque Pod, Kubernetes crÃ©e automatiquement un PersistentVolumeClaim (PVC) distinct :

```
StatefulSet postgres (replicas: 3)
         â”‚
         â”œâ”€â”€ postgres-0
         â”‚      â””â”€â”€ PVC: data-postgres-0 â”€â”€â–º Volume dÃ©diÃ©
         â”‚
         â”œâ”€â”€ postgres-1
         â”‚      â””â”€â”€ PVC: data-postgres-1 â”€â”€â–º Volume dÃ©diÃ©
         â”‚
         â””â”€â”€ postgres-2
                â””â”€â”€ PVC: data-postgres-2 â”€â”€â–º Volume dÃ©diÃ©
```

---

## L'IdentitÃ© Stable en DÃ©tail

### Nommage PrÃ©visible des Pods

Contrairement aux Deployments, les StatefulSets utilisent un nommage **ordonnÃ© et prÃ©visible** :

```
Format : <nom-statefulset>-<index>

Exemples :
  postgres-0    (premier Pod, index 0)
  postgres-1    (deuxiÃ¨me Pod, index 1)
  postgres-2    (troisiÃ¨me Pod, index 2)
```

Cette prÃ©visibilitÃ© est cruciale pour PostgreSQL :

```
CONFIGURATION POSTGRESQL AVEC STATEFULSET
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

postgres-0  â†’  Primary (maÃ®tre)
               Accepte lectures ET Ã©critures

postgres-1  â†’  Replica (esclave)
               RÃ©plique depuis postgres-0
               Lectures uniquement

postgres-2  â†’  Replica (esclave)
               RÃ©plique depuis postgres-0
               Lectures uniquement

L'index 0 est TOUJOURS le primary
Les scripts de configuration peuvent s'y fier
```

### DNS Stable avec le Service Headless

Un **Service Headless** est un Service sans ClusterIP qui permet d'accÃ©der directement aux Pods :

```yaml
apiVersion: v1
kind: Service
metadata:
  name: postgres-svc
spec:
  clusterIP: None          # â† Headless : pas d'IP de service
  selector:
    app: postgres
  ports:
  - port: 5432
```

Avec ce Service, chaque Pod obtient un enregistrement DNS individuel :

```
ENREGISTREMENTS DNS CRÃ‰Ã‰S
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

postgres-0.postgres-svc.default.svc.cluster.local
    â”‚         â”‚          â”‚      â”‚      â”‚
    â”‚         â”‚          â”‚      â”‚      â””â”€â”€ Domaine cluster
    â”‚         â”‚          â”‚      â””â”€â”€ Suffixe standard
    â”‚         â”‚          â””â”€â”€ Namespace
    â”‚         â””â”€â”€ Nom du Service
    â””â”€â”€ Nom du Pod (hostname)

Autres Pods :
postgres-1.postgres-svc.default.svc.cluster.local
postgres-2.postgres-svc.default.svc.cluster.local
```

**Utilisation pratique :**

```python
# Connexion au Primary (postgres-0)
conn = psycopg2.connect(
    host="postgres-0.postgres-svc.default.svc.cluster.local",
    database="mydb",
    user="postgres"
)

# Connexion Ã  un Replica spÃ©cifique
conn_replica = psycopg2.connect(
    host="postgres-1.postgres-svc.default.svc.cluster.local",
    database="mydb",
    user="postgres"
)
```

### Hostname dans le Pod

Chaque Pod connaÃ®t son propre hostname, ce qui permet des scripts de configuration intelligents :

```bash
# Dans le conteneur postgres-0
$ hostname
postgres-0

# Dans le conteneur postgres-1
$ hostname
postgres-1
```

Exemple de script d'initialisation :

```bash
#!/bin/bash

# RÃ©cupÃ©rer l'index du Pod
HOSTNAME=$(hostname)
INDEX=${HOSTNAME##*-}  # Extrait le numÃ©ro aprÃ¨s le dernier "-"

if [ "$INDEX" -eq 0 ]; then
    echo "Je suis le PRIMARY (postgres-0)"
    # Configuration en tant que primary
    pg_ctl start -D /var/lib/postgresql/data
else
    echo "Je suis un REPLICA (postgres-$INDEX)"
    # Configuration en tant que replica
    # Attendre que le primary soit prÃªt
    until pg_isready -h postgres-0.postgres-svc; do
        echo "Attente du primary..."
        sleep 2
    done
    # DÃ©marrer la rÃ©plication
    pg_basebackup -h postgres-0.postgres-svc -D /var/lib/postgresql/data -R
    pg_ctl start -D /var/lib/postgresql/data
fi
```

---

## La Persistance des DonnÃ©es

### Le ProblÃ¨me de la Persistance dans Kubernetes

Par dÃ©faut, les donnÃ©es dans un conteneur sont **Ã©phÃ©mÃ¨res** :

```
SANS PERSISTANCE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Pod postgres-0 crÃ©Ã©
   â””â”€â”€ DonnÃ©es en mÃ©moire/filesystem conteneur

2. Pod postgres-0 crashe ou est supprimÃ©

3. Pod postgres-0 recrÃ©Ã©
   â””â”€â”€ Nouveau filesystem vide !

   â†’ TOUTES LES DONNÃ‰ES SONT PERDUES
```

### PersistentVolume et PersistentVolumeClaim

Kubernetes utilise deux concepts pour la persistance :

| Concept | Description |
|---------|-------------|
| **PersistentVolume (PV)** | Un espace de stockage rÃ©el (disque, NFS, cloud storage) |
| **PersistentVolumeClaim (PVC)** | Une demande de stockage par une application |

```
RELATION PV / PVC
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        INFRASTRUCTURE                           â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚     PV 1    â”‚  â”‚     PV 2    â”‚  â”‚     PV 3    â”‚              â”‚
â”‚  â”‚   100 Gi    â”‚  â”‚    50 Gi    â”‚  â”‚   200 Gi    â”‚              â”‚
â”‚  â”‚  SSD Fast   â”‚  â”‚  HDD Slow   â”‚  â”‚  SSD Fast   â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚         â”‚                â”‚                â”‚                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                â”‚                â”‚
          â”‚    BINDING     â”‚                â”‚
          â”‚   (liaison)    â”‚                â”‚
          â–¼                â–¼                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        APPLICATIONS                             â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚    PVC 1    â”‚  â”‚    PVC 2    â”‚  â”‚    PVC 3    â”‚              â”‚
â”‚  â”‚"Je veux     â”‚  â”‚"Je veux     â”‚  â”‚"Je veux     â”‚              â”‚
â”‚  â”‚ 50Gi SSD"   â”‚  â”‚ 20Gi"       â”‚  â”‚ 100Gi SSD"  â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚         â”‚                â”‚                â”‚                     â”‚
â”‚         â–¼                â–¼                â–¼                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚ postgres-0  â”‚  â”‚ postgres-1  â”‚  â”‚ postgres-2  â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Le volumeClaimTemplates du StatefulSet

Le StatefulSet automatise la crÃ©ation des PVC via `volumeClaimTemplates` :

```yaml
volumeClaimTemplates:
- metadata:
    name: data
  spec:
    accessModes: ["ReadWriteOnce"]
    storageClassName: "fast-ssd"    # Classe de stockage
    resources:
      requests:
        storage: 10Gi
```

Ã€ la crÃ©ation du StatefulSet, Kubernetes gÃ©nÃ¨re automatiquement :

```
StatefulSet: postgres (replicas: 3)
â”‚
â”œâ”€â”€ CrÃ©e Pod: postgres-0
â”‚   â””â”€â”€ CrÃ©e PVC: data-postgres-0
â”‚       â””â”€â”€ Lie Ã  un PV de 10Gi (fast-ssd)
â”‚
â”œâ”€â”€ CrÃ©e Pod: postgres-1
â”‚   â””â”€â”€ CrÃ©e PVC: data-postgres-1
â”‚       â””â”€â”€ Lie Ã  un PV de 10Gi (fast-ssd)
â”‚
â””â”€â”€ CrÃ©e Pod: postgres-2
    â””â”€â”€ CrÃ©e PVC: data-postgres-2
        â””â”€â”€ Lie Ã  un PV de 10Gi (fast-ssd)
```

### Cycle de Vie des Volumes

**Point crucial** : Les PVC survivent Ã  la suppression des Pods !

```
CYCLE DE VIE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. StatefulSet crÃ©Ã© avec replicas: 3
   â†’ postgres-0, postgres-1, postgres-2 crÃ©Ã©s
   â†’ data-postgres-0, data-postgres-1, data-postgres-2 crÃ©Ã©s

2. postgres-1 crashe
   â†’ Pod supprimÃ©
   â†’ PVC data-postgres-1 CONSERVÃ‰ (donnÃ©es intactes)

3. Kubernetes recrÃ©e postgres-1
   â†’ Nouveau Pod avec le mÃªme nom
   â†’ Se rattache Ã  data-postgres-1
   â†’ RETROUVE SES DONNÃ‰ES !

4. Scale down Ã  replicas: 1
   â†’ postgres-2 supprimÃ©, PVC data-postgres-2 CONSERVÃ‰
   â†’ postgres-1 supprimÃ©, PVC data-postgres-1 CONSERVÃ‰
   â†’ postgres-0 reste actif

5. Scale up Ã  replicas: 3
   â†’ postgres-1 recrÃ©Ã©, retrouve data-postgres-1
   â†’ postgres-2 recrÃ©Ã©, retrouve data-postgres-2
```

### StorageClass : Choisir le Type de Stockage

Une **StorageClass** dÃ©finit le type de stockage Ã  utiliser :

```yaml
# Exemple de StorageClass pour AWS EBS
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast-ssd
provisioner: ebs.csi.aws.com
parameters:
  type: gp3
  iops: "3000"
  throughput: "125"
reclaimPolicy: Retain          # Garder les donnÃ©es aprÃ¨s suppression
allowVolumeExpansion: true     # Permettre l'agrandissement
volumeBindingMode: WaitForFirstConsumer
```

**StorageClasses courantes par cloud :**

| Cloud Provider | StorageClass | Type de stockage |
|---------------|--------------|------------------|
| **AWS** | gp3, io2 | EBS SSD |
| **GCP** | pd-ssd, pd-balanced | Persistent Disk |
| **Azure** | managed-premium | Azure Disk SSD |
| **On-premise** | local-storage | Disques locaux |

---

## L'Ordre de DÃ©ploiement

### CrÃ©ation SÃ©quentielle

Le StatefulSet crÃ©e les Pods **un par un**, dans l'ordre :

```
CRÃ‰ATION DES PODS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Temps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º

      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ postgres-0   â”‚ CrÃ©Ã© en premier
      â”‚   Starting   â”‚
      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚ Ready âœ“
             â–¼
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚ postgres-1   â”‚ CrÃ©Ã© quand postgres-0 est Ready
             â”‚   Starting   â”‚
             â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚ Ready âœ“
                    â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ postgres-2   â”‚ CrÃ©Ã© quand postgres-1 est Ready
                    â”‚   Starting   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Pourquoi c'est important pour PostgreSQL :**

1. `postgres-0` dÃ©marre en tant que **primary**
2. `postgres-0` initialise le cluster et devient disponible
3. `postgres-1` dÃ©marre et peut se connecter Ã  `postgres-0` pour la rÃ©plication
4. `postgres-2` dÃ©marre et se connecte Ã©galement Ã  `postgres-0`

Sans cet ordre, les replicas essaieraient de se connecter Ã  un primary qui n'existe pas encore !

### Suppression en Ordre Inverse

La suppression suit l'ordre **inverse** :

```
SUPPRESSION DES PODS (scale down ou delete)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Temps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º

                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ postgres-2   â”‚ SupprimÃ© en premier
                    â”‚  Terminating â”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚ TerminÃ© âœ“
                           â–¼
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚ postgres-1   â”‚ SupprimÃ© ensuite
             â”‚  Terminating â”‚
             â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚ TerminÃ© âœ“
                    â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ postgres-0   â”‚ SupprimÃ© en dernier (le primary)
      â”‚  Terminating â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Pourquoi c'est important :**

- Les replicas sont supprimÃ©s avant le primary
- Ã‰vite les erreurs de rÃ©plication vers un primary inexistant
- Permet une dÃ©gradation gracieuse du cluster

### ContrÃ´ler l'Ordre avec podManagementPolicy

Par dÃ©faut, le StatefulSet utilise `OrderedReady`. Vous pouvez changer ce comportement :

```yaml
spec:
  podManagementPolicy: OrderedReady  # DÃ©faut : un par un, attend Ready
  # ou
  podManagementPolicy: Parallel      # Tous en parallÃ¨le (use case avancÃ©)
```

| Policy | Comportement | Cas d'usage |
|--------|--------------|-------------|
| **OrderedReady** | SÃ©quentiel, attend que chaque Pod soit Ready | Bases de donnÃ©es, systÃ¨mes avec dÃ©pendances |
| **Parallel** | Tous les Pods en mÃªme temps | Applications stateful sans dÃ©pendance d'ordre |

Pour PostgreSQL, gardez **toujours** `OrderedReady`.

---

## Mise Ã  Jour d'un StatefulSet

### StratÃ©gies de Mise Ã  Jour

Le StatefulSet supporte deux stratÃ©gies de mise Ã  jour :

#### 1. RollingUpdate (DÃ©faut)

```yaml
spec:
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      partition: 0    # Mettre Ã  jour tous les Pods
```

Les Pods sont mis Ã  jour **un par un**, en ordre inverse (du plus grand index au plus petit) :

```
ROLLING UPDATE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Ã‰tat initial : postgres-0 (v1), postgres-1 (v1), postgres-2 (v1)

1. postgres-2 supprimÃ© â†’ recrÃ©Ã© avec v2
   postgres-0 (v1), postgres-1 (v1), postgres-2 (v2) âœ“

2. postgres-1 supprimÃ© â†’ recrÃ©Ã© avec v2
   postgres-0 (v1), postgres-1 (v2), postgres-2 (v2) âœ“

3. postgres-0 supprimÃ© â†’ recrÃ©Ã© avec v2
   postgres-0 (v2), postgres-1 (v2), postgres-2 (v2) âœ“

Mise Ã  jour terminÃ©e !
```

#### 2. OnDelete

```yaml
spec:
  updateStrategy:
    type: OnDelete
```

Les Pods ne sont mis Ã  jour que lorsqu'ils sont **manuellement supprimÃ©s** :

```bash
# Mise Ã  jour manuelle du Pod 0
kubectl delete pod postgres-0
# Kubernetes recrÃ©e postgres-0 avec la nouvelle configuration
```

**Utile pour :** Mises Ã  jour contrÃ´lÃ©es, tests progressifs.

### Partition : Mise Ã  Jour Partielle

Le paramÃ¨tre `partition` permet des mises Ã  jour "canary" :

```yaml
spec:
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      partition: 2    # Seuls les Pods avec index >= 2 seront mis Ã  jour
```

```
PARTITION UPDATE (partition: 2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Pods existants : postgres-0 (v1), postgres-1 (v1), postgres-2 (v1)

AprÃ¨s changement de l'image vers v2 :

â€¢ postgres-2 (index 2 >= partition 2) â†’ Mis Ã  jour vers v2
â€¢ postgres-1 (index 1 < partition 2)  â†’ Reste en v1
â€¢ postgres-0 (index 0 < partition 2)  â†’ Reste en v1

Ã‰tat final : postgres-0 (v1), postgres-1 (v1), postgres-2 (v2)

Vous pouvez tester v2 sur postgres-2 avant de mettre Ã  jour les autres !
```

---

## Exemple Complet : PostgreSQL avec StatefulSet

### Architecture Cible

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CLUSTER POSTGRESQL                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚         â”‚        Service: postgres-svc          â”‚              â”‚
â”‚         â”‚         (Headless, ClusterIP: None)   â”‚              â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                             â”‚                                  â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚         â”‚                   â”‚                   â”‚              â”‚
â”‚         â–¼                   â–¼                   â–¼              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ postgres-0  â”‚    â”‚ postgres-1  â”‚    â”‚ postgres-2  â”‚         â”‚
â”‚  â”‚  (PRIMARY)  â”‚    â”‚  (REPLICA)  â”‚    â”‚  (REPLICA)  â”‚         â”‚
â”‚  â”‚             â”‚    â”‚             â”‚    â”‚             â”‚         â”‚
â”‚  â”‚ Port: 5432  â”‚    â”‚ Port: 5432  â”‚    â”‚ Port: 5432  â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚         â”‚                  â”‚                  â”‚                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚     PVC     â”‚    â”‚     PVC     â”‚    â”‚     PVC     â”‚         â”‚
â”‚  â”‚data-postgresâ”‚    â”‚data-postgresâ”‚    â”‚data-postgresâ”‚         â”‚
â”‚  â”‚     -0      â”‚    â”‚     -1      â”‚    â”‚     -2      â”‚         â”‚
â”‚  â”‚   (10Gi)    â”‚    â”‚   (10Gi)    â”‚    â”‚   (10Gi)    â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Les Manifestes Kubernetes

#### 1. Le Service Headless

```yaml
# postgres-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: postgres-svc
  labels:
    app: postgres
spec:
  clusterIP: None              # Headless Service
  selector:
    app: postgres
  ports:
  - name: postgresql
    port: 5432
    targetPort: 5432
```

#### 2. Le ConfigMap pour la Configuration

```yaml
# postgres-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-config
data:
  POSTGRES_DB: "myapp"
  POSTGRES_USER: "appuser"
  # Configuration PostgreSQL
  postgresql.conf: |
    listen_addresses = '*'
    max_connections = 100
    shared_buffers = 256MB
    wal_level = replica
    max_wal_senders = 3
    max_replication_slots = 3
    hot_standby = on
```

#### 3. Le Secret pour le Mot de Passe

```yaml
# postgres-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: postgres-secret
type: Opaque
stringData:
  POSTGRES_PASSWORD: "your-secure-password"
  REPLICATION_PASSWORD: "replication-password"
```

#### 4. Le StatefulSet

```yaml
# postgres-statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
spec:
  serviceName: "postgres-svc"
  replicas: 3
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:16
        ports:
        - containerPort: 5432
          name: postgresql
        env:
        - name: POSTGRES_DB
          valueFrom:
            configMapKeyRef:
              name: postgres-config
              key: POSTGRES_DB
        - name: POSTGRES_USER
          valueFrom:
            configMapKeyRef:
              name: postgres-config
              key: POSTGRES_USER
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: POSTGRES_PASSWORD
        - name: PGDATA
          value: /var/lib/postgresql/data/pgdata
        volumeMounts:
        - name: data
          mountPath: /var/lib/postgresql/data
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        readinessProbe:
          exec:
            command:
            - pg_isready
            - -U
            - $(POSTGRES_USER)
            - -d
            - $(POSTGRES_DB)
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          exec:
            command:
            - pg_isready
            - -U
            - $(POSTGRES_USER)
            - -d
            - $(POSTGRES_DB)
          initialDelaySeconds: 30
          periodSeconds: 10
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      storageClassName: "standard"    # Adapter selon votre cluster
      resources:
        requests:
          storage: 10Gi
```

### Commandes de DÃ©ploiement

```bash
# Appliquer les manifestes
kubectl apply -f postgres-secret.yaml
kubectl apply -f postgres-configmap.yaml
kubectl apply -f postgres-service.yaml
kubectl apply -f postgres-statefulset.yaml

# VÃ©rifier le dÃ©ploiement
kubectl get statefulset postgres
kubectl get pods -l app=postgres
kubectl get pvc

# Voir les logs du primary
kubectl logs postgres-0

# Se connecter au primary
kubectl exec -it postgres-0 -- psql -U appuser -d myapp
```

---

## Bonnes Pratiques

### 1. Toujours Utiliser des Probes

```yaml
readinessProbe:
  exec:
    command: ["pg_isready", "-U", "postgres"]
  initialDelaySeconds: 5
  periodSeconds: 10

livenessProbe:
  exec:
    command: ["pg_isready", "-U", "postgres"]
  initialDelaySeconds: 30
  periodSeconds: 10
```

Les probes garantissent que :
- Les Pods ne reÃ§oivent du trafic que lorsqu'ils sont prÃªts
- Les Pods dÃ©faillants sont redÃ©marrÃ©s

### 2. DÃ©finir des Resources

```yaml
resources:
  requests:
    memory: "1Gi"
    cpu: "500m"
  limits:
    memory: "2Gi"
    cpu: "1000m"
```

Ã‰vite les problÃ¨mes de :
- Pods Ã©vincÃ©s par manque de mÃ©moire
- Contention CPU

### 3. Utiliser un StorageClass AppropriÃ©

| Workload | StorageClass recommandÃ©e |
|----------|-------------------------|
| **Production** | SSD avec IOPS garantis |
| **DÃ©veloppement** | Standard/balanced |
| **Haute performance** | NVMe local ou io2 |

### 4. Configurer la RÃ©tention des PVC

```yaml
# Dans le StorageClass
reclaimPolicy: Retain  # Ne jamais supprimer automatiquement les donnÃ©es
```

### 5. Ne Pas GÃ©rer la RÃ©plication Manuellement

Pour la rÃ©plication PostgreSQL en production, utilisez un **Operator** (voir chapitre 20bis.4.2) plutÃ´t que de scripter la rÃ©plication vous-mÃªme.

---

## Limitations des StatefulSets

### Ce que les StatefulSets NE FONT PAS

| Limitation | Description |
|------------|-------------|
| **Pas de rÃ©plication automatique** | Vous devez configurer la rÃ©plication PostgreSQL vous-mÃªme |
| **Pas de failover automatique** | Si postgres-0 meurt, pas de promotion automatique d'un replica |
| **Pas de backup intÃ©grÃ©** | Les sauvegardes sont votre responsabilitÃ© |
| **Pas de monitoring intÃ©grÃ©** | Vous devez ajouter vos propres outils |

### Pourquoi les Operators Existent

Les StatefulSets fournissent les **briques de base** (identitÃ©, persistance, ordre), mais pas la **logique mÃ©tier** spÃ©cifique Ã  PostgreSQL.

C'est pourquoi des **Operators PostgreSQL** ont Ã©tÃ© crÃ©Ã©s :

```
STATEFULSET SEUL                    STATEFULSET + OPERATOR
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ“ IdentitÃ© stable                   âœ“ IdentitÃ© stable
âœ“ Persistance                       âœ“ Persistance
âœ“ Ordre de dÃ©ploiement              âœ“ Ordre de dÃ©ploiement
                                    âœ“ RÃ©plication automatique
âœ— Pas de rÃ©plication auto           âœ“ Failover automatique
âœ— Pas de failover                   âœ“ Backups planifiÃ©s
âœ— Pas de backup                     âœ“ Monitoring intÃ©grÃ©
âœ— Pas de monitoring                 âœ“ Scaling simplifiÃ©
```

Le chapitre suivant (20bis.4.2) couvre les Operators en dÃ©tail.

---

## RÃ©sumÃ©

### Points ClÃ©s Ã  Retenir

| Concept | Description |
|---------|-------------|
| **StatefulSet** | Ressource Kubernetes pour applications stateful |
| **IdentitÃ© stable** | Noms prÃ©visibles (postgres-0, postgres-1, ...) |
| **Persistance** | Chaque Pod a son PVC dÃ©diÃ© qui survit aux redÃ©marrages |
| **Ordre** | CrÃ©ation sÃ©quentielle, suppression en ordre inverse |
| **DNS stable** | Chaque Pod accessible via `<pod>.<service>.<namespace>.svc.cluster.local` |

### Quand Utiliser un StatefulSet

âœ… **Utilisez un StatefulSet pour :**
- Bases de donnÃ©es (PostgreSQL, MySQL, MongoDB)
- SystÃ¨mes de cache distribuÃ©s (Redis Cluster)
- SystÃ¨mes de messaging (Kafka, RabbitMQ)
- Toute application nÃ©cessitant identitÃ© + persistance

âŒ **N'utilisez PAS un StatefulSet pour :**
- Applications web stateless
- Workers de traitement sans Ã©tat
- Toute application oÃ¹ les instances sont interchangeables

### Ce Qui Manque pour la Production

Un StatefulSet seul n'est pas suffisant pour PostgreSQL en production. Vous aurez besoin de :

1. **Un Operator** pour la gestion automatisÃ©e (failover, backups)
2. **Du monitoring** (Prometheus, Grafana)
3. **Une stratÃ©gie de backup** (pg_dump, pgBackRest, WAL archiving)
4. **Une configuration rÃ©seau sÃ©curisÃ©e** (NetworkPolicies, TLS)

Ces sujets sont couverts dans les chapitres suivants.

---

## Conclusion

Les StatefulSets sont la **fondation** pour exÃ©cuter PostgreSQL sur Kubernetes. Ils rÃ©solvent les problÃ¨mes fondamentaux d'identitÃ© et de persistance que les Deployments ne peuvent pas adresser.

Cependant, ils ne sont qu'une partie de la solution. Pour une configuration production-ready de PostgreSQL sur Kubernetes, vous combinerez :

- **StatefulSets** : Pour l'infrastructure de base
- **Operators** : Pour l'automatisation et la gestion du cycle de vie
- **Services** : Pour l'accÃ¨s rÃ©seau
- **ConfigMaps/Secrets** : Pour la configuration
- **Monitoring** : Pour l'observabilitÃ©

Le chapitre suivant sur les Operators vous montrera comment automatiser tout ce que les StatefulSets ne gÃ¨rent pas nativement.

---

## Ressources ComplÃ©mentaires

### Documentation Officielle

- [Kubernetes StatefulSets](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/)
- [Kubernetes Persistent Volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/)
- [Kubernetes Services](https://kubernetes.io/docs/concepts/services-networking/service/)

### Tutoriels

- Kubernetes : DÃ©ployer une base de donnÃ©es stateful
- Comprendre le stockage dans Kubernetes
- StatefulSets vs Deployments : Quand utiliser quoi

### Outils

- kubectl : CLI Kubernetes
- k9s : Interface terminal pour Kubernetes
- Lens : IDE Kubernetes

---


â­ï¸ [Operators : Zalando, CloudNativePG, Crunchy](/20bis-postgresql-et-architectures-modernes/04.2-operators.md)
