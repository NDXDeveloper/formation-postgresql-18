ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 20bis.1.1 â€” Database per Service vs Shared Database

## Introduction

Lorsqu'on conÃ§oit une application moderne basÃ©e sur une architecture microservices, une question fondamentale se pose rapidement : **comment organiser les bases de donnÃ©es ?** Faut-il que chaque microservice possÃ¨de sa propre base de donnÃ©es, ou plusieurs services peuvent-ils partager une mÃªme base ?

Cette dÃ©cision architecturale a des consÃ©quences profondes sur la scalabilitÃ©, la maintenance, l'autonomie des Ã©quipes et la cohÃ©rence des donnÃ©es de votre systÃ¨me.

Dans ce chapitre, nous allons explorer les deux approches principales â€” **Database per Service** et **Shared Database** â€” en prÃ©sentant leurs avantages, inconvÃ©nients et cas d'usage, avec un focus particulier sur PostgreSQL.

---

## Qu'est-ce qu'une Architecture Microservices ?

Avant d'aborder la gestion des bases de donnÃ©es, rappelons briÃ¨vement ce qu'est une architecture microservices.

Une **architecture microservices** consiste Ã  dÃ©couper une application en plusieurs services indÃ©pendants, chacun responsable d'une fonctionnalitÃ© mÃ©tier spÃ©cifique. Par exemple, une application e-commerce pourrait Ãªtre divisÃ©e en :

- Un service **Utilisateurs** (gestion des comptes)
- Un service **Catalogue** (produits et catÃ©gories)
- Un service **Commandes** (panier et achats)
- Un service **Paiements** (transactions financiÃ¨res)
- Un service **Notifications** (emails, SMS)

Chaque service peut Ãªtre dÃ©veloppÃ©, dÃ©ployÃ© et mis Ã  l'Ã©chelle indÃ©pendamment des autres.

---

## Approche 1 : Shared Database (Base de DonnÃ©es PartagÃ©e)

### Principe

Dans l'approche **Shared Database**, tous les microservices accÃ¨dent Ã  une **unique base de donnÃ©es PostgreSQL**. Les tables de tous les services coexistent dans la mÃªme instance.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Service    â”‚  â”‚  Service    â”‚  â”‚  Service    â”‚
â”‚ Utilisateursâ”‚  â”‚  Catalogue  â”‚  â”‚  Commandes  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                â”‚                â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   PostgreSQL    â”‚
              â”‚  (Base unique)  â”‚
              â”‚                 â”‚
              â”‚ - users         â”‚
              â”‚ - products      â”‚
              â”‚ - orders        â”‚
              â”‚ - payments      â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Avantages

**1. SimplicitÃ© de mise en Å“uvre**

C'est l'approche la plus simple Ã  mettre en place. Il n'y a qu'une seule base de donnÃ©es Ã  installer, configurer et maintenir. Pour une petite Ã©quipe ou un projet en dÃ©marrage, cela rÃ©duit considÃ©rablement la complexitÃ© opÃ©rationnelle.

**2. Transactions ACID natives**

Avec une base partagÃ©e, vous pouvez utiliser les **transactions PostgreSQL classiques** pour garantir la cohÃ©rence des donnÃ©es entre plusieurs tables, mÃªme si elles "appartiennent" Ã  diffÃ©rents services.

```sql
BEGIN;
  -- CrÃ©er la commande (service Commandes)
  INSERT INTO orders (user_id, total) VALUES (42, 99.99);

  -- DÃ©duire le stock (service Catalogue)
  UPDATE products SET stock = stock - 1 WHERE id = 101;

  -- Enregistrer le paiement (service Paiements)
  INSERT INTO payments (order_id, amount, status) VALUES (1, 99.99, 'completed');
COMMIT;
```

Cette transaction garantit que soit toutes les opÃ©rations rÃ©ussissent, soit aucune n'est appliquÃ©e (atomicitÃ©).

**3. Jointures directes entre services**

Vous pouvez Ã©crire des requÃªtes SQL qui joignent des tables de diffÃ©rents domaines mÃ©tier :

```sql
SELECT u.name, o.total, p.name AS product
FROM users u
JOIN orders o ON o.user_id = u.id
JOIN order_items oi ON oi.order_id = o.id
JOIN products p ON p.id = oi.product_id
WHERE o.created_at > NOW() - INTERVAL '7 days';
```

**4. Pas de duplication de donnÃ©es**

Les donnÃ©es existent en un seul endroit. Il n'y a pas besoin de synchroniser des informations entre plusieurs bases.

**5. CoÃ»ts d'infrastructure rÃ©duits**

Une seule instance PostgreSQL Ã  gÃ©rer, ce qui simplifie les sauvegardes, la supervision et rÃ©duit les coÃ»ts d'hÃ©bergement.

### InconvÃ©nients

**1. Couplage fort entre services**

C'est le problÃ¨me majeur. Si le service Commandes accÃ¨de directement Ã  la table `users`, il devient dÃ©pendant de sa structure. Toute modification du schÃ©ma de `users` peut casser le service Commandes.

Ce couplage va Ã  l'encontre du principe fondamental des microservices : **l'indÃ©pendance des services**.

**2. Point de dÃ©faillance unique (Single Point of Failure)**

Si la base de donnÃ©es PostgreSQL tombe en panne, **tous les services** sont impactÃ©s simultanÃ©ment. Il n'y a pas d'isolation des pannes.

**3. DifficultÃ©s de mise Ã  l'Ã©chelle**

Tous les services partagent les mÃªmes ressources (CPU, mÃ©moire, connexions). Si le service Catalogue gÃ©nÃ¨re des requÃªtes lourdes, cela peut impacter les performances du service Commandes.

Il est Ã©galement impossible de choisir une technologie de base de donnÃ©es diffÃ©rente pour un service ayant des besoins spÃ©cifiques (par exemple, une base orientÃ©e graphe pour des recommandations).

**4. Goulot d'Ã©tranglement organisationnel**

Si plusieurs Ã©quipes travaillent sur diffÃ©rents services, elles doivent coordonner leurs modifications de schÃ©ma. Les migrations deviennent complexes et risquÃ©es.

**5. Limites de connexions**

PostgreSQL a un nombre limitÃ© de connexions simultanÃ©es. Avec de nombreux services, chacun ayant son propre pool de connexions, vous pouvez rapidement atteindre cette limite.

### Cas d'usage appropriÃ©s

L'approche Shared Database est adaptÃ©e pour :

- Les **petites Ã©quipes** (moins de 5 dÃ©veloppeurs)
- Les **projets en phase de dÃ©marrage** (MVP, prototypes)
- Les applications avec un **domaine mÃ©tier simple**
- Les situations oÃ¹ la **cohÃ©rence transactionnelle forte** est critique
- Les environnements avec des **contraintes budgÃ©taires** importantes

---

## Approche 2 : Database per Service (Base par Service)

### Principe

Dans l'approche **Database per Service**, chaque microservice possÃ¨de sa **propre base de donnÃ©es PostgreSQL dÃ©diÃ©e**. Aucun autre service n'a le droit d'accÃ©der directement Ã  cette base.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Service    â”‚  â”‚  Service    â”‚  â”‚  Service    â”‚
â”‚ Utilisateursâ”‚  â”‚  Catalogue  â”‚  â”‚  Commandes  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                â”‚                â”‚
       â–¼                â–¼                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PostgreSQL  â”‚  â”‚ PostgreSQL  â”‚  â”‚ PostgreSQL  â”‚
â”‚   users_db  â”‚  â”‚ catalog_db  â”‚  â”‚  orders_db  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Les services communiquent entre eux via des **APIs** (REST, gRPC) ou des **Ã©vÃ©nements asynchrones** (messages), jamais par accÃ¨s direct Ã  la base d'un autre service.

### Avantages

**1. Autonomie totale des Ã©quipes**

Chaque Ã©quipe est propriÃ©taire de son service ET de sa base de donnÃ©es. Elle peut :

- Modifier le schÃ©ma sans impacter les autres services
- Choisir sa stratÃ©gie d'indexation
- Effectuer des migrations indÃ©pendamment
- DÃ©ployer Ã  son propre rythme

Cette autonomie accÃ©lÃ¨re considÃ©rablement le dÃ©veloppement dans les grandes organisations.

**2. Isolation des pannes**

Si la base de donnÃ©es du service Catalogue tombe en panne, les services Utilisateurs et Commandes continuent de fonctionner (en mode dÃ©gradÃ© Ã©ventuellement).

**3. ScalabilitÃ© indÃ©pendante**

Chaque base peut Ãªtre dimensionnÃ©e selon les besoins spÃ©cifiques de son service :

- Le service Catalogue peut avoir besoin de beaucoup de mÃ©moire pour des requÃªtes complexes
- Le service Commandes peut nÃ©cessiter des I/O rapides pour les Ã©critures frÃ©quentes
- Le service Utilisateurs peut rester sur une instance modeste

**4. LibertÃ© technologique (Polyglot Persistence)**

Bien que nous parlions de PostgreSQL, cette approche permet de choisir la technologie la plus adaptÃ©e Ã  chaque service :

- PostgreSQL pour les donnÃ©es relationnelles classiques
- Redis pour le cache et les sessions
- Elasticsearch pour la recherche full-text
- MongoDB pour des documents flexibles
- Neo4j pour des donnÃ©es en graphe

**5. SÃ©curitÃ© renforcÃ©e**

L'isolation limite la surface d'attaque. Une faille dans un service ne compromet que sa propre base de donnÃ©es.

### InconvÃ©nients

**1. ComplexitÃ© des transactions distribuÃ©es**

Sans base partagÃ©e, impossible d'utiliser une simple transaction SQL pour modifier des donnÃ©es de plusieurs services. Il faut recourir Ã  des patterns comme :

- **Saga** : orchestration de transactions compensatoires
- **Two-Phase Commit (2PC)** : coordination distribuÃ©e (rarement recommandÃ©)
- **Eventual Consistency** : accepter une cohÃ©rence Ã  terme

Ces patterns ajoutent une complexitÃ© significative au code applicatif.

**2. Jointures impossibles**

Vous ne pouvez plus Ã©crire de jointures SQL entre les donnÃ©es de diffÃ©rents services. Pour obtenir une vue combinÃ©e, vous devez :

- Effectuer plusieurs appels API et agrÃ©ger cÃ´tÃ© application
- Maintenir des vues matÃ©rialisÃ©es dÃ©normalisÃ©es
- Utiliser un service dÃ©diÃ© de reporting

**3. Duplication de donnÃ©es**

Pour Ã©viter les appels rÃ©seau constants, les services dupliquent souvent certaines donnÃ©es. Par exemple, le service Commandes peut stocker une copie du nom de l'utilisateur et du nom du produit, plutÃ´t que d'interroger les autres services Ã  chaque affichage.

Cette duplication nÃ©cessite des mÃ©canismes de synchronisation (Ã©vÃ©nements, CDC).

**4. CoÃ»ts opÃ©rationnels accrus**

Plusieurs bases de donnÃ©es signifient :

- Plus d'instances Ã  superviser
- Plus de sauvegardes Ã  gÃ©rer
- Plus de mises Ã  jour Ã  orchestrer
- Plus de ressources infrastructure

**5. ComplexitÃ© des requÃªtes de reporting**

Les analyses transversales (par exemple, "chiffre d'affaires par catÃ©gorie de produit et par rÃ©gion utilisateur") deviennent complexes car les donnÃ©es sont dispersÃ©es.

### Cas d'usage appropriÃ©s

L'approche Database per Service est adaptÃ©e pour :

- Les **grandes organisations** avec plusieurs Ã©quipes indÃ©pendantes
- Les applications avec un **trafic important** nÃ©cessitant une scalabilitÃ© fine
- Les systÃ¨mes oÃ¹ l'**isolation des pannes** est critique
- Les projets matures ayant besoin de **flexibilitÃ© technologique**
- Les contextes oÃ¹ la **cohÃ©rence Ã  terme** est acceptable

---

## Variante : SchÃ©ma par Service (Compromis)

PostgreSQL offre une solution intermÃ©diaire grÃ¢ce aux **schÃ©mas** (namespaces). Chaque service utilise son propre schÃ©ma au sein d'une mÃªme instance PostgreSQL.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              PostgreSQL (instance unique)   â”‚
â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ Schema:     â”‚  â”‚ Schema:     â”‚           â”‚
â”‚  â”‚ users       â”‚  â”‚ catalog     â”‚           â”‚
â”‚  â”‚ - users     â”‚  â”‚ - products  â”‚           â”‚
â”‚  â”‚ - profiles  â”‚  â”‚ - categoriesâ”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ Schema:     â”‚  â”‚ Schema:     â”‚           â”‚
â”‚  â”‚ orders      â”‚  â”‚ payments    â”‚           â”‚
â”‚  â”‚ - orders    â”‚  â”‚ - payments  â”‚           â”‚
â”‚  â”‚ - items     â”‚  â”‚ - refunds   â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Configuration PostgreSQL

Chaque service se connecte avec un utilisateur dÃ©diÃ© ayant accÃ¨s uniquement Ã  son schÃ©ma :

```sql
-- CrÃ©er les schÃ©mas
CREATE SCHEMA users_schema;
CREATE SCHEMA catalog_schema;
CREATE SCHEMA orders_schema;

-- CrÃ©er des rÃ´les dÃ©diÃ©s
CREATE ROLE users_service LOGIN PASSWORD 'secret1';
CREATE ROLE catalog_service LOGIN PASSWORD 'secret2';
CREATE ROLE orders_service LOGIN PASSWORD 'secret3';

-- Attribuer les permissions
GRANT USAGE ON SCHEMA users_schema TO users_service;
GRANT ALL ON ALL TABLES IN SCHEMA users_schema TO users_service;

-- Configurer le search_path par dÃ©faut
ALTER ROLE users_service SET search_path TO users_schema;
```

### Avantages de cette variante

- Une seule instance Ã  maintenir
- Isolation logique entre les services
- PossibilitÃ© de transactions cross-schÃ©mas si vraiment nÃ©cessaire
- Migration progressive vers Database per Service possible

### Limites

- Pas d'isolation physique (ressources partagÃ©es)
- Un seul point de dÃ©faillance reste prÃ©sent

---

## Tableau Comparatif

| CritÃ¨re | Shared Database | Database per Service |
|---------|-----------------|---------------------|
| **ComplexitÃ© initiale** | Faible | Ã‰levÃ©e |
| **Autonomie des Ã©quipes** | Faible | Ã‰levÃ©e |
| **Transactions ACID** | Natives | DistribuÃ©es (Saga) |
| **Jointures SQL** | Possibles | Impossibles |
| **Isolation des pannes** | Aucune | Totale |
| **ScalabilitÃ©** | LimitÃ©e | IndÃ©pendante |
| **CohÃ©rence des donnÃ©es** | Forte | Ã‰ventuelle |
| **CoÃ»t infrastructure** | Faible | Ã‰levÃ© |
| **Duplication de donnÃ©es** | Aucune | FrÃ©quente |
| **FlexibilitÃ© techno** | Aucune | Totale |

---

## Comment Choisir ?

La dÃ©cision dÃ©pend de plusieurs facteurs. Voici un guide pour vous aider :

### Choisissez Shared Database si :

- Vous dÃ©marrez un nouveau projet avec une petite Ã©quipe
- La cohÃ©rence transactionnelle forte est une exigence mÃ©tier non nÃ©gociable
- Vous avez des contraintes budgÃ©taires importantes
- Le domaine mÃ©tier est relativement simple et stable
- Vous prÃ©fÃ©rez la simplicitÃ© Ã  la flexibilitÃ©

### Choisissez Database per Service si :

- Vous avez plusieurs Ã©quipes travaillant sur diffÃ©rents services
- Chaque service a des exigences de performance ou de stockage diffÃ©rentes
- L'isolation des pannes est critique pour votre activitÃ©
- Vous Ãªtes prÃªt Ã  gÃ©rer la complexitÃ© des transactions distribuÃ©es
- Votre organisation valorise l'autonomie des Ã©quipes

### Approche Ã©volutive recommandÃ©e

Dans la pratique, beaucoup d'organisations adoptent une **approche progressive** :

1. **Phase initiale** : Shared Database ou Schema per Service pour valider le produit rapidement
2. **Phase de croissance** : Extraire progressivement les services critiques vers leur propre base
3. **Phase mature** : Database per Service pour les services Ã  fort trafic, base partagÃ©e pour les services secondaires

Cette stratÃ©gie permet de ne pas sur-architecturer au dÃ©part tout en gardant la possibilitÃ© d'Ã©voluer.

---

## Bonnes Pratiques avec PostgreSQL

Quelle que soit l'approche choisie, voici quelques recommandations :

### Pour Shared Database

- Utilisez des **schÃ©mas sÃ©parÃ©s** pour chaque domaine mÃ©tier
- DÃ©finissez des **rÃ´les avec permissions minimales** pour chaque service
- Ã‰vitez les jointures entre schÃ©mas dans le code applicatif courant
- Documentez clairement les "propriÃ©taires" de chaque table
- Utilisez **PgBouncer** pour gÃ©rer le pool de connexions

### Pour Database per Service

- Mettez en place une **stratÃ©gie de sauvegarde cohÃ©rente** pour toutes les bases
- Utilisez des **outils de supervision centralisÃ©s** (Prometheus, Grafana)
- ImplÃ©mentez le pattern **Outbox** pour la publication fiable d'Ã©vÃ©nements
- ConsidÃ©rez les **Foreign Data Wrappers** pour le reporting transversal
- Standardisez les configurations PostgreSQL entre les instances

---

## Conclusion

Le choix entre **Database per Service** et **Shared Database** n'est pas binaire. Il dÃ©pend de votre contexte : taille de l'Ã©quipe, exigences de cohÃ©rence, budget, et maturitÃ© de l'organisation.

PostgreSQL, grÃ¢ce Ã  sa flexibilitÃ© (schÃ©mas, Foreign Data Wrappers, rÃ©plication logique), s'adapte aux deux modÃ¨les et permet mÃªme des approches hybrides.

L'essentiel est de comprendre les **compromis** de chaque approche et de faire un choix Ã©clairÃ© en fonction de vos contraintes actuelles, tout en gardant Ã  l'esprit les Ã©volutions futures de votre systÃ¨me.

---

## Points ClÃ©s Ã  Retenir

- **Shared Database** : Simple, cohÃ©rent, mais crÃ©e du couplage et limite la scalabilitÃ©
- **Database per Service** : Autonome, scalable, mais complexifie les transactions et les requÃªtes
- **Schema per Service** : Compromis intÃ©ressant pour dÃ©buter avec PostgreSQL
- Le choix dÃ©pend de la **taille de l'Ã©quipe**, des **exigences de cohÃ©rence** et du **budget**
- Une **approche Ã©volutive** permet de commencer simple et de migrer progressivement

---


â­ï¸ [Distributed transactions et Saga pattern](/20bis-postgresql-et-architectures-modernes/01.2-distributed-transactions-saga.md)
