ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 20bis.1.2 â€” Distributed Transactions et Saga Pattern

## Introduction

Dans le chapitre prÃ©cÃ©dent, nous avons vu que l'approche **Database per Service** offre de nombreux avantages : autonomie des Ã©quipes, isolation des pannes, scalabilitÃ© indÃ©pendante. Cependant, elle introduit un dÃ©fi majeur : **comment garantir la cohÃ©rence des donnÃ©es lorsqu'une opÃ©ration mÃ©tier implique plusieurs services ?**

Avec une base de donnÃ©es unique, une simple transaction SQL suffit. Mais quand les donnÃ©es sont rÃ©parties sur plusieurs bases, les transactions classiques ne fonctionnent plus. C'est lÃ  qu'interviennent les **transactions distribuÃ©es** et, plus particuliÃ¨rement, le **pattern Saga**.

Ce chapitre vous expliquera pourquoi les transactions traditionnelles Ã©chouent dans un contexte distribuÃ©, et comment le pattern Saga permet de maintenir la cohÃ©rence des donnÃ©es de maniÃ¨re Ã©lÃ©gante et rÃ©siliente.

---

## Rappel : Les Transactions ACID Classiques

Avant d'aborder les transactions distribuÃ©es, rappelons le fonctionnement des transactions dans PostgreSQL.

### Les PropriÃ©tÃ©s ACID

Une transaction PostgreSQL garantit quatre propriÃ©tÃ©s fondamentales :

| PropriÃ©tÃ© | Signification |
|-----------|---------------|
| **AtomicitÃ©** | Tout ou rien : soit toutes les opÃ©rations rÃ©ussissent, soit aucune n'est appliquÃ©e |
| **CohÃ©rence** | La base passe d'un Ã©tat valide Ã  un autre Ã©tat valide |
| **Isolation** | Les transactions concurrentes ne s'interfÃ¨rent pas |
| **DurabilitÃ©** | Une fois validÃ©e, la transaction survit aux pannes |

### Exemple Concret

Imaginons une commande e-commerce simple avec une seule base de donnÃ©es :

```sql
BEGIN;

-- 1. CrÃ©er la commande
INSERT INTO orders (id, user_id, total, status)
VALUES (1001, 42, 150.00, 'pending');

-- 2. Ajouter les articles
INSERT INTO order_items (order_id, product_id, quantity, price)
VALUES (1001, 501, 2, 75.00);

-- 3. DÃ©duire le stock
UPDATE products
SET stock = stock - 2
WHERE id = 501;

-- 4. DÃ©biter le compte client
UPDATE user_accounts
SET balance = balance - 150.00
WHERE user_id = 42;

COMMIT;
```

Si une erreur survient Ã  l'Ã©tape 4 (solde insuffisant), PostgreSQL annule automatiquement toutes les opÃ©rations prÃ©cÃ©dentes grÃ¢ce au `ROLLBACK`. Le stock n'est pas dÃ©duit, la commande n'est pas crÃ©Ã©e. **C'est l'atomicitÃ© en action.**

---

## Le ProblÃ¨me : Transactions sur Plusieurs Bases

### Quand ACID Ne Suffit Plus

Maintenant, imaginons la mÃªme opÃ©ration dans une architecture microservices avec **Database per Service** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Service    â”‚     â”‚  Service    â”‚     â”‚  Service    â”‚     â”‚  Service    â”‚
â”‚  Commandes  â”‚     â”‚  Catalogue  â”‚     â”‚  Paiements  â”‚     â”‚   Stock     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                   â”‚                   â”‚                   â”‚
       â–¼                   â–¼                   â–¼                   â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚orders_dbâ”‚         â”‚catalog_ â”‚         â”‚payments_â”‚         â”‚stock_db â”‚
  â”‚         â”‚         â”‚   db    â”‚         â”‚   db    â”‚         â”‚         â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Chaque service a sa propre base PostgreSQL. **Il est impossible d'Ã©crire une seule transaction SQL qui englobe les quatre bases.**

### ScÃ©nario de DÃ©faillance

Voici ce qui peut mal se passer :

1. âœ… Service Commandes â†’ CrÃ©e la commande (succÃ¨s)
2. âœ… Service Stock â†’ RÃ©serve le stock (succÃ¨s)
3. âœ… Service Paiements â†’ DÃ©bite le client (succÃ¨s)
4. âŒ Service Livraison â†’ Ã‰chec (transporteur indisponible)

**RÃ©sultat** : Le client est dÃ©bitÃ©, le stock est rÃ©servÃ©, mais la livraison n'est pas planifiÃ©e. Le systÃ¨me est dans un **Ã©tat incohÃ©rent**.

Sans mÃ©canisme appropriÃ©, il faudrait manuellement annuler les opÃ©rations des Ã©tapes 1, 2 et 3. C'est exactement le problÃ¨me que rÃ©solvent les transactions distribuÃ©es.

---

## Les Approches pour les Transactions DistribuÃ©es

Il existe plusieurs stratÃ©gies pour gÃ©rer les transactions distribuÃ©es. Examinons-les avant de nous concentrer sur le pattern Saga.

### 1. Two-Phase Commit (2PC)

Le **Two-Phase Commit** est un protocole classique qui coordonne les transactions entre plusieurs bases de donnÃ©es.

#### Fonctionnement

```
                    Coordinateur
                         â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚               â”‚               â”‚
         â–¼               â–¼               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Base 1 â”‚     â”‚  Base 2 â”‚     â”‚  Base 3 â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Phase 1 (Prepare) : Le coordinateur demande Ã  chaque base
                    si elle peut valider la transaction.

Phase 2 (Commit)  : Si toutes rÃ©pondent "oui", le coordinateur
                    ordonne la validation. Sinon, rollback gÃ©nÃ©ral.
```

#### Pourquoi 2PC Est ProblÃ©matique

Bien que PostgreSQL supporte 2PC via `PREPARE TRANSACTION`, cette approche prÃ©sente des inconvÃ©nients majeurs dans une architecture microservices :

| ProblÃ¨me | Description |
|----------|-------------|
| **Verrouillage prolongÃ©** | Les ressources sont bloquÃ©es pendant toute la durÃ©e du protocole |
| **Point de dÃ©faillance unique** | Si le coordinateur tombe en panne, les transactions restent en suspens |
| **Latence Ã©levÃ©e** | Deux allers-retours rÃ©seau nÃ©cessaires |
| **Couplage fort** | Tous les participants doivent Ãªtre disponibles simultanÃ©ment |
| **Non adaptÃ© au cloud** | Mal compatible avec les environnements Ã©lastiques et Ã©phÃ©mÃ¨res |

**En pratique, le 2PC est rarement utilisÃ© dans les architectures microservices modernes.**

### 2. Le Pattern Saga (RecommandÃ©)

Le **pattern Saga** est l'alternative privilÃ©giÃ©e. Au lieu d'une transaction atomique globale, il dÃ©coupe l'opÃ©ration en une **sÃ©quence de transactions locales**, chacune avec une **action de compensation** en cas d'Ã©chec.

---

## Le Pattern Saga en DÃ©tail

### Principe Fondamental

Une Saga est une sÃ©quence de transactions locales oÃ¹ :

- Chaque transaction met Ã  jour une base de donnÃ©es et publie un Ã©vÃ©nement
- Si une Ã©tape Ã©choue, des **transactions de compensation** sont exÃ©cutÃ©es pour annuler les Ã©tapes prÃ©cÃ©dentes
- La cohÃ©rence est **Ã©ventuelle** (eventual consistency), pas immÃ©diate

### Anatomie d'une Saga

```
Flux Normal (Happy Path)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â–º

  T1              T2              T3              T4
â”Œâ”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”
â”‚CrÃ©erâ”‚â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚RÃ©serâ”‚â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚DÃ©bi-â”‚â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚Planiâ”‚
â”‚Comm.â”‚        â”‚Stockâ”‚        â”‚ ter â”‚        â”‚Livr.â”‚
â””â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”˜


Flux avec Ã‰chec et Compensation
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â–º

  T1              T2              T3              T4
â”Œâ”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”
â”‚CrÃ©erâ”‚â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚RÃ©serâ”‚â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚DÃ©bi-â”‚â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚Planiâ”‚ âœ— Ã‰CHEC
â”‚Comm.â”‚        â”‚Stockâ”‚        â”‚ ter â”‚        â”‚Livr.â”‚
â””â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”˜
                                â”‚
â—„â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    COMPENSATIONS

  C3              C2              C1
â”Œâ”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”
â”‚Rem- â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”‚LibÃ©-â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”‚Annu-â”‚
â”‚boursâ”‚        â”‚Stockâ”‚        â”‚Comm.â”‚
â””â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”˜
```

### Les Deux Types de Saga

Il existe deux faÃ§ons d'implÃ©menter une Saga : **Orchestration** et **ChorÃ©graphie**.

---

## Saga par Orchestration

### Principe

Un **orchestrateur central** (le "chef d'orchestre") coordonne toutes les Ã©tapes de la Saga. Il sait quelles Ã©tapes exÃ©cuter, dans quel ordre, et quelles compensations dÃ©clencher en cas d'Ã©chec.

### SchÃ©ma

```
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚   Orchestrateur  â”‚
                      â”‚   (OrderSaga)    â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚           â”‚           â”‚           â”‚           â”‚
       â–¼           â–¼           â–¼           â–¼           â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Service â”‚ â”‚ Service â”‚ â”‚ Service â”‚ â”‚ Service â”‚ â”‚ Service â”‚
  â”‚Commandesâ”‚ â”‚  Stock  â”‚ â”‚Paiement â”‚ â”‚Livraisonâ”‚ â”‚ Notif.  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

L'orchestrateur envoie des commandes aux services et attend leurs rÃ©ponses pour dÃ©cider de la suite.

### Exemple : Saga de Commande

Voici comment modÃ©liser une Saga de commande avec PostgreSQL comme stockage de l'Ã©tat.

#### Table de Suivi de la Saga

```sql
-- Table pour suivre l'Ã©tat de chaque saga
CREATE TABLE order_sagas (
    saga_id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    order_id        UUID NOT NULL,
    current_step    VARCHAR(50) NOT NULL,
    status          VARCHAR(20) NOT NULL DEFAULT 'STARTED',
    created_at      TIMESTAMPTZ DEFAULT NOW(),
    updated_at      TIMESTAMPTZ DEFAULT NOW(),

    -- DonnÃ©es de contexte
    user_id         INTEGER NOT NULL,
    total_amount    NUMERIC(10,2) NOT NULL,
    items           JSONB NOT NULL,

    -- RÃ©sultats des Ã©tapes
    payment_id      UUID,
    shipment_id     UUID,

    -- Contrainte sur le statut
    CONSTRAINT valid_status CHECK (
        status IN ('STARTED', 'PENDING', 'COMPLETED', 'COMPENSATING', 'FAILED')
    )
);

-- Table pour l'historique des Ã©tapes
CREATE TABLE saga_steps (
    id              SERIAL PRIMARY KEY,
    saga_id         UUID REFERENCES order_sagas(saga_id),
    step_name       VARCHAR(50) NOT NULL,
    step_type       VARCHAR(20) NOT NULL, -- 'FORWARD' ou 'COMPENSATE'
    status          VARCHAR(20) NOT NULL,
    executed_at     TIMESTAMPTZ DEFAULT NOW(),
    error_message   TEXT,

    CONSTRAINT valid_step_status CHECK (
        status IN ('PENDING', 'SUCCESS', 'FAILED')
    )
);
```

#### DÃ©finition des Ã‰tapes et Compensations

```sql
-- Table de dÃ©finition des Ã©tapes de la saga
CREATE TABLE saga_step_definitions (
    step_order          INTEGER PRIMARY KEY,
    step_name           VARCHAR(50) NOT NULL UNIQUE,
    service_name        VARCHAR(50) NOT NULL,
    command_type        VARCHAR(50) NOT NULL,
    compensation_type   VARCHAR(50),
    is_compensatable    BOOLEAN DEFAULT TRUE
);

-- Insertion des Ã©tapes pour la saga de commande
INSERT INTO saga_step_definitions VALUES
(1, 'CREATE_ORDER',     'order-service',    'CreateOrder',    'CancelOrder',      TRUE),
(2, 'RESERVE_STOCK',    'stock-service',    'ReserveStock',   'ReleaseStock',     TRUE),
(3, 'PROCESS_PAYMENT',  'payment-service',  'ProcessPayment', 'RefundPayment',    TRUE),
(4, 'SCHEDULE_SHIPMENT','shipping-service', 'ScheduleShip',   'CancelShipment',   TRUE),
(5, 'SEND_CONFIRMATION','notif-service',    'SendEmail',      NULL,               FALSE);
```

#### Logique de l'Orchestrateur (Pseudocode SQL/PL/pgSQL)

```sql
-- Fonction pour avancer la saga Ã  l'Ã©tape suivante
CREATE OR REPLACE FUNCTION advance_saga(p_saga_id UUID, p_step_result VARCHAR, p_error TEXT DEFAULT NULL)
RETURNS void AS $$
DECLARE
    v_saga RECORD;
    v_current_step RECORD;
    v_next_step RECORD;
BEGIN
    -- RÃ©cupÃ©rer l'Ã©tat actuel de la saga
    SELECT * INTO v_saga FROM order_sagas WHERE saga_id = p_saga_id FOR UPDATE;

    -- RÃ©cupÃ©rer la dÃ©finition de l'Ã©tape actuelle
    SELECT * INTO v_current_step
    FROM saga_step_definitions
    WHERE step_name = v_saga.current_step;

    IF p_step_result = 'SUCCESS' THEN
        -- Enregistrer le succÃ¨s
        INSERT INTO saga_steps (saga_id, step_name, step_type, status)
        VALUES (p_saga_id, v_saga.current_step, 'FORWARD', 'SUCCESS');

        -- Trouver l'Ã©tape suivante
        SELECT * INTO v_next_step
        FROM saga_step_definitions
        WHERE step_order = v_current_step.step_order + 1;

        IF v_next_step IS NULL THEN
            -- Saga terminÃ©e avec succÃ¨s
            UPDATE order_sagas
            SET status = 'COMPLETED', updated_at = NOW()
            WHERE saga_id = p_saga_id;
        ELSE
            -- Passer Ã  l'Ã©tape suivante
            UPDATE order_sagas
            SET current_step = v_next_step.step_name,
                status = 'PENDING',
                updated_at = NOW()
            WHERE saga_id = p_saga_id;

            -- Ici, dÃ©clencher l'appel au service suivant
            -- (via message queue, API call, etc.)
        END IF;

    ELSIF p_step_result = 'FAILED' THEN
        -- Enregistrer l'Ã©chec
        INSERT INTO saga_steps (saga_id, step_name, step_type, status, error_message)
        VALUES (p_saga_id, v_saga.current_step, 'FORWARD', 'FAILED', p_error);

        -- DÃ©marrer la compensation
        UPDATE order_sagas
        SET status = 'COMPENSATING', updated_at = NOW()
        WHERE saga_id = p_saga_id;

        -- Lancer les compensations (voir fonction suivante)
        PERFORM start_compensation(p_saga_id);
    END IF;
END;
$$ LANGUAGE plpgsql;
```

### Avantages de l'Orchestration

| Avantage | Description |
|----------|-------------|
| **Logique centralisÃ©e** | Toute la logique est dans l'orchestrateur, facile Ã  comprendre |
| **Flux explicite** | L'ordre des Ã©tapes est clairement dÃ©fini |
| **DÃ©bogage simplifiÃ©** | Un seul endroit pour suivre l'Ã©tat de la saga |
| **Gestion des erreurs** | L'orchestrateur contrÃ´le les compensations |

### InconvÃ©nients de l'Orchestration

| InconvÃ©nient | Description |
|--------------|-------------|
| **Point central** | L'orchestrateur peut devenir un goulot d'Ã©tranglement |
| **Couplage** | L'orchestrateur connaÃ®t tous les services |
| **ComplexitÃ© croissante** | Peut devenir difficile Ã  maintenir avec beaucoup d'Ã©tapes |

---

## Saga par ChorÃ©graphie

### Principe

Dans la **chorÃ©graphie**, il n'y a pas de coordinateur central. Chaque service Ã©coute les Ã©vÃ©nements des autres services et rÃ©agit en consÃ©quence. Les services "dansent" ensemble sans chef d'orchestre.

### SchÃ©ma

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Message Broker                           â”‚
â”‚                    (ex: RabbitMQ, Kafka)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚         â”‚         â”‚         â”‚         â”‚
   Publie    Ã‰coute    Publie    Ã‰coute    Publie
        â”‚         â”‚         â”‚         â”‚         â”‚
        â–¼         â–¼         â–¼         â–¼         â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Service â”‚ â”‚ Service â”‚ â”‚ Service â”‚ â”‚ Service â”‚
   â”‚Commandesâ”‚ â”‚  Stock  â”‚ â”‚Paiement â”‚ â”‚Livraisonâ”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰vÃ©nements :
OrderCreated â”€â”€â–º StockReserved â”€â”€â–º PaymentProcessed â”€â”€â–º ShipmentScheduled
```

### Flux d'Ã‰vÃ©nements

```
1. Client passe commande
   â”‚
   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Service Commandes                                               â”‚
â”‚ - CrÃ©e la commande (status: PENDING)                            â”‚
â”‚ - Publie: OrderCreated { orderId, items, userId, amount }       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â”‚
   â”‚ OrderCreated
   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Service Stock                                                   â”‚
â”‚ - Ã‰coute: OrderCreated                                          â”‚
â”‚ - RÃ©serve le stock                                              â”‚
â”‚ - Publie: StockReserved { orderId, reservationId }              â”‚
â”‚   OU                                                            â”‚
â”‚ - Publie: StockInsufficient { orderId, reason }                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â”‚
   â”‚ StockReserved
   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Service Paiement                                                â”‚
â”‚ - Ã‰coute: StockReserved                                         â”‚
â”‚ - Traite le paiement                                            â”‚
â”‚ - Publie: PaymentSucceeded { orderId, paymentId }               â”‚
â”‚   OU                                                            â”‚
â”‚ - Publie: PaymentFailed { orderId, reason }                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â”‚
   â”‚ PaymentSucceeded
   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Service Livraison                                               â”‚
â”‚ - Ã‰coute: PaymentSucceeded                                      â”‚
â”‚ - Planifie la livraison                                         â”‚
â”‚ - Publie: ShipmentScheduled { orderId, shipmentId, eta }        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Gestion des Compensations en ChorÃ©graphie

Quand une Ã©tape Ã©choue, elle publie un Ã©vÃ©nement d'Ã©chec. Les services prÃ©cÃ©dents Ã©coutent cet Ã©vÃ©nement et exÃ©cutent leur compensation.

```
PaymentFailed publiÃ©
        â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                              â”‚
        â–¼                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Service Stock     â”‚         â”‚ Service Commandes â”‚
â”‚ Ã‰coute:           â”‚         â”‚ Ã‰coute:           â”‚
â”‚   PaymentFailed   â”‚         â”‚   PaymentFailed   â”‚
â”‚ Action:           â”‚         â”‚ Action:           â”‚
â”‚   LibÃ¨re le stock â”‚         â”‚   Annule commande â”‚
â”‚ Publie:           â”‚         â”‚ Publie:           â”‚
â”‚   StockReleased   â”‚         â”‚   OrderCancelled  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ImplÃ©mentation avec PostgreSQL et LISTEN/NOTIFY

PostgreSQL offre un mÃ©canisme natif de publication/souscription avec `LISTEN` et `NOTIFY`. Bien qu'il ne remplace pas un vrai message broker pour la production, il est utile pour comprendre le concept.

```sql
-- Service Commandes : Publication d'Ã©vÃ©nement
CREATE OR REPLACE FUNCTION notify_order_created()
RETURNS TRIGGER AS $$
BEGIN
    -- Publier l'Ã©vÃ©nement sur le canal 'order_events'
    PERFORM pg_notify(
        'order_events',
        json_build_object(
            'event_type', 'OrderCreated',
            'order_id', NEW.id,
            'user_id', NEW.user_id,
            'total', NEW.total,
            'items', NEW.items,
            'timestamp', NOW()
        )::text
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER order_created_trigger
AFTER INSERT ON orders
FOR EACH ROW
EXECUTE FUNCTION notify_order_created();
```

```sql
-- Service Stock : Ã‰coute et rÃ©action (conceptuel)
-- En pratique, cela serait dans le code applicatif

-- CÃ´tÃ© applicatif (pseudocode Python avec psycopg)
--
-- conn.execute("LISTEN order_events")
-- while True:
--     conn.poll()
--     for notify in conn.notifies:
--         event = json.loads(notify.payload)
--         if event['event_type'] == 'OrderCreated':
--             reserve_stock(event['order_id'], event['items'])
```

### Avantages de la ChorÃ©graphie

| Avantage | Description |
|----------|-------------|
| **DÃ©couplage fort** | Les services ne se connaissent pas directement |
| **Pas de point central** | Pas de goulot d'Ã©tranglement |
| **ScalabilitÃ©** | Chaque service Ã©volue indÃ©pendamment |
| **RÃ©silience** | La panne d'un service n'arrÃªte pas les autres |

### InconvÃ©nients de la ChorÃ©graphie

| InconvÃ©nient | Description |
|--------------|-------------|
| **Flux difficile Ã  suivre** | La logique est dispersÃ©e dans tous les services |
| **DÃ©bogage complexe** | NÃ©cessite une bonne observabilitÃ© (tracing distribuÃ©) |
| **DÃ©pendances cycliques** | Risque de crÃ©er des boucles d'Ã©vÃ©nements |
| **CohÃ©rence difficile** | Plus complexe de garantir que toutes les compensations s'exÃ©cutent |

---

## Le Pattern Outbox : FiabilitÃ© des Ã‰vÃ©nements

Un problÃ¨me critique des Sagas est la **publication fiable des Ã©vÃ©nements**. Que se passe-t-il si le service met Ã  jour sa base de donnÃ©es mais plante avant de publier l'Ã©vÃ©nement ?

### Le ProblÃ¨me du Double Write

```
1. BEGIN transaction
2. UPDATE orders SET status = 'confirmed'   âœ“ SuccÃ¨s
3. COMMIT                                    âœ“ SuccÃ¨s
4. Publier Ã©vÃ©nement OrderConfirmed          âœ— CRASH !

RÃ©sultat : Base mise Ã  jour, mais Ã©vÃ©nement jamais publiÃ©.
           Les autres services ne sont pas informÃ©s.
```

### Solution : Le Pattern Outbox

Au lieu de publier directement, on Ã©crit l'Ã©vÃ©nement dans une table **Outbox** dans la mÃªme transaction que la modification mÃ©tier.

```sql
-- Table Outbox pour les Ã©vÃ©nements Ã  publier
CREATE TABLE outbox (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    aggregate_type  VARCHAR(100) NOT NULL,  -- ex: 'Order'
    aggregate_id    UUID NOT NULL,           -- ex: order_id
    event_type      VARCHAR(100) NOT NULL,   -- ex: 'OrderCreated'
    payload         JSONB NOT NULL,
    created_at      TIMESTAMPTZ DEFAULT NOW(),
    published_at    TIMESTAMPTZ,             -- NULL = pas encore publiÃ©

    -- Index pour le polling efficace
    CONSTRAINT idx_outbox_unpublished
        CHECK (published_at IS NOT NULL OR TRUE)
);

CREATE INDEX idx_outbox_pending ON outbox(created_at)
WHERE published_at IS NULL;
```

```sql
-- Transaction atomique : modification + Ã©vÃ©nement
BEGIN;

-- Modification mÃ©tier
INSERT INTO orders (id, user_id, total, status, items)
VALUES ('ord-123', 42, 150.00, 'pending', '["item1", "item2"]');

-- Ã‰vÃ©nement dans la mÃªme transaction
INSERT INTO outbox (aggregate_type, aggregate_id, event_type, payload)
VALUES (
    'Order',
    'ord-123',
    'OrderCreated',
    jsonb_build_object(
        'orderId', 'ord-123',
        'userId', 42,
        'total', 150.00,
        'items', '["item1", "item2"]'::jsonb
    )
);

COMMIT;
-- Les deux Ã©critures rÃ©ussissent ou Ã©chouent ensemble !
```

### Publication des Ã‰vÃ©nements Outbox

Un processus sÃ©parÃ© (polling ou CDC) lit la table Outbox et publie les Ã©vÃ©nements.

```sql
-- RÃ©cupÃ©rer les Ã©vÃ©nements non publiÃ©s
SELECT * FROM outbox
WHERE published_at IS NULL
ORDER BY created_at
LIMIT 100
FOR UPDATE SKIP LOCKED;  -- Ã‰vite les conflits en parallÃ¨le

-- AprÃ¨s publication rÃ©ussie au message broker
UPDATE outbox
SET published_at = NOW()
WHERE id = 'evt-xxx';
```

### CDC avec Debezium (Alternative au Polling)

Pour les systÃ¨mes Ã  fort volume, **Debezium** peut capturer les changements de la table Outbox directement depuis le WAL de PostgreSQL, sans polling.

```
PostgreSQL WAL â”€â”€â–º Debezium â”€â”€â–º Kafka â”€â”€â–º Services consommateurs
```

---

## Gestion des Erreurs et Idempotence

### L'Idempotence : Une NÃ©cessitÃ© Absolue

Dans un systÃ¨me distribuÃ©, les messages peuvent Ãªtre dÃ©livrÃ©s **plusieurs fois** (at-least-once delivery). Chaque Ã©tape de la Saga doit Ãªtre **idempotente** : exÃ©cutÃ©e plusieurs fois, elle produit le mÃªme rÃ©sultat.

```sql
-- âŒ NON IDEMPOTENT : DÃ©duire le stock Ã  chaque appel
UPDATE products SET stock = stock - 1 WHERE id = 501;
-- ProblÃ¨me : Si appelÃ© 3 fois, stock dÃ©duit de 3 !

-- âœ… IDEMPOTENT : Utiliser une rÃ©servation unique
INSERT INTO stock_reservations (reservation_id, product_id, quantity)
VALUES ('res-abc', 501, 1)
ON CONFLICT (reservation_id) DO NOTHING;
-- AppelÃ© 3 fois = 1 seule rÃ©servation crÃ©Ã©e
```

### StratÃ©gies d'Idempotence

| StratÃ©gie | Description |
|-----------|-------------|
| **ClÃ© d'idempotence** | Stocker l'ID de chaque requÃªte traitÃ©e |
| **Upsert conditionnel** | `ON CONFLICT DO NOTHING` ou `DO UPDATE` |
| **Ã‰tat final** | VÃ©rifier l'Ã©tat avant modification |
| **Version optimiste** | Utiliser un numÃ©ro de version |

```sql
-- Table pour tracker les requÃªtes traitÃ©es
CREATE TABLE processed_requests (
    request_id      UUID PRIMARY KEY,
    processed_at    TIMESTAMPTZ DEFAULT NOW(),
    result          JSONB
);

-- VÃ©rifier avant traitement
CREATE OR REPLACE FUNCTION process_payment_idempotent(
    p_request_id UUID,
    p_order_id UUID,
    p_amount NUMERIC
) RETURNS JSONB AS $$
DECLARE
    v_existing RECORD;
    v_result JSONB;
BEGIN
    -- VÃ©rifier si dÃ©jÃ  traitÃ©
    SELECT * INTO v_existing
    FROM processed_requests
    WHERE request_id = p_request_id;

    IF FOUND THEN
        -- Retourner le rÃ©sultat prÃ©cÃ©dent
        RETURN v_existing.result;
    END IF;

    -- Traiter le paiement...
    -- ... logique mÃ©tier ...

    v_result := jsonb_build_object('status', 'success', 'payment_id', 'pay-xyz');

    -- Enregistrer le traitement
    INSERT INTO processed_requests (request_id, result)
    VALUES (p_request_id, v_result);

    RETURN v_result;
END;
$$ LANGUAGE plpgsql;
```

---

## Compensation vs Rollback : DiffÃ©rences ClÃ©s

Il est crucial de comprendre que les **compensations** ne sont pas des rollbacks classiques.

### Rollback (Transaction Unique)

- Annule les modifications **non commitÃ©es**
- Automatique et complet
- Aucune trace laissÃ©e
- GÃ©rÃ© par le SGBD

### Compensation (Saga)

- CrÃ©e une **nouvelle opÃ©ration** qui "annule" l'effet de la prÃ©cÃ©dente
- Doit Ãªtre explicitement programmÃ©e
- Laisse une trace dans l'historique
- Peut Ãªtre plus complexe que l'opÃ©ration originale

### Exemple Concret

```sql
-- OPÃ‰RATION ORIGINALE : RÃ©server du stock
INSERT INTO stock_reservations (id, product_id, quantity, status)
VALUES ('res-123', 501, 5, 'active');

UPDATE products SET available_stock = available_stock - 5
WHERE id = 501;

-- COMPENSATION (ce n'est PAS un rollback !)
-- On ne supprime pas la rÃ©servation, on la marque comme annulÃ©e
UPDATE stock_reservations
SET status = 'cancelled', cancelled_at = NOW()
WHERE id = 'res-123';

UPDATE products SET available_stock = available_stock + 5
WHERE id = 501;

-- L'historique montre : rÃ©servation crÃ©Ã©e PUIS annulÃ©e
```

### Compensations Complexes

Certaines opÃ©rations ne peuvent pas Ãªtre parfaitement compensÃ©es :

| OpÃ©ration | Compensation possible |
|-----------|----------------------|
| Envoyer un email | âŒ Impossible d'annuler (on peut envoyer un autre email d'excuse) |
| Facturer un client | âš ï¸ Remboursement (frais possibles) |
| Publier sur rÃ©seau social | âŒ Ou âš ï¸ Supprimer (mais vu par certains) |
| RÃ©server un billet d'avion | âš ï¸ Annulation (avec pÃ©nalitÃ©s potentielles) |

Pour ces cas, on parle de **transactions de mitigation** plutÃ´t que de vraies compensations.

---

## Choisir entre Orchestration et ChorÃ©graphie

### Tableau de DÃ©cision

| CritÃ¨re | Orchestration | ChorÃ©graphie |
|---------|--------------|--------------|
| **Nombre d'Ã©tapes** | Beaucoup (5+) | Peu (2-4) |
| **ComplexitÃ© logique** | Ã‰levÃ©e | Simple |
| **Besoin de visibilitÃ©** | Fort | Faible |
| **Ã‰quipes** | Une Ã©quipe centrale | Ã‰quipes autonomes |
| **Ã‰volutivitÃ© logique** | Modifications centralisÃ©es | Modifications distribuÃ©es |
| **Latence acceptable** | Moins critique | Plus critique |

### Recommandation Pratique

- **DÃ©butez avec l'orchestration** si vous n'Ãªtes pas familier avec les architectures Ã©vÃ©nementielles
- **Passez Ã  la chorÃ©graphie** lorsque le dÃ©couplage devient plus important que la visibilitÃ©
- **Hybride** : Orchestration pour les flux critiques, chorÃ©graphie pour les flux secondaires

---

## Bonnes Pratiques avec PostgreSQL

### 1. Utilisez le Pattern Outbox

Toujours Ã©crire les Ã©vÃ©nements dans une table Outbox dans la mÃªme transaction que la modification mÃ©tier.

### 2. Rendez Chaque Ã‰tape Idempotente

Utilisez des clÃ©s d'idempotence et des upserts conditionnels.

### 3. Stockez l'Ã‰tat de la Saga

Maintenez une table de suivi pour chaque saga, avec l'historique des Ã©tapes.

### 4. ImplÃ©mentez des Timeouts

Les sagas peuvent rester bloquÃ©es. PrÃ©voyez des timeouts et des mÃ©canismes de reprise.

```sql
-- Trouver les sagas bloquÃ©es depuis plus d'une heure
SELECT * FROM order_sagas
WHERE status = 'PENDING'
AND updated_at < NOW() - INTERVAL '1 hour';
```

### 5. Utilisez le Dead Letter Queue

Les Ã©vÃ©nements qui Ã©chouent de maniÃ¨re rÃ©pÃ©tÃ©e doivent Ãªtre mis de cÃ´tÃ© pour analyse manuelle.

### 6. Investissez dans l'ObservabilitÃ©

- Tracing distribuÃ© (OpenTelemetry)
- Logs corrÃ©lÃ©s par saga_id
- MÃ©triques sur les durÃ©es et taux d'Ã©chec

---

## Outils et Frameworks

Voici quelques outils qui facilitent l'implÃ©mentation des Sagas :

| Outil | Description |
|-------|-------------|
| **Temporal.io** | Orchestration de workflows durable et rÃ©siliente |
| **Eventuate Tram** | Framework Saga pour Java avec support Outbox |
| **MassTransit** | Framework .NET avec saga state machine |
| **NServiceBus** | Saga pattern pour .NET avec persistance PostgreSQL |
| **Debezium** | CDC pour publier les Ã©vÃ©nements Outbox |
| **Apache Kafka** | Message broker pour la chorÃ©graphie |

---

## Conclusion

Les **transactions distribuÃ©es** sont un dÃ©fi inÃ©vitable dans les architectures microservices. PlutÃ´t que de forcer des transactions ACID globales (2PC), le **pattern Saga** offre une approche pragmatique :

- DÃ©couper en **transactions locales** indÃ©pendantes
- PrÃ©voir des **compensations** pour chaque Ã©tape
- Accepter la **cohÃ©rence Ã©ventuelle**
- Garantir l'**idempotence** de chaque opÃ©ration

PostgreSQL, grÃ¢ce Ã  ses transactions locales robustes, son support JSONB pour les Ã©vÃ©nements, et ses mÃ©canismes comme `LISTEN/NOTIFY`, est un excellent choix pour implÃ©menter les Sagas.

Le choix entre **orchestration** et **chorÃ©graphie** dÃ©pend de votre contexte : complexitÃ© du flux, besoin de visibilitÃ©, et organisation des Ã©quipes.

---

## Points ClÃ©s Ã  Retenir

- **2PC** : Protocole classique mais peu adaptÃ© aux microservices (verrouillage, latence, couplage)
- **Saga** : SÃ©quence de transactions locales avec compensations en cas d'Ã©chec
- **Orchestration** : Un coordinateur central dirige le flux (visibilitÃ©, mais point central)
- **ChorÃ©graphie** : Les services rÃ©agissent aux Ã©vÃ©nements (dÃ©couplage, mais complexitÃ©)
- **Pattern Outbox** : Garantit la publication fiable des Ã©vÃ©nements
- **Idempotence** : Chaque Ã©tape doit pouvoir Ãªtre rejouÃ©e sans effet de bord
- **Compensation â‰  Rollback** : C'est une nouvelle opÃ©ration qui annule l'effet, pas un retour en arriÃ¨re

---


â­ï¸ [Foreign Data Wrappers pour la fÃ©dÃ©ration](/20bis-postgresql-et-architectures-modernes/01.3-fdw-federation.md)
