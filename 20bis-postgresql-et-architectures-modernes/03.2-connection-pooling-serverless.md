ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 20bis.3.2. Connection Pooling Serverless (PgBouncer, RDS Proxy)

## Introduction

Dans les architectures serverless, la gestion des connexions Ã  la base de donnÃ©es reprÃ©sente un dÃ©fi majeur. Chaque fonction serverless qui s'exÃ©cute a tendance Ã  ouvrir sa propre connexion, ce qui peut rapidement saturer PostgreSQL.

Ce chapitre explique pourquoi le **connection pooling** est indispensable en environnement serverless, et comment utiliser les deux solutions les plus rÃ©pandues : **PgBouncer** et **AWS RDS Proxy**.

---

## Le ProblÃ¨me des Connexions en Serverless

### Comment Fonctionne une Connexion PostgreSQL ?

Pour comprendre le problÃ¨me, commenÃ§ons par les bases. Quand une application se connecte Ã  PostgreSQL :

1. **Le client envoie une demande de connexion**
2. **PostgreSQL crÃ©e un nouveau processus** dÃ©diÃ© Ã  cette connexion (fork)
3. **L'authentification est vÃ©rifiÃ©e** (mot de passe, certificat, etc.)
4. **La connexion est Ã©tablie** et prÃªte Ã  recevoir des requÃªtes
5. **Ã€ la dÃ©connexion**, le processus est dÃ©truit

Chaque connexion consomme des ressources :

| Ressource | Consommation par connexion |
|-----------|---------------------------|
| **MÃ©moire RAM** | ~5-10 MB minimum |
| **Processus systÃ¨me** | 1 processus dÃ©diÃ© |
| **File descriptors** | Plusieurs par connexion |
| **Temps CPU** | Pour la crÃ©ation/destruction |

### Le Comportement des Fonctions Serverless

Dans une architecture serverless (AWS Lambda, Google Cloud Functions, Azure Functions, Vercel, etc.), le comportement est fondamentalement diffÃ©rent d'une application traditionnelle :

```
Architecture Traditionnelle (Serveur)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Application       â”‚
â”‚   (1 instance)      â”‚
â”‚                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Pool de 10    â”‚  â”‚â”€â”€â”€â”€â”€â”€â–º PostgreSQL (10 connexions)
â”‚  â”‚ connexions    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Architecture Serverless
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Lambda  â”‚ â”‚ Lambda  â”‚ â”‚ Lambda  â”‚ â”‚ Lambda  â”‚
â”‚   #1    â”‚ â”‚   #2    â”‚ â”‚   #3    â”‚ â”‚  ...    â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚           â”‚           â”‚           â”‚
     â–¼           â–¼           â–¼           â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚         PostgreSQL                      â”‚
   â”‚    (potentiellement 100+ connexions)    â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Pourquoi C'est ProblÃ©matique ?

Les fonctions serverless prÃ©sentent plusieurs caractÃ©ristiques qui amplifient le problÃ¨me :

#### 1. Scaling Automatique et ImprÃ©visible

Lors d'un pic de trafic, des dizaines ou centaines de fonctions peuvent dÃ©marrer simultanÃ©ment :

```
Trafic normal :     10 fonctions  â†’  10 connexions
Pic de trafic :    500 fonctions  â†’ 500 connexions !
```

#### 2. Connexions de Courte DurÃ©e

Chaque fonction :
- DÃ©marre (cold start)
- Ouvre une connexion
- ExÃ©cute 1-2 requÃªtes
- Se termine (ou reste "warm" quelques minutes)

Ce cycle constant de crÃ©ation/destruction est trÃ¨s coÃ»teux.

#### 3. Limite de Connexions PostgreSQL

PostgreSQL a une limite configurable de connexions simultanÃ©es :

| Configuration | Valeur typique |
|---------------|----------------|
| **max_connections** (dÃ©faut) | 100 |
| **RDS db.t3.micro** | ~85 |
| **RDS db.r5.large** | ~1 000 |

DÃ©passer cette limite provoque des erreurs :

```
FATAL: too many connections for role "myuser"
FATAL: sorry, too many clients already
```

### Le CoÃ»t CachÃ© : La Performance

MÃªme sans atteindre la limite, trop de connexions dÃ©gradent les performances :

- **MÃ©moire saturÃ©e** : Moins de RAM pour le cache (shared_buffers)
- **Contention CPU** : Trop de processus concurrents
- **Context switching** : Le systÃ¨me passe son temps Ã  jongler entre processus

---

## La Solution : Le Connection Pooling

### Qu'est-ce qu'un Connection Pooler ?

Un **connection pooler** est un intermÃ©diaire entre les applications et la base de donnÃ©es qui :

1. **Maintient un pool de connexions** vers PostgreSQL
2. **Accepte les connexions des clients** (en nombre illimitÃ© ou trÃ¨s Ã©levÃ©)
3. **RÃ©utilise les connexions existantes** au lieu d'en crÃ©er de nouvelles
4. **RÃ©duit la charge** sur PostgreSQL

```
SANS Connection Pooler
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client 1â”‚â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client 2â”‚â”€â”€â”€â”€â”¼â”€â”€â”€â”€â–ºâ”‚ PostgreSQL â”‚  100 connexions directes
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚     â”‚            â”‚  = 100 processus
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ Client Nâ”‚â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


AVEC Connection Pooler
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client 1â”‚â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚     â”‚              â”‚      â”‚            â”‚
â”‚ Client 2â”‚â”€â”€â”€â”€â”¼â”€â”€â”€â”€â–ºâ”‚  PgBouncer   â”‚â”€â”€â”€â”€â”€â–ºâ”‚ PostgreSQL â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚     â”‚  (pooler)    â”‚      â”‚            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚     â”‚              â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ Client Nâ”‚â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           1000 clients          20 connexions
                      â†’ 20 connexions        = 20 processus
```

### BÃ©nÃ©fices du Connection Pooling

| Aspect | Sans pooler | Avec pooler |
|--------|-------------|-------------|
| **Connexions Ã  PG** | = nombre de clients | Fixe et contrÃ´lÃ© |
| **Temps de connexion** | ~50-200ms | ~1-5ms |
| **MÃ©moire PostgreSQL** | Ã‰levÃ©e | OptimisÃ©e |
| **StabilitÃ©** | Risque de saturation | PrÃ©visible |

---

## PgBouncer : Le Standard de l'Industrie

### PrÃ©sentation

**PgBouncer** est le connection pooler le plus populaire pour PostgreSQL. CrÃ©Ã© en 2007, il est lÃ©ger, fiable et Ã©prouvÃ© en production par des milliers d'entreprises.

### CaractÃ©ristiques

- **LÃ©ger** : Consomme trÃ¨s peu de ressources (~2 KB par connexion)
- **Rapide** : Ã‰crit en C, performances optimales
- **Configurable** : Trois modes de pooling diffÃ©rents
- **Mature** : Plus de 15 ans de dÃ©veloppement

### Les Trois Modes de Pooling

PgBouncer propose trois modes de fonctionnement, chacun avec ses avantages et contraintes :

#### 1. Session Pooling (mode `session`)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SESSION POOLING                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                            â”‚
â”‚  Client A â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â–º Connexion PG 1  â”‚
â”‚            (toute la session)                              â”‚
â”‚                                                            â”‚
â”‚  Client B â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â–º Connexion PG 2  â”‚
â”‚            (toute la session)                              â”‚
â”‚                                                            â”‚
â”‚  La connexion PG est rÃ©servÃ©e tant que le client           â”‚
â”‚  est connectÃ© Ã  PgBouncer                                  â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Fonctionnement** : Une connexion PostgreSQL est assignÃ©e Ã  un client pour toute la durÃ©e de sa session.

| Avantages | InconvÃ©nients |
|-----------|---------------|
| Toutes les fonctionnalitÃ©s PG | Peu d'Ã©conomie de connexions |
| Prepared statements | Pas adaptÃ© au serverless |
| Variables de session | Limite = pool_size |

**Cas d'usage** : Applications traditionnelles qui utilisent des fonctionnalitÃ©s de session.

#### 2. Transaction Pooling (mode `transaction`) â­ RecommandÃ© pour Serverless

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  TRANSACTION POOLING                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                            â”‚
â”‚  Client A â”€â”€[BEGIN...COMMIT]â”€â”€â–º Connexion PG 1             â”‚
â”‚                                      â”‚                     â”‚
â”‚  Client B â”€â”€[requÃªte simple]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (rÃ©utilise PG 1)    â”‚
â”‚                                      â”‚                     â”‚
â”‚  Client A â”€â”€[BEGIN...COMMIT]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (rÃ©utilise PG 1)    â”‚
â”‚                                                            â”‚
â”‚  La connexion PG est libÃ©rÃ©e aprÃ¨s chaque transaction      â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Fonctionnement** : Une connexion PostgreSQL n'est rÃ©servÃ©e que pendant une transaction. Entre les transactions, elle peut servir Ã  d'autres clients.

| Avantages | InconvÃ©nients |
|-----------|---------------|
| Excellent ratio clients/connexions | Pas de prepared statements* |
| IdÃ©al pour serverless | Pas de variables de session |
| TrÃ¨s efficace | Pas de LISTEN/NOTIFY |

*Note : PostgreSQL 14+ supporte les prepared statements en mode transaction avec `protocol_native_password`.

**Cas d'usage** : Applications serverless, microservices, API REST.

#### 3. Statement Pooling (mode `statement`)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   STATEMENT POOLING                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                            â”‚
â”‚  Client A â”€â”€[SELECT 1]â”€â”€â–º Connexion PG 1                   â”‚
â”‚                                 â”‚                          â”‚
â”‚  Client B â”€â”€[SELECT 2]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (immÃ©diatement)          â”‚
â”‚                                 â”‚                          â”‚
â”‚  Client A â”€â”€[SELECT 3]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (immÃ©diatement)          â”‚
â”‚                                                            â”‚
â”‚  La connexion est libÃ©rÃ©e aprÃ¨s CHAQUE requÃªte             â”‚
â”‚  âš ï¸  Les transactions multi-requÃªtes sont INTERDITES       â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Fonctionnement** : La connexion est libÃ©rÃ©e aprÃ¨s chaque requÃªte individuelle.

| Avantages | InconvÃ©nients |
|-----------|---------------|
| Ratio maximal | Pas de transactions ! |
| Ultra-efficace | Usage trÃ¨s limitÃ© |

**Cas d'usage** : Workloads trÃ¨s spÃ©cifiques avec uniquement des requÃªtes autonomes.

### Comparaison des Modes

| FonctionnalitÃ© | Session | Transaction | Statement |
|----------------|---------|-------------|-----------|
| **Transactions** | âœ… | âœ… | âŒ |
| **Prepared Statements** | âœ… | âš ï¸ PG14+ | âŒ |
| **SET / Variables** | âœ… | âŒ | âŒ |
| **LISTEN/NOTIFY** | âœ… | âŒ | âŒ |
| **Advisory Locks** | âœ… | âŒ | âŒ |
| **Curseurs WITH HOLD** | âœ… | âŒ | âŒ |
| **EfficacitÃ© pooling** | Faible | Haute | Maximale |
| **AdaptÃ© serverless** | âŒ | âœ… | âš ï¸ |

### Architecture de DÃ©ploiement

PgBouncer peut Ãªtre dÃ©ployÃ© de plusieurs faÃ§ons :

#### Option 1 : Sidecar (mÃªme machine que l'application)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Serveur App            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚    App    â”‚â”€â–ºâ”‚ PgBouncer  â”‚â”€â”€â”¼â”€â”€â”€â”€â”€â–ºâ”‚ PostgreSQL â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚                localhost:6432   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Avantages** : Latence minimale, simple Ã  configurer.

#### Option 2 : Proxy centralisÃ©

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  App 1  â”‚â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”œâ”€â”€â”€â”€â–ºâ”‚ PgBouncer  â”‚â”€â”€â”€â”€â”€â–ºâ”‚ PostgreSQL â”‚
â”‚  App 2  â”‚â”€â”€â”€â”€â”¤     â”‚  (central) â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  App N  â”‚â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Avantages** : Gestion centralisÃ©e, un seul point de configuration.

#### Option 3 : IntÃ©grÃ© au service (Neon, Supabase)

Les plateformes serverless PostgreSQL intÃ¨grent souvent PgBouncer :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Neon / Supabase                     â”‚
â”‚                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚ PgBouncer  â”‚â”€â”€â”€â”€â”€â–ºâ”‚ PostgreSQL â”‚                 â”‚
â”‚  â”‚ (intÃ©grÃ©)  â”‚      â”‚            â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚        â–²                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    Connexion poolÃ©e automatique
```

### Configuration Essentielle de PgBouncer

Voici les paramÃ¨tres les plus importants du fichier `pgbouncer.ini` :

#### Section [databases]

```ini
[databases]
; Format : nom_logique = connexion_string
mydb = host=localhost port=5432 dbname=mydb

; Avec authentification
mydb = host=db.example.com port=5432 dbname=production user=app_user password=secret
```

#### Section [pgbouncer]

```ini
[pgbouncer]
; Adresse d'Ã©coute
listen_addr = 0.0.0.0
listen_port = 6432

; Mode de pooling (session, transaction, statement)
pool_mode = transaction

; Taille du pool par utilisateur/base
default_pool_size = 20

; Connexions supplÃ©mentaires si le pool est plein
reserve_pool_size = 5

; Temps d'attente max pour une connexion du pool (secondes)
reserve_pool_timeout = 3

; Nombre max de connexions clients
max_client_conn = 1000

; Nombre max de connexions vers PostgreSQL (toutes bases)
max_db_connections = 50

; Authentification
auth_type = scram-sha-256
auth_file = /etc/pgbouncer/userlist.txt

; Logs
log_connections = 1
log_disconnections = 1
log_pooler_errors = 1
```

#### Fichier d'authentification (userlist.txt)

```
; Format : "utilisateur" "mot_de_passe_hashÃ©_ou_clair"
"app_user" "scram-sha-256$4096:..."
"readonly_user" "scram-sha-256$4096:..."
```

### Dimensionnement du Pool

La question cruciale : combien de connexions configurer ?

#### Formule de Base

```
pool_size = (nombre_coeurs_cpu Ã— 2) + nombre_disques
```

Pour un serveur avec 4 cÅ“urs et 1 SSD :
```
pool_size = (4 Ã— 2) + 1 = 9 connexions
```

#### RÃ¨gles Pratiques

| ScÃ©nario | pool_size recommandÃ© |
|----------|---------------------|
| **Petit projet** (1-2 vCPU) | 10-20 |
| **Application moyenne** (4 vCPU) | 20-50 |
| **Charge importante** (8+ vCPU) | 50-100 |
| **Serverless intense** | 20-30 (+ reserve) |

#### L'Erreur Classique

> "Plus de connexions = meilleures performances"

**FAUX !** Trop de connexions parallÃ¨les crÃ©ent de la contention. PostgreSQL est souvent plus performant avec 20 connexions actives qu'avec 200.

### Monitoring PgBouncer

PgBouncer expose des statistiques via une base virtuelle `pgbouncer` :

```sql
-- Se connecter Ã  la base admin
psql -h localhost -p 6432 -U admin pgbouncer

-- Voir les pools actifs
SHOW POOLS;

-- Statistiques par base
SHOW STATS;

-- Connexions clients
SHOW CLIENTS;

-- Connexions serveur (vers PostgreSQL)
SHOW SERVERS;

-- Configuration actuelle
SHOW CONFIG;
```

#### MÃ©triques Importantes

| MÃ©trique | Description | Seuil d'alerte |
|----------|-------------|----------------|
| **cl_active** | Clients actifs | - |
| **cl_waiting** | Clients en attente | > 0 prolongÃ© |
| **sv_active** | Connexions PG actives | Proche de pool_size |
| **sv_idle** | Connexions PG inactives | Devrait Ãªtre > 0 |
| **maxwait** | Temps d'attente max | > 1 seconde |

---

## AWS RDS Proxy : Le Pooling ManagÃ©

### PrÃ©sentation

**AWS RDS Proxy** est un service de connection pooling entiÃ¨rement gÃ©rÃ© par Amazon Web Services. Il est conÃ§u spÃ©cifiquement pour les architectures serverless AWS.

### Pourquoi RDS Proxy ?

AWS a crÃ©Ã© RDS Proxy pour rÃ©soudre le problÃ¨me spÃ©cifique des Lambda + RDS :

```
PROBLÃˆME CLASSIQUE AWS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Lambda  â”‚ â”‚ Lambda  â”‚ â”‚ Lambda  â”‚    Pic de trafic :
â”‚   #1    â”‚ â”‚   #2    â”‚ â”‚  #100   â”‚    100 Lambdas
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    = 100 connexions
     â”‚           â”‚           â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚    RDS PostgreSQL     â”‚  â† ERREUR: too many connections
     â”‚   (max_connections:   â”‚
     â”‚        87)            â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


SOLUTION AVEC RDS PROXY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Lambda  â”‚ â”‚ Lambda  â”‚ â”‚ Lambda  â”‚    1000+ Lambdas
â”‚   #1    â”‚ â”‚   #2    â”‚ â”‚ #1000   â”‚    supportÃ©es
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚           â”‚           â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚      RDS Proxy        â”‚  â† GÃ¨re la file d'attente
     â”‚   (pooling + queue)   â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚    RDS PostgreSQL     â”‚  â† Seulement 20-50 connexions
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### CaractÃ©ristiques Principales

#### 1. EntiÃ¨rement GÃ©rÃ© (Serverless)

- Pas de serveur Ã  provisionner
- Scaling automatique
- Haute disponibilitÃ© native (multi-AZ)
- Maintenance automatique

#### 2. IntÃ©gration AWS Native

- **IAM Authentication** : Authentification via rÃ´les IAM (pas de mots de passe)
- **Secrets Manager** : Rotation automatique des credentials
- **VPC** : Fonctionne dans votre rÃ©seau privÃ©
- **CloudWatch** : MÃ©triques et logs intÃ©grÃ©s

#### 3. Failover Automatique

RDS Proxy amÃ©liore la rÃ©silience :

```
SANS RDS Proxy (Failover classique)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Instance primaire tombe
2. Failover vers standby (~30-60s)
3. Applications : connexions cassÃ©es
4. Applications : doivent reconnecter
5. Erreurs pendant la transition


AVEC RDS Proxy
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Instance primaire tombe
2. RDS Proxy dÃ©tecte la panne
3. RDS Proxy maintient les connexions clients
4. Failover vers standby
5. RDS Proxy reconnecte automatiquement
6. Applications : voient un lÃ©ger dÃ©lai, pas d'erreur
```

### Configuration de RDS Proxy

#### PrÃ©requis

1. Une instance RDS PostgreSQL ou Aurora PostgreSQL
2. Un secret dans AWS Secrets Manager avec les credentials
3. Un VPC avec les security groups appropriÃ©s

#### Ã‰tapes de CrÃ©ation (Console AWS)

1. **AccÃ©der Ã  RDS** â†’ **Proxies** â†’ **Create proxy**

2. **Configuration de base** :
   - Nom du proxy
   - Engine : PostgreSQL
   - Require TLS : RecommandÃ©

3. **Target group** :
   - Base de donnÃ©es cible (votre RDS/Aurora)
   - Connection pool configuration :
     - Max connections : % de max_connections de la DB

4. **Authentification** :
   - Secret ARN depuis Secrets Manager
   - IAM authentication : Optionnel mais recommandÃ©

5. **Connectivity** :
   - VPC et subnets
   - Security groups

#### Configuration via Infrastructure as Code (Terraform)

```hcl
resource "aws_db_proxy" "main" {
  name                   = "my-postgres-proxy"
  debug_logging          = false
  engine_family          = "POSTGRESQL"
  idle_client_timeout    = 1800
  require_tls            = true
  vpc_subnet_ids         = var.private_subnet_ids
  vpc_security_group_ids = [aws_security_group.proxy.id]

  auth {
    auth_scheme               = "SECRETS"
    iam_auth                  = "REQUIRED"
    secret_arn                = aws_secretsmanager_secret.db_credentials.arn
  }
}

resource "aws_db_proxy_default_target_group" "main" {
  db_proxy_name = aws_db_proxy.main.name

  connection_pool_config {
    max_connections_percent      = 50
    max_idle_connections_percent = 10
    connection_borrow_timeout    = 120
  }
}

resource "aws_db_proxy_target" "main" {
  db_proxy_name          = aws_db_proxy.main.name
  target_group_name      = aws_db_proxy_default_target_group.main.name
  db_instance_identifier = aws_db_instance.main.identifier
}
```

### Connexion via RDS Proxy

#### Endpoint

RDS Proxy fournit un endpoint dÃ©diÃ© :
```
my-proxy.proxy-xxxxxxxxxxxx.region.rds.amazonaws.com
```

#### Avec mot de passe (Secrets Manager)

```python
import psycopg2

conn = psycopg2.connect(
    host="my-proxy.proxy-xxxx.us-east-1.rds.amazonaws.com",
    port=5432,
    database="mydb",
    user="app_user",
    password="from_secrets_manager",
    sslmode="require"
)
```

#### Avec IAM Authentication (RecommandÃ©)

```python
import boto3
import psycopg2

# GÃ©nÃ©rer un token d'authentification IAM
client = boto3.client('rds')
token = client.generate_db_auth_token(
    DBHostname='my-proxy.proxy-xxxx.us-east-1.rds.amazonaws.com',
    Port=5432,
    DBUsername='iam_user'
)

conn = psycopg2.connect(
    host="my-proxy.proxy-xxxx.us-east-1.rds.amazonaws.com",
    port=5432,
    database="mydb",
    user="iam_user",
    password=token,  # Le token IAM comme mot de passe
    sslmode="require"
)
```

### ParamÃ¨tres de Configuration Importants

| ParamÃ¨tre | Description | Valeur recommandÃ©e |
|-----------|-------------|-------------------|
| **max_connections_percent** | % de max_connections de la DB Ã  utiliser | 50-90% |
| **max_idle_connections_percent** | % de connexions idle Ã  maintenir | 10-50% |
| **connection_borrow_timeout** | Temps max d'attente pour une connexion (sec) | 120 |
| **idle_client_timeout** | Timeout des connexions client idle (sec) | 1800 |

### Monitoring RDS Proxy

RDS Proxy expose des mÃ©triques dans CloudWatch :

#### MÃ©triques ClÃ©s

| MÃ©trique | Description | Action si problÃ¨me |
|----------|-------------|-------------------|
| **ClientConnections** | Nombre de connexions clients | Normal, informatif |
| **ClientConnectionsNoTLS** | Connexions sans TLS | Devrait Ãªtre 0 |
| **DatabaseConnections** | Connexions vers RDS | Surveiller vs max |
| **DatabaseConnectionsBorrowLatency** | Temps pour obtenir une connexion | < 100ms idÃ©al |
| **QueryRequests** | Nombre de requÃªtes | Baseline du trafic |
| **QueryDatabaseResponseLatency** | Latence des requÃªtes | DÃ©tecter les lenteurs |

#### Alarmes RecommandÃ©es

```yaml
# Exemple CloudWatch Alarm (pseudo-YAML)
Alarms:
  - Name: HighBorrowLatency
    Metric: DatabaseConnectionsBorrowLatency
    Threshold: 1000  # ms
    Action: Augmenter pool ou optimiser requÃªtes

  - Name: PoolExhaustion
    Metric: DatabaseConnections
    Threshold: 90%  # de max_connections_percent
    Action: Augmenter % ou scaler la DB
```

### Tarification RDS Proxy

RDS Proxy est facturÃ© Ã  l'heure par vCPU provisionnÃ© :

| Ã‰lÃ©ment | CoÃ»t approximatif |
|---------|-------------------|
| **Par vCPU/heure** | ~$0.015 |
| **Proxy minimal** | 2 vCPU = ~$22/mois |
| **DonnÃ©es transfÃ©rÃ©es** | Inclus |

Le coÃ»t dÃ©pend de la rÃ©gion AWS et peut Ã©voluer. Consultez la page de tarification officielle.

---

## Comparaison : PgBouncer vs RDS Proxy

### Tableau Comparatif DÃ©taillÃ©

| Aspect | PgBouncer | RDS Proxy |
|--------|-----------|-----------|
| **Type** | Open source, self-managed | Service managÃ© AWS |
| **CoÃ»t** | Gratuit (+ infra) | Payant (~$22+/mois) |
| **Modes de pooling** | Session, Transaction, Statement | Transaction-like |
| **Configuration** | Fichier texte, trÃ¨s flexible | Console/API, options limitÃ©es |
| **Haute disponibilitÃ©** | Ã€ configurer soi-mÃªme | IntÃ©grÃ©e (multi-AZ) |
| **Authentification** | Fichier userlist, LDAP | IAM, Secrets Manager |
| **IntÃ©gration Lambda** | Possible mais manuel | Native et optimisÃ©e |
| **Failover** | Manuel ou via orchestrateur | Automatique et transparent |
| **MÃ©triques** | SHOW commands, custom | CloudWatch natif |
| **Prepared statements** | Configurable | SupportÃ©s |
| **Support** | CommunautÃ© | Support AWS |

### Quand Choisir PgBouncer ?

âœ… **Choisissez PgBouncer si :**

- Vous n'Ãªtes pas sur AWS ou utilisez plusieurs clouds
- Vous voulez un contrÃ´le total sur la configuration
- Le budget est serrÃ© (PgBouncer est gratuit)
- Vous avez l'expertise pour gÃ©rer l'infrastructure
- Vous avez besoin du mode `session` ou `statement`
- Votre PostgreSQL n'est pas sur RDS/Aurora

### Quand Choisir RDS Proxy ?

âœ… **Choisissez RDS Proxy si :**

- Vous Ãªtes sur AWS avec RDS ou Aurora PostgreSQL
- Vous utilisez intensivement AWS Lambda
- Vous voulez une solution sans maintenance
- L'authentification IAM est importante pour vous
- Vous avez besoin d'un failover transparent
- Le coÃ»t supplÃ©mentaire est acceptable

### Architecture Hybride

Dans certains cas, vous pouvez combiner les deux :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Architecture Hybride                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                            â”‚
â”‚  â”‚   Lambda    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚  â”‚ Functions   â”‚            â”‚                               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â–¼                               â”‚
â”‚                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚ RDS Proxy  â”‚â”€â”€â”€â”€â”€â–ºâ”‚              â”‚   â”‚
â”‚  â”‚   ECS /     â”‚â”€â”€â”€â”€â–ºâ”‚            â”‚      â”‚  PostgreSQL  â”‚   â”‚
â”‚  â”‚   EKS       â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚    (RDS)     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚              â”‚   â”‚
â”‚                                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â–²            â”‚
â”‚  â”‚   EC2 /     â”‚â”€â”€â”€â”€â–ºâ”‚ PgBouncer  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚  â”‚   On-prem   â”‚     â”‚ (self-mgd) â”‚                         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Autres Solutions de Connection Pooling

### Odyssey (Yandex)

- Alternative moderne Ã  PgBouncer
- Multi-threading (meilleure utilisation CPU)
- DÃ©veloppÃ© par Yandex
- Open source

### Pgpool-II

- Plus qu'un pooler : load balancing, rÃ©plication
- Plus complexe Ã  configurer
- FonctionnalitÃ©s avancÃ©es (cache de requÃªtes)

### Pooling IntÃ©grÃ© aux Plateformes

| Plateforme | Solution intÃ©grÃ©e |
|------------|-------------------|
| **Neon** | PgBouncer intÃ©grÃ© + Neon Proxy |
| **Supabase** | Supavisor (PgBouncer-based) |
| **Azure** | Azure Database Proxy (preview) |
| **Google Cloud** | Cloud SQL Proxy (+ Auth Proxy) |

---

## Bonnes Pratiques

### 1. Toujours Utiliser un Pooler en Serverless

MÃªme pour de petits projets, un pooler Ã©vite les surprises lors des montÃ©es en charge.

### 2. Configurer des Timeouts AppropriÃ©s

```ini
# PgBouncer
server_connect_timeout = 15
server_idle_timeout = 600
query_timeout = 300
```

Les fonctions serverless ont des timeouts courts ; configurez le pooler en consÃ©quence.

### 3. GÃ©rer les Connexions dans le Code

```python
# âŒ MAUVAIS : Connexion globale qui peut expirer
conn = psycopg2.connect(...)

def handler(event, context):
    cursor = conn.cursor()  # Peut Ã©chouer si connexion morte
    ...

# âœ… BON : Connexion par invocation avec gestion d'erreur
def handler(event, context):
    conn = psycopg2.connect(...)
    try:
        cursor = conn.cursor()
        ...
    finally:
        conn.close()
```

### 4. Utiliser le Mode Transaction pour Serverless

Le mode `transaction` offre le meilleur Ã©quilibre efficacitÃ©/compatibilitÃ©.

### 5. Surveiller les MÃ©triques

Configurez des alertes pour :
- Connexions en attente
- Temps d'obtention de connexion
- Erreurs de connexion

### 6. Tester la Charge

Avant la production, simulez des pics de trafic pour valider le dimensionnement.

---

## Conclusion

Le connection pooling est **indispensable** dans les architectures serverless. Sans lui, vous risquez des erreurs de connexion, des performances dÃ©gradÃ©es et une instabilitÃ© gÃ©nÃ©rale.

**En rÃ©sumÃ© :**

- **PgBouncer** est la solution universelle, gratuite et flexible. IdÃ©ale si vous gÃ©rez votre infrastructure ou n'Ãªtes pas sur AWS.

- **RDS Proxy** est la solution "clÃ© en main" pour l'Ã©cosystÃ¨me AWS. Plus coÃ»teuse mais sans maintenance et parfaitement intÃ©grÃ©e.

Le choix dÃ©pend de votre contexte : cloud provider, budget, expertise interne et besoins spÃ©cifiques. Dans tous les cas, l'investissement dans un connection pooler sera rapidement rentabilisÃ© par la stabilitÃ© et les performances gagnÃ©es.

---

## Ressources ComplÃ©mentaires

### Documentation Officielle

- [Documentation PgBouncer](https://www.pgbouncer.org/)
- [Documentation RDS Proxy](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-proxy.html)

### Articles Techniques

- PgBouncer : Configuration avancÃ©e et tuning
- RDS Proxy : Best practices pour Lambda
- Comparaison des poolers PostgreSQL

### Outils

- pgbench : Tests de charge PostgreSQL
- Artillery : Tests de charge applicatifs
- CloudWatch : Monitoring RDS Proxy

---


â­ï¸ [Cold starts et gestion des connexions](/20bis-postgresql-et-architectures-modernes/03.3-cold-starts-connexions.md)
