üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.3.3. Dictionnaires et Langues Multiples

## Introduction

Imaginez que vous construisez une plateforme internationale qui doit supporter la recherche en fran√ßais, anglais, espagnol et arabe simultan√©ment. Ou que vous devez personnaliser le comportement de la recherche pour votre domaine sp√©cifique (m√©dical, juridique, technique).

Les **dictionnaires** et les **configurations linguistiques** de PostgreSQL vous permettent de :
- G√©rer correctement le **stemming** (r√©duction des mots) dans diff√©rentes langues
- D√©finir des **stop words** (mots vides) personnalis√©s
- Cr√©er des **synonymes** et des **th√©saurus**
- Supporter le **multilinguisme** dans une m√™me application
- Adapter le traitement du texte √† votre domaine m√©tier

**Sans configuration linguistique** :
```sql
-- Recherche sans stemming fran√ßais
SELECT to_tsvector('simple', 'Les bases de donn√©es sont essentielles');
-- R√©sultat : 'bases':2 'de':3 'donn√©es':4 'essentielles':6 'les':1 'sont':5
-- Probl√®me : "Les", "de", "sont" ne sont pas filtr√©s
```

**Avec configuration fran√ßaise** :
```sql
-- Recherche avec stemming fran√ßais
SELECT to_tsvector('french', 'Les bases de donn√©es sont essentielles');
-- R√©sultat : 'base':2 'donn':4 'essenti':6
-- Stop words supprim√©s, stemming appliqu√©
```

---

## 1. Architecture des Dictionnaires PostgreSQL

### Les Composants du Full-Text Search

Le traitement d'un texte en Full-Text Search suit ce pipeline :

```
Texte original
     ‚Üì
[1. PARSER] ‚Üí D√©coupage en tokens (mots, nombres, ponctuation)
     ‚Üì
[2. DICTIONNAIRES] ‚Üí Normalisation, stemming, filtrage
     ‚Üì
[3. TSVECTOR] ‚Üí Repr√©sentation finale indexable
```

### Les Trois Niveaux

#### 1. Parser (Analyseur)

Le **parser** d√©coupe le texte en **tokens** (unit√©s lexicales).

```sql
-- Voir les tokens produits par le parser
SELECT * FROM ts_token_type('default');
```

**R√©sultat** :
```
tokid | alias      | description
------+------------+---------------------------
    1 | asciiword  | Word, all ASCII
    2 | word       | Word, all letters
    3 | numword    | Word, letters and digits
    4 | email      | Email address
    5 | url        | URL
    6 | host       | Host
    7 | sfloat     | Scientific notation
    8 | version    | Version number
   12 | blank      | Space symbols
   23 | tag        | XML tag
```

**Exemple de parsing** :
```sql
SELECT * FROM ts_parse('default', 'PostgreSQL 16.2 est disponible sur postgresql.org');
```

**R√©sultat** :
```
tokid |    token
------+-------------
    1 | PostgreSQL
   12 |
    8 | 16.2
   12 |
    1 | est
   12 |
    1 | disponible
   12 |
    1 | sur
   12 |
    6 | postgresql.org
```

#### 2. Dictionnaires

Les **dictionnaires** transforment les tokens en **lex√®mes** (formes normalis√©es).

**Types de dictionnaires** :
- **Stop words** : Filtre les mots vides
- **Stemming** : R√©duit les mots √† leur racine
- **Synonym** : Remplace par des synonymes
- **Thesaurus** : Gestion avanc√©e des synonymes
- **Ispell** : Dictionnaires morphologiques
- **Snowball** : Algorithmes de stemming

#### 3. Configuration (Text Search Configuration)

La **configuration** lie les types de tokens aux dictionnaires appropri√©s.

```sql
-- Voir les configurations disponibles
SELECT cfgname FROM pg_ts_config;
-- R√©sultat : simple, danish, dutch, english, finnish, french, german, etc.
```

---

## 2. Configurations Linguistiques Pr√©-d√©finies

### Configurations Disponibles

PostgreSQL offre 20+ configurations linguistiques pr√™tes √† l'emploi :

```sql
-- Lister toutes les configurations avec d√©tails
SELECT
    cfgname AS nom,
    cfgnamespace::regnamespace AS schema,
    (SELECT COUNT(*) FROM pg_ts_config_map WHERE mapcfg = c.oid) AS nombre_mappings
FROM pg_ts_config c
ORDER BY cfgname;
```

**Principales configurations** :

| Configuration | Langue | Stemmer | Stop Words |
|---------------|--------|---------|------------|
| `simple` | Aucune | ‚ùå Non | ‚ùå Non |
| `english` | Anglais | ‚úÖ Snowball | ‚úÖ Oui |
| `french` | Fran√ßais | ‚úÖ Snowball | ‚úÖ Oui |
| `spanish` | Espagnol | ‚úÖ Snowball | ‚úÖ Oui |
| `german` | Allemand | ‚úÖ Snowball | ‚úÖ Oui |
| `italian` | Italien | ‚úÖ Snowball | ‚úÖ Oui |
| `portuguese` | Portugais | ‚úÖ Snowball | ‚úÖ Oui |
| `russian` | Russe | ‚úÖ Snowball | ‚úÖ Oui |
| `arabic` | Arabe | ‚úÖ Oui | ‚úÖ Oui |
| `danish` | Danois | ‚úÖ Snowball | ‚úÖ Oui |
| `dutch` | N√©erlandais | ‚úÖ Snowball | ‚úÖ Oui |
| `finnish` | Finnois | ‚úÖ Snowball | ‚úÖ Oui |
| `hungarian` | Hongrois | ‚úÖ Snowball | ‚úÖ Oui |
| `norwegian` | Norv√©gien | ‚úÖ Snowball | ‚úÖ Oui |
| `romanian` | Roumain | ‚úÖ Snowball | ‚úÖ Oui |
| `swedish` | Su√©dois | ‚úÖ Snowball | ‚úÖ Oui |
| `turkish` | Turc | ‚úÖ Snowball | ‚úÖ Oui |

### Comparaison des Configurations

```sql
-- Comparer le traitement d'un m√™me texte dans diff√©rentes langues
SELECT
    'simple' AS config,
    to_tsvector('simple', 'running runs runner') AS result
UNION ALL
SELECT
    'english',
    to_tsvector('english', 'running runs runner')
UNION ALL
SELECT
    'french',
    to_tsvector('french', 'courir cours coureur');
```

**R√©sultat** :
```
config  | result
--------+----------------------------
simple  | 'runner':3 'running':1 'runs':2
english | 'run':1,2,3                    ‚Üê Stemming : tous ‚Üí "run"
french  | 'cour':1,2,3                   ‚Üê Stemming : tous ‚Üí "cour"
```

### Configuration par D√©faut

```sql
-- Voir la configuration par d√©faut
SHOW default_text_search_config;
-- R√©sultat typique : pg_catalog.english (ou french selon l'installation)

-- Changer la configuration par d√©faut pour la session
SET default_text_search_config = 'french';

-- Utiliser to_tsvector sans sp√©cifier la langue (utilise le d√©faut)
SELECT to_tsvector('Les bases de donn√©es');
-- Utilise maintenant la configuration fran√ßaise
```

---

## 3. Anatomie d'une Configuration

### Inspecter une Configuration

```sql
-- D√©tails de la configuration fran√ßaise
SELECT
    cfgname,
    (SELECT dictname FROM pg_ts_dict d
     WHERE d.oid = ANY(m.mapdict) LIMIT 1) AS premier_dictionnaire
FROM pg_ts_config c
JOIN pg_ts_config_map m ON m.mapcfg = c.oid
WHERE cfgname = 'french'
LIMIT 5;
```

### Mapping Token ‚Üí Dictionnaires

Chaque configuration associe des types de tokens √† des dictionnaires :

```sql
-- Voir le mapping complet pour le fran√ßais
SELECT
    tt.alias AS type_token,
    tt.description,
    ARRAY_AGG(d.dictname ORDER BY m.mapseqno) AS dictionnaires
FROM pg_ts_config c
JOIN pg_ts_config_map m ON m.mapcfg = c.oid
JOIN pg_ts_dict d ON d.oid = ANY(m.mapdict)
JOIN ts_token_type(c.cfgparser) tt ON tt.tokid = m.maptokentype
WHERE c.cfgname = 'french'
GROUP BY tt.alias, tt.description, m.maptokentype
ORDER BY m.maptokentype;
```

**R√©sultat typique pour "french"** :
```
type_token  | description         | dictionnaires
------------+--------------------+------------------------
asciiword   | Word, all ASCII    | {french_stem}
word        | Word, all letters  | {french_stem}
numword     | Word, letters+num  | {simple}
email       | Email address      | {simple}
url         | URL                | {simple}
host        | Host               | {simple}
```

**Interpr√©tation** :
- Les **mots** (asciiword, word) passent par `french_stem` (stemming fran√ßais)
- Les **nombres** et **URLs** passent par `simple` (pas de transformation)
- Les **espaces** et **ponctuation** sont ignor√©s

### Ordre d'Application des Dictionnaires

Les dictionnaires sont appliqu√©s **s√©quentiellement** jusqu'√† ce que l'un produise un r√©sultat :

```
Token: "couraient"
   ‚Üì
[1] french_stem ‚Üí "cour" ‚úì (succ√®s, on s'arr√™te)
   ‚Üì
Lex√®me: "cour"
```

Si le premier dictionnaire ne produit rien (stop word), le suivant est essay√© :

```
Token: "le"
   ‚Üì
[1] french_stem ‚Üí NULL (stop word, aucun r√©sultat)
   ‚Üì
[2] simple ‚Üí NULL (pas d'autre dictionnaire)
   ‚Üì
Lex√®me: (aucun, token ignor√©)
```

---

## 4. Les Types de Dictionnaires

### 4.1. Simple Dictionary

Le dictionnaire **simple** ne fait **aucune transformation** : il retourne le token tel quel en minuscules.

```sql
-- Cr√©er un dictionnaire simple
CREATE TEXT SEARCH DICTIONARY public.simple_dict (
    TEMPLATE = pg_catalog.simple
);

-- Test
SELECT ts_lexize('simple_dict', 'PostgreSQL');
-- R√©sultat : {postgresql}

SELECT ts_lexize('simple_dict', 'Les');
-- R√©sultat : {les} (m√™me les stop words sont conserv√©s)
```

**Usage** : Pour les tokens qu'on ne veut pas transformer (URLs, emails, codes).

### 4.2. Snowball Dictionary (Stemming)

Le dictionnaire **Snowball** applique un algorithme de stemming pour r√©duire les mots √† leur racine.

```sql
-- Voir les stemmers Snowball disponibles
SELECT * FROM pg_ts_dict WHERE dictname LIKE '%stem';
```

**Algorithmes Snowball** :
- `danish_stem` : Danois
- `dutch_stem` : N√©erlandais
- `english_stem` : Anglais
- `finnish_stem` : Finnois
- `french_stem` : Fran√ßais
- `german_stem` : Allemand
- `hungarian_stem` : Hongrois
- `italian_stem` : Italien
- `norwegian_stem` : Norv√©gien
- `portuguese_stem` : Portugais
- `romanian_stem` : Roumain
- `russian_stem` : Russe
- `spanish_stem` : Espagnol
- `swedish_stem` : Su√©dois
- `turkish_stem` : Turc

**Exemple de stemming fran√ßais** :
```sql
-- Tester le stemmer fran√ßais
SELECT ts_lexize('french_stem', 'couraient');
-- R√©sultat : {cour}

SELECT ts_lexize('french_stem', 'coureur');
-- R√©sultat : {cour}

SELECT ts_lexize('french_stem', 'courses');
-- R√©sultat : {cours}

SELECT ts_lexize('french_stem', 'bases');
-- R√©sultat : {base}

SELECT ts_lexize('french_stem', 'donn√©es');
-- R√©sultat : {donn}
```

**Cr√©er un dictionnaire Snowball personnalis√©** :
```sql
-- Cr√©er un stemmer fran√ßais avec stop words personnalis√©s
CREATE TEXT SEARCH DICTIONARY french_custom (
    TEMPLATE = snowball,
    Language = french,
    StopWords = french  -- Fichier de stop words (optionnel)
);
```

### 4.3. Ispell Dictionary (Dictionnaires Morphologiques)

Les dictionnaires **Ispell** utilisent des fichiers de dictionnaires morphologiques (comme les correcteurs orthographiques).

```sql
-- Cr√©er un dictionnaire Ispell pour le fran√ßais
CREATE TEXT SEARCH DICTIONARY french_ispell (
    TEMPLATE = ispell,
    DictFile = french,    -- Fichier .dict
    AffFile = french,     -- Fichier .affix
    StopWords = french    -- Fichier de stop words
);

-- Les fichiers doivent √™tre dans $SHAREDIR/tsearch_data/
-- Exemple : french.dict, french.affix
```

**Avantages Ispell** :
- Plus pr√©cis que Snowball (connaissance morphologique)
- G√®re les irr√©gularit√©s linguistiques
- Peut faire de la lemmatisation (pas juste du stemming)

**Inconv√©nients** :
- N√©cessite des fichiers de dictionnaires externes
- Plus lent que Snowball
- Fichiers volumineux

**Exemple d'utilisation** :
```sql
-- Si le dictionnaire est configur√©
SELECT ts_lexize('french_ispell', 'couraient');
-- R√©sultat : {courir} (lemme, pas juste stem)
```

### 4.4. Synonym Dictionary (Synonymes)

Le dictionnaire **synonym** remplace des mots par leurs synonymes.

```sql
-- Cr√©er un fichier de synonymes : /usr/share/postgresql/16/tsearch_data/synonyms.syn
-- Contenu du fichier :
-- postgres    postgresql
-- pgsql       postgresql
-- pg          postgresql

-- Cr√©er le dictionnaire
CREATE TEXT SEARCH DICTIONARY synonym_dict (
    TEMPLATE = synonym,
    SYNONYMS = synonyms  -- Nom du fichier (sans .syn)
);

-- Test
SELECT ts_lexize('synonym_dict', 'postgres');
-- R√©sultat : {postgresql}

SELECT ts_lexize('synonym_dict', 'pgsql');
-- R√©sultat : {postgresql}
```

**Format du fichier de synonymes** :
```
# Commentaire
mot_original    synonyme

# Exemples
db              database
rdbms           database
sgbd            database
bdd             database
```

### 4.5. Thesaurus Dictionary (Th√©saurus)

Le dictionnaire **thesaurus** est une version avanc√©e du dictionnaire de synonymes qui g√®re des **phrases multi-mots**.

```sql
-- Fichier thesaurus.ths
-- Format : phrase originale : liste de synonymes
-- Exemple :
-- postgres sql : postgresql
-- relational database : rdbms
-- artificial intelligence : ai machine_learning

-- Cr√©er le dictionnaire
CREATE TEXT SEARCH DICTIONARY thesaurus_dict (
    TEMPLATE = thesaurus,
    DictFile = thesaurus,      -- Fichier .ths
    Dictionary = english_stem  -- Dictionnaire sous-jacent pour stemming
);

-- Test
SELECT ts_lexize('thesaurus_dict', 'relational');
-- R√©sultat : NULL (attente du mot suivant "database")

-- Utilisation via to_tsvector (traite les phrases)
SELECT to_tsvector('thesaurus_config', 'relational database system');
-- R√©sultat : 'rdbms':1 'system':3
```

---

## 5. Stop Words (Mots Vides)

### Qu'est-ce qu'un Stop Word ?

Les **stop words** sont des mots tr√®s fr√©quents et peu significatifs qu'on ignore lors de l'indexation.

**Exemples fran√ßais** : le, la, les, un, une, de, du, des, √†, au, en, et, ou, mais, etc.
**Exemples anglais** : the, a, an, in, on, at, to, for, of, with, etc.

### Fichiers de Stop Words

Les configurations linguistiques utilisent des fichiers de stop words :

```bash
# Localisation typique
/usr/share/postgresql/16/tsearch_data/

# Fichiers
french.stop      # Stop words fran√ßais
english.stop     # Stop words anglais
spanish.stop     # Stop words espagnol
# etc.
```

### Voir les Stop Words

```sql
-- Tester si un mot est un stop word
SELECT ts_lexize('french_stem', 'le');
-- R√©sultat : NULL (c'est un stop word)

SELECT ts_lexize('french_stem', 'les');
-- R√©sultat : NULL (stop word)

SELECT ts_lexize('french_stem', 'postgresql');
-- R√©sultat : {postgresql} (pas un stop word)
```

### Liste des Stop Words Fran√ßais

**Extrait du fichier french.stop** :
```
au
aux
avec
ce
ces
dans
de
des
du
elle
en
et
eux
il
je
la
le
leur
lui
ma
mais
me
m√™me
mes
moi
mon
ne
nos
notre
nous
on
ou
par
pas
pour
qu
que
qui
sa
se
ses
son
sur
ta
te
tes
toi
ton
tu
un
une
vos
votre
vous
```

### Cr√©er un Fichier de Stop Words Personnalis√©

```sql
-- 1. Cr√©er le fichier /usr/share/postgresql/16/tsearch_data/custom_french.stop
-- Contenu : un mot par ligne
-- Exemple :
-- le
-- la
-- les
-- mon_mot_specifique
-- acronyme_frequent

-- 2. Cr√©er un dictionnaire avec ces stop words
CREATE TEXT SEARCH DICTIONARY french_custom_stop (
    TEMPLATE = snowball,
    Language = french,
    StopWords = custom_french  -- Sans l'extension .stop
);

-- 3. L'utiliser dans une configuration
```

---

## 6. Cr√©er une Configuration Personnalis√©e

### Pourquoi Cr√©er une Configuration ?

- Combiner plusieurs dictionnaires
- Personnaliser le traitement pour votre domaine
- G√©rer des cas sp√©cifiques (termes techniques, acronymes)
- Optimiser pour votre application

### √âtapes de Cr√©ation

#### 1. Cr√©er les Dictionnaires N√©cessaires

```sql
-- Dictionnaire de synonymes techniques
CREATE TEXT SEARCH DICTIONARY tech_synonyms (
    TEMPLATE = synonym,
    SYNONYMS = tech_synonyms  -- Fichier tech_synonyms.syn
);

-- Dictionnaire de stemming fran√ßais
-- (d√©j√† existant : french_stem)

-- Dictionnaire simple pour les codes/acronymes
CREATE TEXT SEARCH DICTIONARY simple_dict (
    TEMPLATE = pg_catalog.simple
);
```

#### 2. Cr√©er la Configuration

```sql
-- Cr√©er une nouvelle configuration bas√©e sur french
CREATE TEXT SEARCH CONFIGURATION french_tech (
    COPY = french  -- Copie la configuration fran√ßaise
);

-- Ou cr√©er une configuration from scratch
CREATE TEXT SEARCH CONFIGURATION custom_config (
    PARSER = default
);
```

#### 3. Modifier les Mappings

```sql
-- Ajouter le dictionnaire de synonymes AVANT le stemmer
ALTER TEXT SEARCH CONFIGURATION french_tech
    ALTER MAPPING FOR asciiword, word
    WITH tech_synonyms, french_stem;

-- Les tokens "asciiword" et "word" passeront par:
-- 1. tech_synonyms (remplace par synonyme si trouv√©)
-- 2. french_stem (stemming si pas de synonyme)
```

#### 4. Utiliser la Configuration

```sql
-- Test
SELECT to_tsvector('french_tech', 'Le postgresql et le pgsql');
-- Si tech_synonyms.syn contient : pgsql postgresql
-- R√©sultat : 'postgresql':2,5 (pgsql remplac√© par postgresql)

-- Utiliser dans une table
ALTER TABLE articles
ADD COLUMN search_vector tsvector;

UPDATE articles
SET search_vector = to_tsvector('french_tech', titre || ' ' || contenu);
```

### Exemple Complet : Configuration E-commerce

```sql
-- 1. Dictionnaire de synonymes produits
-- Fichier : /tsearch_data/ecommerce_synonyms.syn
-- Contenu :
-- smartphone    telephone
-- portable      telephone
-- tel           telephone
-- ordi          ordinateur
-- pc            ordinateur

CREATE TEXT SEARCH DICTIONARY ecommerce_synonyms (
    TEMPLATE = synonym,
    SYNONYMS = ecommerce_synonyms
);

-- 2. Stop words personnalis√©s (ignorer marques communes)
-- Fichier : /tsearch_data/ecommerce.stop
-- Contenu : article, produit, neuf, occasion, promo

CREATE TEXT SEARCH DICTIONARY ecommerce_stop (
    TEMPLATE = snowball,
    Language = french,
    StopWords = ecommerce
);

-- 3. Cr√©er la configuration
CREATE TEXT SEARCH CONFIGURATION french_ecommerce (COPY = french);

-- 4. Configurer les mappings
ALTER TEXT SEARCH CONFIGURATION french_ecommerce
    ALTER MAPPING FOR asciiword, word
    WITH ecommerce_synonyms, ecommerce_stop;

-- 5. Test
SELECT to_tsvector('french_ecommerce', 'smartphone portable Apple neuf');
-- R√©sultat : 'appl':3 'telephon':1,2
-- "smartphone" et "portable" ‚Üí "telephon"
-- "neuf" ‚Üí ignor√© (stop word)
-- "Apple" ‚Üí "appl" (stemming)
```

---

## 7. Multilinguisme : G√©rer Plusieurs Langues

### Approche 1 : Colonne de Langue + Indexation Conditionnelle

```sql
-- Table multilingue
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(200),
    contenu TEXT,
    langue VARCHAR(10),  -- 'fr', 'en', 'es', etc.
    search_vector tsvector
);

-- Trigger intelligent qui choisit la configuration selon la langue
CREATE OR REPLACE FUNCTION articles_multilingual_trigger()
RETURNS trigger AS $$
DECLARE
    config regconfig;
BEGIN
    -- D√©terminer la configuration selon la langue
    config := CASE NEW.langue
        WHEN 'fr' THEN 'french'::regconfig
        WHEN 'en' THEN 'english'::regconfig
        WHEN 'es' THEN 'spanish'::regconfig
        WHEN 'de' THEN 'german'::regconfig
        WHEN 'it' THEN 'italian'::regconfig
        ELSE 'simple'::regconfig  -- Fallback
    END;

    -- Cr√©er le tsvector avec la bonne configuration
    NEW.search_vector := to_tsvector(config, COALESCE(NEW.titre, '') || ' ' || COALESCE(NEW.contenu, ''));

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tsvector_update
BEFORE INSERT OR UPDATE ON articles
FOR EACH ROW EXECUTE FUNCTION articles_multilingual_trigger();

-- Index
CREATE INDEX idx_articles_search ON articles USING GIN(search_vector);

-- Insertion
INSERT INTO articles (titre, contenu, langue) VALUES
    ('Guide PostgreSQL', 'PostgreSQL est puissant', 'fr'),
    ('PostgreSQL Guide', 'PostgreSQL is powerful', 'en'),
    ('Gu√≠a PostgreSQL', 'PostgreSQL es potente', 'es');

-- Recherche multilingue
SELECT titre, langue
FROM articles
WHERE search_vector @@ to_tsquery('french', 'puissant')
   OR search_vector @@ to_tsquery('english', 'powerful')
   OR search_vector @@ to_tsquery('spanish', 'potente');
```

### Approche 2 : Colonnes S√©par√©es par Langue

```sql
-- Table avec colonnes par langue
CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    nom_fr VARCHAR(200),
    description_fr TEXT,
    nom_en VARCHAR(200),
    description_en TEXT,
    nom_es VARCHAR(200),
    description_es TEXT,
    search_vector_fr tsvector,
    search_vector_en tsvector,
    search_vector_es tsvector
);

-- Triggers s√©par√©s pour chaque langue
CREATE OR REPLACE FUNCTION produits_fr_trigger() RETURNS trigger AS $$
BEGIN
    NEW.search_vector_fr := to_tsvector('french',
        COALESCE(NEW.nom_fr, '') || ' ' || COALESCE(NEW.description_fr, '')
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tsvector_fr_update
BEFORE INSERT OR UPDATE ON produits
FOR EACH ROW EXECUTE FUNCTION produits_fr_trigger();

-- R√©p√©ter pour EN et ES...

-- Index s√©par√©s
CREATE INDEX idx_produits_search_fr ON produits USING GIN(search_vector_fr);
CREATE INDEX idx_produits_search_en ON produits USING GIN(search_vector_en);
CREATE INDEX idx_produits_search_es ON produits USING GIN(search_vector_es);

-- Recherche par langue
SELECT nom_fr, description_fr
FROM produits
WHERE search_vector_fr @@ plainto_tsquery('french', 'chaussure rouge');
```

### Approche 3 : Configuration Multilingue Unifi√©e

Pour des cas simples o√π on veut indexer dans plusieurs langues simultan√©ment :

```sql
-- Cr√©er une configuration qui combine plusieurs langues
CREATE TEXT SEARCH CONFIGURATION multilang (PARSER = default);

-- Mapper les tokens vers plusieurs stemmers
ALTER TEXT SEARCH CONFIGURATION multilang
    ADD MAPPING FOR asciiword, word
    WITH french_stem, english_stem, spanish_stem;

-- Utilisation
SELECT to_tsvector('multilang', 'running courir corriendo');
-- R√©sultat : 'cour':2 'corr':3 'run':1
-- (chaque mot est stemmed par son stemmer appropri√©)
```

**‚ö†Ô∏è Attention** : Cette approche est moins pr√©cise car elle ne conna√Æt pas la langue de chaque mot.

### Approche 4 : D√©tection Automatique de Langue

```sql
-- Fonction de d√©tection basique (simplifi√©)
CREATE OR REPLACE FUNCTION detect_language(text TEXT)
RETURNS regconfig AS $$
DECLARE
    config regconfig;
BEGIN
    -- D√©tection basique par mots communs
    IF text ~* '\m(the|is|are|and)\M' THEN
        config := 'english';
    ELSIF text ~* '\m(le|la|les|est|sont|et)\M' THEN
        config := 'french';
    ELSIF text ~* '\m(el|la|los|las|es|son|y)\M' THEN
        config := 'spanish';
    ELSE
        config := 'simple';
    END IF;

    RETURN config;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Utilisation dans un trigger
CREATE OR REPLACE FUNCTION articles_auto_lang_trigger() RETURNS trigger AS $$
BEGIN
    NEW.search_vector := to_tsvector(
        detect_language(NEW.contenu),
        COALESCE(NEW.titre, '') || ' ' || COALESCE(NEW.contenu, '')
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

**‚ö†Ô∏è Note** : La d√©tection de langue est complexe. Pour des besoins s√©rieux, utilisez une biblioth√®que externe (langdetect, polyglot) ou une colonne de langue explicite.

---

## 8. Cas d'Usage Avanc√©s

### Cas 1 : Documentation Technique avec Acronymes

```sql
-- Dictionnaire de pr√©servation d'acronymes
-- Fichier : tech_preserve.syn
-- Contenu :
-- sql     SQL
-- html    HTML
-- css     CSS
-- api     API
-- json    JSON
-- xml     XML

CREATE TEXT SEARCH DICTIONARY tech_preserve (
    TEMPLATE = synonym,
    SYNONYMS = tech_preserve
);

-- Configuration technique
CREATE TEXT SEARCH CONFIGURATION tech_doc (COPY = english);

ALTER TEXT SEARCH CONFIGURATION tech_doc
    ALTER MAPPING FOR asciiword
    WITH tech_preserve, english_stem;

-- Test
SELECT to_tsvector('tech_doc', 'This API uses JSON and SQL');
-- R√©sultat : 'API':2 'JSON':4 'SQL':6 'use':3
-- Acronymes pr√©serv√©s en majuscules
```

### Cas 2 : Contenu M√©dical avec Termes Sp√©cialis√©s

```sql
-- Synonymes m√©dicaux
-- Fichier : medical_synonyms.syn
-- Contenu :
-- imc             indice_masse_corporelle
-- avc             accident_vasculaire_cerebral
-- ecg             electrocardiogramme
-- irm             imagerie_resonance_magnetique

CREATE TEXT SEARCH DICTIONARY medical_synonyms (
    TEMPLATE = synonym,
    SYNONYMS = medical_synonyms
);

-- Stop words m√©dicaux (mots trop fr√©quents)
-- Fichier : medical.stop
-- Contenu : patient, traitement, diagnostic, symptome

CREATE TEXT SEARCH DICTIONARY medical_stem (
    TEMPLATE = snowball,
    Language = french,
    StopWords = medical
);

-- Configuration m√©dicale
CREATE TEXT SEARCH CONFIGURATION french_medical (COPY = french);

ALTER TEXT SEARCH CONFIGURATION french_medical
    ALTER MAPPING FOR asciiword, word
    WITH medical_synonyms, medical_stem;

-- Test
SELECT to_tsvector('french_medical', 'Le patient a un IMC √©lev√© apr√®s AVC');
-- R√©sultat : 'accident_vasculaire_cerebral':7 'elev':5 'indice_masse_corporelle':4
```

### Cas 3 : Recherche Insensible aux Accents

Par d√©faut, PostgreSQL respecte les accents dans le Full-Text Search.

```sql
-- Test standard
SELECT to_tsvector('french', 'caf√©') @@ to_tsquery('french', 'cafe');
-- R√©sultat : false (caf√© ‚â† cafe)

-- Solution 1 : Extension unaccent
CREATE EXTENSION IF NOT EXISTS unaccent;

-- Cr√©er un dictionnaire qui enl√®ve les accents
CREATE TEXT SEARCH DICTIONARY french_unaccent (
    TEMPLATE = unaccent
);

-- Configuration sans accents
CREATE TEXT SEARCH CONFIGURATION french_no_accent (COPY = french);

ALTER TEXT SEARCH CONFIGURATION french_no_accent
    ALTER MAPPING FOR asciiword, word
    WITH french_unaccent, french_stem;

-- Test
SELECT to_tsvector('french_no_accent', 'caf√©') @@
       to_tsquery('french_no_accent', 'cafe');
-- R√©sultat : true (accent enlev√©)
```

---

## 9. Debugging et Analyse

### Voir Comment un Texte est Trait√©

```sql
-- Debug complet du traitement
SELECT * FROM ts_debug('french', 'Les bases de donn√©es PostgreSQL');
```

**R√©sultat** :
```
alias     | description       | token      | dictionaries  | dictionary   | lexemes
----------+------------------+------------+---------------+-------------+---------
asciiword | Word, all ASCII  | Les        | {french_stem} | french_stem | {}
blank     | Space symbols    |            | {}            |             |
asciiword | Word, all ASCII  | bases      | {french_stem} | french_stem | {base}
blank     | Space symbols    |            | {}            |             |
asciiword | Word, all ASCII  | de         | {french_stem} | french_stem | {}
blank     | Space symbols    |            | {}            |             |
asciiword | Word, all ASCII  | donn√©es    | {french_stem} | french_stem | {donn}
blank     | Space symbols    |            | {}            |             |
asciiword | Word, all ASCII  | PostgreSQL | {french_stem} | french_stem | {postgresql}
```

**Colonnes importantes** :
- `token` : Mot original
- `dictionaries` : Dictionnaires disponibles pour ce type
- `dictionary` : Dictionnaire utilis√©
- `lexemes` : R√©sultat (vide = stop word)

### Tester un Dictionnaire Sp√©cifique

```sql
-- Tester directement un dictionnaire
SELECT ts_lexize('french_stem', 'donn√©es');
-- R√©sultat : {donn}

SELECT ts_lexize('french_stem', 'le');
-- R√©sultat : NULL (stop word)

-- Tester plusieurs mots
SELECT word, ts_lexize('french_stem', word) AS lexemes
FROM unnest(ARRAY['courir', 'couraient', 'coureur', 'course']) AS word;
```

**R√©sultat** :
```
word       | lexemes
-----------+---------
courir     | {cour}
couraient  | {cour}
coureur    | {cour}
course     | {cours}
```

### Comparer Plusieurs Configurations

```sql
-- Voir les diff√©rences entre configurations
SELECT
    'simple' AS config,
    to_tsvector('simple', 'Les coureurs courent rapidement') AS result
UNION ALL
SELECT
    'french',
    to_tsvector('french', 'Les coureurs courent rapidement')
UNION ALL
SELECT
    'english',
    to_tsvector('english', 'Les coureurs courent rapidement');
```

---

## 10. Performance et Optimisation

### Impact des Dictionnaires sur la Performance

**Ordre de rapidit√©** (du plus rapide au plus lent) :

1. **Simple** : Aucun traitement (tr√®s rapide)
2. **Snowball** : Algorithme de stemming (rapide)
3. **Synonym** : Lookup dans un fichier (rapide pour petits fichiers)
4. **Ispell** : Analyse morphologique (lent)
5. **Thesaurus** : Phrases multi-mots (tr√®s lent)

```sql
-- Benchmark simplifi√©
EXPLAIN ANALYZE
SELECT COUNT(*) FROM articles
WHERE to_tsvector('simple', contenu) @@ to_tsquery('simple', 'postgresql');
-- Temps : ~50ms

EXPLAIN ANALYZE
SELECT COUNT(*) FROM articles
WHERE to_tsvector('french', contenu) @@ to_tsquery('french', 'postgresql');
-- Temps : ~65ms (15% plus lent √† cause du stemming)
```

### Optimisations

#### 1. Pr√©-calculer les tsvector (Colonne D√©di√©e)

```sql
-- ‚úÖ BON : Colonne pr√©calcul√©e
ALTER TABLE articles ADD COLUMN search_vector tsvector;
UPDATE articles SET search_vector = to_tsvector('french', contenu);
CREATE INDEX idx_search ON articles USING GIN(search_vector);

SELECT * FROM articles WHERE search_vector @@ query;
-- Tr√®s rapide : lecture d'index

-- ‚ùå LENT : Calcul √† chaque requ√™te
SELECT * FROM articles
WHERE to_tsvector('french', contenu) @@ query;
-- Lent : recalcul du tsvector √† chaque fois
```

#### 2. Choisir la Configuration Appropri√©e

```sql
-- Pour du contenu sans stemming n√©cessaire (codes, IDs)
to_tsvector('simple', code_produit)

-- Pour du texte en langue naturelle
to_tsvector('french', description)
```

#### 3. Limiter les Dictionnaires dans une Configuration

```sql
-- ‚ùå Trop de dictionnaires (lent)
ALTER TEXT SEARCH CONFIGURATION my_config
    ALTER MAPPING FOR asciiword
    WITH synonym1, synonym2, thesaurus1, ispell1, french_stem;
-- Chaque token passe par 5 dictionnaires !

-- ‚úÖ Uniquement les n√©cessaires
ALTER TEXT SEARCH CONFIGURATION my_config
    ALTER MAPPING FOR asciiword
    WITH synonym1, french_stem;
-- 2 dictionnaires suffisent g√©n√©ralement
```

---

## 11. Bonnes Pratiques

### ‚úÖ Choisir la Bonne Configuration pour Chaque Langue

```sql
-- ‚úÖ BON : Configuration appropri√©e
to_tsvector('french', texte_francais)
to_tsvector('english', english_text)

-- ‚ùå MAUVAIS : Mauvaise configuration
to_tsvector('english', texte_francais)  -- Stemming anglais sur fran√ßais !
```

### ‚úÖ Documenter les Configurations Personnalis√©es

```sql
-- Documenter avec des commentaires
COMMENT ON TEXT SEARCH CONFIGURATION french_tech IS
'Configuration fran√ßaise avec synonymes techniques pour le secteur IT';

COMMENT ON TEXT SEARCH DICTIONARY tech_synonyms IS
'Synonymes techniques : postgres‚Üípostgresql, pgsql‚Üípostgresql, etc.';
```

### ‚úÖ Tester les Configurations Avant D√©ploiement

```sql
-- Suite de tests
CREATE TABLE test_search_config (
    id SERIAL PRIMARY KEY,
    input TEXT,
    expected_lexemes TEXT[],
    config regconfig
);

-- Ins√©rer des cas de test
INSERT INTO test_search_config (input, expected_lexemes, config) VALUES
    ('postgresql', ARRAY['postgresql'], 'french'),
    ('bases de donn√©es', ARRAY['base', 'donn'], 'french'),
    ('couraient', ARRAY['cour'], 'french');

-- V√©rifier
SELECT
    input,
    expected_lexemes,
    to_tsvector(config, input) AS actual_tsvector,
    expected_lexemes = ARRAY(SELECT unnest(to_tsvector(config, input))) AS passed
FROM test_search_config;
```

### ‚úÖ G√©rer les Fichiers de Configuration Externes

```bash
# Structure recommand√©e
/usr/share/postgresql/16/tsearch_data/
‚îú‚îÄ‚îÄ french.stop            # Stop words fran√ßais standard
‚îú‚îÄ‚îÄ custom_french.stop     # Stop words personnalis√©s
‚îú‚îÄ‚îÄ tech_synonyms.syn      # Synonymes techniques
‚îú‚îÄ‚îÄ medical_synonyms.syn   # Synonymes m√©dicaux
‚îî‚îÄ‚îÄ ecommerce.syn          # Synonymes e-commerce

# Versionner ces fichiers
git add tsearch_data/
git commit -m "Add custom dictionaries"
```

### ‚úÖ Pr√©voir un Fallback pour Langues Non Support√©es

```sql
-- Trigger avec fallback
CREATE OR REPLACE FUNCTION safe_tsvector_trigger() RETURNS trigger AS $$
DECLARE
    config regconfig;
BEGIN
    BEGIN
        config := (NEW.langue || '_text_search')::regconfig;
    EXCEPTION WHEN OTHERS THEN
        config := 'simple'::regconfig;  -- Fallback sur 'simple'
    END;

    NEW.search_vector := to_tsvector(config, NEW.contenu);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

---

## 12. R√©sum√© et Aide-M√©moire

### Configurations Linguistiques

```sql
-- Voir toutes les configurations disponibles
SELECT cfgname FROM pg_ts_config;

-- Utiliser une configuration
to_tsvector('french', texte)
to_tsquery('french', 'recherche')

-- Configuration par d√©faut
SHOW default_text_search_config;
SET default_text_search_config = 'french';
```

### Types de Dictionnaires

| Type | Description | Exemple |
|------|-------------|---------|
| `simple` | Pas de transformation | Codes, IDs |
| `snowball` | Stemming algorithmique | Texte g√©n√©ral |
| `ispell` | Morphologie (dictionnaires) | Haute pr√©cision |
| `synonym` | Remplacement 1:1 | Synonymes simples |
| `thesaurus` | Phrases multi-mots | Expressions |
| `unaccent` | Suppression accents | Insensible accents |

### Cr√©er une Configuration Personnalis√©e

```sql
-- 1. Cr√©er dictionnaires
CREATE TEXT SEARCH DICTIONARY mon_dict (
    TEMPLATE = snowball,
    Language = french,
    StopWords = custom
);

-- 2. Cr√©er configuration
CREATE TEXT SEARCH CONFIGURATION ma_config (COPY = french);

-- 3. Modifier mappings
ALTER TEXT SEARCH CONFIGURATION ma_config
    ALTER MAPPING FOR asciiword, word
    WITH mon_dict, french_stem;

-- 4. Utiliser
to_tsvector('ma_config', texte)
```

### Multilinguisme

```sql
-- Approche 1 : Colonne de langue
CREATE TABLE articles (
    langue VARCHAR(10),
    search_vector tsvector
);

-- Trigger qui choisit la config selon langue
-- (voir section 7 pour code complet)

-- Approche 2 : Colonnes s√©par√©es
CREATE TABLE produits (
    search_vector_fr tsvector,
    search_vector_en tsvector,
    search_vector_es tsvector
);
```

### Debug

```sql
-- Analyse compl√®te
SELECT * FROM ts_debug('french', texte);

-- Test d'un dictionnaire
SELECT ts_lexize('french_stem', 'mot');

-- Test d'une configuration
SELECT to_tsvector('french', texte);
```

---

## Conclusion

Les **dictionnaires** et les **configurations linguistiques** sont les fondations du Full-Text Search multilingue et personnalisable dans PostgreSQL.

**Points cl√©s √† retenir** :

1. **Configurations pr√©-d√©finies** : 20+ langues support√©es (french, english, spanish, etc.)
   - Stemming automatique
   - Stop words int√©gr√©s
   - Pr√™tes √† l'emploi

2. **Types de dictionnaires** :
   - **Simple** : Pas de transformation
   - **Snowball** : Stemming algorithmique (rapide)
   - **Ispell** : Morphologie (pr√©cis mais lent)
   - **Synonym** : Remplacements simples
   - **Thesaurus** : Phrases complexes

3. **Personnalisation** :
   - Cr√©er des dictionnaires sp√©cifiques √† votre domaine
   - Combiner plusieurs dictionnaires
   - Adapter les stop words

4. **Multilinguisme** :
   - Colonne de langue + trigger dynamique
   - Colonnes s√©par√©es par langue
   - Configuration unifi√©e (cas simples)

5. **Performance** :
   - Pr√©-calculer les tsvector (colonne d√©di√©e)
   - Limiter le nombre de dictionnaires
   - Choisir le bon type selon les besoins

Les dictionnaires permettent d'adapter PostgreSQL Full-Text Search √† n'importe quel contexte linguistique ou m√©tier, tout en conservant d'excellentes performances. C'est ce qui en fait une solution v√©ritablement professionnelle et polyvalente.

**Prochaine √©tape** : Explorez les index GIN avanc√©s et les optimisations de performance pour des syst√®mes de recherche √† grande √©chelle !

---

**Ressources compl√©mentaires** :
- Documentation dictionnaires : https://www.postgresql.org/docs/current/textsearch-dictionaries.html
- Configurations : https://www.postgresql.org/docs/current/textsearch-configuration.html
- Snowball stemmers : https://snowballstem.org/
- Ispell dictionaries : https://www.postgresql.org/docs/current/textsearch-ispell.html

‚è≠Ô∏è [Index GIN pour la performance](/18-extensions-et-integrations/03.4-index-gin-performance.md)
