üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.4.2. file_fdw, oracle_fdw, mysql_fdw

## Introduction

Dans le chapitre pr√©c√©dent, nous avons d√©couvert **postgres_fdw** qui permet de connecter PostgreSQL √† d'autres bases PostgreSQL. Mais PostgreSQL peut aussi se connecter √† d'autres types de sources de donn√©es gr√¢ce aux **Foreign Data Wrappers (FDW)** sp√©cialis√©s.

Ce chapitre couvre trois FDW importants :
- **file_fdw** : Lire des fichiers CSV, texte ou autres formats de fichiers
- **oracle_fdw** : Connecter PostgreSQL √† des bases de donn√©es Oracle
- **mysql_fdw** : Connecter PostgreSQL √† des bases de donn√©es MySQL/MariaDB

### Pourquoi ces FDW sont-ils utiles ?

Imaginez ces sc√©narios :

üìÅ **file_fdw** : Vous recevez quotidiennement des fichiers CSV de vos partenaires et vous voulez les interroger directement avec SQL sans les importer.

üî∂ **oracle_fdw** : Votre entreprise migre d'Oracle vers PostgreSQL, mais certaines applications utilisent encore Oracle. Vous voulez acc√©der aux donn√©es Oracle depuis PostgreSQL.

üê¨ **mysql_fdw** : Vous consolidez des donn√©es depuis plusieurs syst√®mes MySQL vers un data warehouse PostgreSQL.

---

## Partie 1 : file_fdw - Interroger des Fichiers

### Qu'est-ce que file_fdw ?

**file_fdw** est un FDW fourni nativement avec PostgreSQL qui permet de lire des fichiers comme s'ils √©taient des tables PostgreSQL. C'est particuli√®rement utile pour :
- Fichiers CSV
- Fichiers texte d√©limit√©s (TSV, pipes, etc.)
- Logs structur√©s
- Exports de donn√©es

### Sch√©ma conceptuel

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    PostgreSQL Server               ‚îÇ
‚îÇ                                    ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  SELECT * FROM               ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  fichier_ventes;             ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ             ‚îÇ                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  Foreign Table               ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  (d√©finition de structure)   ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ             ‚îÇ                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  file_fdw                    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ Lecture syst√®me de fichiers
              ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  /data/ventes.csv                   ‚îÇ
‚îÇ  id,produit,quantite,prix           ‚îÇ
‚îÇ  1,Laptop,2,1200.00                 ‚îÇ
‚îÇ  2,Souris,10,25.00                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Installation et Configuration

#### √âtape 1 : Activer l'extension

```sql
CREATE EXTENSION file_fdw;
```

#### √âtape 2 : Cr√©er un Foreign Server

M√™me pour les fichiers locaux, il faut d√©clarer un "serveur" :

```sql
CREATE SERVER serveur_fichiers
    FOREIGN DATA WRAPPER file_fdw;
```

**Note** : Contrairement √† postgres_fdw, il n'y a pas d'options de connexion car les fichiers sont locaux.

#### √âtape 3 : Cr√©er une Foreign Table pointant vers un fichier

**Exemple : Fichier CSV simple**

Supposons que vous avez un fichier `/data/ventes.csv` :
```csv
id,produit,quantite,prix
1,Laptop,2,1200.00
2,Souris,10,25.00
3,Clavier,5,75.00
```

Cr√©ez la foreign table :

```sql
CREATE FOREIGN TABLE ventes_csv (
    id INTEGER,
    produit TEXT,
    quantite INTEGER,
    prix NUMERIC(10, 2)
)
SERVER serveur_fichiers
OPTIONS (
    filename '/data/ventes.csv',
    format 'csv',
    header 'true',           -- Le fichier a une ligne d'en-t√™te
    delimiter ',',           -- S√©parateur (virgule)
    null ''                  -- Repr√©sentation des NULL (cha√Æne vide)
);
```

#### √âtape 4 : Interroger le fichier

```sql
-- Lire toutes les donn√©es
SELECT * FROM ventes_csv;

-- Filtrer
SELECT produit, prix
FROM ventes_csv
WHERE quantite > 5;

-- Agr√©ger
SELECT SUM(quantite * prix) AS chiffre_affaires
FROM ventes_csv;
```

### Options de Configuration

#### Options principales de file_fdw

| Option | Description | Exemple |
|--------|-------------|---------|
| `filename` | Chemin absolu du fichier | `/data/ventes.csv` |
| `format` | Format du fichier | `csv`, `text` |
| `header` | Le fichier a une ligne d'en-t√™te | `true`, `false` |
| `delimiter` | Caract√®re s√©parateur | `,` (CSV), `\t` (TSV), `|` (pipe) |
| `quote` | Caract√®re d'√©chappement des cha√Ænes | `"` (guillemet double) |
| `escape` | Caract√®re d'√©chappement | `\` (backslash) |
| `null` | Repr√©sentation des valeurs NULL | `''` (vide), `NULL`, `\N` |
| `encoding` | Encodage du fichier | `UTF8`, `LATIN1`, `WIN1252` |

#### Exemples de configurations

**Fichier TSV (Tab-Separated Values)** :

```sql
CREATE FOREIGN TABLE logs_tsv (
    timestamp TIMESTAMP,
    niveau TEXT,
    message TEXT
)
SERVER serveur_fichiers
OPTIONS (
    filename '/var/log/application.tsv',
    format 'text',
    delimiter E'\t',    -- Tabulation (\t avec E pour escape)
    null 'NULL'
);
```

**Fichier avec s√©parateur pipe** :

```sql
CREATE FOREIGN TABLE donnees_pipe (
    id INTEGER,
    nom TEXT,
    valeur NUMERIC
)
SERVER serveur_fichiers
OPTIONS (
    filename '/data/export.txt',
    format 'text',
    delimiter '|',
    header 'false'
);
```

**Fichier avec encodage sp√©cifique** :

```sql
CREATE FOREIGN TABLE donnees_latines (
    id INTEGER,
    nom TEXT
)
SERVER serveur_fichiers
OPTIONS (
    filename '/data/legacy.csv',
    format 'csv',
    encoding 'LATIN1'    -- Pour les anciens syst√®mes
);
```

### Cas d'usage r√©els

#### 1. Int√©gration de fichiers externes

**Contexte** : Vos partenaires vous envoient quotidiennement des fichiers CSV de commandes.

**Solution** :

```sql
-- Cr√©er la foreign table
CREATE FOREIGN TABLE commandes_partenaire (
    commande_id TEXT,
    date_commande DATE,
    montant NUMERIC
)
SERVER serveur_fichiers
OPTIONS (
    filename '/imports/commandes_2025-11-23.csv',
    format 'csv',
    header 'true'
);

-- Importer dans la base locale
INSERT INTO commandes_locales (commande_id, date_commande, montant)
SELECT * FROM commandes_partenaire
WHERE date_commande >= CURRENT_DATE - INTERVAL '7 days';
```

**Script automatis√©** : Vous pourriez cr√©er une fonction PL/pgSQL qui :
1. D√©tecte les nouveaux fichiers
2. Cr√©e dynamiquement la foreign table
3. Importe les donn√©es
4. Archive le fichier

#### 2. Analyse de logs

**Contexte** : Analyser des logs d'application directement avec SQL.

**Fichier de log** (`/var/log/app.log`) :
```
2025-11-23 10:15:32|INFO|Utilisateur connect√©: user123
2025-11-23 10:16:45|ERROR|√âchec connexion base de donn√©es
2025-11-23 10:17:01|INFO|Transaction valid√©e: 89234
```

```sql
CREATE FOREIGN TABLE logs_app (
    timestamp TIMESTAMP,
    niveau TEXT,
    message TEXT
)
SERVER serveur_fichiers
OPTIONS (
    filename '/var/log/app.log',
    format 'text',
    delimiter '|'
);

-- Compter les erreurs par heure
SELECT
    DATE_TRUNC('hour', timestamp) AS heure,
    COUNT(*) AS nb_erreurs
FROM logs_app
WHERE niveau = 'ERROR'
GROUP BY heure
ORDER BY heure DESC;
```

#### 3. Validation de donn√©es avant import

```sql
-- V√©rifier la qualit√© des donn√©es
SELECT
    COUNT(*) AS total_lignes,
    COUNT(DISTINCT commande_id) AS commandes_uniques,
    COUNT(*) FILTER (WHERE montant IS NULL) AS montants_null,
    MIN(montant) AS montant_min,
    MAX(montant) AS montant_max
FROM commandes_partenaire;

-- D√©tecter les anomalies
SELECT *
FROM commandes_partenaire
WHERE montant < 0 OR montant > 100000;
```

### Limitations de file_fdw

‚ùå **Lecture seule** : file_fdw est en **lecture seule**. Vous ne pouvez pas faire de `INSERT`, `UPDATE` ou `DELETE`.

```sql
-- ‚ùå Erreur
INSERT INTO ventes_csv VALUES (4, '√âcran', 3, 450.00);
-- ERROR: cannot insert into foreign table "ventes_csv"
```

‚ùå **Fichiers locaux uniquement** : Les fichiers doivent √™tre accessibles sur le serveur PostgreSQL (pas sur la machine cliente).

‚ùå **Permissions** : L'utilisateur PostgreSQL (souvent `postgres`) doit avoir les droits de lecture sur le fichier.

```bash
# Donner les permissions de lecture
chmod 644 /data/ventes.csv
chown postgres:postgres /data/ventes.csv
```

‚ùå **Pas d'index** : Les requ√™tes sur foreign tables file_fdw font toujours un scan s√©quentiel (pas d'optimisation par index).

‚ùå **Performance** : Pour de gros fichiers (>100 Mo), les performances peuvent √™tre m√©diocres. Privil√©giez `COPY` pour l'import.

### Comparaison : file_fdw vs COPY

| Crit√®re | file_fdw | COPY |
|---------|----------|------|
| Vitesse | ‚ö†Ô∏è Moyen | ‚úÖ Tr√®s rapide |
| Persistance | ‚ùå Donn√©es non stock√©es | ‚úÖ Donn√©es import√©es dans PostgreSQL |
| Filtrage SQL avant import | ‚úÖ Oui | ‚ùå Non (import tout) |
| Transformations | ‚úÖ Avec SELECT | ‚ö†Ô∏è N√©cessite post-traitement |
| Cas d'usage | Analyse ponctuelle, validation | Import massif de donn√©es |

**Recommandation** :
- Utilisez **file_fdw** pour analyser ou valider avant import
- Utilisez **COPY** pour des imports volumineux en production

---

## Partie 2 : oracle_fdw - Connexion √† Oracle

### Qu'est-ce que oracle_fdw ?

**oracle_fdw** est un FDW tiers qui permet √† PostgreSQL de se connecter √† des bases de donn√©es Oracle et d'interroger leurs tables comme si elles √©taient locales.

### Pourquoi utiliser oracle_fdw ?

üîÑ **Migration progressive** : Migrer d'Oracle vers PostgreSQL sans interruption de service

üìä **Reporting consolid√©** : Agr√©ger des donn√©es depuis Oracle et PostgreSQL dans un seul rapport

üîó **Int√©gration hybride** : Applications utilisant PostgreSQL qui doivent acc√©der √† des donn√©es Oracle legacy

### Pr√©requis

Avant d'utiliser oracle_fdw, vous devez installer :

1. **Oracle Instant Client** : Biblioth√®ques Oracle pour se connecter √† Oracle
2. **oracle_fdw** : L'extension PostgreSQL (non fournie par d√©faut)

**Installation sur Linux (exemple Ubuntu)** :

```bash
# 1. T√©l√©charger Oracle Instant Client depuis le site Oracle
# (n√©cessite un compte Oracle gratuit)

# 2. Installer les packages
sudo apt-get install libaio1
sudo dpkg -i oracle-instantclient-basic_*.deb
sudo dpkg -i oracle-instantclient-sqlplus_*.deb
sudo dpkg -i oracle-instantclient-devel_*.deb

# 3. Configurer les variables d'environnement
export ORACLE_HOME=/usr/lib/oracle/21/client64
export LD_LIBRARY_PATH=$ORACLE_HOME/lib

# 4. Installer oracle_fdw (depuis les sources ou package)
sudo apt-get install postgresql-16-oracle-fdw
```

### Configuration

#### √âtape 1 : Cr√©er l'extension

```sql
CREATE EXTENSION oracle_fdw;
```

#### √âtape 2 : Cr√©er le Foreign Server

```sql
CREATE SERVER serveur_oracle
    FOREIGN DATA WRAPPER oracle_fdw
    OPTIONS (
        dbserver '//oracle-prod.entreprise.com:1521/ORCL'  -- Connexion Oracle (TNS ou Easy Connect)
    );
```

**Format de dbserver** :
- **Easy Connect** : `//host:port/service_name`
- **TNS** : `tns_alias` (d√©fini dans tnsnames.ora)

Exemple avec TNS :
```sql
OPTIONS (dbserver 'PROD_DB')  -- R√©f√©rence √† l'alias dans tnsnames.ora
```

#### √âtape 3 : Cr√©er le User Mapping

```sql
CREATE USER MAPPING FOR utilisateur_postgresql
    SERVER serveur_oracle
    OPTIONS (
        user 'admin_oracle',        -- Utilisateur Oracle
        password 'mot_de_passe'     -- Mot de passe Oracle
    );
```

#### √âtape 4 : Cr√©er les Foreign Tables

**M√©thode manuelle** :

```sql
CREATE FOREIGN TABLE clients_oracle (
    client_id NUMBER,
    nom VARCHAR2(100),
    email VARCHAR2(100),
    date_creation DATE
)
SERVER serveur_oracle
OPTIONS (
    schema 'SALES',         -- Sch√©ma Oracle
    table 'CUSTOMERS'       -- Table Oracle
);
```

**M√©thode automatique (IMPORT)** :

```sql
-- Importer toutes les tables d'un sch√©ma Oracle
IMPORT FOREIGN SCHEMA "SALES"
    FROM SERVER serveur_oracle
    INTO public;

-- Importer uniquement certaines tables
IMPORT FOREIGN SCHEMA "SALES"
    LIMIT TO (CUSTOMERS, ORDERS)
    FROM SERVER serveur_oracle
    INTO public;
```

**‚ö†Ô∏è Note** : Les noms de sch√©ma Oracle doivent √™tre en **MAJUSCULES** et entre guillemets doubles.

### Utilisation

#### Requ√™tes de lecture

```sql
-- S√©lection simple
SELECT * FROM clients_oracle;

-- Jointure avec table PostgreSQL locale
SELECT
    c.nom,
    p.montant
FROM clients_oracle c
INNER JOIN paiements_postgresql p ON c.client_id = p.client_id;

-- Agr√©gation
SELECT
    COUNT(*) AS nb_clients,
    AVG(montant_total) AS moyenne
FROM clients_oracle
WHERE date_creation >= DATE '2024-01-01';
```

#### Requ√™tes d'√©criture

oracle_fdw supporte les √©critures :

```sql
-- Insertion
INSERT INTO clients_oracle (client_id, nom, email, date_creation)
VALUES (1001, 'Nouveau Client', 'client@exemple.com', SYSDATE);

-- Mise √† jour
UPDATE clients_oracle
SET email = 'nouveau@exemple.com'
WHERE client_id = 1001;

-- Suppression
DELETE FROM clients_oracle WHERE client_id = 1001;
```

### Mapping des Types de Donn√©es

PostgreSQL et Oracle ont des types de donn√©es diff√©rents. oracle_fdw fait la conversion automatiquement :

| Type Oracle | Type PostgreSQL | Notes |
|-------------|-----------------|-------|
| `NUMBER` | `NUMERIC` | Conversion exacte |
| `NUMBER(10)` | `INTEGER` ou `BIGINT` | Selon la pr√©cision |
| `VARCHAR2(n)` | `VARCHAR(n)` | Taille pr√©serv√©e |
| `CHAR(n)` | `CHAR(n)` | Taille fixe |
| `DATE` | `TIMESTAMP` | Oracle DATE inclut l'heure |
| `TIMESTAMP` | `TIMESTAMP` | Conversion directe |
| `CLOB` | `TEXT` | Texte long |
| `BLOB` | `BYTEA` | Donn√©es binaires |
| `RAW` | `BYTEA` | Binaire de taille limit√©e |

### Options de Performance

```sql
-- Options au niveau du serveur
ALTER SERVER serveur_oracle OPTIONS (
    ADD nls_lang 'AMERICAN_AMERICA.UTF8',  -- Encodage Oracle
    ADD prefetch '200'                      -- Nombre de lignes √† pr√©charger
);

-- Options au niveau de la foreign table
ALTER FOREIGN TABLE clients_oracle OPTIONS (
    ADD prefetch '500',                     -- Surcharge pour cette table
    ADD readonly 'true'                     -- Lecture seule (plus rapide)
);
```

### Cas d'usage : Migration d'Oracle vers PostgreSQL

**Sc√©nario** : Migration progressive d'une application Oracle vers PostgreSQL.

**Phase 1 : Pr√©paration**
```sql
-- Dans PostgreSQL, importer la structure Oracle
IMPORT FOREIGN SCHEMA "APP_PROD"
    FROM SERVER serveur_oracle
    INTO oracle_legacy;
```

**Phase 2 : Tests de compatibilit√©**
```sql
-- Tester les requ√™tes applicatives
SELECT client_id, nom
FROM oracle_legacy.customers
WHERE status = 'ACTIVE';

-- Comparer les performances
EXPLAIN ANALYZE SELECT * FROM oracle_legacy.orders WHERE order_date > SYSDATE - 30;
```

**Phase 3 : Migration progressive table par table**
```sql
-- Migrer une table
CREATE TABLE customers_pg (LIKE oracle_legacy.customers INCLUDING ALL);

-- Copier les donn√©es
INSERT INTO customers_pg
SELECT * FROM oracle_legacy.customers;

-- V√©rifier la coh√©rence
SELECT
    (SELECT COUNT(*) FROM oracle_legacy.customers) AS oracle_count,
    (SELECT COUNT(*) FROM customers_pg) AS pg_count;
```

**Phase 4 : Basculement**
- Rediriger l'application vers les tables PostgreSQL natives
- Garder oracle_fdw en lecture seule pour consultation historique

### Limitations et Consid√©rations

#### Limitations de oracle_fdw

‚ùå **Pas de support pour tous les types Oracle** :
- Types objets (OBJECT)
- Collections (VARRAY, nested tables)
- Types XML complexes
- Spatial (SDO_GEOMETRY) n√©cessite des conversions

‚ùå **Diff√©rences SQL** :
```sql
-- Oracle
SELECT SYSDATE FROM DUAL;

-- PostgreSQL (via oracle_fdw, fonctionne mais...)
SELECT CURRENT_DATE FROM dual;  -- 'dual' doit √™tre mapp√©
```

‚ùå **Fonctions Oracle propri√©taires** : Les fonctions Oracle (comme `NVL`, `DECODE`) ne sont pas directement utilisables dans PostgreSQL. Utilisez les √©quivalents :

| Oracle | PostgreSQL √âquivalent |
|--------|----------------------|
| `NVL(col, 'N/A')` | `COALESCE(col, 'N/A')` |
| `DECODE(col, 1, 'Un', 2, 'Deux')` | `CASE WHEN col = 1 THEN 'Un' WHEN col = 2 THEN 'Deux' END` |
| `SYSDATE` | `CURRENT_TIMESTAMP` |
| `ROWNUM` | `ROW_NUMBER()` |

#### Performance

‚ö†Ô∏è **Latence r√©seau** : Chaque requ√™te traverse le r√©seau vers Oracle. Pour des volumes importants, pr√©f√©rez :
- La r√©plication (Oracle GoldenGate vers PostgreSQL)
- Des imports batch r√©guliers

‚ö†Ô∏è **Pushdown limit√©** : oracle_fdw pousse certaines op√©rations vers Oracle, mais moins efficacement que postgres_fdw :
- `WHERE` : ‚úÖ Pouss√©
- `ORDER BY` : ‚úÖ Pouss√©
- `LIMIT` : ‚úÖ Pouss√©
- `JOIN` entre foreign tables Oracle : ‚úÖ Pouss√©
- `JOIN` entre Oracle et PostgreSQL : ‚ùå Rapatri√©

### S√©curit√©

```sql
-- Cr√©er un utilisateur Oracle d√©di√© en lecture seule
-- (c√¥t√© Oracle)
CREATE USER fdw_readonly IDENTIFIED BY "mot_de_passe_fort";
GRANT CONNECT TO fdw_readonly;
GRANT SELECT ON schema.table TO fdw_readonly;

-- Utiliser SSL/TLS (si Oracle est configur√© pour)
CREATE SERVER serveur_oracle
    FOREIGN DATA WRAPPER oracle_fdw
    OPTIONS (
        dbserver '//oracle-prod:1521/ORCL',
        nls_lang 'AMERICAN_AMERICA.UTF8'
    );
```

---

## Partie 3 : mysql_fdw - Connexion √† MySQL/MariaDB

### Qu'est-ce que mysql_fdw ?

**mysql_fdw** est un FDW tiers qui permet √† PostgreSQL de se connecter √† des bases MySQL ou MariaDB.

### Pourquoi utiliser mysql_fdw ?

üîó **Int√©gration multi-SGBD** : Votre entreprise utilise MySQL pour certaines applications et PostgreSQL pour d'autres

üìä **Data Warehouse** : Consolider des donn√©es depuis plusieurs sources MySQL vers PostgreSQL

üîÑ **Migration** : Migrer progressivement de MySQL vers PostgreSQL

### Pr√©requis

**Installation sur Linux (exemple Ubuntu)** :

```bash
# 1. Installer les biblioth√®ques MySQL client
sudo apt-get install libmysqlclient-dev

# 2. Installer mysql_fdw
sudo apt-get install postgresql-16-mysql-fdw

# Ou compiler depuis les sources
git clone https://github.com/EnterpriseDB/mysql_fdw.git
cd mysql_fdw
make USE_PGXS=1
sudo make USE_PGXS=1 install
```

### Configuration

#### √âtape 1 : Cr√©er l'extension

```sql
CREATE EXTENSION mysql_fdw;
```

#### √âtape 2 : Cr√©er le Foreign Server

```sql
CREATE SERVER serveur_mysql
    FOREIGN DATA WRAPPER mysql_fdw
    OPTIONS (
        host 'mysql-prod.entreprise.com',   -- Serveur MySQL
        port '3306'                          -- Port MySQL (3306 par d√©faut)
    );
```

#### √âtape 3 : Cr√©er le User Mapping

```sql
CREATE USER MAPPING FOR utilisateur_postgresql
    SERVER serveur_mysql
    OPTIONS (
        username 'admin_mysql',   -- Utilisateur MySQL
        password 'mot_de_passe'   -- Mot de passe MySQL
    );
```

#### √âtape 4 : Cr√©er les Foreign Tables

**M√©thode manuelle** :

```sql
CREATE FOREIGN TABLE produits_mysql (
    produit_id INT,
    nom VARCHAR(100),
    prix DECIMAL(10, 2),
    stock INT
)
SERVER serveur_mysql
OPTIONS (
    dbname 'boutique',      -- Nom de la base MySQL
    table_name 'products'   -- Nom de la table MySQL
);
```

**M√©thode automatique (IMPORT)** :

```sql
-- Importer toutes les tables d'une base MySQL
IMPORT FOREIGN SCHEMA 'boutique'
    FROM SERVER serveur_mysql
    INTO public;

-- Limiter √† certaines tables
IMPORT FOREIGN SCHEMA 'boutique'
    LIMIT TO (products, categories)
    FROM SERVER serveur_mysql
    INTO public;
```

### Utilisation

#### Requ√™tes de lecture

```sql
-- S√©lection
SELECT * FROM produits_mysql;

-- Jointure avec PostgreSQL
SELECT
    p.nom AS produit,
    c.quantite
FROM produits_mysql p
INNER JOIN commandes_postgresql c ON p.produit_id = c.produit_id;

-- Agr√©gation
SELECT
    COUNT(*) AS nb_produits,
    SUM(stock) AS stock_total
FROM produits_mysql
WHERE prix > 100;
```

#### Requ√™tes d'√©criture

mysql_fdw supporte les √©critures :

```sql
-- Insertion
INSERT INTO produits_mysql (produit_id, nom, prix, stock)
VALUES (101, 'Nouveau produit', 49.99, 50);

-- Mise √† jour
UPDATE produits_mysql
SET stock = stock - 1
WHERE produit_id = 101;

-- Suppression
DELETE FROM produits_mysql WHERE produit_id = 101;
```

### Mapping des Types de Donn√©es

| Type MySQL | Type PostgreSQL | Notes |
|------------|-----------------|-------|
| `INT`, `INTEGER` | `INTEGER` | Entiers standards |
| `BIGINT` | `BIGINT` | Grands entiers |
| `DECIMAL(p,s)` | `NUMERIC(p,s)` | Nombres d√©cimaux |
| `FLOAT`, `DOUBLE` | `REAL`, `DOUBLE PRECISION` | Nombres flottants |
| `VARCHAR(n)` | `VARCHAR(n)` | Cha√Ænes variables |
| `TEXT` | `TEXT` | Texte long |
| `DATE` | `DATE` | Dates |
| `DATETIME` | `TIMESTAMP` | Date + heure |
| `TIMESTAMP` | `TIMESTAMP` | Horodatage |
| `BLOB` | `BYTEA` | Donn√©es binaires |
| `ENUM` | `TEXT` | Converti en texte |
| `SET` | `TEXT` | Converti en texte |

### Options de Performance

```sql
-- Options au niveau du serveur
ALTER SERVER serveur_mysql OPTIONS (
    ADD fetch_size '1000',           -- Taille des lots
    ADD use_remote_estimate 'true'   -- Utiliser stats MySQL
);

-- Options au niveau de la table
ALTER FOREIGN TABLE produits_mysql OPTIONS (
    ADD fetch_size '5000'            -- Surcharge pour cette table
);
```

### Diff√©rences MySQL vs PostgreSQL

Lors de l'utilisation de mysql_fdw, soyez conscient des diff√©rences SQL :

#### 1. Syntaxe des cha√Ænes

```sql
-- MySQL accepte les guillemets simples ET doubles
SELECT * FROM produits WHERE nom = "Laptop";

-- PostgreSQL pr√©f√®re les guillemets simples
SELECT * FROM produits_mysql WHERE nom = 'Laptop';
```

#### 2. Auto-increment vs SERIAL

```sql
-- MySQL
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nom VARCHAR(100)
);

-- PostgreSQL √©quivalent
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100)
);
```

#### 3. Fonctions sp√©cifiques

| MySQL | PostgreSQL √âquivalent |
|-------|----------------------|
| `IFNULL(col, 'N/A')` | `COALESCE(col, 'N/A')` |
| `CONCAT(a, b)` | `a || b` ou `CONCAT(a, b)` |
| `NOW()` | `NOW()` (identique) |
| `DATE_FORMAT()` | `TO_CHAR()` |
| `LIMIT 10 OFFSET 20` | `LIMIT 10 OFFSET 20` (identique) |

#### 4. Comportement du NULL

MySQL a des comportements particuliers avec NULL et les cha√Ænes vides :

```sql
-- MySQL : '' et NULL peuvent √™tre trait√©s diff√©remment selon sql_mode
-- PostgreSQL : '' et NULL sont TOUJOURS distincts

-- V√©rifier dans PostgreSQL
SELECT * FROM produits_mysql WHERE description IS NULL;
SELECT * FROM produits_mysql WHERE description = '';  -- Diff√©rent!
```

### Cas d'usage : Consolidation multi-SGBD

**Sc√©nario** : Cr√©er un data warehouse PostgreSQL qui consolide des donn√©es depuis plusieurs bases MySQL.

```sql
-- Serveur MySQL 1 (boutique en ligne)
CREATE SERVER mysql_boutique
    FOREIGN DATA WRAPPER mysql_fdw
    OPTIONS (host 'mysql1.exemple.com', port '3306');

-- Serveur MySQL 2 (CRM)
CREATE SERVER mysql_crm
    FOREIGN DATA WRAPPER mysql_fdw
    OPTIONS (host 'mysql2.exemple.com', port '3306');

-- Importer les donn√©es
IMPORT FOREIGN SCHEMA 'shop'
    LIMIT TO (orders, order_items)
    FROM SERVER mysql_boutique INTO shop_data;

IMPORT FOREIGN SCHEMA 'crm'
    LIMIT TO (customers, interactions)
    FROM SERVER mysql_crm INTO crm_data;

-- Cr√©er une vue consolid√©e
CREATE VIEW ventes_consolidees AS
SELECT
    c.customer_id,
    c.nom,
    c.email,
    o.order_id,
    o.montant,
    o.date_commande
FROM crm_data.customers c
INNER JOIN shop_data.orders o ON c.customer_id = o.customer_id;

-- Mat√©rialiser pour les performances
CREATE MATERIALIZED VIEW ventes_consolidees_mv AS
SELECT * FROM ventes_consolidees;

-- Rafra√Æchir quotidiennement
REFRESH MATERIALIZED VIEW ventes_consolidees_mv;
```

### Cas d'usage : Migration MySQL vers PostgreSQL

**√âtape 1 : Analyse de la structure**

```sql
-- Importer toutes les tables
IMPORT FOREIGN SCHEMA 'app_prod'
    FROM SERVER serveur_mysql
    INTO mysql_legacy;

-- Analyser les types de donn√©es
SELECT
    table_name,
    column_name,
    data_type,
    character_maximum_length
FROM information_schema.columns
WHERE table_schema = 'mysql_legacy'
ORDER BY table_name, ordinal_position;
```

**√âtape 2 : Cr√©er le sch√©ma PostgreSQL**

```sql
-- Recr√©er les tables avec types PostgreSQL optimis√©s
CREATE TABLE users_pg (
    id SERIAL PRIMARY KEY,                    -- Au lieu de AUTO_INCREMENT
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()        -- Au lieu de DEFAULT CURRENT_TIMESTAMP
);

-- Cr√©er les index
CREATE INDEX idx_users_email ON users_pg(email);
```

**√âtape 3 : Migrer les donn√©es**

```sql
-- Migration initiale
INSERT INTO users_pg (id, username, email, created_at)
SELECT id, username, email, created_at
FROM mysql_legacy.users;

-- Mettre √† jour la s√©quence
SELECT setval('users_pg_id_seq', (SELECT MAX(id) FROM users_pg));
```

**√âtape 4 : Synchronisation incr√©mentale**

```sql
-- Migrer uniquement les nouveaux enregistrements
INSERT INTO users_pg (id, username, email, created_at)
SELECT id, username, email, created_at
FROM mysql_legacy.users
WHERE id > (SELECT COALESCE(MAX(id), 0) FROM users_pg);
```

### Performance et Optimisation

#### Bonnes pratiques

‚úÖ **Utiliser des index sur MySQL** : Les index MySQL sont utilis√©s lors du pushdown.

‚úÖ **Limiter les transferts** :
```sql
-- ‚ùå Mauvais : transf√®re toute la table
SELECT * FROM produits_mysql;

-- ‚úÖ Bon : filtre √† distance
SELECT * FROM produits_mysql WHERE categorie = '√âlectronique';
```

‚úÖ **Mat√©rialiser pour les requ√™tes fr√©quentes** :
```sql
-- Au lieu d'interroger MySQL √† chaque fois
CREATE MATERIALIZED VIEW produits_cache AS
SELECT * FROM produits_mysql;

-- Rafra√Æchir p√©riodiquement
REFRESH MATERIALIZED VIEW produits_cache;
```

#### Monitoring

```sql
-- Sur PostgreSQL, voir les requ√™tes vers MySQL
EXPLAIN (VERBOSE, ANALYZE)
SELECT * FROM produits_mysql WHERE prix > 100;

-- Sur MySQL, activer le slow query log
-- (fichier de config MySQL)
slow_query_log = 1
slow_query_log_file = /var/log/mysql/slow.log
long_query_time = 1
```

### Limitations

‚ùå **Transactions distribu√©es** : mysql_fdw ne garantit pas l'atomicit√© parfaite entre PostgreSQL et MySQL.

```sql
BEGIN;
UPDATE table_postgresql SET statut = 'trait√©';
UPDATE produits_mysql SET stock = stock - 1;
COMMIT;  -- Pas de garantie 2PC
```

‚ùå **Pushdown limit√©** : Moins efficace que postgres_fdw. Certaines op√©rations ne sont pas pouss√©es vers MySQL.

‚ùå **Diff√©rences s√©mantiques** : Les comportements subtils (NULL, comparaisons de cha√Ænes, etc.) peuvent diff√©rer.

‚ùå **Types complexes** : Les types PostgreSQL avanc√©s (JSONB, ARRAY, hstore) ne peuvent pas √™tre √©crits vers MySQL.

---

## Comparaison des FDW

### Tableau r√©capitulatif

| Crit√®re | file_fdw | oracle_fdw | mysql_fdw |
|---------|----------|------------|-----------|
| **Source** | Fichiers locaux | Oracle Database | MySQL/MariaDB |
| **Inclus par d√©faut** | ‚úÖ Oui | ‚ùå Non (tierce partie) | ‚ùå Non (tierce partie) |
| **Lecture** | ‚úÖ | ‚úÖ | ‚úÖ |
| **√âcriture** | ‚ùå Lecture seule | ‚úÖ | ‚úÖ |
| **Performance** | ‚ö†Ô∏è Moyenne | ‚ö†Ô∏è‚ö†Ô∏è D√©pend r√©seau | ‚ö†Ô∏è‚ö†Ô∏è D√©pend r√©seau |
| **Pushdown** | ‚ùå Aucun | ‚úÖ‚úÖ Bon | ‚úÖ Partiel |
| **Transactions** | N/A | ‚ö†Ô∏è Pas 2PC garantie | ‚ö†Ô∏è Pas 2PC garantie |
| **Complexit√© installation** | ‚úÖ Facile | ‚ö†Ô∏è‚ö†Ô∏è Oracle Client requis | ‚ö†Ô∏è Biblioth√®ques MySQL requises |
| **Cas d'usage principal** | Import/Analyse fichiers | Migration Oracle | Migration/Int√©gration MySQL |

### Quand utiliser quel FDW ?

#### file_fdw

‚úÖ **Utilisez quand** :
- Vous devez analyser des fichiers CSV/TSV avant import
- Donn√©es externes non structur√©es en base
- Validation de donn√©es avant int√©gration
- Logs et fichiers texte structur√©s

‚ùå **N'utilisez PAS quand** :
- Vous avez besoin de performances √©lev√©es (utilisez COPY)
- Les fichiers sont distants (utilisez des outils de transfert d'abord)
- Vous voulez modifier les fichiers (lecture seule)

#### oracle_fdw

‚úÖ **Utilisez quand** :
- Migration d'Oracle vers PostgreSQL
- Acc√®s ponctuel √† des donn√©es Oracle legacy
- Reporting consolid√© Oracle + PostgreSQL
- Prototypage d'applications avant migration

‚ùå **N'utilisez PAS quand** :
- Les performances sont critiques (pr√©f√©rez la r√©plication)
- Vous avez besoin de transactions distribu√©es strictes
- La latence r√©seau est √©lev√©e

#### mysql_fdw

‚úÖ **Utilisez quand** :
- Migration de MySQL vers PostgreSQL
- Data warehouse multi-SGBD
- Int√©gration d'applications MySQL + PostgreSQL
- Consolidation de plusieurs bases MySQL

‚ùå **N'utilisez PAS quand** :
- Vous avez besoin de types PostgreSQL avanc√©s (JSONB, etc.)
- Les performances temps r√©el sont critiques
- Vous voulez des garanties transactionnelles fortes

---

## S√©curit√© Commune aux FDW

### Principes g√©n√©raux

#### 1. Principe du moindre privil√®ge

```sql
-- Cr√©er des utilisateurs d√©di√©s avec permissions minimales
-- Sur la source (Oracle/MySQL)
CREATE USER fdw_readonly IDENTIFIED BY 'mot_de_passe';
GRANT CONNECT ON DATABASE TO fdw_readonly;
GRANT SELECT ON schema.table TO fdw_readonly;  -- Lecture seule
```

#### 2. Stockage des mots de passe

‚ùå **√âvitez** :
```sql
CREATE USER MAPPING FOR user
    SERVER serveur_distant
    OPTIONS (password 'mot_de_passe_en_clair');  -- Visible dans pg_catalog
```

‚úÖ **Pr√©f√©rez** :
- Fichiers `.pgpass`
- Gestionnaires de secrets (HashiCorp Vault, AWS Secrets Manager)
- Certificats SSL/TLS pour l'authentification

#### 3. Chiffrement des connexions

```sql
-- Forcer SSL pour oracle_fdw
-- (n√©cessite configuration Oracle SSL)

-- Pour mysql_fdw
ALTER SERVER serveur_mysql OPTIONS (
    ADD ssl_ca '/etc/ssl/mysql-ca.pem',
    ADD ssl_cert '/etc/ssl/mysql-cert.pem',
    ADD ssl_key '/etc/ssl/mysql-key.pem'
);
```

#### 4. Audit et monitoring

```sql
-- Surveiller les connexions FDW
SELECT
    datname,
    usename,
    application_name,
    client_addr,
    state,
    query
FROM pg_stat_activity
WHERE application_name LIKE '%fdw%';
```

---

## D√©pannage Commun

### Probl√®mes fr√©quents et solutions

#### Erreur : "extension not found"

```
ERROR: could not open extension control file
```

**Solution** : Installer le package correspondant :
```bash
sudo apt-get install postgresql-16-mysql-fdw
sudo apt-get install postgresql-16-oracle-fdw
```

#### Erreur de connexion r√©seau

```
ERROR: could not connect to server
```

**Checklist** :
1. V√©rifier la connectivit√© : `telnet host port`
2. V√©rifier le firewall : Port ouvert ?
3. V√©rifier les permissions de connexion distante (my.cnf pour MySQL, listener.ora pour Oracle)
4. Tester avec les outils natifs (mysql client, sqlplus)

#### Erreur d'authentification

```
ERROR: authentication failed
```

**Solutions** :
1. V√©rifier les credentials dans le user mapping
2. V√©rifier que l'utilisateur existe c√¥t√© distant
3. V√©rifier les permissions (GRANT)

#### Performances lentes

**Diagnostic** :
```sql
EXPLAIN (ANALYZE, VERBOSE, BUFFERS)
SELECT * FROM foreign_table WHERE condition;
```

**Solutions** :
- V√©rifier le pushdown (Remote SQL)
- Ajouter des index c√¥t√© distant
- Augmenter `fetch_size`
- Utiliser une vue mat√©rialis√©e pour le cache

---

## Conclusion

### Points cl√©s √† retenir

‚úÖ **file_fdw** : Id√©al pour lire et analyser des fichiers CSV/texte sans les importer

‚úÖ **oracle_fdw** : Permet de connecter PostgreSQL √† Oracle, utile pour les migrations et l'int√©gration

‚úÖ **mysql_fdw** : Connecte PostgreSQL √† MySQL/MariaDB, essentiel pour les environnements multi-SGBD

‚ö†Ô∏è **Performance** : Les FDW vers bases distantes (Oracle, MySQL) ont une latence r√©seau √† consid√©rer

‚ö†Ô∏è **Transactions** : Pas de garantie 2PC stricte par d√©faut

üîí **S√©curit√©** : Toujours utiliser des comptes d√©di√©s avec privil√®ges minimaux et chiffrement

### Prochaines √©tapes

Pour aller plus loin :
1. **Pratiquer** : Installer et configurer chaque FDW dans un environnement de test
2. **Explorer** d'autres FDW : MongoDB (mongo_fdw), Redis (redis_fdw), REST APIs (multicorn)
3. **Approfondir** la r√©plication pour comparer avec les FDW
4. **√âtudier** les strat√©gies de migration et d'int√©gration de donn√©es

### Ressources

- [Documentation PostgreSQL - Foreign Data Wrappers](https://www.postgresql.org/docs/current/ddl-foreign-data.html)
- [file_fdw Documentation](https://www.postgresql.org/docs/current/file-fdw.html)
- [oracle_fdw sur GitHub](https://github.com/laurenz/oracle_fdw)
- [mysql_fdw sur GitHub](https://github.com/EnterpriseDB/mysql_fdw)
- [Wiki PostgreSQL - Liste compl√®te des FDW](https://wiki.postgresql.org/wiki/Foreign_data_wrappers)

---


‚è≠Ô∏è [Pushdown d'op√©rations et performance](/18-extensions-et-integrations/04.3-pushdown-operations.md)
