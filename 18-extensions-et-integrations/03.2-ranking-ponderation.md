üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.3.2. Ranking et Pond√©ration : ts_rank et setweight

## Introduction

Imaginez que vous recherchez "base de donn√©es PostgreSQL" dans un blog technique. Vous obtenez 500 r√©sultats. Mais comment les trier ? Lequel est le plus pertinent ? Celui qui mentionne PostgreSQL une fois en passant, ou celui qui en parle en profondeur ?

C'est l√† qu'interviennent le **ranking** (classement par pertinence) et la **pond√©ration** (attribution d'importance aux diff√©rentes parties du document).

**Le probl√®me sans ranking** :
```sql
-- Tous les articles qui mentionnent "postgresql"
SELECT titre FROM articles
WHERE search_vector @@ to_tsquery('french', 'postgresql');
-- R√©sultats : pas d'ordre logique, ordre al√©atoire ou par ID
```

**La solution avec ranking** :
```sql
-- Articles tri√©s par pertinence
SELECT titre, ts_rank(search_vector, query) AS score
FROM articles, to_tsquery('french', 'postgresql') query
WHERE search_vector @@ query
ORDER BY score DESC;
-- R√©sultats : les plus pertinents en premier !
```

Dans ce chapitre, nous allons explorer :
- **ts_rank** : Calcule un score de pertinence
- **setweight** : Attribue de l'importance aux parties d'un document
- **Normalisation** : Ajuste les scores pour √©viter les biais
- **Optimisations** : Combine ranking et performance

---

## 1. Qu'est-ce que le Ranking ?

### Le Concept de Pertinence

Le **ranking** (ou classement) consiste √† attribuer un **score de pertinence** √† chaque document qui correspond √† une requ√™te. Plus le score est √©lev√©, plus le document est consid√©r√© comme pertinent.

**Facteurs de pertinence** :
1. **Fr√©quence** : Combien de fois le terme recherch√© appara√Æt
2. **Position** : O√π le terme appara√Æt (titre > contenu)
3. **Raret√©** : Les termes rares sont plus significatifs
4. **Proximit√©** : Les termes proches sont plus pertinents

### Exemple Visuel

Recherche : "postgresql"

```
Document A : "PostgreSQL"
Score : 0.06 (1 occurrence)

Document B : "PostgreSQL est puissant. PostgreSQL est open-source."
Score : 0.12 (2 occurrences)

Document C : "Le guide complet de PostgreSQL. PostgreSQL pour d√©butants.
              Ma√Ætriser PostgreSQL en profondeur."
Score : 0.30 (3 occurrences + densit√© √©lev√©e)
```

**Ordre de pertinence** : C > B > A

---

## 2. La Fonction ts_rank

### Signature et Usage de Base

```sql
ts_rank(tsvector, tsquery) ‚Üí real
ts_rank(weights, tsvector, tsquery) ‚Üí real
ts_rank(weights, tsvector, tsquery, normalization) ‚Üí real
```

**Param√®tres** :
- `tsvector` : Le document √† √©valuer
- `tsquery` : La requ√™te de recherche
- `weights` : (Optionnel) Tableau de poids par cat√©gorie [D, C, B, A]
- `normalization` : (Optionnel) M√©thode de normalisation (0-32)

### Exemple Simple

```sql
-- Score de base pour un document
SELECT ts_rank(
    to_tsvector('french', 'PostgreSQL est un SGBD puissant'),
    to_tsquery('french', 'postgresql')
) AS score;
-- R√©sultat : ~0.0607927 (score relatif)
```

### Application Pratique : Trier les R√©sultats

```sql
-- Table d'articles
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(200),
    contenu TEXT,
    search_vector tsvector
);

-- Donn√©es d'exemple
INSERT INTO articles (titre, contenu) VALUES
    ('Introduction PostgreSQL', 'PostgreSQL est un SGBD relationnel.'),
    ('Guide avanc√© PostgreSQL', 'PostgreSQL offre de nombreuses fonctionnalit√©s. PostgreSQL est extensible. PostgreSQL supporte JSON.'),
    ('Bases de donn√©es', 'Les bases de donn√©es stockent des informations. MySQL et PostgreSQL sont populaires.');

-- Mise √† jour du search_vector
UPDATE articles SET search_vector =
    setweight(to_tsvector('french', titre), 'A') ||
    setweight(to_tsvector('french', contenu), 'B');

-- Recherche avec ranking
SELECT
    titre,
    ts_rank(search_vector, query) AS score
FROM
    articles,
    to_tsquery('french', 'postgresql') query
WHERE search_vector @@ query
ORDER BY score DESC;
```

**R√©sultat** :
```
titre                      | score
---------------------------+----------
Guide avanc√© PostgreSQL    | 0.303964  ‚Üê Plus pertinent (3 mentions + titre)
Introduction PostgreSQL    | 0.151982  ‚Üê Moyennement pertinent (titre + 1 mention)
Bases de donn√©es          | 0.075991  ‚Üê Moins pertinent (1 mention parmi d'autres)
```

### Comment ts_rank Calcule le Score

Le score d√©pend de plusieurs facteurs :

#### 1. Fr√©quence des Termes

Plus un terme appara√Æt souvent, plus le score augmente.

```sql
-- Document avec 1 occurrence
SELECT ts_rank(
    to_tsvector('french', 'PostgreSQL est puissant'),
    to_tsquery('french', 'postgresql')
) AS score_1;
-- R√©sultat : ~0.06

-- Document avec 3 occurrences
SELECT ts_rank(
    to_tsvector('french', 'PostgreSQL est puissant. PostgreSQL est rapide. PostgreSQL est fiable.'),
    to_tsquery('french', 'postgresql')
) AS score_3;
-- R√©sultat : ~0.30

-- Score √ó 5 car 5√ó plus de mentions
```

#### 2. Nombre Total de Mots (Longueur du Document)

Un document plus long dilue la pertinence.

```sql
-- Document court avec 1 mention
SELECT ts_rank(
    to_tsvector('french', 'PostgreSQL'),
    to_tsquery('french', 'postgresql')
) AS score_court;
-- R√©sultat : ~0.06

-- Document long avec 1 mention
SELECT ts_rank(
    to_tsvector('french', 'PostgreSQL est un syst√®me de gestion de base de donn√©es relationnel et objet tr√®s puissant et performant.'),
    to_tsquery('french', 'postgresql')
) AS score_long;
-- R√©sultat : ~0.02 (dilu√© par les autres mots)
```

#### 3. Poids des Lex√®mes (A, B, C, D)

Les lex√®mes avec un poids √©lev√© comptent plus.

```sql
-- Sans poids (tous D par d√©faut)
SELECT ts_rank(
    to_tsvector('french', 'PostgreSQL est puissant'),
    to_tsquery('french', 'postgresql')
) AS score_sans_poids;
-- R√©sultat : ~0.06

-- Avec poids A (titre)
SELECT ts_rank(
    setweight(to_tsvector('french', 'PostgreSQL'), 'A'),
    to_tsquery('french', 'postgresql')
) AS score_avec_poids_A;
-- R√©sultat : ~0.60 (10√ó plus √©lev√© !)
```

---

## 3. Les Poids : setweight

### Qu'est-ce qu'un Poids ?

Un **poids** est une √©tiquette (A, B, C, ou D) assign√©e √† un lex√®me pour indiquer son importance dans le document.

**Hi√©rarchie standard** :
- **A** : Titre, nom (le plus important) - Poids : 1.0
- **B** : Sous-titre, r√©sum√©, description - Poids : 0.4
- **C** : Contenu principal - Poids : 0.2
- **D** : M√©tadonn√©es, contenu secondaire (d√©faut) - Poids : 0.1

### Utiliser setweight

```sql
-- Syntaxe
setweight(tsvector, weight) ‚Üí tsvector
```

**Exemples** :

```sql
-- Assigner le poids A (titre)
SELECT setweight(to_tsvector('french', 'PostgreSQL'), 'A');
-- R√©sultat : 'postgresql':1A

-- Assigner le poids B (description)
SELECT setweight(to_tsvector('french', 'Base de donn√©es performante'), 'B');
-- R√©sultat : 'base':1B 'donn':3B 'perform':4B

-- Combiner plusieurs poids
SELECT
    setweight(to_tsvector('french', 'PostgreSQL'), 'A') ||
    setweight(to_tsvector('french', 'SGBD puissant'), 'B') ||
    setweight(to_tsvector('french', 'Open source et gratuit'), 'C');
-- R√©sultat : 'gratuit':9C 'open':7C 'postgresql':1A 'puiss':3B 'sgbd':2B 'sourc':8C
```

### Impact du Poids sur le Score

```sql
-- Sans poids (tous D par d√©faut)
SELECT ts_rank(
    to_tsvector('french', 'PostgreSQL'),
    to_tsquery('french', 'postgresql')
) AS score_D;
-- R√©sultat : ~0.06

-- Avec poids C
SELECT ts_rank(
    setweight(to_tsvector('french', 'PostgreSQL'), 'C'),
    to_tsquery('french', 'postgresql')
) AS score_C;
-- R√©sultat : ~0.12 (2√ó plus √©lev√©)

-- Avec poids B
SELECT ts_rank(
    setweight(to_tsvector('french', 'PostgreSQL'), 'B'),
    to_tsquery('french', 'postgresql')
) AS score_B;
-- R√©sultat : ~0.24 (4√ó plus √©lev√©)

-- Avec poids A
SELECT ts_rank(
    setweight(to_tsvector('french', 'PostgreSQL'), 'A'),
    to_tsquery('french', 'postgresql')
) AS score_A;
-- R√©sultat : ~0.60 (10√ó plus √©lev√©)
```

**Ratio de poids par d√©faut** : A:B:C:D = 1.0:0.4:0.2:0.1

### Cas Pratique : Article de Blog avec Poids

```sql
-- Structure r√©aliste d'un article
WITH article AS (
    SELECT
        'Guide PostgreSQL' AS titre,
        'Apprenez PostgreSQL facilement' AS description,
        'PostgreSQL est un SGBD open-source. PostgreSQL offre de nombreuses fonctionnalit√©s.' AS contenu,
        'postgresql, base de donn√©es, tutoriel' AS tags
)
SELECT
    setweight(to_tsvector('french', titre), 'A') ||           -- Titre : poids A
    setweight(to_tsvector('french', description), 'B') ||     -- Description : poids B
    setweight(to_tsvector('french', contenu), 'C') ||         -- Contenu : poids C
    setweight(to_tsvector('french', tags), 'D') AS search_vector  -- Tags : poids D
FROM article;

-- R√©sultat :
-- 'base':13D 'donn':15D 'facil':4B 'fonctionnalite':14C 'guid':1A
-- 'nombr':12C 'offr':10C 'open':9C 'open-sourc':9C 'postgresql':2A,3B,7C,8C,13D
-- 'sgbd':8C 'sourc':9C 'tutori':16D
```

### Strat√©gie de Pond√©ration Typique

```sql
-- Pattern recommand√© pour un syst√®me de contenu
CREATE OR REPLACE FUNCTION create_search_vector(
    titre TEXT,
    description TEXT,
    contenu TEXT,
    tags TEXT
) RETURNS tsvector AS $$
BEGIN
    RETURN
        setweight(to_tsvector('french', COALESCE(titre, '')), 'A') ||
        setweight(to_tsvector('french', COALESCE(description, '')), 'B') ||
        setweight(to_tsvector('french', COALESCE(contenu, '')), 'C') ||
        setweight(to_tsvector('french', COALESCE(tags, '')), 'D');
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Utilisation
UPDATE articles
SET search_vector = create_search_vector(titre, description, contenu, tags);
```

---

## 4. Personnaliser les Poids avec ts_rank

### Tableau de Poids Custom

Par d√©faut, ts_rank utilise les poids `{0.1, 0.2, 0.4, 1.0}` pour `{D, C, B, A}`.

Vous pouvez les personnaliser :

```sql
-- Syntaxe avec poids personnalis√©s
ts_rank(ARRAY[weight_D, weight_C, weight_B, weight_A], tsvector, tsquery)
```

#### Exemple : Augmenter l'Importance du Titre

```sql
-- Poids par d√©faut : {0.1, 0.2, 0.4, 1.0}
SELECT ts_rank(
    setweight(to_tsvector('french', 'PostgreSQL'), 'A'),
    to_tsquery('french', 'postgresql')
) AS score_defaut;
-- R√©sultat : ~0.60

-- Poids custom : titre 3√ó plus important
SELECT ts_rank(
    ARRAY[0.1, 0.2, 0.4, 3.0],  -- A = 3.0 au lieu de 1.0
    setweight(to_tsvector('french', 'PostgreSQL'), 'A'),
    to_tsquery('french', 'postgresql')
) AS score_custom;
-- R√©sultat : ~1.80 (3√ó plus √©lev√©)
```

#### Exemple : Ignorer le Contenu Secondaire

```sql
-- Poids custom : ignorer compl√®tement le poids D
SELECT ts_rank(
    ARRAY[0.0, 0.2, 0.4, 1.0],  -- D = 0.0 (ignor√©)
    to_tsvector('french', 'PostgreSQL est puissant'),  -- Tout en D par d√©faut
    to_tsquery('french', 'postgresql')
) AS score_ignore_D;
-- R√©sultat : ~0.00 (ignor√© car poids D)

-- Comparaison avec poids A
SELECT ts_rank(
    ARRAY[0.0, 0.2, 0.4, 1.0],
    setweight(to_tsvector('french', 'PostgreSQL est puissant'), 'A'),
    to_tsquery('french', 'postgresql')
) AS score_avec_A;
-- R√©sultat : ~0.60 (pris en compte)
```

#### Cas d'Usage : E-commerce

Pour un site e-commerce, le nom du produit est crucial :

```sql
-- Poids pour produits : nom > description > sp√©cifications
WITH produit AS (
    SELECT
        setweight(to_tsvector('french', 'Chaussures de sport Nike Air'), 'A') ||
        setweight(to_tsvector('french', 'Chaussures running confortables'), 'B') ||
        setweight(to_tsvector('french', 'Semelle en mousse, taille 42'), 'C') AS search_vector
)
SELECT ts_rank(
    ARRAY[0.0, 0.1, 0.3, 2.0],  -- A=2.0 (nom tr√®s important), D=0.0 (ignor√©)
    search_vector,
    plainto_tsquery('french', 'chaussures nike')
) AS score
FROM produit;
-- Nom du produit booste significativement le score
```

---

## 5. Normalisation du Score

### Pourquoi Normaliser ?

Sans normalisation, les documents longs ont tendance √† avoir des scores plus √©lev√©s simplement parce qu'ils contiennent plus de mots.

**Probl√®me** :
```sql
-- Document court : "PostgreSQL"
Score : 0.06

-- Document long : "PostgreSQL" + 1000 autres mots
Score : 0.08 (l√©g√®rement plus √©lev√© √† cause de la longueur)
```

**Solution** : Normaliser le score pour compenser la longueur.

### M√©thodes de Normalisation

PostgreSQL offre plusieurs m√©thodes de normalisation via un param√®tre entier :

```sql
ts_rank(tsvector, tsquery, normalization) ‚Üí real
```

**Valeurs de normalisation** (combinables avec `|`) :

| Valeur | Description | Formule |
|--------|-------------|---------|
| 0 | Pas de normalisation (d√©faut) | score brut |
| 1 | Diviser par (1 + log(longueur)) | score / (1 + log(length)) |
| 2 | Diviser par longueur | score / length |
| 4 | Diviser par moyenne harmonique | formule complexe |
| 8 | Diviser par nombre de mots uniques | score / unique_words |
| 16 | Diviser par (1 + log(nombre uniques)) | score / (1 + log(unique)) |
| 32 | Diviser par lui-m√™me + 1 | score / (score + 1) |

### Exemples de Normalisation

#### Sans Normalisation (0)

```sql
-- Document court
SELECT ts_rank(
    to_tsvector('french', 'PostgreSQL'),
    to_tsquery('french', 'postgresql'),
    0  -- Pas de normalisation
) AS score_court;
-- R√©sultat : ~0.06

-- Document long (m√™me nombre d'occurrences de "PostgreSQL")
SELECT ts_rank(
    to_tsvector('french', 'PostgreSQL ' || repeat('mot ', 100)),
    to_tsquery('french', 'postgresql'),
    0
) AS score_long;
-- R√©sultat : ~0.06 (similaire mais l√©g√®rement diff√©rent)
```

#### Normalisation par Longueur (2)

```sql
-- Document court
SELECT ts_rank(
    to_tsvector('french', 'PostgreSQL'),
    to_tsquery('french', 'postgresql'),
    2  -- Diviser par longueur
) AS score_court;
-- R√©sultat : ~0.06

-- Document long
SELECT ts_rank(
    to_tsvector('french', 'PostgreSQL ' || repeat('mot ', 100)),
    to_tsquery('french', 'postgresql'),
    2
) AS score_long;
-- R√©sultat : ~0.0006 (100√ó plus faible car 100√ó plus long)
```

#### Normalisation Logarithmique (1) - Recommand√©e

```sql
-- Normalisation douce (recommand√©e pour la plupart des cas)
SELECT ts_rank(
    to_tsvector('french', 'PostgreSQL ' || repeat('mot ', 100)),
    to_tsquery('french', 'postgresql'),
    1  -- 1 + log(length)
) AS score_norm;
-- R√©sultat : ~0.02 (r√©duit mais pas autant que /2)
```

### Combiner Plusieurs Normalisations

Les valeurs peuvent √™tre combin√©es avec l'op√©rateur `|` (OR binaire) :

```sql
-- Normalisation 1 + 2 (logarithmique ET longueur)
SELECT ts_rank(
    to_tsvector('french', 'PostgreSQL ' || repeat('mot ', 100)),
    to_tsquery('french', 'postgresql'),
    1 | 2  -- Combine les deux m√©thodes
) AS score_combine;
```

### Quelle Normalisation Choisir ?

**Recommandations** :

| Cas d'usage | Normalisation | Raison |
|-------------|---------------|--------|
| **Articles/Blog** | `1` (log) | Documents de longueur variable |
| **Produits e-commerce** | `0` ou `1` | Descriptions courtes, longueur similaire |
| **Documents techniques** | `1` ou `2` | Peut √™tre tr√®s long, favoriser la densit√© |
| **Recherche g√©n√©rale** | `1` (par d√©faut) | Bon compromis |
| **Tweets/Messages courts** | `0` | Longueur limit√©e, pas besoin de normaliser |

```sql
-- Pattern recommand√© : normalisation logarithmique
SELECT
    titre,
    ts_rank(search_vector, query, 1) AS score  -- Normalisation = 1
FROM articles, plainto_tsquery('french', 'recherche') query
WHERE search_vector @@ query
ORDER BY score DESC;
```

---

## 6. ts_rank_cd : Cover Density Ranking

### Qu'est-ce que ts_rank_cd ?

**ts_rank_cd** calcule le score bas√© sur la **densit√© de couverture** (cover density) : la proximit√© des termes de recherche dans le document.

**Diff√©rence cl√©** :
- **ts_rank** : Se concentre sur la fr√©quence et les poids
- **ts_rank_cd** : Favorise les documents o√π les termes sont **proches les uns des autres**

```sql
ts_rank_cd(tsvector, tsquery) ‚Üí real
ts_rank_cd(weights, tsvector, tsquery, normalization) ‚Üí real
```

### Exemple de Diff√©rence

```sql
-- Document A : termes espac√©s
WITH doc_a AS (
    SELECT to_tsvector('french',
        'PostgreSQL est puissant. ' || repeat('Texte sans rapport. ', 50) || 'Base de donn√©es performante.'
    ) AS vec
)
SELECT
    ts_rank(vec, query) AS score_rank,
    ts_rank_cd(vec, query) AS score_rank_cd
FROM doc_a, to_tsquery('french', 'postgresql & base') query;
-- ts_rank : ~0.08
-- ts_rank_cd : ~0.02 (p√©nalis√© car termes √©loign√©s)

-- Document B : termes proches
WITH doc_b AS (
    SELECT to_tsvector('french',
        'PostgreSQL est une base de donn√©es puissante.'
    ) AS vec
)
SELECT
    ts_rank(vec, query) AS score_rank,
    ts_rank_cd(vec, query) AS score_rank_cd
FROM doc_b, to_tsquery('french', 'postgresql & base') query;
-- ts_rank : ~0.10
-- ts_rank_cd : ~0.15 (r√©compens√© car termes proches)
```

### Quand Utiliser ts_rank_cd ?

**Utilisez ts_rank_cd quand** :
- ‚úÖ La proximit√© des termes est importante (recherche de phrases)
- ‚úÖ Vous recherchez plusieurs termes qui doivent √™tre ensemble
- ‚úÖ Documents longs o√π les termes peuvent √™tre dispers√©s

**Utilisez ts_rank quand** :
- ‚úÖ La fr√©quence globale est plus importante
- ‚úÖ Documents courts
- ‚úÖ Cas g√©n√©ral (plus rapide)

```sql
-- Comparaison pour une recherche de phrase
SELECT
    titre,
    ts_rank(search_vector, query) AS score_freq,
    ts_rank_cd(search_vector, query) AS score_proximite
FROM articles, phraseto_tsquery('french', 'base de donn√©es') query
WHERE search_vector @@ query
ORDER BY score_proximite DESC;  -- Privil√©gier la proximit√©
```

---

## 7. Strat√©gies de Ranking Avanc√©es

### Combinaison de Plusieurs Facteurs

Dans la pratique, vous voudrez souvent combiner le score textuel avec d'autres crit√®res :

#### Score Hybride : Texte + Popularit√©

```sql
-- Table avec m√©tadonn√©es
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(200),
    contenu TEXT,
    vues INTEGER DEFAULT 0,
    likes INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    search_vector tsvector
);

-- Fonction de score hybride
SELECT
    titre,
    -- Score textuel (60%)
    ts_rank(search_vector, query, 1) * 0.6 +
    -- Popularit√© normalis√©e (30%)
    (likes::float / NULLIF((SELECT MAX(likes) FROM articles), 0)) * 0.3 +
    -- Fra√Æcheur (10%)
    (EXTRACT(EPOCH FROM (NOW() - created_at)) / -86400 / 365) * 0.1 AS score_total
FROM articles, plainto_tsquery('french', 'postgresql') query
WHERE search_vector @@ query
ORDER BY score_total DESC;
```

#### Score avec Boost Temporel (Articles R√©cents)

```sql
-- Favoriser les articles r√©cents
SELECT
    titre,
    created_at,
    ts_rank(search_vector, query, 1) *
    -- Boost exponentiel pour les articles r√©cents
    (1 + EXP(-EXTRACT(EPOCH FROM (NOW() - created_at)) / 2592000)) AS score_boosted
    -- 2592000 = 30 jours en secondes
FROM articles, plainto_tsquery('french', 'postgresql') query
WHERE search_vector @@ query
ORDER BY score_boosted DESC;
```

#### Score avec Cat√©gories Privil√©gi√©es

```sql
-- Boost pour certaines cat√©gories
SELECT
    titre,
    categorie,
    ts_rank(search_vector, query, 1) *
    CASE categorie
        WHEN 'Tutoriel' THEN 2.0  -- Boost 2√ó
        WHEN 'Documentation' THEN 1.5  -- Boost 1.5√ó
        ELSE 1.0  -- Pas de boost
    END AS score_avec_boost
FROM articles, plainto_tsquery('french', 'postgresql') query
WHERE search_vector @@ query
ORDER BY score_avec_boost DESC;
```

### Multi-Field Search avec Poids Diff√©rents

```sql
-- Recherche dans plusieurs champs avec importance variable
SELECT
    titre,
    -- Score titre (poids 3)
    ts_rank(setweight(to_tsvector('french', titre), 'A'), query) * 3 +
    -- Score description (poids 2)
    ts_rank(setweight(to_tsvector('french', description), 'B'), query) * 2 +
    -- Score contenu (poids 1)
    ts_rank(setweight(to_tsvector('french', contenu), 'C'), query) * 1 AS score_total
FROM articles, plainto_tsquery('french', 'postgresql base donn√©es') query
WHERE
    to_tsvector('french', titre) @@ query OR
    to_tsvector('french', description) @@ query OR
    to_tsvector('french', contenu) @@ query
ORDER BY score_total DESC;
```

---

## 8. Performance et Optimisation

### Pr√©-calculer le Ranking vs Calculer √† la Vol√©e

#### Option 1 : Calculer √† la Vol√©e (Simple mais Plus Lent)

```sql
-- Calcul du score √† chaque requ√™te
SELECT
    titre,
    ts_rank(search_vector, query, 1) AS score
FROM articles, plainto_tsquery('french', 'postgresql') query
WHERE search_vector @@ query
ORDER BY score DESC
LIMIT 20;

-- Impact : +5-10ms par requ√™te pour 100k documents
```

#### Option 2 : Pr√©-calculer le Score (Complexe mais Plus Rapide)

Cette approche n'est utile que si vous avez des **requ√™tes fr√©quentes identiques**.

```sql
-- Table de cache pour requ√™tes populaires
CREATE TABLE search_cache (
    query_text TEXT PRIMARY KEY,
    article_id INTEGER,
    score REAL,
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Pr√©-calculer pour les requ√™tes populaires
INSERT INTO search_cache (query_text, article_id, score)
SELECT
    'postgresql' AS query_text,
    a.id,
    ts_rank(a.search_vector, to_tsquery('french', 'postgresql'), 1)
FROM articles a
WHERE a.search_vector @@ to_tsquery('french', 'postgresql');

-- Requ√™te ultra-rapide
SELECT a.titre, sc.score
FROM search_cache sc
JOIN articles a ON a.id = sc.article_id
WHERE sc.query_text = 'postgresql'
ORDER BY sc.score DESC
LIMIT 20;

-- Impact : <1ms (lecture simple d'index)
```

### Optimiser les Requ√™tes avec Ranking

#### ‚úÖ Filtrer PUIS Ranker (Pas l'Inverse)

```sql
-- ‚úÖ BON : Filtrer d'abord avec @@, puis ranker les r√©sultats
SELECT titre, ts_rank(search_vector, query, 1) AS score
FROM articles, plainto_tsquery('french', 'postgresql') query
WHERE search_vector @@ query  -- Filtre d'abord (utilise index GIN)
ORDER BY score DESC
LIMIT 20;

-- ‚ùå MAUVAIS : Ranker tous les documents puis filtrer
SELECT titre, score
FROM (
    SELECT titre, ts_rank(search_vector, query, 1) AS score
    FROM articles, plainto_tsquery('french', 'postgresql') query
) t
WHERE score > 0  -- Filtre apr√®s ranking (inefficace)
ORDER BY score DESC;
```

#### ‚úÖ Limiter les R√©sultats T√¥t

```sql
-- Utiliser LIMIT pour √©viter de trier tous les r√©sultats
SELECT titre, ts_rank(search_vector, query, 1) AS score
FROM articles, plainto_tsquery('french', 'postgresql') query
WHERE search_vector @@ query
ORDER BY score DESC
LIMIT 20;  -- ‚Üê Important : ne calcule/trie que le top 20
```

#### ‚úÖ Utiliser une CTE pour R√©utiliser la Query

```sql
-- √âviter de recr√©er la query plusieurs fois
WITH search AS (
    SELECT plainto_tsquery('french', 'postgresql base donn√©es') AS query
)
SELECT
    a.titre,
    ts_rank(a.search_vector, s.query, 1) AS score
FROM articles a, search s
WHERE a.search_vector @@ s.query
ORDER BY score DESC
LIMIT 20;
```

### Index et Ranking

**Important** : Le ranking lui-m√™me n'est **PAS** acc√©l√©r√© par les index. Seul le **filtrage** (`@@`) b√©n√©ficie de l'index GIN.

```sql
-- L'index GIN acc√©l√®re le WHERE, pas le ORDER BY
CREATE INDEX idx_articles_search ON articles USING GIN(search_vector);

-- Processus :
-- 1. WHERE utilise l'index GIN ‚Üí Rapide (10ms)
-- 2. ts_rank calcule le score ‚Üí Co√ªt proportionnel au nombre de r√©sultats (5ms pour 100 docs)
-- 3. ORDER BY trie les scores ‚Üí Rapide pour un petit nombre de r√©sultats
```

**Best Practice** : Combiner avec LIMIT pour minimiser le nombre de documents √† ranker.

---

## 9. Cas Pratiques Complets

### Cas 1 : Moteur de Recherche de Blog

```sql
-- Structure compl√®te
CREATE TABLE blog_articles (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(200),
    description TEXT,
    contenu TEXT,
    auteur VARCHAR(100),
    categorie VARCHAR(50),
    vues INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    search_vector tsvector
);

-- Trigger pour maintenir search_vector avec poids
CREATE OR REPLACE FUNCTION blog_search_trigger() RETURNS trigger AS $$
BEGIN
    NEW.search_vector :=
        setweight(to_tsvector('french', COALESCE(NEW.titre, '')), 'A') ||
        setweight(to_tsvector('french', COALESCE(NEW.description, '')), 'B') ||
        setweight(to_tsvector('french', COALESCE(NEW.contenu, '')), 'C') ||
        setweight(to_tsvector('french', COALESCE(NEW.auteur, '')), 'D');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tsvector_update
BEFORE INSERT OR UPDATE ON blog_articles
FOR EACH ROW EXECUTE FUNCTION blog_search_trigger();

-- Index GIN
CREATE INDEX idx_blog_search ON blog_articles USING GIN(search_vector);

-- Fonction de recherche avec ranking hybride
CREATE OR REPLACE FUNCTION search_blog(
    search_text TEXT,
    max_results INTEGER DEFAULT 20
)
RETURNS TABLE (
    id INTEGER,
    titre VARCHAR,
    description TEXT,
    auteur VARCHAR,
    score REAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        a.id,
        a.titre,
        a.description,
        a.auteur,
        -- Score hybride : pertinence + popularit√© + fra√Æcheur
        (
            ts_rank(
                ARRAY[0.1, 0.2, 0.4, 1.0],  -- Poids custom
                a.search_vector,
                query,
                1  -- Normalisation logarithmique
            ) * 0.7 +  -- 70% pertinence textuelle
            (a.vues::float / NULLIF((SELECT MAX(vues) FROM blog_articles), 0)) * 0.2 +  -- 20% popularit√©
            (1.0 / (1.0 + EXTRACT(EPOCH FROM (NOW() - a.created_at)) / 2592000)) * 0.1  -- 10% fra√Æcheur
        ) AS score
    FROM
        blog_articles a,
        websearch_to_tsquery('french', search_text) query
    WHERE a.search_vector @@ query
    ORDER BY score DESC
    LIMIT max_results;
END;
$$ LANGUAGE plpgsql;

-- Utilisation
SELECT * FROM search_blog('postgresql base donn√©es');
```

### Cas 2 : E-commerce avec Ranking de Produits

```sql
-- Table produits
CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    description TEXT,
    marque VARCHAR(100),
    categorie VARCHAR(50),
    prix NUMERIC(10, 2),
    stock INTEGER,
    note_moyenne NUMERIC(2, 1),
    nombre_avis INTEGER,
    search_vector tsvector
);

-- Trigger avec poids adapt√©s e-commerce
CREATE OR REPLACE FUNCTION produits_search_trigger() RETURNS trigger AS $$
BEGIN
    NEW.search_vector :=
        -- Nom du produit : tr√®s important (poids A, multipli√© par 2)
        setweight(to_tsvector('french', COALESCE(NEW.nom, '')), 'A') ||
        setweight(to_tsvector('french', COALESCE(NEW.nom, '')), 'A') ||  -- Dupliqu√© pour doubler l'importance
        -- Marque : important (poids A)
        setweight(to_tsvector('french', COALESCE(NEW.marque, '')), 'A') ||
        -- Description : moyen (poids B)
        setweight(to_tsvector('french', COALESCE(NEW.description, '')), 'B') ||
        -- Cat√©gorie : faible (poids C)
        setweight(to_tsvector('french', COALESCE(NEW.categorie, '')), 'C');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tsvector_update
BEFORE INSERT OR UPDATE ON produits
FOR EACH ROW EXECUTE FUNCTION produits_search_trigger();

-- Index
CREATE INDEX idx_produits_search ON produits USING GIN(search_vector);

-- Recherche avec ranking e-commerce
SELECT
    nom,
    marque,
    prix,
    note_moyenne,
    -- Score composite
    (
        ts_rank(
            ARRAY[0.05, 0.2, 0.4, 2.0],  -- Nom/Marque tr√®s importants
            search_vector,
            query,
            1
        ) * 0.5 +  -- 50% pertinence textuelle
        (note_moyenne / 5.0) * 0.2 +  -- 20% note client
        (LEAST(nombre_avis, 1000)::float / 1000) * 0.15 +  -- 15% nombre d'avis
        CASE
            WHEN stock > 10 THEN 0.15  -- 15% disponibilit√©
            WHEN stock > 0 THEN 0.075
            ELSE 0
        END
    ) AS score_final
FROM produits, websearch_to_tsquery('french', 'chaussures running nike') query
WHERE search_vector @@ query
  AND stock > 0  -- Uniquement produits en stock
ORDER BY score_final DESC
LIMIT 50;
```

### Cas 3 : Documentation Technique avec Phrases Exactes

```sql
-- Recherche privil√©giant les phrases exactes
WITH search_params AS (
    SELECT
        websearch_to_tsquery('french', 'error "connection refused" postgresql') AS query,
        phraseto_tsquery('french', 'connection refused') AS phrase_query
)
SELECT
    titre,
    -- Bonus si phrase exacte trouv√©e
    ts_rank(search_vector, sp.query, 1) +
    CASE
        WHEN search_vector @@ sp.phrase_query THEN 0.5  -- Bonus +0.5 pour phrase exacte
        ELSE 0
    END AS score_avec_bonus
FROM documentation, search_params sp
WHERE search_vector @@ sp.query
ORDER BY score_avec_bonus DESC;
```

---

## 10. Bonnes Pratiques

### ‚úÖ Utiliser des Poids Appropri√©s

```sql
-- ‚úÖ BON : Hi√©rarchie claire
setweight(to_tsvector('french', titre), 'A')       -- Le plus important
setweight(to_tsvector('french', description), 'B') -- Important
setweight(to_tsvector('french', contenu), 'C')     -- Contenu principal
setweight(to_tsvector('french', metadata), 'D')    -- Secondaire

-- ‚ùå MAUVAIS : Tout au m√™me poids
to_tsvector('french', titre || ' ' || description || ' ' || contenu)
```

### ‚úÖ Normaliser pour les Documents de Longueur Variable

```sql
-- ‚úÖ BON : Normalisation logarithmique (1)
ts_rank(search_vector, query, 1)

-- ‚ö†Ô∏è ATTENTION : Pas de normalisation si documents de longueur similaire
ts_rank(search_vector, query, 0)  -- OK pour tweets, titres de produits
```

### ‚úÖ Combiner avec LIMIT pour la Performance

```sql
-- ‚úÖ BON : Limite t√¥t
SELECT titre, ts_rank(search_vector, query, 1) AS score
FROM articles, query
WHERE search_vector @@ query
ORDER BY score DESC
LIMIT 20;  -- ‚Üê Ne calcule/trie que le n√©cessaire
```

### ‚úÖ Tester Diff√©rentes Strat√©gies de Poids

```sql
-- Tester et comparer diff√©rentes strat√©gies
WITH strategies AS (
    SELECT
        'Standard' AS strategie,
        ts_rank(search_vector, query, 1) AS score
    FROM articles, query
    WHERE search_vector @@ query

    UNION ALL

    SELECT
        'Titre Boosted' AS strategie,
        ts_rank(ARRAY[0.1, 0.2, 0.4, 2.0], search_vector, query, 1) AS score
    FROM articles, query
    WHERE search_vector @@ query
)
SELECT strategie, AVG(score), MIN(score), MAX(score)
FROM strategies
GROUP BY strategie;
```

### ‚úÖ Documenter Votre Strat√©gie de Ranking

```sql
-- Commenter votre logique de scoring
SELECT
    titre,
    -- SCORING STRATEGY v2.1 (2024-11-23)
    -- Weights: A=2.0 (title), B=0.4 (desc), C=0.2 (content), D=0.1 (tags)
    -- Normalization: 1 (logarithmic)
    -- Boost: +20% for popularity, +10% for recency
    ts_rank(ARRAY[0.1, 0.2, 0.4, 2.0], search_vector, query, 1) * 0.7 +
    (vues::float / MAX(vues) OVER ()) * 0.2 +
    (1.0 / (1.0 + EXTRACT(EPOCH FROM (NOW() - created_at)) / 86400)) * 0.1 AS score
FROM articles, query
WHERE search_vector @@ query
ORDER BY score DESC;
```

---

## 11. R√©sum√© et Aide-M√©moire

### ts_rank : Calculer le Score

```sql
-- Basique
ts_rank(tsvector, tsquery) ‚Üí real

-- Avec poids personnalis√©s
ts_rank(ARRAY[D, C, B, A], tsvector, tsquery) ‚Üí real

-- Avec normalisation
ts_rank(tsvector, tsquery, normalization_code) ‚Üí real

-- Complet
ts_rank(ARRAY[0.1, 0.2, 0.4, 1.0], tsvector, tsquery, 1) ‚Üí real
```

### setweight : Attribuer un Poids

```sql
-- Syntaxe
setweight(tsvector, 'A'|'B'|'C'|'D') ‚Üí tsvector

-- Exemple
setweight(to_tsvector('french', 'texte'), 'A')

-- Combiner plusieurs poids
setweight(to_tsvector('french', 'titre'), 'A') ||
setweight(to_tsvector('french', 'contenu'), 'C')
```

### Hi√©rarchie de Poids Standard

| Poids | Usage Typique | Multiplicateur par D√©faut |
|-------|---------------|---------------------------|
| **A** | Titre, nom | 1.0 (r√©f√©rence) |
| **B** | Sous-titre, description | 0.4 |
| **C** | Contenu principal | 0.2 |
| **D** | M√©tadonn√©es, tags | 0.1 |

### Normalisation

| Code | Description | Cas d'usage |
|------|-------------|-------------|
| `0` | Pas de normalisation | Documents de longueur similaire |
| `1` | Logarithmique (recommand√©) | Cas g√©n√©ral, documents variables |
| `2` | Par longueur | Favoriser forte densit√© |
| `1\|2` | Combin√© | Maximum de normalisation |

### Pattern Complet

```sql
-- 1. Structure
CREATE TABLE ma_table (
    id SERIAL PRIMARY KEY,
    titre TEXT,
    description TEXT,
    contenu TEXT,
    search_vector tsvector
);

-- 2. Trigger avec poids
CREATE FUNCTION ma_table_search_trigger() RETURNS trigger AS $$
BEGIN
    NEW.search_vector :=
        setweight(to_tsvector('french', COALESCE(NEW.titre, '')), 'A') ||
        setweight(to_tsvector('french', COALESCE(NEW.description, '')), 'B') ||
        setweight(to_tsvector('french', COALESCE(NEW.contenu, '')), 'C');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tsvector_update BEFORE INSERT OR UPDATE ON ma_table
FOR EACH ROW EXECUTE FUNCTION ma_table_search_trigger();

-- 3. Index
CREATE INDEX idx_search ON ma_table USING GIN(search_vector);

-- 4. Recherche avec ranking
SELECT
    titre,
    ts_rank(
        ARRAY[0.1, 0.2, 0.4, 1.0],  -- Poids custom
        search_vector,
        query,
        1  -- Normalisation
    ) AS score
FROM ma_table, websearch_to_tsquery('french', 'recherche') query
WHERE search_vector @@ query
ORDER BY score DESC
LIMIT 20;
```

---

## Conclusion

Le **ranking** et la **pond√©ration** sont essentiels pour obtenir des r√©sultats de recherche pertinents et tri√©s intelligemment.

**Points cl√©s √† retenir** :

1. **ts_rank** calcule un score de pertinence bas√© sur :
   - Fr√©quence des termes
   - Poids des lex√®mes (A, B, C, D)
   - Longueur du document

2. **setweight** attribue de l'importance aux parties d'un document :
   - A (titre) > B (description) > C (contenu) > D (m√©tadonn√©es)
   - Ratio par d√©faut : 1.0 : 0.4 : 0.2 : 0.1

3. **Normalisation** compense la longueur des documents :
   - `0` : Pas de normalisation
   - `1` : Logarithmique (recommand√©)
   - `2` : Par longueur (strict)

4. **Strat√©gies avanc√©es** combinent :
   - Score textuel (ts_rank)
   - Popularit√© (vues, likes)
   - Fra√Æcheur (date)
   - Disponibilit√© (stock)

5. **Performance** :
   - L'index GIN acc√©l√®re le filtrage, pas le ranking
   - Utiliser LIMIT pour √©viter de calculer trop de scores
   - Pr√©-calculer pour les requ√™tes fr√©quentes

Le ranking transforme une simple recherche en un moteur de recherche intelligent qui comprend l'**intention** de l'utilisateur et retourne les r√©sultats les plus **pertinents** en premier.

**Prochaine √©tape** : Explorez les dictionnaires personnalis√©s, les langues multiples, et les techniques avanc√©es de Full-Text Search pour aller encore plus loin !

---

**Ressources compl√©mentaires** :
- Documentation ts_rank : https://www.postgresql.org/docs/current/textsearch-controls.html#TEXTSEARCH-RANKING
- Controlling Text Search : https://www.postgresql.org/docs/current/textsearch-controls.html
- Full-Text Search Tutorial : https://www.postgresql.org/docs/current/textsearch-intro.html

‚è≠Ô∏è [Dictionnaires et langues multiples](/18-extensions-et-integrations/03.3-dictionnaires-langues.md)
