üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.2.3. Fonctions Spatiales : ST_Distance, ST_Intersects et Plus

## Introduction

Les **fonctions spatiales** sont le c≈ìur de PostGIS. Elles vous permettent d'interroger et d'analyser les relations entre les g√©om√©tries : quelle est la distance entre deux points ? Est-ce que cette route traverse ce parc ? Quel restaurant est le plus proche ?

PostGIS offre plus de 400 fonctions spatiales, mais certaines sont particuli√®rement importantes et fr√©quemment utilis√©es. Dans ce chapitre, nous allons explorer en d√©tail :

- **ST_Distance** : Calculer des distances
- **ST_Intersects** : D√©tecter des intersections
- Et de nombreuses autres fonctions essentielles

> **Convention de nommage** : Toutes les fonctions spatiales PostGIS commencent par `ST_` (Spatial Type). C'est une norme du consortium OGC (Open Geospatial Consortium).

---

## 1. ST_Distance : Mesurer les Distances

### Qu'est-ce que ST_Distance ?

**ST_Distance** calcule la distance **la plus courte** entre deux g√©om√©tries. C'est l'une des fonctions les plus utilis√©es en analyse spatiale.

**Signature de la fonction** :
```sql
ST_Distance(geometry1, geometry2) ‚Üí numeric
ST_Distance(geography1, geography2) ‚Üí numeric (en m√®tres)
```

### Distance entre Deux Points

C'est le cas le plus simple et le plus fr√©quent.

```sql
-- Distance entre Paris et Londres (en degr√©s avec geometry)
SELECT ST_Distance(
    ST_MakePoint(2.3522, 48.8566),  -- Paris
    ST_MakePoint(-0.1278, 51.5074)  -- Londres
);
-- R√©sultat : ~3.75 (degr√©s) ‚Üê PAS TR√àS UTILE !

-- Distance en M√àTRES avec geography
SELECT ST_Distance(
    ST_MakePoint(2.3522, 48.8566)::geography,  -- Paris
    ST_MakePoint(-0.1278, 51.5074)::geography  -- Londres
);
-- R√©sultat : ~343,866 m√®tres (343 km) ‚Üê UTILE !
```

**Conversion en kilom√®tres** :
```sql
SELECT
    ST_Distance(
        ST_MakePoint(2.3522, 48.8566)::geography,
        ST_MakePoint(-0.1278, 51.5074)::geography
    ) / 1000 AS distance_km;
-- R√©sultat : 343.866 km
```

### Distance d'un Point √† une Ligne

La distance d'un point √† une ligne est la **distance perpendiculaire** du point √† la ligne (le chemin le plus court).

```sql
-- Cr√©er une route (ligne)
WITH route AS (
    SELECT ST_MakeLine(ARRAY[
        ST_MakePoint(2.35, 48.85),
        ST_MakePoint(2.36, 48.86),
        ST_MakePoint(2.37, 48.87)
    ])::geography AS trace
),
maison AS (
    SELECT ST_MakePoint(2.36, 48.85)::geography AS position
)
SELECT
    ST_Distance(maison.position, route.trace) AS distance_metres
FROM maison, route;
-- R√©sultat : distance perpendiculaire de la maison √† la route
```

**Visualisation** :
```
Route: ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
              ‚îÇ
              ‚îÇ ‚Üê Distance perpendiculaire (la plus courte)
              ‚îÇ
            Maison ‚Ä¢
```

### Distance d'un Point √† un Polygone

La distance d'un point √† un polygone d√©pend de la position du point :
- **Point √† l'int√©rieur** : distance = 0
- **Point √† l'ext√©rieur** : distance jusqu'au bord le plus proche

```sql
-- Cr√©er un parc (polygone carr√©)
WITH parc AS (
    SELECT ST_MakeEnvelope(2.35, 48.85, 2.37, 48.87, 4326)::geography AS zone
),
personne AS (
    SELECT ST_MakePoint(2.38, 48.86)::geography AS position
)
SELECT
    ST_Distance(personne.position, parc.zone) AS distance_metres
FROM personne, parc;
-- R√©sultat : distance du point au bord du parc
```

### Distance entre Deux Polygones

La distance entre deux polygones est :
- **0** s'ils se touchent ou se chevauchent
- **> 0** sinon (distance entre les bords les plus proches)

```sql
-- Distance entre deux parcelles
SELECT ST_Distance(
    ST_MakeEnvelope(2.35, 48.85, 2.36, 48.86, 4326)::geography,  -- Parcelle 1
    ST_MakeEnvelope(2.37, 48.85, 2.38, 48.86, 4326)::geography   -- Parcelle 2
) AS distance_metres;
```

### Exemple Pratique : Trouver le Restaurant le Plus Proche

```sql
-- Table de restaurants
CREATE TABLE restaurants (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    position GEOMETRY(Point, 4326)
);

INSERT INTO restaurants (nom, position) VALUES
    ('Le Bon Caf√©', ST_SetSRID(ST_MakePoint(2.3520, 48.8565), 4326)),
    ('Pizza Express', ST_SetSRID(ST_MakePoint(2.3525, 48.8570), 4326)),
    ('Sushi Bar', ST_SetSRID(ST_MakePoint(2.3530, 48.8560), 4326));

-- Position de l'utilisateur
WITH ma_position AS (
    SELECT ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326)::geography AS pos
)
SELECT
    r.nom,
    ST_Distance(r.position::geography, mp.pos) AS distance_metres,
    ROUND(ST_Distance(r.position::geography, mp.pos)::numeric, 0) AS distance_arrondie
FROM restaurants r, ma_position mp
ORDER BY distance_metres
LIMIT 1;
-- R√©sultat : Le restaurant le plus proche avec sa distance
```

### ST_Distance vs Op√©rateur <->

PostgreSQL offre un **op√©rateur de distance** `<->` qui est optimis√© pour l'utilisation avec les index :

```sql
-- M√©thode 1 : ST_Distance (standard, clair)
SELECT nom, ST_Distance(position::geography, point_ref::geography)
FROM restaurants
ORDER BY ST_Distance(position::geography, point_ref::geography)
LIMIT 5;

-- M√©thode 2 : Op√©rateur <-> (optimis√© pour l'index)
SELECT nom, position <-> point_ref AS distance_approximative
FROM restaurants
ORDER BY position <-> point_ref
LIMIT 5;
```

**Diff√©rences importantes** :
- `<->` utilise l'index spatial (tr√®s rapide pour top N)
- `<->` retourne une distance approximative (en degr√©s avec geometry)
- `ST_Distance` est plus pr√©cis mais potentiellement plus lent
- **Best practice** : Utiliser `<->` pour ORDER BY, puis ST_Distance pour afficher la vraie distance

**Exemple optimis√©** :
```sql
-- Combiner les deux : rapidit√© ET pr√©cision
WITH ma_position AS (
    SELECT ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326) AS pos
)
SELECT
    nom,
    ST_Distance(position::geography, pos::geography) AS distance_metres
FROM restaurants, ma_position
ORDER BY position <-> pos  -- ‚Üê Utilise l'index (rapide)
LIMIT 10;
```

---

## 2. ST_DWithin : Distance avec Seuil

### Qu'est-ce que ST_DWithin ?

**ST_DWithin** v√©rifie si deux g√©om√©tries sont **√† moins d'une certaine distance** l'une de l'autre. C'est beaucoup plus efficace que de calculer la distance puis comparer.

**Signature** :
```sql
ST_DWithin(geometry1, geometry2, distance) ‚Üí boolean
ST_DWithin(geography1, geography2, distance_metres) ‚Üí boolean
```

### Pourquoi ST_DWithin est Plus Rapide

```sql
-- ‚ùå LENT : Calculer toutes les distances
SELECT nom FROM restaurants
WHERE ST_Distance(position::geography, point_ref::geography) < 1000;
-- Doit calculer TOUTES les distances

-- ‚úÖ RAPIDE : Utiliser ST_DWithin
SELECT nom FROM restaurants
WHERE ST_DWithin(position::geography, point_ref::geography, 1000);
-- Peut utiliser l'index spatial pour filtrer rapidement
```

**Gain de performance** : 10√ó √† 100√ó plus rapide sur de grandes tables.

### Exemples Pratiques

#### Trouver Tous les Restaurants dans un Rayon

```sql
-- Restaurants dans un rayon de 500 m√®tres
WITH ma_position AS (
    SELECT ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326)::geography AS pos
)
SELECT
    r.nom,
    ST_Distance(r.position::geography, mp.pos) AS distance_metres
FROM restaurants r, ma_position mp
WHERE ST_DWithin(r.position::geography, mp.pos, 500)
ORDER BY distance_metres;
```

#### Points d'Int√©r√™t Proches d'une Route

```sql
-- POI (Points of Interest) √† moins de 100m d'une route
WITH route AS (
    SELECT ST_MakeLine(ARRAY[
        ST_MakePoint(2.35, 48.85),
        ST_MakePoint(2.37, 48.87)
    ])::geography AS trace
)
SELECT
    poi.nom,
    ST_Distance(poi.position::geography, route.trace) AS distance_m
FROM points_interet poi, route
WHERE ST_DWithin(poi.position::geography, route.trace, 100)
ORDER BY distance_m;
```

#### Zones de Livraison

```sql
-- V√©rifier si une adresse est dans la zone de livraison d'un restaurant
SELECT
    r.nom AS restaurant,
    CASE
        WHEN ST_DWithin(
            r.position::geography,
            client.adresse::geography,
            3000  -- 3 km
        ) THEN 'Livraison possible'
        ELSE 'Hors zone'
    END AS statut_livraison
FROM restaurants r
CROSS JOIN (SELECT ST_MakePoint(2.36, 48.87)::geography AS adresse) client;
```

---

## 3. ST_Intersects : D√©tecter les Intersections

### Qu'est-ce que ST_Intersects ?

**ST_Intersects** v√©rifie si deux g√©om√©tries **se touchent ou se chevauchent** d'une quelconque mani√®re. C'est la fonction de relation spatiale la plus utilis√©e.

**Signature** :
```sql
ST_Intersects(geometry1, geometry2) ‚Üí boolean
```

**Retourne TRUE si** :
- Les g√©om√©tries se touchent
- Les g√©om√©tries se chevauchent
- Une g√©om√©trie est √† l'int√©rieur de l'autre
- Les g√©om√©tries partagent au moins un point

**Retourne FALSE si** :
- Les g√©om√©tries sont compl√®tement s√©par√©es

### Cas d'Usage : Point dans un Polygone

Le cas le plus fr√©quent : v√©rifier si un point est dans une zone.

```sql
-- V√©rifier si un restaurant est dans le 1er arrondissement
WITH arrondissement_1 AS (
    SELECT ST_MakeEnvelope(2.337, 48.861, 2.345, 48.866, 4326) AS zone
)
SELECT
    r.nom,
    CASE
        WHEN ST_Intersects(r.position, a.zone)
        THEN '‚úì Dans l''arrondissement'
        ELSE '‚úó Hors arrondissement'
    END AS localisation
FROM restaurants r, arrondissement_1 a;
```

**Note** : Pour "point dans polygone", on peut aussi utiliser `ST_Contains` ou `ST_Within` (voir plus bas).

### Cas d'Usage : Lignes qui se Croisent

V√©rifier si deux routes se croisent.

```sql
-- Deux routes
WITH route_a AS (
    SELECT ST_MakeLine(ARRAY[
        ST_MakePoint(2.35, 48.85),
        ST_MakePoint(2.37, 48.87)
    ]) AS trace
),
route_b AS (
    SELECT ST_MakeLine(ARRAY[
        ST_MakePoint(2.36, 48.86),
        ST_MakePoint(2.38, 48.86)
    ]) AS trace
)
SELECT
    ST_Intersects(route_a.trace, route_b.trace) AS se_croisent,
    ST_AsText(ST_Intersection(route_a.trace, route_b.trace)) AS point_croisement
FROM route_a, route_b;
-- Si TRUE : les routes se croisent
```

### Cas d'Usage : Zones qui se Chevauchent

Trouver les parcelles qui chevauchent une zone d'urbanisme.

```sql
-- Parcelles touch√©es par une zone constructible
SELECT
    p.reference AS parcelle,
    ROUND(ST_Area(ST_Intersection(p.geometrie, z.geometrie))::numeric, 2) AS surface_impactee_m2
FROM parcelles p
JOIN zones_urbanisme z ON ST_Intersects(p.geometrie, z.geometrie)
WHERE z.type = 'Zone constructible';
```

### Optimisation avec l'Op√©rateur &&

Pour am√©liorer les performances, PostGIS utilise d'abord l'**op√©rateur de bo√Æte englobante** `&&` :

```sql
-- ‚ùå Moins optimis√©
SELECT * FROM parcelles
WHERE ST_Intersects(geometrie, zone_recherche);

-- ‚úÖ Mieux optimis√© (PostgreSQL le fait automatiquement)
SELECT * FROM parcelles
WHERE geometrie && zone_recherche  -- Filtre rapide (index)
  AND ST_Intersects(geometrie, zone_recherche);  -- V√©rification pr√©cise
```

**Note** : Vous n'avez g√©n√©ralement pas besoin d'√©crire `&&` manuellement. PostgreSQL l'ajoute automatiquement quand vous utilisez ST_Intersects avec un index spatial.

---

## 4. Relations Spatiales : La Famille ST_

PostGIS offre de nombreuses fonctions pour tester les relations entre g√©om√©tries. Voici les plus importantes :

### ST_Contains et ST_Within

**ST_Contains** : "A contient compl√®tement B"
**ST_Within** : "A est compl√®tement dans B" (inverse de Contains)

```sql
-- Un point est-il dans un polygone ?
SELECT ST_Contains(
    ST_MakeEnvelope(2.35, 48.85, 2.37, 48.87, 4326),  -- Polygone
    ST_MakePoint(2.36, 48.86)  -- Point
);  -- TRUE

-- Inverse : le point est-il dans le polygone ?
SELECT ST_Within(
    ST_MakePoint(2.36, 48.86),  -- Point
    ST_MakeEnvelope(2.35, 48.85, 2.37, 48.87, 4326)  -- Polygone
);  -- TRUE
```

**Diff√©rence avec ST_Intersects** :
```
ST_Intersects : A et B se touchent (m√™me juste au bord)
ST_Contains   : B est COMPL√àTEMENT √† l'int√©rieur de A
ST_Within     : A est COMPL√àTEMENT √† l'int√©rieur de B

Exemple :
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ    A    ‚îÇ              ‚îÇ    A    ‚îÇ
  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ              ‚îÇ  ‚ïî‚ïê‚ïê‚ïê   ‚îÇ ‚Üê B d√©borde
  ‚îÇ  ‚îÇ B ‚îÇ  ‚îÇ              ‚îÇ  ‚ïë  ‚ïë   ‚îÇ
  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ              ‚îÇ  ‚ïö‚ïê‚ïê‚ïê   ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

ST_Contains(A,B): TRUE    ST_Contains(A,B): FALSE
ST_Within(B,A):   TRUE    ST_Within(B,A):   FALSE
ST_Intersects(A,B): TRUE  ST_Intersects(A,B): TRUE
```

**Exemple pratique** :
```sql
-- Trouver TOUS les restaurants dans un arrondissement
-- Utiliser ST_Contains (pas ST_Intersects)
SELECT r.nom
FROM restaurants r
JOIN arrondissements a ON ST_Contains(a.zone, r.position)
WHERE a.nom = '5e arrondissement';

-- √âquivalent avec ST_Within
SELECT r.nom
FROM restaurants r
JOIN arrondissements a ON ST_Within(r.position, a.zone)
WHERE a.nom = '5e arrondissement';
```

### ST_Overlaps

**ST_Overlaps** : "A et B se chevauchent partiellement" (ni l'un ne contient l'autre compl√®tement).

```sql
-- Deux parcelles se chevauchent-elles partiellement ?
SELECT ST_Overlaps(
    ST_MakeEnvelope(2.35, 48.85, 2.37, 48.87, 4326),
    ST_MakeEnvelope(2.36, 48.86, 2.38, 48.88, 4326)
);  -- TRUE (elles se chevauchent)
```

**Diff√©rence avec ST_Intersects** :
- ST_Intersects : TRUE si A et B partagent au moins un point
- ST_Overlaps : TRUE seulement si A et B se chevauchent **partiellement** (pas de contenance compl√®te)

### ST_Touches

**ST_Touches** : "A et B se touchent mais ne se chevauchent pas".

```sql
-- Deux parcelles adjacentes
SELECT ST_Touches(
    ST_MakeEnvelope(2.35, 48.85, 2.36, 48.86, 4326),
    ST_MakeEnvelope(2.36, 48.85, 2.37, 48.86, 4326)
);  -- TRUE (elles partagent un bord)
```

**Visualisation** :
```
ST_Touches = TRUE :        ST_Touches = FALSE :
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  A  ‚îÇ  B  ‚îÇ              ‚îÇ  A  ‚îÇ  ‚îÇ  B  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Bord partag√©               S√©par√©s

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    A    ‚îÇ                ‚îÇ   ‚ïî‚ïê‚ïê‚ïê  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ                ‚îÇ   ‚ïë B ‚ïë ‚îÇ
‚îÇ  ‚îÇ B ‚îÇ  ‚îÇ                ‚îÇ   ‚ïö‚ïê‚ïê‚ïê  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                A contient B (pas touch)
B √† l'int√©rieur
```

### ST_Crosses

**ST_Crosses** : "A croise B" (utilis√© principalement pour lignes).

```sql
-- Une route croise-t-elle une rivi√®re ?
WITH route AS (
    SELECT ST_MakeLine(ARRAY[
        ST_MakePoint(2.35, 48.85),
        ST_MakePoint(2.37, 48.87)
    ]) AS trace
),
riviere AS (
    SELECT ST_MakeLine(ARRAY[
        ST_MakePoint(2.34, 48.86),
        ST_MakePoint(2.38, 48.86)
    ]) AS trace
)
SELECT ST_Crosses(route.trace, riviere.trace) AS route_traverse_riviere
FROM route, riviere;
```

### ST_Disjoint

**ST_Disjoint** : "A et B sont compl√®tement s√©par√©s" (oppos√© de ST_Intersects).

```sql
-- Parcelles qui NE touchent PAS une zone dangereuse
SELECT p.reference
FROM parcelles p
CROSS JOIN zones_dangereuses zd
WHERE ST_Disjoint(p.geometrie, zd.zone);

-- √âquivalent √† :
WHERE NOT ST_Intersects(p.geometrie, zd.zone);
```

---

## 5. Op√©rations G√©om√©triques

Au-del√† des tests de relation, PostGIS permet de **cr√©er de nouvelles g√©om√©tries** √† partir d'op√©rations.

### ST_Buffer : Cr√©er une Zone Tampon

**ST_Buffer** cr√©e une zone autour d'une g√©om√©trie.

```sql
-- Zone de 500m autour d'un restaurant
SELECT
    nom,
    ST_Buffer(position::geography, 500)::geometry AS zone_livraison
FROM restaurants
WHERE nom = 'Le Bon Caf√©';
```

**Visualisation** :
```
     Point                Buffer(Point, 500m)
       ‚Ä¢                       ‚ï±‚îÄ‚îÄ‚îÄ‚ï≤
                              ‚îÇ  ‚Ä¢  ‚îÇ
                               ‚ï≤‚îÄ‚îÄ‚îÄ‚ï±
                             Cercle de 500m
```

**Utilisations pratiques** :
```sql
-- 1. Compter les restaurants dans un rayon de 1km
WITH point_interet AS (
    SELECT ST_MakePoint(2.3522, 48.8566)::geography AS pos
)
SELECT COUNT(*) AS nombre_restaurants
FROM restaurants r, point_interet poi
WHERE ST_Intersects(
    r.position::geography,
    ST_Buffer(poi.pos, 1000)
);

-- 2. Cr√©er des zones de s√©curit√© autour d'√©coles
SELECT
    e.nom AS ecole,
    ST_Buffer(e.position::geography, 200)::geometry AS zone_securite_200m
FROM ecoles e;
```

### ST_Intersection : Trouver la Partie Commune

**ST_Intersection** retourne la g√©om√©trie **commune** √† A et B.

```sql
-- Surface commune entre deux parcelles
WITH parcelle_a AS (
    SELECT ST_MakeEnvelope(2.35, 48.85, 2.37, 48.87, 4326) AS geom
),
parcelle_b AS (
    SELECT ST_MakeEnvelope(2.36, 48.86, 2.38, 48.88, 4326) AS geom
)
SELECT
    ST_AsText(ST_Intersection(pa.geom, pb.geom)) AS geometrie_commune,
    ST_Area(ST_Intersection(pa.geom, pb.geom)::geography) AS surface_commune_m2
FROM parcelle_a pa, parcelle_b pb
WHERE ST_Intersects(pa.geom, pb.geom);  -- Important : tester d'abord !
```

**Visualisation** :
```
Parcelle A:        Parcelle B:       Intersection:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         ‚îÇ        ‚îÇ         ‚îÇ          ‚îÇ X ‚îÇ ‚Üê Partie commune
‚îÇ    A    ‚îÇ   +    ‚îÇ    B    ‚îÇ   =      ‚îî‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### ST_Union : Fusionner des G√©om√©tries

**ST_Union** combine plusieurs g√©om√©tries en une seule.

```sql
-- Fusionner plusieurs parcelles adjacentes
SELECT
    proprietaire,
    ST_Union(geometrie) AS parcelle_totale,
    SUM(ST_Area(geometrie::geography)) AS surface_totale_m2
FROM parcelles
GROUP BY proprietaire;
```

**Visualisation** :
```
Parcelle 1 + Parcelle 2:        Union:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  1  ‚îÇ   ‚îÇ  2  ‚îÇ    ‚Üí      ‚îÇ   1 + 2   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### ST_Difference : Soustraire des G√©om√©tries

**ST_Difference** retourne la partie de A qui n'est **pas** dans B.

```sql
-- Parcelle A moins la zone constructible B
WITH parcelle AS (
    SELECT ST_MakeEnvelope(2.35, 48.85, 2.37, 48.87, 4326) AS geom
),
zone_constructible AS (
    SELECT ST_MakeEnvelope(2.36, 48.86, 2.38, 48.88, 4326) AS geom
)
SELECT
    ST_AsText(ST_Difference(p.geom, zc.geom)) AS zone_non_constructible,
    ST_Area(ST_Difference(p.geom, zc.geom)::geography) AS surface_m2
FROM parcelle p, zone_constructible zc;
```

**Visualisation** :
```
Parcelle A:        Zone B:           Difference(A, B):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         ‚îÇ   -    ‚îÇ    B    ‚îÇ   =   ‚îÇ A' ‚îÇ ‚Üê Partie de A hors de B
‚îÇ    A    ‚îÇ        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### ST_SymDifference : Diff√©rence Sym√©trique

**ST_SymDifference** retourne les parties de A et B qui ne se chevauchent **pas**.

```sql
-- Parties non communes entre deux zones
SELECT
    ST_SymDifference(zone_a.geom, zone_b.geom) AS difference_symetrique
FROM zone_a, zone_b;
```

**Visualisation** :
```
Zone A:            Zone B:           SymDifference:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îê
‚îÇ    A    ‚îÇ   ‚äï    ‚îÇ    B    ‚îÇ   =   ‚îÇA'‚îÇ  ‚îÇB'‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îò
Partie de A seule + Partie de B seule
```

---

## 6. Fonctions de Mesure

### ST_Area : Calculer la Surface

**ST_Area** calcule la surface d'un polygone.

```sql
-- Surface d'un arrondissement
SELECT
    nom,
    ST_Area(zone::geography) AS surface_m2,
    ROUND(ST_Area(zone::geography) / 1000000, 2) AS surface_km2
FROM arrondissements;
```

**‚ö†Ô∏è Attention** :
```sql
-- ‚ùå MAUVAIS : avec geometry, r√©sultat en degr√©s¬≤
SELECT ST_Area(ST_MakeEnvelope(2.35, 48.85, 2.36, 48.86, 4326));
-- R√©sultat : 0.0001 (degr√©s carr√©s, inutile)

-- ‚úÖ BON : avec geography, r√©sultat en m¬≤
SELECT ST_Area(ST_MakeEnvelope(2.35, 48.85, 2.36, 48.86, 4326)::geography);
-- R√©sultat : ~70,000,000 (m¬≤)
```

### ST_Length : Calculer la Longueur

**ST_Length** calcule la longueur d'une ligne.

```sql
-- Longueur d'une ligne de m√©tro
SELECT
    nom,
    ST_Length(trace::geography) AS longueur_metres,
    ROUND(ST_Length(trace::geography) / 1000, 2) AS longueur_km
FROM lignes_metro;
```

### ST_Perimeter : Calculer le P√©rim√®tre

**ST_Perimeter** calcule le p√©rim√®tre d'un polygone.

```sql
-- P√©rim√®tre d'une parcelle
SELECT
    reference,
    ST_Perimeter(geometrie::geography) AS perimetre_metres
FROM parcelles;
```

---

## 7. Fonctions de Transformation

### ST_Centroid : Trouver le Centre

**ST_Centroid** calcule le centre g√©om√©trique (centro√Øde) d'une g√©om√©trie.

```sql
-- Centre d'un arrondissement
SELECT
    nom,
    ST_AsText(ST_Centroid(zone)) AS centre_wkt,
    ST_X(ST_Centroid(zone)) AS longitude,
    ST_Y(ST_Centroid(zone)) AS latitude
FROM arrondissements;
```

**‚ö†Ô∏è Attention** : Le centro√Øde peut √™tre **en dehors** d'un polygone complexe (forme en U, etc.).

### ST_PointOnSurface : Point Garanti √† l'Int√©rieur

**ST_PointOnSurface** retourne un point **garanti** d'√™tre √† l'int√©rieur du polygone.

```sql
-- Point s√ªr √† l'int√©rieur d'une zone
SELECT
    nom,
    ST_AsText(ST_PointOnSurface(zone)) AS point_interieur
FROM arrondissements;
```

### ST_SimplifyPreserveTopology : Simplifier

**ST_SimplifyPreserveTopology** r√©duit le nombre de points d'une g√©om√©trie tout en pr√©servant la forme g√©n√©rale.

```sql
-- Simplifier une fronti√®re complexe
SELECT
    nom,
    ST_NPoints(geometrie) AS points_avant,
    ST_NPoints(ST_SimplifyPreserveTopology(geometrie, 0.001)) AS points_apres,
    ST_SimplifyPreserveTopology(geometrie, 0.001) AS geometrie_simplifiee
FROM frontieres_pays;
```

**Utilisation** : R√©duire la taille des donn√©es pour l'affichage web.

### ST_Transform : Changer de Syst√®me de Coordonn√©es

**ST_Transform** convertit une g√©om√©trie d'un SRID √† un autre.

```sql
-- WGS84 (4326) vers Lambert 93 (2154)
SELECT
    nom,
    ST_AsText(position) AS position_wgs84,
    ST_AsText(ST_Transform(position, 2154)) AS position_lambert93
FROM restaurants;
```

---

## 8. Requ√™tes Spatiales Avanc√©es

### Trouver le Top N le Plus Proche

```sql
-- Les 5 restaurants les plus proches d'une position
WITH ma_position AS (
    SELECT ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326) AS pos
)
SELECT
    r.nom,
    ST_Distance(r.position::geography, mp.pos::geography) AS distance_m,
    ROUND(ST_Distance(r.position::geography, mp.pos::geography)::numeric, 0) AS distance_arrondie
FROM restaurants r, ma_position mp
ORDER BY r.position <-> mp.pos  -- Utilise l'index
LIMIT 5;
```

### Recherche dans un Rectangle

```sql
-- Tous les restaurants dans un rectangle (bounding box)
SELECT nom, position
FROM restaurants
WHERE position && ST_MakeEnvelope(2.35, 48.85, 2.36, 48.86, 4326);
-- Tr√®s rapide car utilise directement l'index spatial
```

### Zones Tampons Multiples (Isochrones)

```sql
-- Cr√©er des zones de 500m, 1km, 2km autour d'un point
WITH centre AS (
    SELECT ST_MakePoint(2.3522, 48.8566)::geography AS pos
)
SELECT
    distance_km,
    ST_Buffer(pos, distance_km * 1000)::geometry AS zone
FROM centre
CROSS JOIN (VALUES (0.5), (1), (2)) AS t(distance_km);
```

### Compter les Points par Zone

```sql
-- Nombre de restaurants par arrondissement
SELECT
    a.nom AS arrondissement,
    COUNT(r.id) AS nombre_restaurants
FROM arrondissements a
LEFT JOIN restaurants r ON ST_Contains(a.zone, r.position)
GROUP BY a.nom
ORDER BY nombre_restaurants DESC;
```

### Densit√© Spatiale

```sql
-- Densit√© de restaurants (nombre par km¬≤)
SELECT
    a.nom AS arrondissement,
    COUNT(r.id) AS nombre_restaurants,
    ROUND(ST_Area(a.zone::geography) / 1000000, 2) AS surface_km2,
    ROUND(COUNT(r.id)::numeric / (ST_Area(a.zone::geography) / 1000000), 2) AS densite_par_km2
FROM arrondissements a
LEFT JOIN restaurants r ON ST_Contains(a.zone, r.position)
GROUP BY a.nom, a.zone
ORDER BY densite_par_km2 DESC;
```

### Route la Plus Courte (Simplifi√©e)

```sql
-- Distance totale d'un itin√©raire multi-√©tapes
WITH etapes AS (
    SELECT * FROM (VALUES
        (1, ST_MakePoint(2.3522, 48.8566)::geography),  -- √âtape 1
        (2, ST_MakePoint(2.3620, 48.8700)::geography),  -- √âtape 2
        (3, ST_MakePoint(2.3800, 48.8600)::geography)   -- √âtape 3
    ) AS t(ordre, position)
)
SELECT
    SUM(ST_Distance(
        e1.position,
        e2.position
    )) AS distance_totale_metres
FROM etapes e1
JOIN etapes e2 ON e2.ordre = e1.ordre + 1;
```

---

## 9. Bonnes Pratiques

### ‚úÖ Toujours Utiliser geography pour les Distances

```sql
-- ‚ùå MAUVAIS : geometry donne des degr√©s
SELECT ST_Distance(point1, point2);

-- ‚úÖ BON : geography donne des m√®tres
SELECT ST_Distance(point1::geography, point2::geography);
```

### ‚úÖ Filtrer avec ST_DWithin au Lieu de ST_Distance

```sql
-- ‚ùå LENT
SELECT * FROM restaurants
WHERE ST_Distance(position::geography, ref::geography) < 1000;

-- ‚úÖ RAPIDE
SELECT * FROM restaurants
WHERE ST_DWithin(position::geography, ref::geography, 1000);
```

### ‚úÖ Utiliser l'Op√©rateur && pour Pr√©-Filtrage

```sql
-- Utiliser && implicitement via les fonctions spatiales
SELECT * FROM parcelles
WHERE ST_Intersects(geometrie, zone_recherche);
-- PostgreSQL ajoute automatiquement : geometrie && zone_recherche

-- Ou explicitement pour des requ√™tes complexes
SELECT * FROM parcelles
WHERE geometrie && zone_recherche  -- Filtre rapide (index)
  AND ST_Area(ST_Intersection(geometrie, zone_recherche)) > 100;  -- Calcul pr√©cis
```

### ‚úÖ V√©rifier ST_Intersects Avant ST_Intersection

```sql
-- ‚ùå INEFFICACE : calcule l'intersection m√™me si vide
SELECT ST_Intersection(geom1, geom2) FROM ...;

-- ‚úÖ EFFICACE : teste d'abord, puis calcule
SELECT ST_Intersection(geom1, geom2)
FROM ...
WHERE ST_Intersects(geom1, geom2);  -- Filtre d'abord
```

### ‚úÖ Utiliser les Index Spatiaux

```sql
-- Cr√©er un index spatial
CREATE INDEX idx_restaurants_position
ON restaurants
USING GIST(position);

-- V√©rifier son utilisation
EXPLAIN ANALYZE
SELECT * FROM restaurants
WHERE ST_DWithin(position::geography, ref::geography, 1000);
```

### ‚úÖ Cast en geography pour Calculs M√©triques

```sql
-- Conversion explicite quand n√©cessaire
SELECT
    ST_Distance(pos1::geography, pos2::geography) AS distance_m,
    ST_Area(zone::geography) AS surface_m2,
    ST_Length(ligne::geography) AS longueur_m
FROM ...;
```

---

## 10. Tableau R√©capitulatif des Fonctions

### Fonctions de Distance

| Fonction | Description | Retour | Exemple |
|----------|-------------|--------|---------|
| `ST_Distance(geom1, geom2)` | Distance minimale | numeric | `ST_Distance(a, b)` |
| `ST_DWithin(geom1, geom2, dist)` | Distance < seuil | boolean | `ST_DWithin(a, b, 1000)` |
| `ST_DistanceSphere(geom1, geom2)` | Distance sur sph√®re | numeric | `ST_DistanceSphere(a, b)` |

### Fonctions de Relation

| Fonction | Description | Retour | Usage |
|----------|-------------|--------|-------|
| `ST_Intersects(A, B)` | A et B se touchent | boolean | G√©n√©ral |
| `ST_Contains(A, B)` | A contient B compl√®tement | boolean | Point dans polygone |
| `ST_Within(A, B)` | A est dans B | boolean | Inverse de Contains |
| `ST_Overlaps(A, B)` | A et B se chevauchent | boolean | Polygones |
| `ST_Touches(A, B)` | A et B se touchent (bords) | boolean | Adjacence |
| `ST_Crosses(A, B)` | A croise B | boolean | Lignes |
| `ST_Disjoint(A, B)` | A et B s√©par√©s | boolean | Non-intersection |

### Op√©rations G√©om√©triques

| Fonction | Description | Retour | Usage |
|----------|-------------|--------|-------|
| `ST_Buffer(geom, radius)` | Zone tampon | geometry | Zones de proximit√© |
| `ST_Intersection(A, B)` | Partie commune | geometry | Chevauchements |
| `ST_Union(geom1, geom2)` | Fusion | geometry | Combiner |
| `ST_Difference(A, B)` | A moins B | geometry | Soustraction |
| `ST_SymDifference(A, B)` | Parties non communes | geometry | XOR |

### Fonctions de Mesure

| Fonction | Description | Retour | Type |
|----------|-------------|--------|------|
| `ST_Area(geom)` | Surface | numeric | Polygon |
| `ST_Length(geom)` | Longueur | numeric | LineString |
| `ST_Perimeter(geom)` | P√©rim√®tre | numeric | Polygon |

### Fonctions de Transformation

| Fonction | Description | Retour | Usage |
|----------|-------------|--------|-------|
| `ST_Centroid(geom)` | Centre g√©om√©trique | geometry | Centre |
| `ST_PointOnSurface(geom)` | Point √† l'int√©rieur | geometry | Label placement |
| `ST_Simplify(geom, tol)` | Simplification | geometry | Optimisation |
| `ST_Transform(geom, srid)` | Changement SRID | geometry | Projection |

---

## 11. Cas d'Usage R√©els

### Application de Livraison

```sql
-- Trouver les restaurants qui livrent √† une adresse
WITH adresse_client AS (
    SELECT ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326)::geography AS pos
)
SELECT
    r.nom,
    r.zone_livraison_km,
    ST_Distance(r.position::geography, ac.pos) / 1000 AS distance_km,
    CASE
        WHEN ST_DWithin(
            r.position::geography,
            ac.pos,
            r.zone_livraison_km * 1000
        ) THEN 'Livraison disponible ‚úì'
        ELSE 'Hors zone ‚úó'
    END AS statut
FROM restaurants r, adresse_client ac
WHERE r.actif = true
  AND ST_DWithin(r.position::geography, ac.pos, 5000)  -- Pr√©-filtre 5km
ORDER BY distance_km
LIMIT 10;
```

### Analyse de Couverture R√©seau

```sql
-- Couverture 4G : zones sans signal
WITH antennes AS (
    SELECT position, portee_metres FROM antennes_4g WHERE actif = true
),
zones_couvertes AS (
    SELECT ST_Union(ST_Buffer(position::geography, portee_metres))::geometry AS couverture
    FROM antennes
),
territoire AS (
    SELECT geometrie FROM communes WHERE nom = 'Paris'
)
SELECT
    'Zone couverte' AS type,
    ST_Area(zc.couverture::geography) / 1000000 AS surface_km2
FROM zones_couvertes zc
UNION ALL
SELECT
    'Zone blanche' AS type,
    ST_Area(ST_Difference(t.geometrie, zc.couverture)::geography) / 1000000 AS surface_km2
FROM territoire t, zones_couvertes zc;
```

### Optimisation de Tourn√©es

```sql
-- Distance totale d'une tourn√©e de livraison
WITH tournee AS (
    SELECT * FROM (VALUES
        (1, ST_MakePoint(2.35, 48.85)::geography),
        (2, ST_MakePoint(2.36, 48.86)::geography),
        (3, ST_MakePoint(2.37, 48.87)::geography),
        (4, ST_MakePoint(2.38, 48.86)::geography)
    ) AS t(ordre, position)
)
SELECT
    t1.ordre AS de_etape,
    t2.ordre AS vers_etape,
    ROUND(ST_Distance(t1.position, t2.position)::numeric, 0) AS distance_m,
    SUM(ROUND(ST_Distance(t1.position, t2.position)::numeric, 0))
        OVER (ORDER BY t1.ordre) AS distance_cumulee_m
FROM tournee t1
JOIN tournee t2 ON t2.ordre = t1.ordre + 1
ORDER BY t1.ordre;
```

---

## 12. R√©sum√© et Aide-M√©moire

### Quand Utiliser Quelle Fonction ?

**Pour mesurer une distance** :
- `ST_Distance(a::geography, b::geography)` ‚Üí Distance en m√®tres
- `ST_DWithin(a::geography, b::geography, 1000)` ‚Üí Si distance < 1000m (plus rapide)

**Pour tester une relation** :
- Point dans zone : `ST_Contains(zone, point)` ou `ST_Within(point, zone)`
- Intersection quelconque : `ST_Intersects(a, b)`
- Chevauchement partiel : `ST_Overlaps(a, b)`
- Adjacence : `ST_Touches(a, b)`

**Pour cr√©er une nouvelle g√©om√©trie** :
- Zone tampon : `ST_Buffer(geom::geography, 500)` ‚Üí 500m autour
- Partie commune : `ST_Intersection(a, b)`
- Fusion : `ST_Union(a, b)`

**Pour mesurer** :
- Surface : `ST_Area(geom::geography)` ‚Üí m¬≤
- Longueur : `ST_Length(geom::geography)` ‚Üí m
- P√©rim√®tre : `ST_Perimeter(geom::geography)` ‚Üí m

### Erreurs Courantes √† √âviter

‚ùå **Oublier ::geography pour des distances en m√®tres**
```sql
-- Retourne des degr√©s (inutile)
ST_Distance(point1, point2)

-- Retourne des m√®tres (correct)
ST_Distance(point1::geography, point2::geography)
```

‚ùå **Utiliser ST_Distance pour filtrer au lieu de ST_DWithin**
```sql
-- Lent
WHERE ST_Distance(a, b) < 1000

-- Rapide
WHERE ST_DWithin(a, b, 1000)
```

‚ùå **Ne pas v√©rifier ST_Intersects avant ST_Intersection**
```sql
-- Peut g√©n√©rer des g√©om√©tries vides inutilement
SELECT ST_Intersection(a, b) FROM ...

-- Optimal
SELECT ST_Intersection(a, b) FROM ... WHERE ST_Intersects(a, b)
```

---

## Conclusion

Les fonctions spatiales sont le c≈ìur de PostGIS. **ST_Distance** et **ST_Intersects** sont les deux piliers √† ma√Ætriser absolument, car elles couvrent 80% des besoins courants :

- **ST_Distance** : "Quelle est la distance ?"
- **ST_Intersects** : "Est-ce que √ßa se touche ?"

√Ä partir de ces deux fonctions, vous pouvez construire des analyses spatiales tr√®s sophistiqu√©es. Les autres fonctions (ST_Contains, ST_Buffer, ST_Union, etc.) viennent enrichir votre bo√Æte √† outils pour des cas plus sp√©cifiques.

**Points cl√©s √† retenir** :
1. Toujours utiliser `::geography` pour des distances en m√®tres
2. Pr√©f√©rer `ST_DWithin` √† `ST_Distance` pour filtrer
3. Les index spatiaux sont essentiels pour la performance
4. Tester `ST_Intersects` avant des op√©rations co√ªteuses
5. PostGIS offre 400+ fonctions, mais 10-15 couvrent 90% des besoins

Avec ces fonctions spatiales, vous pouvez transformer PostgreSQL en un puissant moteur d'analyse g√©ographique !

---

**Ressources compl√©mentaires** :
- Documentation PostGIS (r√©f√©rence compl√®te) : https://postgis.net/docs/reference.html
- PostGIS Spatial Relationships : https://postgis.net/workshops/postgis-intro/spatial_relationships.html
- Cheat Sheet PostGIS : https://postgis.net/docs/PostGIS_FAQ.html

‚è≠Ô∏è [Full-Text Search Avanc√©](/18-extensions-et-integrations/03-full-text-search.md)
