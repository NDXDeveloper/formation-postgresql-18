üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.2.1. Types G√©om√©triques PostGIS : Point, LineString, Polygon

## Introduction

PostGIS est une extension PostgreSQL qui transforme votre base de donn√©es en un puissant syst√®me d'information g√©ographique (SIG). Elle permet de stocker, manipuler et analyser des donn√©es spatiales directement dans PostgreSQL.

Dans ce chapitre, nous allons d√©couvrir les trois types g√©om√©triques fondamentaux de PostGIS :
- **Point** : Pour repr√©senter une position pr√©cise
- **LineString** : Pour repr√©senter des lignes et des chemins
- **Polygon** : Pour repr√©senter des surfaces et des zones

> **Note pour d√©butants** : Avant d'utiliser PostGIS, vous devez installer l'extension dans votre base de donn√©es avec la commande `CREATE EXTENSION postgis;`

---

## 1. Le Type Point

### Qu'est-ce qu'un Point ?

Un **Point** repr√©sente une position unique dans l'espace, d√©finie par des coordonn√©es. C'est le type g√©om√©trique le plus simple et le plus courant.

**Exemples d'utilisation** :
- Localisation d'un restaurant, d'un h√¥tel
- Position GPS d'un utilisateur
- Emplacement d'un capteur IoT
- Adresse d'un client

### Structure d'un Point

Un point est d√©fini par :
- **X** (longitude) : position est-ouest
- **Y** (latitude) : position nord-sud
- Optionnellement **Z** (altitude) et **M** (mesure)

### Cr√©er un Point

Il existe plusieurs fa√ßons de cr√©er un point dans PostGIS :

#### M√©thode 1 : Avec ST_MakePoint()

```sql
-- Cr√©er un point simple (2D)
SELECT ST_MakePoint(-0.127758, 51.507351);  -- Coordonn√©es de Londres

-- Cr√©er un point avec altitude (3D)
SELECT ST_MakePoint(2.3522, 48.8566, 35);  -- Tour Eiffel (lon, lat, altitude)
```

#### M√©thode 2 : Avec ST_GeomFromText() (format WKT)

```sql
-- Format Well-Known Text (WKT)
SELECT ST_GeomFromText('POINT(-0.127758 51.507351)');

-- Avec sp√©cification du syst√®me de coordonn√©es (SRID 4326 = WGS84, utilis√© par GPS)
SELECT ST_GeomFromText('POINT(-0.127758 51.507351)', 4326);
```

#### M√©thode 3 : Avec ST_Point() (syntaxe courte)

```sql
-- Syntaxe simplifi√©e
SELECT ST_Point(-0.127758, 51.507351);
```

### Exemple pratique : Table de restaurants

```sql
-- Cr√©er une table de restaurants avec leur position
CREATE TABLE restaurants (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    adresse TEXT,
    position GEOMETRY(Point, 4326)  -- Point en WGS84
);

-- Ins√©rer des restaurants
INSERT INTO restaurants (nom, adresse, position) VALUES
    ('Le Bon Caf√©', '12 rue de Paris, Paris', ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326)),
    ('Pizza Roma', '45 avenue Mozart, Lyon', ST_SetSRID(ST_MakePoint(4.8357, 45.7640), 4326)),
    ('Sushi Express', '8 place Kl√©ber, Strasbourg', ST_SetSRID(ST_MakePoint(7.7521, 48.5734), 4326));

-- R√©cup√©rer les coordonn√©es
SELECT
    nom,
    ST_X(position) AS longitude,
    ST_Y(position) AS latitude
FROM restaurants;
```

### Op√©rations courantes sur les Points

```sql
-- Extraire les coordonn√©es
SELECT
    ST_X(position) AS longitude,
    ST_Y(position) AS latitude
FROM restaurants
WHERE nom = 'Le Bon Caf√©';

-- Convertir en texte lisible
SELECT
    nom,
    ST_AsText(position) AS position_wkt
FROM restaurants;

-- Convertir en GeoJSON
SELECT
    nom,
    ST_AsGeoJSON(position) AS position_geojson
FROM restaurants;
```

---

## 2. Le Type LineString

### Qu'est-ce qu'une LineString ?

Une **LineString** (cha√Æne de lignes) est une s√©quence ordonn√©e de points connect√©s qui forment une ligne. C'est une ligne continue qui peut √™tre droite ou courbe.

**Exemples d'utilisation** :
- Trajets routiers
- Rivi√®res et cours d'eau
- Lignes de m√©tro ou de bus
- Itin√©raires de randonn√©e
- C√¢bles √©lectriques

### Structure d'une LineString

Une LineString est compos√©e de :
- **Au minimum 2 points** (d√©but et fin)
- Une **s√©quence ordonn√©e** de points
- Les points sont connect√©s dans l'ordre

### Cr√©er une LineString

#### M√©thode 1 : Avec ST_MakeLine()

```sql
-- Cr√©er une ligne entre deux points
SELECT ST_MakeLine(
    ST_MakePoint(2.3522, 48.8566),  -- Point de d√©part
    ST_MakePoint(4.8357, 45.7640)   -- Point d'arriv√©e
);

-- Cr√©er une ligne avec plusieurs points
SELECT ST_MakeLine(ARRAY[
    ST_MakePoint(0, 0),
    ST_MakePoint(1, 1),
    ST_MakePoint(2, 1),
    ST_MakePoint(3, 2)
]);
```

#### M√©thode 2 : Avec ST_GeomFromText() (format WKT)

```sql
-- Format Well-Known Text
SELECT ST_GeomFromText('LINESTRING(0 0, 1 1, 2 1, 3 2)');

-- Avec SRID
SELECT ST_GeomFromText('LINESTRING(2.3522 48.8566, 4.8357 45.7640)', 4326);
```

### Exemple pratique : Table de lignes de m√©tro

```sql
-- Cr√©er une table de lignes de m√©tro
CREATE TABLE lignes_metro (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(50),
    numero INTEGER,
    couleur VARCHAR(20),
    trac√© GEOMETRY(LineString, 4326)
);

-- Ins√©rer une ligne de m√©tro (simplifi√©e)
INSERT INTO lignes_metro (nom, numero, couleur, trac√©) VALUES
    ('Ligne 1', 1, 'Jaune', ST_GeomFromText(
        'LINESTRING(2.2945 48.8582, 2.3384 48.8607, 2.3766 48.8533)', 4326
    )),
    ('Ligne 4', 4, 'Violet', ST_GeomFromText(
        'LINESTRING(2.3263 48.8336, 2.3488 48.8534, 2.3598 48.8838)', 4326
    ));

-- Calculer la longueur d'une ligne (en m√®tres)
SELECT
    nom,
    ST_Length(trac√©::geography) AS longueur_metres
FROM lignes_metro;

-- Compter le nombre de stations (points) sur une ligne
SELECT
    nom,
    ST_NPoints(trac√©) AS nombre_points
FROM lignes_metro;
```

### Op√©rations courantes sur les LineStrings

```sql
-- Obtenir le point de d√©part d'une ligne
SELECT
    nom,
    ST_AsText(ST_StartPoint(trac√©)) AS point_depart
FROM lignes_metro;

-- Obtenir le point d'arriv√©e d'une ligne
SELECT
    nom,
    ST_AsText(ST_EndPoint(trac√©)) AS point_arrivee
FROM lignes_metro;

-- Obtenir un point sp√©cifique sur la ligne (le 2√®me point)
SELECT
    nom,
    ST_AsText(ST_PointN(trac√©, 2)) AS deuxieme_point
FROM lignes_metro;

-- Simplifier une ligne complexe (r√©duire le nombre de points)
SELECT
    nom,
    ST_Simplify(trac√©, 0.001) AS trac√©_simplifi√©
FROM lignes_metro;
```

---

## 3. Le Type Polygon

### Qu'est-ce qu'un Polygon ?

Un **Polygon** (polygone) repr√©sente une surface ferm√©e d√©limit√©e par une ou plusieurs lignes. C'est une zone avec des fronti√®res d√©finies.

**Exemples d'utilisation** :
- Fronti√®res administratives (pays, r√©gions, communes)
- Parcelles cadastrales
- Zones de livraison
- Lacs, parcs, for√™ts
- Zones dangereuses ou restreintes

### Structure d'un Polygon

Un Polygon est compos√© de :
- **Un anneau ext√©rieur** (exterior ring) : d√©finit la fronti√®re principale
- **Z√©ro ou plusieurs anneaux int√©rieurs** (interior rings) : d√©finissent des "trous"
- Les anneaux doivent √™tre **ferm√©s** (premier point = dernier point)
- L'ordre des points : **sens antihoraire** pour l'ext√©rieur, **horaire** pour les trous

### Cr√©er un Polygon

#### M√©thode 1 : Avec ST_MakePolygon()

```sql
-- Cr√©er un polygone carr√© simple
SELECT ST_MakePolygon(
    ST_GeomFromText('LINESTRING(0 0, 0 1, 1 1, 1 0, 0 0)')
);

-- Cr√©er un polygone avec un trou (donut)
SELECT ST_MakePolygon(
    ST_GeomFromText('LINESTRING(0 0, 0 4, 4 4, 4 0, 0 0)'),  -- Ext√©rieur
    ARRAY[ST_GeomFromText('LINESTRING(1 1, 1 3, 3 3, 3 1, 1 1)')]  -- Trou int√©rieur
);
```

#### M√©thode 2 : Avec ST_GeomFromText() (format WKT)

```sql
-- Polygone simple (triangle)
SELECT ST_GeomFromText('POLYGON((0 0, 0 1, 1 1, 0 0))');

-- Polygone avec trou
SELECT ST_GeomFromText('POLYGON((0 0, 0 4, 4 4, 4 0, 0 0), (1 1, 1 3, 3 3, 3 1, 1 1))');
```

### Exemple pratique : Table de zones administratives

```sql
-- Cr√©er une table d'arrondissements
CREATE TABLE arrondissements (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    code_postal VARCHAR(10),
    population INTEGER,
    zone GEOMETRY(Polygon, 4326)
);

-- Ins√©rer un arrondissement (simplifi√©, forme rectangulaire)
INSERT INTO arrondissements (nom, code_postal, population, zone) VALUES
    ('1er arrondissement', '75001', 16888, ST_GeomFromText(
        'POLYGON((2.337 48.861, 2.337 48.866, 2.345 48.866, 2.345 48.861, 2.337 48.861))', 4326
    )),
    ('5e arrondissement', '75005', 58850, ST_GeomFromText(
        'POLYGON((2.340 48.841, 2.340 48.853, 2.358 48.853, 2.358 48.841, 2.340 48.841))', 4326
    ));

-- Calculer la superficie d'une zone (en m√®tres carr√©s)
SELECT
    nom,
    ST_Area(zone::geography) AS superficie_m2,
    ROUND(ST_Area(zone::geography) / 1000000, 2) AS superficie_km2
FROM arrondissements;

-- Calculer le p√©rim√®tre d'une zone
SELECT
    nom,
    ST_Perimeter(zone::geography) AS perimetre_metres
FROM arrondissements;
```

### Op√©rations courantes sur les Polygons

```sql
-- Obtenir le centro√Øde (centre g√©om√©trique) d'une zone
SELECT
    nom,
    ST_AsText(ST_Centroid(zone)) AS centre
FROM arrondissements;

-- V√©rifier si un point est dans une zone
SELECT
    nom
FROM arrondissements
WHERE ST_Contains(
    zone,
    ST_SetSRID(ST_MakePoint(2.3488, 48.8534), 4326)
);

-- Cr√©er une zone tampon (buffer) autour d'un polygone
-- Attention : utiliser geography pour des distances en m√®tres
SELECT
    nom,
    ST_Buffer(zone::geography, 500)::geometry AS zone_etendue_500m
FROM arrondissements;

-- Trouver l'intersection entre deux zones
SELECT
    a1.nom AS zone1,
    a2.nom AS zone2,
    ST_Area(ST_Intersection(a1.zone, a2.zone)::geography) AS aire_intersection
FROM arrondissements a1
CROSS JOIN arrondissements a2
WHERE a1.id < a2.id
  AND ST_Intersects(a1.zone, a2.zone);
```

---

## 4. Concepts Transversaux

### Le Syst√®me de R√©f√©rence Spatial (SRID)

Le **SRID** (Spatial Reference System Identifier) d√©finit le syst√®me de coordonn√©es utilis√©.

**Les SRID les plus courants** :
- **4326** : WGS84 (utilis√© par GPS) - coordonn√©es en longitude/latitude
- **3857** : Web Mercator (utilis√© par Google Maps, OpenStreetMap)
- **2154** : Lambert 93 (syst√®me officiel fran√ßais)

```sql
-- D√©finir le SRID lors de la cr√©ation
SELECT ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326);

-- V√©rifier le SRID d'une g√©om√©trie
SELECT ST_SRID(position) FROM restaurants;

-- Transformer d'un SRID √† un autre
SELECT ST_Transform(
    ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326),  -- WGS84
    3857  -- Vers Web Mercator
);
```

### Diff√©rence entre geometry et geography

PostGIS propose deux types de donn√©es spatiales :

#### geometry
- Calculs sur un **plan cart√©sien** (2D plat)
- Plus **rapide**
- Moins **pr√©cis** pour de grandes distances
- Coordonn√©es : unit√©s abstraites (degr√©s pour WGS84)

```sql
-- Avec geometry : distance en degr√©s (peu utile)
SELECT ST_Distance(
    ST_MakePoint(0, 0),
    ST_MakePoint(1, 1)
);  -- R√©sultat : environ 1.41 (degr√©s)
```

#### geography
- Calculs sur une **sph√®re** (mod√®le de la Terre)
- Plus **lent**
- Plus **pr√©cis** pour de grandes distances
- Distances : en **m√®tres**

```sql
-- Avec geography : distance en m√®tres (pr√©cis)
SELECT ST_Distance(
    ST_MakePoint(0, 0)::geography,
    ST_MakePoint(1, 1)::geography
);  -- R√©sultat : environ 157 000 m√®tres
```

**Recommandation** : Utilisez `geography` pour des calculs de distance et de surface pr√©cis.

### Validation des G√©om√©tries

Il est important de s'assurer que vos g√©om√©tries sont valides.

```sql
-- V√©rifier si une g√©om√©trie est valide
SELECT ST_IsValid(zone) FROM arrondissements;

-- Obtenir la raison de l'invalidit√©
SELECT
    nom,
    ST_IsValidReason(zone) AS raison
FROM arrondissements
WHERE NOT ST_IsValid(zone);

-- R√©parer une g√©om√©trie invalide
SELECT ST_MakeValid(zone) FROM arrondissements;
```

---

## 5. Requ√™tes Spatiales Courantes

### Recherche de proximit√©

Trouver tous les restaurants √† moins de 1 km d'un point :

```sql
SELECT
    nom,
    ST_Distance(
        position::geography,
        ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326)::geography
    ) AS distance_metres
FROM restaurants
WHERE ST_DWithin(
    position::geography,
    ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326)::geography,
    1000  -- 1000 m√®tres
)
ORDER BY distance_metres;
```

### Recherche dans une zone

Trouver tous les restaurants dans un arrondissement :

```sql
SELECT r.nom AS restaurant, a.nom AS arrondissement
FROM restaurants r
JOIN arrondissements a ON ST_Contains(a.zone, r.position)
WHERE a.nom = '1er arrondissement';
```

### Intersection de zones

Trouver les lignes de m√©tro qui traversent un arrondissement :

```sql
SELECT DISTINCT lm.nom AS ligne, a.nom AS arrondissement
FROM lignes_metro lm
JOIN arrondissements a ON ST_Intersects(lm.trac√©, a.zone)
WHERE a.nom = '5e arrondissement';
```

### Trouver le restaurant le plus proche

```sql
-- Restaurant le plus proche d'une position donn√©e
SELECT
    nom,
    ST_Distance(
        position::geography,
        ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326)::geography
    ) AS distance_metres
FROM restaurants
ORDER BY position <-> ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326)
LIMIT 1;
```

---

## 6. Formats d'Import/Export

### WKT (Well-Known Text)

Format texte lisible par l'humain :

```sql
-- Export en WKT
SELECT ST_AsText(position) FROM restaurants;
-- R√©sultat : 'POINT(2.3522 48.8566)'

-- Import depuis WKT
SELECT ST_GeomFromText('POINT(2.3522 48.8566)', 4326);
```

### WKB (Well-Known Binary)

Format binaire compact, utilis√© pour les √©changes :

```sql
-- Export en WKB (hexad√©cimal)
SELECT ST_AsEWKB(position) FROM restaurants;

-- Import depuis WKB
SELECT ST_GeomFromWKB('\x01010000000000...');
```

### GeoJSON

Format JSON standard pour les donn√©es g√©ographiques :

```sql
-- Export en GeoJSON
SELECT ST_AsGeoJSON(position) FROM restaurants;
-- R√©sultat : {"type":"Point","coordinates":[2.3522,48.8566]}

-- Import depuis GeoJSON
SELECT ST_GeomFromGeoJSON('{"type":"Point","coordinates":[2.3522,48.8566]}');
```

### KML (Google Earth)

```sql
-- Export en KML
SELECT ST_AsKML(position) FROM restaurants;
```

---

## 7. Bonnes Pratiques

### 1. Toujours d√©finir un SRID

```sql
-- ‚úÖ BON
CREATE TABLE lieux (
    id SERIAL PRIMARY KEY,
    position GEOMETRY(Point, 4326)  -- SRID explicite
);

-- ‚ùå MAUVAIS
CREATE TABLE lieux (
    id SERIAL PRIMARY KEY,
    position GEOMETRY  -- SRID non d√©fini
);
```

### 2. Cr√©er des index spatiaux

Les index spatiaux (GiST) acc√©l√®rent consid√©rablement les requ√™tes spatiales :

```sql
-- Cr√©er un index spatial sur une colonne g√©om√©trique
CREATE INDEX idx_restaurants_position ON restaurants USING GIST(position);
CREATE INDEX idx_arrondissements_zone ON arrondissements USING GIST(zone);
```

### 3. Utiliser geography pour les distances pr√©cises

```sql
-- ‚úÖ BON : distance en m√®tres, pr√©cise
SELECT ST_Distance(
    point1::geography,
    point2::geography
);

-- ‚ùå MOINS BON : distance en degr√©s, peu utile
SELECT ST_Distance(point1, point2);
```

### 4. Valider les g√©om√©tries avant insertion

```sql
-- Ajouter une contrainte de validation
ALTER TABLE arrondissements
ADD CONSTRAINT zone_valide CHECK (ST_IsValid(zone));
```

### 5. Optimiser les requ√™tes avec des bo√Ætes englobantes

Pour les requ√™tes complexes, filtrer d'abord avec `&&` (op√©rateur de bo√Æte englobante) :

```sql
-- Plus rapide car utilise l'index spatial
SELECT * FROM restaurants
WHERE position && ST_MakeEnvelope(2.3, 48.8, 2.4, 48.9, 4326)
  AND ST_DWithin(position::geography, point_reference::geography, 1000);
```

---

## 8. R√©sum√© des Fonctions Essentielles

### Cr√©ation de g√©om√©tries

| Fonction | Description | Exemple |
|----------|-------------|---------|
| `ST_MakePoint(x, y)` | Cr√©e un point | `ST_MakePoint(2.35, 48.85)` |
| `ST_MakeLine(geom1, geom2)` | Cr√©e une ligne | `ST_MakeLine(point1, point2)` |
| `ST_MakePolygon(linestring)` | Cr√©e un polygone | `ST_MakePolygon(ring)` |
| `ST_GeomFromText(wkt, srid)` | Depuis WKT | `ST_GeomFromText('POINT(2 48)', 4326)` |
| `ST_SetSRID(geom, srid)` | D√©finit le SRID | `ST_SetSRID(geom, 4326)` |

### Analyse de g√©om√©tries

| Fonction | Description | Type(s) |
|----------|-------------|---------|
| `ST_X(point)` | Coordonn√©e X | Point |
| `ST_Y(point)` | Coordonn√©e Y | Point |
| `ST_Length(geom)` | Longueur | LineString |
| `ST_Area(geom)` | Superficie | Polygon |
| `ST_Perimeter(geom)` | P√©rim√®tre | Polygon |
| `ST_NPoints(geom)` | Nombre de points | Tous |
| `ST_Centroid(geom)` | Centre g√©om√©trique | Tous |

### Relations spatiales

| Fonction | Description |
|----------|-------------|
| `ST_Contains(geom1, geom2)` | geom1 contient geom2 |
| `ST_Within(geom1, geom2)` | geom1 est dans geom2 |
| `ST_Intersects(geom1, geom2)` | geom1 et geom2 se croisent |
| `ST_Disjoint(geom1, geom2)` | geom1 et geom2 ne se touchent pas |
| `ST_Distance(geom1, geom2)` | Distance entre deux g√©om√©tries |
| `ST_DWithin(geom1, geom2, dist)` | Distance < dist |

### Op√©rations spatiales

| Fonction | Description |
|----------|-------------|
| `ST_Buffer(geom, radius)` | Zone tampon autour de geom |
| `ST_Intersection(geom1, geom2)` | Partie commune |
| `ST_Union(geom1, geom2)` | Fusion |
| `ST_Difference(geom1, geom2)` | Diff√©rence |
| `ST_Transform(geom, srid)` | Change de SRID |

### Export

| Fonction | Description |
|----------|-------------|
| `ST_AsText(geom)` | Vers WKT |
| `ST_AsGeoJSON(geom)` | Vers GeoJSON |
| `ST_AsKML(geom)` | Vers KML |

---

## Conclusion

Les types g√©om√©triques Point, LineString et Polygon sont les fondations de PostGIS. Ils vous permettent de :

- **Stocker** des donn√©es spatiales de mani√®re structur√©e
- **Interroger** des positions, trajets et zones
- **Analyser** des relations spatiales (proximit√©, intersection, contenance)
- **Optimiser** avec des index spatiaux

**Points cl√©s √† retenir** :
1. Un **Point** = une position unique
2. Une **LineString** = une s√©quence de points connect√©s
3. Un **Polygon** = une surface ferm√©e
4. Toujours d√©finir un **SRID** explicite
5. Cr√©er des **index spatiaux** (GiST) pour la performance
6. Utiliser **geography** pour des distances pr√©cises en m√®tres

Dans les prochains chapitres, vous d√©couvrirez les index spatiaux et les fonctions spatiales avanc√©es qui exploitent pleinement ces types g√©om√©triques.

---

**Ressources compl√©mentaires** :
- Documentation officielle PostGIS : https://postgis.net/docs/
- SRID Reference : https://epsg.io/
- GeoJSON Specification : https://geojson.org/

‚è≠Ô∏è [Index spatiaux (GiST, SP-GiST)](/18-extensions-et-integrations/02.2-index-spatiaux.md)
