üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.7.5. pg_repack : R√©organisation Sans Verrous dans PostgreSQL

## Introduction

**pg_repack** est une extension PostgreSQL qui permet de **r√©organiser** et **compacter** des tables et index **en ligne**, c'est-√†-dire **sans bloquer** les op√©rations de lecture et d'√©criture pendant le processus. C'est une alternative moderne et s√ªre √† `VACUUM FULL` et `CLUSTER`.

### Le Probl√®me : Le Bloat (Gonflement) des Tables

Au fil du temps, les tables PostgreSQL peuvent devenir **gonfl√©es** (bloated) √† cause du fonctionnement de MVCC (Multiversion Concurrency Control).

#### Qu'est-ce que le Bloat ?

Le **bloat** est l'accumulation d'espace mort (dead space) dans une table ou un index :

```
Table au d√©part (10 000 lignes, 1 Mo)
‚îú‚îÄ Donn√©es utiles : 100%
‚îî‚îÄ Espace mort : 0%

Apr√®s 1 an d'UPDATE/DELETE (toujours 10 000 lignes visibles)
‚îú‚îÄ Donn√©es utiles : 40%  ‚Üê Seulement 400 Ko de donn√©es utiles
‚îî‚îÄ Espace mort : 60%     ‚Üê 600 Ko d'anciennes versions et trous
                           Taille totale : 2.5 Mo au lieu de 1 Mo
```

**Pourquoi le bloat se produit-il ?**

PostgreSQL utilise MVCC (voir tutoriel sur les transactions). Quand vous faites un `UPDATE` ou `DELETE` :

1. **UPDATE** : L'ancienne ligne n'est pas supprim√©e imm√©diatement, une nouvelle version est cr√©√©e
2. **DELETE** : La ligne est marqu√©e comme supprim√©e mais reste physiquement pr√©sente
3. **VACUUM** : Nettoie l'espace mort, mais ne le rend pas au syst√®me d'exploitation

**Cons√©quence** : La table occupe plus d'espace que n√©cessaire, ce qui ralentit :
- Les scans s√©quentiels (plus de pages √† lire)
- Les sauvegardes (plus de donn√©es √† copier)
- La r√©plication (plus de WAL √† transf√©rer)

**Analogie** : Imaginez une biblioth√®que o√π vous ne jetez jamais les vieux livres, vous les marquez juste comme "obsol√®te" et ajoutez les nouvelles versions sur de nouvelles √©tag√®res. Avec le temps, la biblioth√®que devient √©norme et il faut marcher longtemps pour trouver les livres actuels.

### Les Solutions Traditionnelles (Imparfaites)

#### 1. VACUUM (normal)

```sql
VACUUM customers;
```

**Ce que √ßa fait** :
- Nettoie l'espace mort
- Marque l'espace comme r√©utilisable
- **Ne rend PAS l'espace au syst√®me d'exploitation**
- N'optimise pas l'ordre des donn√©es

**Avantage** : Pas de verrous exclusifs, fonctionne en ligne
**Inconv√©nient** : Ne r√©duit pas la taille du fichier de la table

#### 2. VACUUM FULL

```sql
VACUUM FULL customers;
```

**Ce que √ßa fait** :
- Reconstruit compl√®tement la table
- √âlimine tout le bloat
- Rend l'espace au syst√®me d'exploitation

**Avantage** : Compactage maximal
**Inconv√©nients** :
- ‚ùå **Verrou exclusif (ACCESS EXCLUSIVE)** : Bloque TOUTES les op√©rations (SELECT, INSERT, UPDATE, DELETE)
- ‚ùå Tr√®s lent sur grandes tables (peut prendre des heures)
- ‚ùå N√©cessite 2√ó l'espace disque temporairement
- ‚ùå Inutilisable en production pour des tables actives

#### 3. CLUSTER

```sql
CLUSTER customers USING idx_customers_pk;
```

**Ce que √ßa fait** :
- R√©organise physiquement la table selon un index
- √âlimine le bloat
- Optimise l'ordre des donn√©es (am√©liore les scans s√©quentiels)

**Avantages** : Compactage + optimisation de l'ordre
**Inconv√©nients** :
- ‚ùå **Verrou exclusif** : M√™me probl√®me que VACUUM FULL
- ‚ùå Tr√®s lent
- ‚ùå Inutilisable en production

### La Solution : pg_repack

**pg_repack** fait la m√™me chose que `VACUUM FULL` ou `CLUSTER`, mais **sans bloquer** l'application :

- ‚úÖ **Pas de verrou exclusif** : Les SELECT, INSERT, UPDATE, DELETE continuent pendant le repack
- ‚úÖ **En ligne** : Transparence totale pour l'application
- ‚úÖ **S√ªr** : M√©canisme transactionnel, rollback en cas d'erreur
- ‚úÖ **Efficace** : Compactage complet et r√©organisation
- ‚úÖ **Flexible** : Peut r√©organiser tables, index, ou les deux

**Limitation** : N√©cessite un verrou exclusif tr√®s bref (quelques millisecondes) au d√©but et √† la fin.

---

## Architecture et Fonctionnement

### Comment pg_repack Fonctionne-t-il ?

pg_repack utilise une approche en **plusieurs phases** pour r√©organiser une table tout en maintenant la disponibilit√©.

#### Phase 1 : Pr√©paration (Verrou Bref)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Table Originale: customers     ‚îÇ
‚îÇ  (10 000 lignes, 2.5 Mo bloat)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì
[Verrou bref ~1-2 ms]
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Cr√©ation de triggers           ‚îÇ
‚îÇ  - INSERT trigger               ‚îÇ
‚îÇ  - UPDATE trigger               ‚îÇ
‚îÇ  - DELETE trigger               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Objectif** : Installer des triggers pour capturer toutes les modifications pendant la copie.

#### Phase 2 : Copie des Donn√©es (Sans Verrou)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Table Originale: customers     ‚îÇ
‚îÇ  (L'application continue √†      ‚îÇ
‚îÇ   lire/√©crire normalement)      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì [Copie progressive]
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Table Temporaire: repack_xxx   ‚îÇ
‚îÇ  (Donn√©es compact√©es)           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         +
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Table de Log: repack_log_xxx   ‚îÇ
‚îÇ  (Capture toutes les modifs     ‚îÇ
‚îÇ   pendant la copie via triggers)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Pendant cette phase** :
- pg_repack copie toutes les donn√©es de la table originale vers une table temporaire
- Les triggers capturent toutes les modifications (INSERT/UPDATE/DELETE) dans une table de log
- **Aucun verrou exclusif** : L'application fonctionne normalement

#### Phase 3 : Application des Modifications (Sans Verrou)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Table Temporaire: repack_xxx    ‚îÇ
‚îÇ  (Donn√©es compact√©es + initiales)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì [Application du log]
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Table Temporaire: repack_xxx   ‚îÇ
‚îÇ  (Donn√©es √† jour et compact√©es) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Objectif** : Rejouer toutes les modifications captur√©es dans le log pour que la table temporaire soit √† jour.

#### Phase 4 : Swap Final (Verrou Bref)

```
[Verrou exclusif bref ~10-100 ms]
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Swap des tables                ‚îÇ
‚îÇ  - Table temporaire ‚Üí customers ‚îÇ
‚îÇ  - customers ‚Üí old_customers    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Nouvelle Table: customers       ‚îÇ
‚îÇ  (10 000 lignes, 1 Mo, compact√©e)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì
[Suppression de l'ancienne table]
```

**Objectif** : √âchanger atomiquement les tables. L'ancienne table devient la nouvelle.

**Verrou exclusif** : N√©cessaire pour garantir la coh√©rence, mais tr√®s bref (quelques dizaines de ms).

### Sch√©ma R√©capitulatif

```
Timeline:
‚îÇ
‚îú‚îÄ T0: D√©but pg_repack
‚îÇ  ‚îî‚îÄ Verrou exclusif: 1-2 ms (cr√©ation triggers)
‚îÇ
‚îú‚îÄ T0+1s √† T0+1h: Copie des donn√©es
‚îÇ  ‚îî‚îÄ Aucun verrou, application fonctionne normalement
‚îÇ  ‚îî‚îÄ Les modifications sont logu√©es via triggers
‚îÇ
‚îú‚îÄ T0+1h: Application des logs
‚îÇ  ‚îî‚îÄ Aucun verrou, rattrapage des modifications
‚îÇ
‚îú‚îÄ T0+1h+5min: Swap final
‚îÇ  ‚îî‚îÄ Verrou exclusif: 10-100 ms (√©change des tables)
‚îÇ
‚îî‚îÄ T0+1h+6min: Fin, nettoyage
```

### D√©tails Techniques

**Triggers cr√©√©s par pg_repack** :

```sql
-- Trigger pour capturer les INSERT
CREATE TRIGGER repack_trigger_insert
AFTER INSERT ON customers
FOR EACH ROW EXECUTE FUNCTION repack_log_insert();

-- Trigger pour capturer les UPDATE
CREATE TRIGGER repack_trigger_update
AFTER UPDATE ON customers
FOR EACH ROW EXECUTE FUNCTION repack_log_update();

-- Trigger pour capturer les DELETE
CREATE TRIGGER repack_trigger_delete
AFTER DELETE ON customers
FOR EACH ROW EXECUTE FUNCTION repack_log_delete();
```

**Ces triggers** capturent toutes les modifications dans une table de log qui sera rejou√©e sur la table temporaire.

---

## Installation et Configuration

### Pr√©requis

- **PostgreSQL 9.4+** (id√©alement PostgreSQL 18)
- **Droits superutilisateur** : Pour l'installation de l'extension
- **Espace disque** : Environ 1.5√ó la taille de la table √† r√©organiser
- **Extension disponible** : Selon votre distribution PostgreSQL

### Processus d'Installation (Th√©orique)

#### √âtape 1 : Installer le binaire pg_repack

pg_repack est un **outil en ligne de commande**, pas juste une extension SQL.

**Sur Linux (Debian/Ubuntu)** :
```bash
sudo apt-get install postgresql-18-repack
```

**Sur Linux (RHEL/CentOS)** :
```bash
sudo yum install pg_repack18
```

**Compilation depuis les sources** :
```bash
git clone https://github.com/reorg/pg_repack.git
cd pg_repack
make
sudo make install
```

#### √âtape 2 : Cr√©er l'extension dans la base de donn√©es

```sql
-- Se connecter √† la base de donn√©es cible
CREATE EXTENSION pg_repack;
```

**V√©rification** :
```sql
-- V√©rifier que l'extension est active
SELECT * FROM pg_extension WHERE extname = 'pg_repack';

-- V√©rifier que le binaire est accessible
-- (depuis le shell)
pg_repack --version
```

#### √âtape 3 : Permissions

L'utilisateur qui ex√©cute pg_repack doit avoir :

```sql
-- Option 1 : Superutilisateur (recommand√© pour simplicit√©)
ALTER USER repack_user WITH SUPERUSER;

-- Option 2 : Permissions minimales (plus s√©curis√©)
GRANT USAGE ON SCHEMA public TO repack_user;
GRANT ALL ON ALL TABLES IN SCHEMA public TO repack_user;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO repack_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO repack_user;
```

**Note** : pg_repack n√©cessite des permissions √©lev√©es car il cr√©e des objets temporaires et modifie des m√©tadonn√©es.

---

## Utilisation de Base

### Syntaxe G√©n√©rale

pg_repack est un **outil en ligne de commande**, pas une commande SQL.

**Format** :
```bash
pg_repack [OPTIONS] [dbname]
```

### R√©organiser une Table Sp√©cifique

```bash
# Syntaxe de base
pg_repack -d mydatabase -t customers

# Avec utilisateur et h√¥te
pg_repack -h localhost -p 5432 -U postgres -d mydatabase -t customers

# Avec sch√©ma explicite
pg_repack -d mydatabase -t public.customers
```

**Options principales** :

| Option | Description |
|--------|-------------|
| `-d, --dbname` | Nom de la base de donn√©es |
| `-t, --table` | Nom de la table √† r√©organiser |
| `-h, --host` | H√¥te PostgreSQL (d√©faut: localhost) |
| `-p, --port` | Port PostgreSQL (d√©faut: 5432) |
| `-U, --username` | Utilisateur PostgreSQL |
| `-n, --schema` | Sch√©ma sp√©cifique |
| `-k, --no-superuser-check` | Ignorer la v√©rification superutilisateur |

### R√©organiser Plusieurs Tables

```bash
# Tables sp√©cifiques (s√©par√©es par des virgules)
pg_repack -d mydatabase -t customers,orders,products

# Toutes les tables d'un sch√©ma
pg_repack -d mydatabase -n public

# Toutes les tables de la base (attention : long !)
pg_repack -d mydatabase --all
```

### R√©organiser Uniquement les Index

Par d√©faut, pg_repack r√©organise la table ET ses index. Pour r√©organiser uniquement les index :

```bash
# R√©organiser uniquement les index d'une table
pg_repack -d mydatabase -t customers --only-indexes

# R√©organiser un index sp√©cifique
pg_repack -d mydatabase -i idx_customers_email
```

### R√©organiser avec CLUSTER (Ordre Physique)

Pour r√©organiser une table selon l'ordre d'un index (√©quivalent de CLUSTER) :

```bash
# R√©organiser selon un index
pg_repack -d mydatabase -t orders -o order_date

# √âquivalent de : CLUSTER orders USING idx_orders_date;
# Mais sans verrou exclusif !
```

**Avantage** : Am√©liore les performances des scans s√©quentiels et des requ√™tes range-based.

### Options Avanc√©es

```bash
# Mode verbeux (affiche les d√©tails)
pg_repack -d mydatabase -t customers --verbose

# Ex√©cution √† vide (dry-run, pour tester)
pg_repack -d mydatabase -t customers --dry-run

# Sp√©cifier un tablespace pour les tables temporaires
pg_repack -d mydatabase -t customers --tablespace fast_ssd

# Limiter le nombre de connexions
pg_repack -d mydatabase -t customers --jobs 2

# Attendre la fin des transactions en cours (au lieu d'√©chouer)
pg_repack -d mydatabase -t customers --wait-timeout 600  # 10 minutes
```

---

## Cas d'Usage D√©taill√©s

### 1. R√©duire le Bloat d'une Table Active

**Sc√©nario** : Table `orders` avec 50% de bloat, utilis√©e 24/7.

**Diagnostic** :

```sql
-- V√©rifier le bloat (requ√™te simplifi√©e)
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) as table_size,
    ROUND(100 * (pg_relation_size(schemaname||'.'||tablename)::numeric /
          NULLIF(pg_total_relation_size(schemaname||'.'||tablename), 0)), 2) as table_percent
FROM pg_tables
WHERE tablename = 'orders';

-- Estimer le bloat (extension pgstattuple recommand√©e)
CREATE EXTENSION IF NOT EXISTS pgstattuple;

SELECT
    schemaname,
    tablename,
    pg_size_pretty(table_len) as table_size,
    ROUND(dead_tuple_percent, 2) as dead_tuple_percent,
    pg_size_pretty(dead_tuple_len) as wasted_space
FROM pgstattuple('orders')
JOIN pg_tables ON pg_tables.schemaname = 'public' AND pg_tables.tablename = 'orders';
```

**R√©sultat hypoth√©tique** :
```
table_size: 5 GB
dead_tuple_percent: 48%
wasted_space: 2.4 GB
```

**Action** :

```bash
# R√©organiser la table avec pg_repack
pg_repack -h localhost -U postgres -d production -t orders --verbose

# R√©sultat attendu apr√®s repack :
# table_size: 2.6 GB (r√©duction de ~50%)
# dead_tuple_percent: 0%
```

**V√©rification post-repack** :

```sql
-- V√©rifier la taille apr√®s
SELECT pg_size_pretty(pg_total_relation_size('orders'));

-- V√©rifier qu'il n'y a plus de bloat
SELECT * FROM pgstattuple('orders');
```

### 2. R√©organiser pour Am√©liorer les Performances (CLUSTER-like)

**Sc√©nario** : Table `events` avec des requ√™tes fr√©quentes par plage de dates.

```sql
-- Requ√™te typique
SELECT * FROM events
WHERE event_date >= '2025-01-01'
  AND event_date < '2025-02-01';
```

**Probl√®me** : Les donn√©es ne sont pas ordonn√©es physiquement par `event_date`, causant des scans inefficaces.

**Solution** : R√©organiser la table selon l'ordre de `event_date`.

```bash
# Cr√©er d'abord un index si n√©cessaire
psql -d production -c "CREATE INDEX IF NOT EXISTS idx_events_date ON events(event_date);"

# R√©organiser selon cet index
pg_repack -d production -t events -o event_date --verbose
```

**Impact** :
- **Avant** : Scan s√©quentiel avec beaucoup d'I/O random
- **Apr√®s** : Scan s√©quentiel optimis√©, I/O s√©quentiel (plus rapide)

**V√©rification** :

```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM events
WHERE event_date >= '2025-01-01'
  AND event_date < '2025-02-01';

-- V√©rifier le nombre de buffers lus
-- Avant: shared buffers read: 50000
-- Apr√®s: shared buffers read: 15000 (am√©lioration ~70%)
```

### 3. Maintenance R√©guli√®re Automatis√©e

**Sc√©nario** : Maintenance hebdomadaire de tables critiques.

```bash
#!/bin/bash
# Script: weekly_repack.sh

DBNAME="production"
TABLES=("orders" "customers" "products")

for table in "${TABLES[@]}"; do
    echo "Repacking $table..."
    pg_repack -h localhost -U postgres -d $DBNAME -t $table --verbose

    if [ $? -eq 0 ]; then
        echo "$table: SUCCESS"
    else
        echo "$table: FAILED"
        # Envoyer une alerte
        send_alert "pg_repack failed for $table"
    fi
done
```

**Planification avec cron** :

```bash
# Ex√©cuter tous les dimanches √† 2h du matin
0 2 * * 0 /scripts/weekly_repack.sh >> /var/log/pg_repack.log 2>&1
```

**Ou avec pg_cron (depuis PostgreSQL)** :

```sql
-- Job pg_cron pour ex√©cuter pg_repack
SELECT cron.schedule(
    'weekly_repack_orders',
    '0 2 * * 0',  -- Dimanches √† 2h
    $$
    -- N√©cessite une fonction wrapper pour appeler pg_repack depuis SQL
    SELECT run_pg_repack_for_table('orders');
    $$
);
```

### 4. R√©organiser Apr√®s une Migration Massive

**Sc√©nario** : Apr√®s un import massif ou une migration, les tables ont un mauvais facteur de remplissage.

```bash
# Apr√®s un gros import
psql -d newdb -c "COPY orders FROM '/data/orders.csv' WITH CSV HEADER;"

# Statistiques obsol√®tes et bloat potentiel
psql -d newdb -c "ANALYZE orders;"

# R√©organiser pour optimiser
pg_repack -d newdb -t orders --verbose
```

### 5. R√©organiser une Table Partitionn√©e

**Important** : pg_repack peut r√©organiser chaque partition individuellement.

```sql
-- Lister les partitions
SELECT
    schemaname,
    tablename
FROM pg_tables
WHERE tablename LIKE 'orders_p%'
ORDER BY tablename;
```

```bash
# R√©organiser chaque partition
pg_repack -d production -t orders_p2024_01 --verbose
pg_repack -d production -t orders_p2024_02 --verbose
pg_repack -d production -t orders_p2024_03 --verbose

# Ou via un script
for partition in $(psql -d production -t -c "SELECT tablename FROM pg_tables WHERE tablename LIKE 'orders_p%'"); do
    pg_repack -d production -t $partition --verbose
done
```

**Note** : Ne pas r√©organiser la table parent, seulement les partitions.

---

## Surveillance et Monitoring

### Suivre la Progression de pg_repack

Pendant l'ex√©cution, pg_repack affiche sa progression (si `--verbose`) :

```
INFO: repacking table "public.customers"
INFO: Setting up workers...
INFO: [1/6] creating table to copy data
INFO: [2/6] copying rows
INFO: 500000 rows copied (5% complete)
INFO: 1000000 rows copied (10% complete)
...
INFO: [3/6] creating indexes
INFO: [4/6] applying log
INFO: [5/6] swapping relations
INFO: [6/6] dropping old tables
INFO: repack complete
```

### Monitorer Depuis PostgreSQL

Pendant le repack, observer l'activit√© :

```sql
-- Voir les processus pg_repack actifs
SELECT
    pid,
    usename,
    application_name,
    state,
    query,
    query_start,
    NOW() - query_start as duration
FROM pg_stat_activity
WHERE application_name LIKE '%repack%'
   OR query LIKE '%repack%';

-- Voir les verrous en attente
SELECT
    locktype,
    mode,
    granted,
    pid
FROM pg_locks
WHERE NOT granted;

-- Voir la taille des tables temporaires cr√©√©es par pg_repack
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename))
FROM pg_tables
WHERE tablename LIKE 'repack%'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

### M√©triques √† Surveiller

| M√©trique | Commande | Alerte si |
|----------|----------|-----------|
| **Dur√©e d'ex√©cution** | Via --verbose | > 4h (selon table) |
| **Espace disque** | `df -h` | < 20% libre |
| **Connexions actives** | `SELECT COUNT(*) FROM pg_stat_activity` | Proche de max_connections |
| **Verrous bloquants** | `SELECT * FROM pg_locks WHERE NOT granted` | > 0 pendant longtemps |
| **I/O** | `iostat -x 1` | Saturation disque |

---

## Bonnes Pratiques

### 1. Planifier les Repack Pendant les Heures Creuses

‚úÖ **Pourquoi** : Bien que pg_repack soit "online", il consomme des ressources (CPU, I/O, m√©moire).

‚úÖ **Quand** : Pendant les heures de faible activit√© (nuit, week-end).

**Exception** : Si le bloat est critique et affecte les performances, r√©organiser imm√©diatement.

### 2. V√©rifier l'Espace Disque Avant

‚úÖ **R√®gle** : Avoir au moins **1.5√ó la taille de la table** en espace libre.

```bash
# V√©rifier l'espace avant
df -h /var/lib/postgresql

# V√©rifier la taille de la table
psql -d production -c "SELECT pg_size_pretty(pg_total_relation_size('orders'));"
```

**Exemple** :
- Table `orders` : 100 GB
- Espace libre requis : ‚â• 150 GB

**Si insuffisant** : R√©organiser les tables les plus petites d'abord, ou lib√©rer de l'espace.

### 3. Tester sur un Clone Avant la Production

‚úÖ **Workflow recommand√©** :

```
1. Cloner la base de production (pg_dump/pg_restore)
2. Tester pg_repack sur le clone
3. Mesurer la dur√©e et l'impact
4. Valider que tout fonctionne apr√®s
5. Planifier l'ex√©cution en production
```

### 4. Utiliser --dry-run pour Valider

```bash
# Test √† blanc (ne fait rien, juste v√©rifie la faisabilit√©)
pg_repack -d production -t orders --dry-run

# Si succ√®s : Ex√©cuter r√©ellement
pg_repack -d production -t orders --verbose
```

### 5. Surveiller les Connexions Actives

pg_repack cr√©e plusieurs connexions. V√©rifier `max_connections` :

```sql
SHOW max_connections;
-- Si proche de la limite, augmenter ou limiter --jobs

-- Voir les connexions utilis√©es
SELECT COUNT(*) FROM pg_stat_activity;
```

**Ajuster --jobs** :

```bash
# Par d√©faut : 1 job (1 connexion principale + quelques auxiliaires)
pg_repack -d production -t orders --jobs 1

# Pour aller plus vite (si ressources disponibles)
pg_repack -d production -t orders --jobs 4
```

### 6. R√©organiser R√©guli√®rement, Pas Ponctuellement

‚úÖ **Strat√©gie pr√©ventive** : R√©organiser avant que le bloat ne devienne critique.

**Exemple de calendrier** :

| Type de Table | Fr√©quence | M√©thode |
|---------------|-----------|---------|
| **Tr√®s actives** (OLTP) | Mensuelle | pg_repack |
| **Mod√©r√©ment actives** | Trimestrielle | pg_repack |
| **Peu actives** | Annuelle | VACUUM FULL acceptable |

### 7. Combiner avec ANALYZE

Apr√®s un repack, mettre √† jour les statistiques :

```bash
# Repack puis ANALYZE
pg_repack -d production -t orders --verbose

psql -d production -c "ANALYZE orders;"
```

**Ou** :

```bash
# pg_repack analyse automatiquement √† la fin (depuis v1.4.6)
# Pas besoin d'ANALYZE manuel suppl√©mentaire
```

### 8. Documenter les Maintenances

```sql
-- Cr√©er une table de logs
CREATE TABLE monitoring.repack_log (
    log_id SERIAL PRIMARY KEY,
    table_name TEXT,
    start_time TIMESTAMPTZ,
    end_time TIMESTAMPTZ,
    size_before BIGINT,
    size_after BIGINT,
    duration INTERVAL,
    success BOOLEAN,
    error_message TEXT
);

-- Logger manuellement ou via script wrapper
INSERT INTO monitoring.repack_log
    (table_name, start_time, end_time, size_before, size_after, duration, success)
VALUES
    ('orders',
     '2025-11-23 02:00:00',
     '2025-11-23 03:45:00',
     107374182400,  -- 100 GB
     53687091200,   -- 50 GB
     '1 hour 45 minutes',
     TRUE);
```

---

## Limitations et Consid√©rations

### Limitations de pg_repack

1. **Verrous exclusifs brefs**

pg_repack n√©cessite deux verrous exclusifs tr√®s brefs :
- **Au d√©but** : ~1-10 ms (cr√©ation des triggers)
- **√Ä la fin** : ~10-100 ms (swap des tables)

**Impact** : Pendant ces quelques ms, toutes les requ√™tes sont bloqu√©es.

**Mitigation** : Utiliser `--wait-timeout` pour attendre la fin des transactions longues.

2. **N√©cessite de l'espace disque**

pg_repack cr√©e une copie compl√®te de la table (1.5√ó la taille).

**Solution** : V√©rifier l'espace avant, ou utiliser un tablespace alternatif (`--tablespace`).

3. **Ne fonctionne pas avec toutes les tables**

pg_repack **ne peut pas** r√©organiser :
- Tables sans cl√© primaire ou UNIQUE
- Tables temporaires (TEMP)
- Tables non-logg√©es (UNLOGGED) avant PostgreSQL 9.5
- Tables syst√®me (pg_catalog)

**V√©rification** :

```sql
-- Identifier les tables sans cl√© primaire
SELECT
    schemaname,
    tablename
FROM pg_tables t
WHERE NOT EXISTS (
    SELECT 1
    FROM pg_constraint c
    WHERE c.conrelid = (t.schemaname||'.'||t.tablename)::regclass
      AND c.contype IN ('p', 'u')  -- PRIMARY KEY ou UNIQUE
)
AND schemaname NOT IN ('pg_catalog', 'information_schema');
```

**Solution** : Ajouter une cl√© primaire avant de repack.

```sql
-- Ajouter une cl√© primaire
ALTER TABLE my_table ADD PRIMARY KEY (id);

-- Puis r√©organiser
pg_repack -d production -t my_table
```

4. **Impact sur les Replicas**

Le repack g√©n√®re beaucoup de WAL (Write-Ahead Log), ce qui peut :
- Saturer la bande passante r√©seau (r√©plication streaming)
- Cr√©er un retard (lag) sur les replicas

**Mitigation** :
- Ex√©cuter pendant les heures creuses
- Augmenter `max_wal_size` temporairement
- Surveiller le lag de r√©plication : `SELECT * FROM pg_stat_replication;`

5. **Tables avec beaucoup d'√©critures**

Si la table est tr√®s active en √©criture pendant le repack, la table de log peut devenir √©norme.

**Sympt√¥me** : Le repack ne finit jamais (il n'arrive pas √† rattraper les modifications).

**Solution** : R√©duire le trafic en √©criture temporairement, ou planifier pendant une fen√™tre plus calme.

6. **Pas de rollback automatique**

Si pg_repack √©choue, il **ne rollback pas** automatiquement. Les objets temporaires peuvent rester.

**Nettoyage manuel** :

```sql
-- Identifier les objets r√©siduels
SELECT
    schemaname,
    tablename
FROM pg_tables
WHERE tablename LIKE 'repack%';

-- Supprimer manuellement
DROP TABLE IF EXISTS repack_123456;
```

---

## D√©pannage (Troubleshooting)

### Probl√®me 1 : ERROR: pg_repack failed with error: relation has no primary key

**Cause** : La table n'a pas de cl√© primaire ou d'index UNIQUE.

**Solution** :

```sql
-- Option 1 : Ajouter une cl√© primaire
ALTER TABLE my_table ADD PRIMARY KEY (id);

-- Option 2 : Ajouter un index UNIQUE
CREATE UNIQUE INDEX idx_my_table_unique ON my_table(id);

-- Puis r√©essayer pg_repack
```

### Probl√®me 2 : ERROR: pg_repack: query failed: ERROR: could not create unique index

**Cause** : La colonne choisie pour cl√© primaire contient des doublons ou des NULL.

**Diagnostic** :

```sql
-- V√©rifier les doublons
SELECT id, COUNT(*)
FROM my_table
GROUP BY id
HAVING COUNT(*) > 1;

-- V√©rifier les NULL
SELECT COUNT(*)
FROM my_table
WHERE id IS NULL;
```

**Solution** :

```sql
-- Nettoyer les doublons et NULL
-- Puis ajouter la cl√© primaire
```

### Probl√®me 3 : ERROR: pg_repack: query failed: ERROR: out of shared memory

**Cause** : Pas assez de m√©moire partag√©e (`shared_buffers` ou `max_locks_per_transaction`).

**Solution** :

```sql
-- Augmenter temporairement
ALTER SYSTEM SET max_locks_per_transaction = 256;  -- D√©faut: 64
SELECT pg_reload_conf();

-- Ou dans postgresql.conf
max_locks_per_transaction = 256
# Puis red√©marrer PostgreSQL
```

### Probl√®me 4 : pg_repack prend trop de temps

**Causes possibles** :
1. Table tr√®s volumineuse
2. Beaucoup d'√©critures concurrentes
3. I/O lent

**Diagnostics** :

```sql
-- V√©rifier l'activit√© I/O
SELECT * FROM pg_stat_database WHERE datname = 'production';

-- V√©rifier les √©critures sur la table
SELECT
    schemaname,
    tablename,
    n_tup_ins + n_tup_upd + n_tup_del as write_activity
FROM pg_stat_user_tables
WHERE tablename = 'orders';
```

**Solutions** :
- Planifier pendant une p√©riode plus calme
- Augmenter `--jobs` pour parall√©liser (si ressources disponibles)
- Utiliser un tablespace sur SSD rapide

### Probl√®me 5 : Verrou en attente prolong√©

**Sympt√¥me** : pg_repack bloqu√© en attente d'un verrou.

```
WARNING: Waiting for a transaction to complete...
```

**Cause** : Une transaction longue emp√™che pg_repack d'acqu√©rir le verrou exclusif final.

**Diagnostic** :

```sql
-- Identifier la transaction bloquante
SELECT
    pid,
    usename,
    state,
    NOW() - xact_start as xact_duration,
    query
FROM pg_stat_activity
WHERE state != 'idle'
  AND xact_start IS NOT NULL
ORDER BY xact_start;
```

**Solutions** :

```bash
# Option 1 : Attendre avec un timeout
pg_repack -d production -t orders --wait-timeout 600  # 10 minutes

# Option 2 : Terminer la transaction bloquante (attention !)
psql -d production -c "SELECT pg_terminate_backend(12345);"  -- PID de la transaction
```

### Probl√®me 6 : Espace disque insuffisant

**Sympt√¥me** : `ERROR: could not extend file`

**Cause** : Plus d'espace disque pendant la copie.

**Solution** :

```bash
# Lib√©rer de l'espace
# Ou utiliser un tablespace alternatif
pg_repack -d production -t orders --tablespace fast_storage
```

---

## Comparaison avec Alternatives

### pg_repack vs VACUUM FULL

| Crit√®re | pg_repack | VACUUM FULL |
|---------|-----------|-------------|
| **Verrou exclusif** | Tr√®s bref (~100 ms) | Complet (heures) |
| **Disponibilit√©** | Application continue | Hors ligne |
| **Vitesse** | Rapide | Lent |
| **Espace disque** | 1.5√ó | 2√ó (temporairement) |
| **S√©curit√©** | Haute (rollback possible) | Moyenne |
| **Complexit√©** | Extension externe | Commande native |

**Verdict** : pg_repack pour production, VACUUM FULL uniquement si repack impossible.

### pg_repack vs CLUSTER

| Crit√®re | pg_repack | CLUSTER |
|---------|-----------|---------|
| **Verrou exclusif** | Tr√®s bref | Complet |
| **Disponibilit√©** | Online | Offline |
| **Ordre physique** | Oui (avec -o) | Oui |
| **Optimisation** | Compl√®te | Compl√®te |

**Verdict** : pg_repack avec `-o` remplace CLUSTER pour la production.

### pg_repack vs pg_squeeze

**pg_squeeze** : Alternative plus r√©cente, similaire √† pg_repack.

| Crit√®re | pg_repack | pg_squeeze |
|---------|-----------|------------|
| **Maturit√©** | Tr√®s mature | Plus r√©cent |
| **Adoption** | Large | √âmergente |
| **Fonctionnalit√©s** | Compl√®tes | Similaires |
| **Maintenance** | Active | Active |

**Verdict** : pg_repack est plus √©prouv√© et recommand√© pour la production critique.

---

## Int√©gration avec l'√âcosyst√®me

### pg_repack + pg_cron (Automatisation)

```sql
-- Cr√©er une fonction wrapper pour pg_repack
CREATE OR REPLACE FUNCTION run_pg_repack(table_name TEXT)
RETURNS BOOLEAN AS $$
DECLARE
    cmd TEXT;
BEGIN
    -- Construire la commande shell
    cmd := format('pg_repack -h localhost -U postgres -d production -t %s --verbose', table_name);

    -- Ex√©cuter via COPY PROGRAM (n√©cessite superutilisateur)
    EXECUTE format('COPY (SELECT 1) TO PROGRAM %L', cmd);

    RETURN TRUE;
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'pg_repack failed for %: %', table_name, SQLERRM;
    RETURN FALSE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Planifier avec pg_cron
SELECT cron.schedule(
    'monthly_repack_orders',
    '0 2 1 * *',  -- Le 1er de chaque mois √† 2h
    'SELECT run_pg_repack(''orders'');'
);
```

### pg_repack + Monitoring (Prometheus/Grafana)

Exporter des m√©triques de bloat et d√©clencher des alertes :

```sql
-- Vue pour m√©triques de bloat
CREATE OR REPLACE VIEW monitoring.table_bloat AS
SELECT
    schemaname,
    tablename,
    pg_relation_size(schemaname||'.'||tablename) as table_bytes,
    (SELECT dead_tuple_percent FROM pgstattuple(schemaname||'.'||tablename)) as bloat_percent
FROM pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema');

-- Alerte si bloat > 30%
```

### pg_repack + Patroni (High Availability)

Dans une configuration Patroni, ex√©cuter pg_repack uniquement sur le **primaire** :

```bash
#!/bin/bash
# Script: repack_if_primary.sh

# V√©rifier si ce n≈ìud est le primaire
ROLE=$(patronictl list -f json | jq -r '.[] | select(.Member == "'$HOSTNAME'") | .Role')

if [ "$ROLE" == "Leader" ]; then
    echo "This node is primary, running pg_repack..."
    pg_repack -d production -t orders --verbose
else
    echo "This node is standby, skipping pg_repack"
fi
```

---

## Cas d'Usage Avanc√©s

### 1. R√©organiser avec Tablespace Alternatif

Pour √©viter de saturer le disque principal :

```sql
-- Cr√©er un tablespace sur un disque rapide
CREATE TABLESPACE fast_ssd LOCATION '/mnt/ssd/pg_tablespace';
```

```bash
# Utiliser ce tablespace pour les tables temporaires
pg_repack -d production -t orders --tablespace fast_ssd
```

### 2. R√©organiser avec Parall√©lisation

Pour des tables tr√®s volumineuses (>1 TB) :

```bash
# Utiliser plusieurs jobs (si assez de CPU/I/O)
pg_repack -d production -t huge_table --jobs 8 --verbose
```

**Attention** : Augmente la consommation de ressources (CPU, m√©moire, connexions).

### 3. R√©organiser Toutes les Tables avec Bloat >30%

```bash
#!/bin/bash
# Script: repack_bloated_tables.sh

DBNAME="production"
BLOAT_THRESHOLD=30

# Requ√™te pour identifier les tables avec bloat > 30%
TABLES=$(psql -d $DBNAME -t -c "
    SELECT tablename
    FROM pgstattuple_approx('public.' || tablename)
    JOIN pg_tables ON pg_tables.tablename = pgstattuple_approx.tablename
    WHERE approx_dead_tuple_percent > $BLOAT_THRESHOLD
      AND schemaname = 'public';
")

for table in $TABLES; do
    echo "Repacking $table (bloat > ${BLOAT_THRESHOLD}%)..."
    pg_repack -d $DBNAME -t $table --verbose
done
```

---

## Pour Aller Plus Loin

### Ressources Officielles

- **GitHub pg_repack** : https://github.com/reorg/pg_repack
- **Documentation PostgreSQL - Routine Maintenance** : https://www.postgresql.org/docs/current/maintenance.html

### Outils Compl√©mentaires

- **pgstattuple** : Extension pour mesurer le bloat
- **check_postgres** : Script Nagios pour surveiller le bloat
- **pg_squeeze** : Alternative √† pg_repack

### Lectures Recommand√©es

- **PostgreSQL: Up and Running** (Regina Obe, Leo Hsu) - Chapitre sur la maintenance
- **PostgreSQL Administration Cookbook** - Recettes de maintenance

### Communaut√© et Support

- **GitHub Issues** : Signaler des bugs ou demander des fonctionnalit√©s
- **PostgreSQL Mailing Lists** : pgsql-admin@postgresql.org
- **Reddit** : r/PostgreSQL

---

## R√©sum√©

**pg_repack** est un outil essentiel pour maintenir les performances PostgreSQL en production en permettant de r√©organiser les tables **sans interruption de service**.

### Points Cl√©s

- ‚úÖ **R√©organisation online** : Pas de downtime, application continue
- ‚úÖ **R√©duction du bloat** : R√©cup√®re l'espace perdu par MVCC
- ‚úÖ **Optimisation physique** : R√©organise selon un ordre optimal (CLUSTER-like)
- ‚úÖ **S√ªr et transactionnel** : Rollback possible en cas d'erreur
- ‚úÖ **Production-ready** : Utilis√© par des milliers d'entreprises

### Quand Utiliser pg_repack ?

- **Bloat √©lev√©** : Table avec >30% de dead tuples
- **Performances d√©grad√©es** : Scans s√©quentiels lents
- **Apr√®s migrations** : Optimiser apr√®s imports massifs
- **Maintenance r√©guli√®re** : Pr√©venir l'accumulation de bloat
- **Alternative √† VACUUM FULL** : R√©organiser sans verrou exclusif

### Workflow Recommand√©

```
1. D√©tecter le bloat (pgstattuple, pg_stat_user_tables)
2. √âvaluer l'impact (taille, activit√©, disponibilit√©)
3. Tester sur un clone (dry-run, mesurer dur√©e)
4. V√©rifier l'espace disque (1.5√ó taille table)
5. Planifier pendant heures creuses
6. Ex√©cuter pg_repack avec monitoring
7. Valider post-repack (taille, performances)
8. Documenter l'op√©ration
```

### Crit√®res de D√©cision

| Situation | Outil Recommand√© |
|-----------|------------------|
| **Production 24/7** | pg_repack |
| **Table < 1 GB, downtime acceptable** | VACUUM FULL |
| **Besoin d'ordre physique** | pg_repack -o |
| **Table sans PK** | Ajouter PK, puis pg_repack |
| **Bloat critique (>80%)** | pg_repack imm√©diatement |

### M√©triques de Succ√®s

Une op√©ration pg_repack r√©ussie devrait :

- ‚úÖ **R√©duire la taille** : Table compact√©e (50-80% de r√©duction typique)
- ‚úÖ **Am√©liorer les performances** : Scans plus rapides
- ‚úÖ **Pas de downtime** : Application ininterrompue
- ‚úÖ **Pas d'erreurs** : Aucune transaction perdue

### Prochaines √âtapes

1. Installer pg_repack sur votre environnement de test
2. Mesurer le bloat actuel de vos tables (pgstattuple)
3. Tester pg_repack sur une petite table
4. Observer le processus et les verrous
5. Planifier la maintenance r√©guli√®re
6. Automatiser avec des scripts

---

**En Conclusion** : pg_repack est un outil indispensable pour maintenir des bases de donn√©es PostgreSQL performantes et saines en production. Il r√©sout le probl√®me du bloat sans les contraintes des outils natifs (VACUUM FULL, CLUSTER), permettant une maintenance transparente et s√ªre. Pour tout DBA, DevOps ou d√©veloppeur g√©rant PostgreSQL en production, ma√Ætriser pg_repack est essentiel pour garantir des performances optimales dans le temps.

**Principe d'or** : "Maintenez r√©guli√®rement, pr√©venez les probl√®mes" - pg_repack transforme la maintenance d'une op√©ration critique et risqu√©e en un processus routinier et s√ªr.

---


‚è≠Ô∏è [PostgreSQL en Production](/19-postgresql-en-production/README.md)
