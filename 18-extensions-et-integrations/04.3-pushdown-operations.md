üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.4.3. Pushdown d'Op√©rations et Performance

## Introduction

Lorsque vous utilisez des **Foreign Data Wrappers (FDW)** pour acc√©der √† des donn√©es distantes, les performances deviennent un enjeu crucial. Le **pushdown d'op√©rations** (ou "query pushdown") est le m√©canisme qui d√©termine si PostgreSQL est intelligent ou non dans la mani√®re dont il traite vos requ√™tes sur des tables distantes.

### Analogie simple : Le restaurant et la cuisine

Imaginez que vous √™tes dans un restaurant (PostgreSQL local) et que vous commandez un plat qui n√©cessite des ingr√©dients stock√©s dans un entrep√¥t distant (serveur distant via FDW).

**Sc√©nario 1 : Sans pushdown (inefficace)** üêå
1. Le serveur demande √† l'entrep√¥t : "Envoyez-moi TOUS vos ingr√©dients"
2. L'entrep√¥t envoie 10 000 bo√Ætes d'ingr√©dients
3. Le restaurant trie, filtre et pr√©pare uniquement ce dont il a besoin
4. Les 9 990 autres bo√Ætes sont jet√©es

**Sc√©nario 2 : Avec pushdown (efficace)** üöÄ
1. Le serveur demande √† l'entrep√¥t : "Envoyez-moi uniquement 10 bo√Ætes de tomates italiennes"
2. L'entrep√¥t trie et filtre sur place
3. L'entrep√¥t envoie exactement 10 bo√Ætes
4. Le restaurant re√ßoit seulement ce dont il a besoin

Le **pushdown** consiste √† envoyer le travail de filtrage, tri et agr√©gation directement vers le serveur distant, plut√¥t que de tout rapatrier localement.

---

## Qu'est-ce que le Pushdown d'Op√©rations ?

### D√©finition

Le **pushdown d'op√©rations** (query pushdown) est la capacit√© de PostgreSQL √† **d√©l√©guer** certaines parties d'une requ√™te SQL au serveur distant, plut√¥t que de rapatrier toutes les donn√©es pour les traiter localement.

### Sch√©ma conceptuel

```
Sans Pushdown (Inefficace)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  PostgreSQL Local                   ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ  SELECT nom, prix                   ‚îÇ
‚îÇ  FROM produits_distants             ‚îÇ
‚îÇ  WHERE categorie = '√âlectronique'   ‚îÇ
‚îÇ  ORDER BY prix DESC                 ‚îÇ
‚îÇ  LIMIT 10;                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ Requ√™te FDW simple:
              ‚îÇ "SELECT * FROM produits"
              ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Serveur Distant                    ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ  Envoie 1 000 000 lignes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  (toute la table)                ‚îÇ  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îò
                                   ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ Transfert r√©seau : 1 000 000 lignes
        ‚îÇ (tr√®s lent !)
        ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  PostgreSQL Local                    ‚îÇ
‚îÇ                                      ‚îÇ
‚îÇ  Filtre WHERE (localement)           ‚îÇ
‚îÇ  Tri ORDER BY (localement)           ‚îÇ
‚îÇ  LIMIT 10 (localement)               ‚îÇ
‚îÇ                                      ‚îÇ
‚îÇ  R√©sultat final : 10 lignes          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Avec Pushdown (Efficace)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  PostgreSQL Local                   ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ  SELECT nom, prix                   ‚îÇ
‚îÇ  FROM produits_distants             ‚îÇ
‚îÇ  WHERE categorie = '√âlectronique'   ‚îÇ
‚îÇ  ORDER BY prix DESC                 ‚îÇ
‚îÇ  LIMIT 10;                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ Requ√™te FDW intelligente:
              ‚îÇ "SELECT nom, prix FROM produits
              ‚îÇ  WHERE categorie = '√âlectronique'
              ‚îÇ  ORDER BY prix DESC
              ‚îÇ  LIMIT 10"
              ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Serveur Distant                    ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ  Filtre WHERE (distant)             ‚îÇ
‚îÇ  Tri ORDER BY (distant)             ‚îÇ
‚îÇ  LIMIT 10 (distant)                 ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ  R√©sultat : 10 lignes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îò
                                  ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ Transfert r√©seau : 10 lignes seulement
        ‚îÇ (tr√®s rapide !)
        ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  PostgreSQL Local                    ‚îÇ
‚îÇ                                      ‚îÇ
‚îÇ  Re√ßoit directement le r√©sultat      ‚îÇ
‚îÇ  R√©sultat final : 10 lignes          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Impact sur les performances

**Exemple concret** :

```sql
-- Table distante avec 10 millions de lignes
SELECT nom, prix
FROM produits_distants
WHERE categorie = '√âlectronique'
  AND prix > 100
LIMIT 10;
```

| M√©thode | Lignes transf√©r√©es | Temps d'ex√©cution | Bande passante |
|---------|-------------------|-------------------|----------------|
| **Sans pushdown** | 10 000 000 lignes | ~120 secondes | ~2 Go |
| **Avec pushdown** | 10 lignes | ~0.05 secondes | ~1 Ko |

**Diff√©rence** : 2400√ó plus rapide ! üöÄ

---

## Types d'Op√©rations Poussables

### Classification des op√©rations

#### 1. S√©lection de colonnes (Projection)

**Poussable** : ‚úÖ Oui (tous les FDW)

```sql
-- PostgreSQL envoie seulement les colonnes demand√©es
SELECT id, nom, prix FROM produits_distants;

-- Au lieu de
SELECT * FROM produits_distants;
```

**B√©n√©fice** : R√©duit la taille des donn√©es transf√©r√©es.

#### 2. Filtrage (WHERE clause)

**Poussable** : ‚úÖ Oui (d√©pend de l'op√©rateur et du FDW)

```sql
SELECT * FROM clients_distants
WHERE pays = 'France'
  AND age >= 18;
```

**Op√©rateurs g√©n√©ralement poussables** :

| Op√©rateur | postgres_fdw | oracle_fdw | mysql_fdw | file_fdw |
|-----------|--------------|------------|-----------|----------|
| `=`, `<>` | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå |
| `<`, `>`, `<=`, `>=` | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå |
| `IN`, `NOT IN` | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå |
| `LIKE`, `ILIKE` | ‚úÖ | ‚úÖ | ‚ö†Ô∏è Partiel | ‚ùå |
| `BETWEEN` | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå |
| `IS NULL`, `IS NOT NULL` | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå |
| `AND`, `OR`, `NOT` | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå |

**Fonctions NON poussables** :
- Fonctions personnalis√©es (UDF)
- Fonctions volatiles (comme `random()`)
- Fonctions PostgreSQL sp√©cifiques non support√©es par la base distante

#### 3. Tri (ORDER BY)

**Poussable** : ‚úÖ Oui (postgres_fdw, oracle_fdw, mysql_fdw)

```sql
SELECT * FROM commandes_distantes
ORDER BY date_commande DESC;
```

**B√©n√©fice** : Le tri se fait sur le serveur distant, √©vitant le transfert puis le tri local.

#### 4. Limitation (LIMIT / OFFSET)

**Poussable** : ‚úÖ Oui (postgres_fdw, oracle_fdw, mysql_fdw)

```sql
SELECT * FROM produits_distants
ORDER BY prix DESC
LIMIT 10;
```

**Impact √©norme** : Au lieu de transf√©rer toute la table tri√©e, seules les 10 premi√®res lignes sont envoy√©es.

#### 5. Agr√©gations (GROUP BY, COUNT, SUM, etc.)

**Poussable** : ‚úÖ Oui (depuis PostgreSQL 10+ pour postgres_fdw)

```sql
SELECT
    categorie,
    COUNT(*) AS nb_produits,
    AVG(prix) AS prix_moyen
FROM produits_distants
GROUP BY categorie;
```

**Fonctions d'agr√©gation poussables** :

| Fonction | postgres_fdw | oracle_fdw | mysql_fdw |
|----------|--------------|------------|-----------|
| `COUNT(*)` | ‚úÖ | ‚úÖ | ‚úÖ |
| `COUNT(DISTINCT)` | ‚úÖ | ‚úÖ | ‚úÖ |
| `SUM`, `AVG` | ‚úÖ | ‚úÖ | ‚úÖ |
| `MIN`, `MAX` | ‚úÖ | ‚úÖ | ‚úÖ |
| `STDDEV`, `VARIANCE` | ‚úÖ | ‚ö†Ô∏è D√©pend | ‚ö†Ô∏è D√©pend |
| Agr√©gations personnalis√©es | ‚ùå | ‚ùå | ‚ùå |

#### 6. Jointures

**Poussable** : ‚úÖ Oui (sous conditions)

**Cas 1 : Jointure entre deux foreign tables du M√äME serveur distant**

```sql
-- Les deux tables sont sur le m√™me serveur Oracle
SELECT
    c.nom,
    o.montant
FROM clients_oracle c
INNER JOIN commandes_oracle o ON c.id = o.client_id;
```

**R√©sultat** : La jointure est effectu√©e sur le serveur Oracle distant. ‚úÖ

**Cas 2 : Jointure entre foreign table et table locale**

```sql
-- clients_distants (distant) + ventes_locales (local)
SELECT
    c.nom,
    v.montant
FROM clients_distants c
INNER JOIN ventes_locales v ON c.id = v.client_id;
```

**R√©sultat** : La foreign table est rapatri√©e localement, puis la jointure est effectu√©e sur PostgreSQL local. ‚ùå

**Cas 3 : Jointure entre foreign tables de serveurs DIFF√âRENTS**

```sql
-- clients_oracle (serveur Oracle) + produits_mysql (serveur MySQL)
SELECT
    c.nom,
    p.nom_produit
FROM clients_oracle c
INNER JOIN produits_mysql p ON c.produit_favori = p.id;
```

**R√©sultat** : Les deux tables sont rapatri√©es localement, puis jointure locale. ‚ùå

#### 7. Sous-requ√™tes

**Poussable** : ‚ö†Ô∏è Partiel (selon la complexit√©)

```sql
-- Sous-requ√™te simple : peut √™tre pouss√©e
SELECT * FROM produits_distants
WHERE prix > (SELECT AVG(prix) FROM produits_distants);

-- Sous-requ√™te corr√©l√©e : g√©n√©ralement NON pouss√©e
SELECT * FROM commandes_distantes c
WHERE montant > (
    SELECT AVG(montant)
    FROM commandes_distantes
    WHERE client_id = c.client_id
);
```

#### 8. CTE (Common Table Expressions)

**Poussable** : ‚ö†Ô∏è Variable

```sql
WITH clients_actifs AS (
    SELECT * FROM clients_distants
    WHERE derniere_commande > NOW() - INTERVAL '1 year'
)
SELECT nom FROM clients_actifs;
```

Le comportement d√©pend du planificateur PostgreSQL et de la complexit√© de la CTE.

---

## V√©rifier le Pushdown avec EXPLAIN

### La commande EXPLAIN

`EXPLAIN` est l'outil essentiel pour comprendre ce qui est pouss√© vers le serveur distant.

#### Syntaxe de base

```sql
EXPLAIN (VERBOSE, ANALYZE)
SELECT * FROM produits_distants WHERE categorie = '√âlectronique';
```

**Options importantes** :
- `VERBOSE` : Affiche le SQL distant (Remote SQL)
- `ANALYZE` : Ex√©cute r√©ellement la requ√™te et affiche les temps
- `BUFFERS` : Affiche l'utilisation des buffers (utile pour les performances)

#### Exemple d'analyse

**Requ√™te avec bon pushdown** :

```sql
EXPLAIN (VERBOSE)
SELECT nom, prix
FROM produits_distants
WHERE categorie = '√âlectronique'
  AND prix > 100
ORDER BY prix DESC
LIMIT 10;
```

**R√©sultat** :

```
Foreign Scan on public.produits_distants
  Output: nom, prix
  Remote SQL: SELECT nom, prix
              FROM public.produits
              WHERE ((categorie = '√âlectronique'::text))
                AND ((prix > '100'::numeric))
              ORDER BY prix DESC
              LIMIT 10
```

**Analyse** :
‚úÖ Le `WHERE` est pouss√© (`categorie = '√âlectronique' AND prix > 100`)
‚úÖ L'`ORDER BY` est pouss√©
‚úÖ Le `LIMIT` est pouss√©
‚úÖ Seules les colonnes n√©cessaires sont s√©lectionn√©es (`nom, prix`)

**Requ√™te avec mauvais pushdown** :

```sql
EXPLAIN (VERBOSE)
SELECT nom, upper(description)
FROM produits_distants
WHERE extract_custom_field(description) = 'valeur';
```

**R√©sultat** :

```
Foreign Scan on public.produits_distants
  Output: nom, upper(description)
  Filter: (extract_custom_field(description) = 'valeur'::text)
  Remote SQL: SELECT nom, description FROM public.produits
```

**Analyse** :
‚ùå Le `WHERE` n'est **pas** pouss√© (fonction personnalis√©e `extract_custom_field`)
‚ùå Le filtrage se fait localement (`Filter:` dans le plan)
‚ö†Ô∏è Toute la table `produits` est transf√©r√©e

### Lire le plan d'ex√©cution

#### Mots-cl√©s √† surveiller

| Mot-cl√© | Signification | Bon/Mauvais |
|---------|---------------|-------------|
| `Remote SQL` | Le SQL ex√©cut√© √† distance | ‚ÑπÔ∏è Info |
| `Filter:` | Filtrage LOCAL (apr√®s transfert) | ‚ùå Mauvais |
| `Sort` (local) | Tri LOCAL | ‚ùå Mauvais |
| `Aggregate` (local) | Agr√©gation LOCALE | ‚ùå Mauvais |
| Tout dans `Remote SQL` | Tout est pouss√© | ‚úÖ Excellent |

#### Exemple complet avec ANALYZE

```sql
EXPLAIN (ANALYZE, VERBOSE, BUFFERS)
SELECT pays, COUNT(*)
FROM clients_distants
WHERE date_inscription > '2024-01-01'
GROUP BY pays;
```

**R√©sultat id√©al (bon pushdown)** :

```
Foreign Scan on public.clients_distants
  Output: pays, (count(*))
  Remote SQL: SELECT pays, count(*)
              FROM public.clients
              WHERE (date_inscription > '2024-01-01'::date)
              GROUP BY pays
Planning Time: 0.523 ms
Execution Time: 45.234 ms
```

**Temps** : 45 ms ‚Üí tr√®s rapide

**R√©sultat probl√©matique (mauvais pushdown)** :

```
Aggregate
  Output: pays, count(*)
  Group Key: clients_distants.pays
  ->  Foreign Scan on public.clients_distants
        Output: pays, id, nom, date_inscription
        Filter: (date_inscription > '2024-01-01'::date)
        Remote SQL: SELECT pays, id, nom, date_inscription
                    FROM public.clients
Planning Time: 0.612 ms
Execution Time: 12453.789 ms
```

**Temps** : 12 453 ms ‚Üí tr√®s lent (12 secondes !)

**Probl√®me** :
- Le `WHERE` n'est pas pouss√© (local `Filter:`)
- Le `GROUP BY` n'est pas pouss√© (local `Aggregate`)
- Toutes les lignes sont transf√©r√©es puis agr√©g√©es localement

---

## Optimisation des Performances

### Strat√©gies d'optimisation

#### 1. Maximiser le pushdown

**‚ùå Mauvais : Fonction PostgreSQL non poussable**

```sql
SELECT * FROM clients_distants
WHERE to_char(date_inscription, 'YYYY') = '2024';
```

**‚úÖ Bon : Op√©rateur standard poussable**

```sql
SELECT * FROM clients_distants
WHERE date_inscription >= '2024-01-01'
  AND date_inscription < '2025-01-01';
```

**‚ùå Mauvais : Expression complexe**

```sql
SELECT * FROM produits_distants
WHERE CASE WHEN prix > 100 THEN 'Cher' ELSE 'Pas cher' END = 'Cher';
```

**‚úÖ Bon : Condition simple**

```sql
SELECT * FROM produits_distants
WHERE prix > 100;
```

#### 2. Limiter les colonnes s√©lectionn√©es

**‚ùå Mauvais : S√©lection de toutes les colonnes**

```sql
SELECT * FROM clients_distants WHERE pays = 'France';
```

Si la table a 50 colonnes, vous transf√©rez 50 colonnes.

**‚úÖ Bon : S√©lection cibl√©e**

```sql
SELECT id, nom, email FROM clients_distants WHERE pays = 'France';
```

Vous transf√©rez seulement 3 colonnes.

**Impact** : R√©duction de 90%+ du volume de donn√©es transf√©r√©.

#### 3. Utiliser LIMIT syst√©matiquement

**‚ùå Mauvais : Pas de limitation**

```sql
SELECT * FROM logs_distants
ORDER BY timestamp DESC;
```

Transf√®re potentiellement des millions de lignes.

**‚úÖ Bon : Limitation explicite**

```sql
SELECT * FROM logs_distants
ORDER BY timestamp DESC
LIMIT 100;
```

Transf√®re seulement 100 lignes.

#### 4. Utiliser les index c√¥t√© distant

Les index sur le serveur distant sont utilis√©s lors du pushdown.

**Sur le serveur distant** :

```sql
-- Cr√©er un index sur la colonne filtr√©e
CREATE INDEX idx_clients_pays ON clients(pays);
CREATE INDEX idx_produits_categorie ON produits(categorie, prix);
```

**Sur PostgreSQL local** :

```sql
-- Cette requ√™te b√©n√©ficiera de l'index distant
SELECT * FROM clients_distants WHERE pays = 'France';
```

**V√©rifier** :

```sql
EXPLAIN (ANALYZE, VERBOSE)
SELECT * FROM clients_distants WHERE pays = 'France';
```

Si le plan distant montre `Index Scan`, l'index est utilis√©. ‚úÖ

#### 5. Ajuster fetch_size

Le param√®tre `fetch_size` contr√¥le le nombre de lignes r√©cup√©r√©es par lot depuis le serveur distant.

**Par d√©faut** : `fetch_size = 100` (trop petit pour gros volumes)

**Configuration serveur** :

```sql
ALTER SERVER serveur_distant OPTIONS (
    SET fetch_size '10000'  -- 10 000 lignes par batch
);
```

**Configuration table sp√©cifique** :

```sql
ALTER FOREIGN TABLE clients_distants OPTIONS (
    SET fetch_size '50000'  -- 50 000 lignes pour cette table
);
```

**R√®gle g√©n√©rale** :
- **Petits r√©sultats (<1000 lignes)** : `fetch_size = 100-1000`
- **R√©sultats moyens (1000-100K lignes)** : `fetch_size = 5000-10000`
- **Gros volumes (>100K lignes)** : `fetch_size = 10000-50000`

**Attention** : Un `fetch_size` trop √©lev√© peut consommer beaucoup de m√©moire.

#### 6. Utiliser use_remote_estimate

Cette option permet √† PostgreSQL d'utiliser les statistiques du serveur distant pour optimiser le plan d'ex√©cution.

```sql
ALTER SERVER serveur_distant OPTIONS (
    ADD use_remote_estimate 'true'
);
```

**B√©n√©fice** : Plans d'ex√©cution plus pr√©cis, surtout pour les jointures.

**Co√ªt** : Requ√™te suppl√©mentaire vers le serveur distant pour obtenir les statistiques (l√©ger surco√ªt).

#### 7. Mat√©rialiser les donn√©es fr√©quemment consult√©es

Si vous interrogez souvent les m√™mes donn√©es distantes, mat√©rialisez-les localement.

**Vue mat√©rialis√©e** :

```sql
CREATE MATERIALIZED VIEW clients_actifs_mv AS
SELECT * FROM clients_distants
WHERE derniere_commande > NOW() - INTERVAL '1 year';

-- Cr√©er des index sur la vue mat√©rialis√©e
CREATE INDEX idx_clients_mv_pays ON clients_actifs_mv(pays);

-- Rafra√Æchir p√©riodiquement
REFRESH MATERIALIZED VIEW clients_actifs_mv;
```

**Utilisation** :

```sql
-- Au lieu de
SELECT * FROM clients_distants WHERE pays = 'France';

-- Utilisez
SELECT * FROM clients_actifs_mv WHERE pays = 'France';
```

**Avantages** :
- ‚úÖ Acc√®s ultra-rapide (local)
- ‚úÖ Possibilit√© d'indexation
- ‚úÖ Pas de latence r√©seau

**Inconv√©nients** :
- ‚ùå Donn√©es pas en temps r√©el
- ‚ùå N√©cessite un rafra√Æchissement r√©gulier

#### 8. Parall√©liser avec plusieurs connexions

Pour postgres_fdw, vous pouvez augmenter le nombre de connexions parall√®les.

```sql
-- Autoriser 4 connexions parall√®les par serveur distant
ALTER SERVER serveur_distant OPTIONS (
    ADD parallel_commit 'true',
    ADD parallel_abort 'true'
);

-- Configuration PostgreSQL
SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 100;
```

**Cas d'usage** : Requ√™tes lourdes sur gros volumes.

---

## Comparaison des Performances par FDW

### Tableau r√©capitulatif

| Crit√®re | postgres_fdw | oracle_fdw | mysql_fdw | file_fdw |
|---------|--------------|------------|-----------|----------|
| **Pushdown WHERE** | ‚úÖ‚úÖ‚úÖ Excellent | ‚úÖ‚úÖ Tr√®s bon | ‚úÖ‚úÖ Bon | ‚ùå Aucun |
| **Pushdown ORDER BY** | ‚úÖ‚úÖ‚úÖ | ‚úÖ‚úÖ | ‚úÖ‚úÖ | ‚ùå |
| **Pushdown LIMIT** | ‚úÖ‚úÖ‚úÖ | ‚úÖ‚úÖ | ‚úÖ‚úÖ | ‚ùå |
| **Pushdown JOIN** | ‚úÖ‚úÖ‚úÖ | ‚úÖ‚úÖ | ‚úÖ Limit√© | ‚ùå |
| **Pushdown Agr√©gations** | ‚úÖ‚úÖ‚úÖ (PG 10+) | ‚úÖ‚úÖ | ‚úÖ Partiel | ‚ùå |
| **Pushdown Sous-requ√™tes** | ‚úÖ‚úÖ | ‚úÖ Limit√© | ‚ö†Ô∏è Variable | ‚ùå |
| **Use remote estimate** | ‚úÖ | ‚úÖ | ‚úÖ | N/A |
| **Parallel query** | ‚úÖ | ‚ùå | ‚ùå | ‚ùå |
| **fetch_size configurable** | ‚úÖ | ‚úÖ | ‚úÖ | N/A |
| **Performance globale** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê |

### Benchmark indicatif

**Sc√©nario** : Table de 10 millions de lignes, requ√™te filtrant 1000 lignes.

```sql
SELECT * FROM table_distante WHERE status = 'actif' LIMIT 1000;
```

| FDW | Temps d'ex√©cution | Donn√©es transf√©r√©es |
|-----|-------------------|---------------------|
| **postgres_fdw** (avec pushdown) | 0.05 s | 1000 lignes (~100 Ko) |
| **oracle_fdw** (avec pushdown) | 0.08 s | 1000 lignes (~100 Ko) |
| **mysql_fdw** (avec pushdown) | 0.12 s | 1000 lignes (~100 Ko) |
| **file_fdw** (sans pushdown) | 45 s | 10M lignes (~2 Go) |
| **postgres_fdw** (SANS pushdown) | 35 s | 10M lignes (~2 Go) |

**Conclusion** : Le pushdown fait une diff√©rence de **700√ó en performance** ! üöÄ

---

## Cas Pratiques d'Optimisation

### Cas 1 : Requ√™te analytique lente

**Probl√®me** :

```sql
SELECT
    categorie,
    COUNT(*) AS nb_ventes,
    SUM(montant) AS ca
FROM ventes_distantes
WHERE date_vente >= '2024-01-01'
GROUP BY categorie;

-- Temps d'ex√©cution : 45 secondes
```

**Diagnostic avec EXPLAIN** :

```sql
EXPLAIN (ANALYZE, VERBOSE)
SELECT categorie, COUNT(*), SUM(montant)
FROM ventes_distantes
WHERE date_vente >= '2024-01-01'
GROUP BY categorie;
```

**R√©sultat** :

```
Aggregate (actual time=45234.123..45234.145 rows=10)
  Group Key: categorie
  ->  Foreign Scan (actual time=123.456..43210.789 rows=5000000)
        Remote SQL: SELECT categorie, montant
                    FROM ventes
                    WHERE date_vente >= '2024-01-01'
```

**Probl√®me identifi√©** : L'agr√©gation (`COUNT`, `SUM`) est faite **localement** apr√®s avoir transf√©r√© 5 millions de lignes.

**Solution 1 : Mettre √† jour postgres_fdw (si ancien)**

```bash
# V√©rifier la version
SELECT * FROM pg_available_extensions WHERE name = 'postgres_fdw';

# Si < PostgreSQL 10, l'agr√©gation n'est pas pouss√©e
# Mettre √† jour vers PostgreSQL 10+
```

**Solution 2 : Forcer le pushdown avec une sous-requ√™te**

```sql
-- Cr√©er une vue distante qui fait l'agr√©gation
CREATE VIEW ventes_agregees AS
SELECT
    categorie,
    COUNT(*) AS nb_ventes,
    SUM(montant) AS ca
FROM ventes
WHERE date_vente >= '2024-01-01'
GROUP BY categorie;

-- Sur PostgreSQL local, r√©f√©rencer cette vue
CREATE FOREIGN TABLE ventes_agregees_fdw (
    categorie TEXT,
    nb_ventes BIGINT,
    ca NUMERIC
)
SERVER serveur_distant
OPTIONS (schema_name 'public', table_name 'ventes_agregees');

-- Requ√™te instantan√©e
SELECT * FROM ventes_agregees_fdw;

-- Temps d'ex√©cution : 0.05 secondes
```

### Cas 2 : Jointure entre distant et local

**Probl√®me** :

```sql
SELECT
    c.nom,
    v.montant
FROM clients_distants c
INNER JOIN ventes_locales v ON c.id = v.client_id
WHERE c.pays = 'France';

-- Temps d'ex√©cution : 2 minutes
```

**Diagnostic** :

```sql
EXPLAIN (ANALYZE, VERBOSE)
SELECT c.nom, v.montant
FROM clients_distants c
INNER JOIN ventes_locales v ON c.id = v.client_id
WHERE c.pays = 'France';
```

**R√©sultat** :

```
Hash Join (actual time=120234.456..120456.789 rows=15000)
  Hash Cond: (v.client_id = c.id)
  ->  Seq Scan on ventes_locales v (actual time=0.012..123.456 rows=100000)
  ->  Hash (actual time=120000.123..120000.456 rows=2000000)
        ->  Foreign Scan on clients_distants c (actual time=45.123..119000.789)
              Remote SQL: SELECT id, nom FROM clients WHERE pays = 'France'
```

**Probl√®me** : La table distante `clients_distants` est enti√®rement rapatri√©e (2M lignes), puis jointure locale.

**Solution 1 : Mat√©rialiser les clients fran√ßais**

```sql
-- Cr√©er une table locale avec les clients fran√ßais
CREATE TABLE clients_france AS
SELECT * FROM clients_distants WHERE pays = 'France';

-- Cr√©er un index
CREATE INDEX idx_clients_france_id ON clients_france(id);

-- Utiliser la table locale
SELECT
    c.nom,
    v.montant
FROM clients_france c
INNER JOIN ventes_locales v ON c.id = v.client_id;

-- Temps d'ex√©cution : 0.3 secondes
```

**Solution 2 : Inverser la jointure (si possible)**

```sql
-- Si ventes_locales est plus petite, la pousser vers la foreign table
-- Cr√©er une foreign table pour ventes_locales sur le serveur distant

-- Puis faire la jointure distante
SELECT
    c.nom,
    v.montant
FROM clients c
INNER JOIN ventes_locales_fdw v ON c.id = v.client_id
WHERE c.pays = 'France';
```

### Cas 3 : Pagination lente

**Probl√®me** :

```sql
-- Page 1000 d'une grande table
SELECT * FROM produits_distants
ORDER BY nom
LIMIT 100 OFFSET 99900;

-- Temps d'ex√©cution : 30 secondes
```

**Diagnostic** :

```sql
EXPLAIN (ANALYZE, VERBOSE)
SELECT * FROM produits_distants
ORDER BY nom
LIMIT 100 OFFSET 99900;
```

**R√©sultat** :

```
Foreign Scan (actual time=29876.123..29876.456 rows=100)
  Remote SQL: SELECT * FROM produits
              ORDER BY nom
              LIMIT 100 OFFSET 99900
```

**Probl√®me** : M√™me avec pushdown, le serveur distant doit trier et parcourir 100 000 lignes.

**Solution : Pagination par cl√© (keyset pagination)**

```sql
-- Au lieu d'OFFSET, utiliser WHERE avec la derni√®re valeur
-- Premi√®re page
SELECT * FROM produits_distants
ORDER BY nom
LIMIT 100;

-- Page suivante (nom_dernier_produit est le dernier 'nom' de la page pr√©c√©dente)
SELECT * FROM produits_distants
WHERE nom > 'nom_dernier_produit'
ORDER BY nom
LIMIT 100;

-- Temps d'ex√©cution : 0.05 secondes (constant, peu importe la page)
```

### Cas 4 : Fonction non poussable

**Probl√®me** :

```sql
SELECT * FROM clients_distants
WHERE age_category(age) = 'adulte';

-- Fonction personnalis√©e PostgreSQL non poussable
-- Temps d'ex√©cution : 15 secondes
```

**Solution 1 : R√©√©crire sans fonction**

```sql
SELECT * FROM clients_distants
WHERE age >= 18 AND age < 65;

-- Temps d'ex√©cution : 0.05 secondes
```

**Solution 2 : Cr√©er la fonction sur le serveur distant**

```sql
-- Sur le serveur DISTANT, cr√©er la m√™me fonction
CREATE FUNCTION age_category(age INTEGER) RETURNS TEXT AS $$
BEGIN
    IF age < 18 THEN RETURN 'mineur';
    ELSIF age < 65 THEN RETURN 'adulte';
    ELSE RETURN 'senior';
    END IF;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Sur PostgreSQL local, la requ√™te devient poussable
SELECT * FROM clients_distants
WHERE age_category(age) = 'adulte';

-- Temps d'ex√©cution : 0.05 secondes
```

---

## Monitoring des Performances

### M√©triques cl√©s √† surveiller

#### 1. Temps d'ex√©cution des requ√™tes

```sql
-- Activer pg_stat_statements (extension)
CREATE EXTENSION pg_stat_statements;

-- Voir les requ√™tes FDW les plus lentes
SELECT
    substring(query, 1, 100) AS query_short,
    calls,
    total_exec_time / 1000 AS total_time_sec,
    mean_exec_time / 1000 AS mean_time_sec,
    max_exec_time / 1000 AS max_time_sec
FROM pg_stat_statements
WHERE query LIKE '%Foreign Scan%'
ORDER BY total_exec_time DESC
LIMIT 20;
```

#### 2. Volume de donn√©es transf√©r√©

Sur le serveur **distant**, surveillez le trafic r√©seau :

```sql
-- V√©rifier les connexions FDW actives
SELECT
    datname,
    usename,
    application_name,
    client_addr,
    state,
    query
FROM pg_stat_activity
WHERE application_name LIKE '%fdw%';
```

Utilisez des outils syst√®me :

```bash
# Surveiller le trafic r√©seau
iftop -i eth0
netstat -i
```

#### 3. Cache hit ratio

```sql
-- Ratio de cache des buffers
SELECT
    schemaname,
    tablename,
    heap_blks_read,
    heap_blks_hit,
    ROUND(
        100.0 * heap_blks_hit / NULLIF(heap_blks_hit + heap_blks_read, 0),
        2
    ) AS cache_hit_ratio
FROM pg_statio_user_tables
ORDER BY cache_hit_ratio ASC
LIMIT 20;
```

Un faible ratio peut indiquer des probl√®mes de m√©moire ou de performance.

#### 4. Nombre de connexions ouvertes

```sql
-- Comptage des connexions par serveur distant
SELECT
    application_name,
    COUNT(*) AS nb_connexions
FROM pg_stat_activity
WHERE application_name LIKE '%fdw%'
GROUP BY application_name;
```

Trop de connexions peuvent saturer le serveur distant.

### Outils de monitoring

#### 1. pg_stat_statements (extension)

```sql
CREATE EXTENSION pg_stat_statements;

-- Configuration dans postgresql.conf
shared_preload_libraries = 'pg_stat_statements'
pg_stat_statements.track = all
```

#### 2. auto_explain (pour logs automatiques)

```sql
-- Configuration dans postgresql.conf
shared_preload_libraries = 'auto_explain'
auto_explain.log_min_duration = 1000  -- Log requ√™tes > 1 seconde
auto_explain.log_analyze = true
auto_explain.log_verbose = true
```

Les plans d'ex√©cution appara√Ætront dans les logs PostgreSQL.

#### 3. pgBadger (analyse de logs)

```bash
# G√©n√©rer un rapport HTML depuis les logs
pgbadger /var/log/postgresql/postgresql.log -o rapport.html
```

Identifie les requ√™tes lentes, les erreurs, etc.

#### 4. Prometheus + Grafana

Utilisez `postgres_exporter` pour exporter les m√©triques vers Prometheus, puis visualisez dans Grafana.

**M√©triques utiles** :
- `pg_stat_database_xact_commit` : Transactions valid√©es
- `pg_stat_database_tup_fetched` : Lignes r√©cup√©r√©es
- `pg_stat_statements_max_exec_time` : Temps max des requ√™tes

---

## Troubleshooting des Probl√®mes de Performance

### Probl√®me 1 : Requ√™te tr√®s lente

**√âtapes de diagnostic** :

1. **V√©rifier le pushdown** :
   ```sql
   EXPLAIN (VERBOSE) SELECT ... FROM foreign_table WHERE ...;
   ```
   Cherchez `Remote SQL` et v√©rifiez que le `WHERE` y appara√Æt.

2. **V√©rifier les index distants** :
   ```sql
   -- Sur le serveur DISTANT
   SELECT indexname, indexdef
   FROM pg_indexes
   WHERE tablename = 'ma_table';
   ```

3. **Ajuster fetch_size** :
   ```sql
   ALTER FOREIGN TABLE ma_table OPTIONS (SET fetch_size '10000');
   ```

4. **Mat√©rialiser si n√©cessaire** :
   ```sql
   CREATE MATERIALIZED VIEW ma_table_cache AS
   SELECT * FROM ma_table_distante;
   ```

### Probl√®me 2 : Timeout de connexion

```
ERROR: could not connect to server "serveur_distant"
```

**Solutions** :

```sql
-- Augmenter les timeouts
ALTER SERVER serveur_distant OPTIONS (
    ADD connect_timeout '60',        -- 60 secondes pour connexion
    ADD tcp_keepalives_idle '60',
    ADD tcp_keepalives_interval '10'
);
```

### Probl√®me 3 : M√©moire insuffisante

```
ERROR: out of memory
```

**Solutions** :

1. **R√©duire fetch_size** :
   ```sql
   ALTER FOREIGN TABLE ma_table OPTIONS (SET fetch_size '1000');
   ```

2. **Augmenter work_mem** :
   ```sql
   SET work_mem = '256MB';
   ```

3. **Utiliser des curseurs** :
   ```sql
   BEGIN;
   DECLARE cur CURSOR FOR SELECT * FROM foreign_table;
   FETCH 1000 FROM cur;
   COMMIT;
   ```

### Probl√®me 4 : Trop de connexions

```
FATAL: sorry, too many clients already
```

**Solutions** :

1. **Augmenter max_connections sur le serveur distant** :
   ```sql
   -- Dans postgresql.conf (serveur distant)
   max_connections = 200
   ```

2. **Utiliser un connection pooler** (PgBouncer) :
   ```ini
   # pgbouncer.ini
   [databases]
   distant_db = host=serveur-distant port=5432 dbname=prod

   [pgbouncer]
   pool_mode = transaction
   max_client_conn = 100
   default_pool_size = 20
   ```

---

## Recommandations Finales

### Checklist de performance FDW

‚úÖ **Avant de cr√©er une foreign table** :
- [ ] V√©rifier que le FDW supporte le pushdown
- [ ] Cr√©er les index n√©cessaires sur le serveur distant
- [ ] D√©finir `fetch_size` appropri√©
- [ ] Activer `use_remote_estimate` si applicable

‚úÖ **Lors de l'√©criture de requ√™tes** :
- [ ] Utiliser `EXPLAIN (VERBOSE)` syst√©matiquement
- [ ] V√©rifier que les `WHERE` sont dans `Remote SQL`
- [ ] Limiter les colonnes s√©lectionn√©es
- [ ] Utiliser `LIMIT` quand possible
- [ ] √âviter les fonctions non poussables

‚úÖ **Pour les jointures** :
- [ ] Privil√©gier les jointures entre foreign tables du m√™me serveur
- [ ] Mat√©rialiser les tables locales petites utilis√©es en jointure
- [ ] Consid√©rer les vues mat√©rialis√©es pour les donn√©es fr√©quentes

‚úÖ **Monitoring continu** :
- [ ] Activer `pg_stat_statements`
- [ ] Surveiller les temps d'ex√©cution
- [ ] Surveiller le volume de donn√©es transf√©r√©
- [ ] Analyser les logs avec pgBadger

### R√®gles d'or

1. **Le pushdown est ROI** : Investir du temps pour maximiser le pushdown donne des gains √©normes.

2. **Mesurer, ne pas deviner** : Toujours utiliser `EXPLAIN` pour comprendre ce qui se passe r√©ellement.

3. **Mat√©rialiser intelligemment** : Pour les donn√©es consult√©es fr√©quemment et qui changent peu, la mat√©rialisation est souvent la meilleure solution.

4. **Optimiser les deux c√¥t√©s** : Index et configuration c√¥t√© distant sont aussi importants que c√¥t√© local.

5. **Latence r√©seau = ennemi #1** : Chaque aller-retour co√ªte cher. Minimisez-les.

---

## Conclusion

### Points cl√©s √† retenir

‚úÖ Le **pushdown d'op√©rations** est le m√©canisme qui d√©termine si le traitement se fait √† distance ou localement

‚úÖ Un bon pushdown peut am√©liorer les performances de **100√ó √† 1000√ó**

‚úÖ **postgres_fdw** a le meilleur pushdown, suivi d'oracle_fdw et mysql_fdw. file_fdw n'a aucun pushdown.

‚úÖ `EXPLAIN (VERBOSE)` est votre meilleur ami pour diagnostiquer les probl√®mes de performance

‚úÖ Les index sur le serveur distant sont essentiels pour de bonnes performances

‚úÖ `fetch_size` et `use_remote_estimate` sont des param√®tres critiques √† ajuster

‚ö†Ô∏è Les jointures entre foreign tables de serveurs diff√©rents sont co√ªteuses

‚ö†Ô∏è Les fonctions personnalis√©es ne sont g√©n√©ralement pas poussables

üéØ Mat√©rialisez les donn√©es fr√©quemment consult√©es avec des vues mat√©rialis√©es

### Prochaines √©tapes

Pour ma√Ætriser les performances FDW :
1. **Pratiquer** avec `EXPLAIN` sur vos propres requ√™tes
2. **Benchmarker** : Comparer les temps avec/sans pushdown
3. **Monitorer** : Mettre en place pg_stat_statements et alerting
4. **Optimiser** : It√©rer sur les requ√™tes les plus lentes

### Ressources

- [Documentation PostgreSQL - FDW Performance](https://www.postgresql.org/docs/current/postgres-fdw.html)
- [Explain Visualizer](https://explain.depesz.com/) - Outil pour analyser les plans
- [PgBadger](https://pgbadger.darold.net/) - Analyse de logs
- Livre : *Mastering PostgreSQL 14* (Chapitre sur FDW)

---


‚è≠Ô∏è [TimescaleDB : S√©ries temporelles et hypertables](/18-extensions-et-integrations/05-timescaledb.md)
