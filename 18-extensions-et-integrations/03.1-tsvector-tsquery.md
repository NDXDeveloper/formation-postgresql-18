üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.3.1. Full-Text Search : tsvector et tsquery

## Introduction

Imaginez que vous devez construire une fonctionnalit√© de recherche pour un site e-commerce, un blog, ou une application de gestion documentaire. Vos utilisateurs tapent "chaussures rouges femme" et s'attendent √† trouver tous les produits pertinents, m√™me si la description dit "escarpin rouge pour dame".

Les recherches simples avec `LIKE` ou `ILIKE` ne suffisent pas :
- ‚ùå Pas de gestion du pluriel ("chaussure" vs "chaussures")
- ‚ùå Pas de recherche par pertinence (quel r√©sultat est le plus pertinent ?)
- ‚ùå Performances m√©diocres sur de grandes quantit√©s de texte
- ‚ùå Pas de gestion des variantes linguistiques ("chaussure", "chaussures", "chausser")

C'est l√† qu'intervient le **Full-Text Search** de PostgreSQL, un syst√®me de recherche textuelle puissant et performant int√©gr√© directement dans la base de donn√©es.

Au c≈ìur de ce syst√®me se trouvent deux types de donn√©es fondamentaux :
- **tsvector** : Repr√©sente un document pr√©par√© pour la recherche (index√©)
- **tsquery** : Repr√©sente une requ√™te de recherche

---

## 1. Qu'est-ce que le Full-Text Search ?

### Le Probl√®me avec LIKE

Prenons un exemple simple :

```sql
-- Table d'articles de blog
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(200),
    contenu TEXT
);

INSERT INTO articles (titre, contenu) VALUES
    ('Guide PostgreSQL', 'PostgreSQL est un syst√®me de gestion de base de donn√©es relationnel puissant.'),
    ('Apprendre SQL', 'SQL est le langage standard pour interroger les bases de donn√©es.'),
    ('Tutoriel Bases de Donn√©es', 'Les bases de donn√©es stockent et organisent vos donn√©es.');

-- Recherche avec LIKE
SELECT titre FROM articles
WHERE contenu LIKE '%base de donn√©es%';
```

**Probl√®mes** :
1. **Performance** : Scan s√©quentiel de toute la table (pas d'index possible)
2. **Pas de pertinence** : Tous les r√©sultats sont √©gaux
3. **Pas de stemming** : "bases" ‚â† "base", "donn√©es" ‚â† "donn√©e"
4. **Sensible √† la casse** : N√©cessite ILIKE (encore plus lent)

### La Solution : Full-Text Search

Le Full-Text Search de PostgreSQL :
- ‚úÖ **Indexable** : Recherches ultra-rapides avec index GIN
- ‚úÖ **Ranking** : Trie par pertinence
- ‚úÖ **Stemming** : Normalise les mots ("bases" ‚Üí "base")
- ‚úÖ **Langues** : Support de 20+ langues (fran√ßais, anglais, espagnol, etc.)
- ‚úÖ **Op√©rateurs riches** : AND, OR, NOT, proximit√©, phrases exactes

---

## 2. tsvector : Le Document Index√©

### Qu'est-ce qu'un tsvector ?

Un **tsvector** est une repr√©sentation optimis√©e d'un document texte pour la recherche. Il contient :
- Les **lex√®mes** (mots normalis√©s/stemmed)
- Les **positions** de chaque lex√®me dans le document
- Les **poids** optionnels (A, B, C, D pour l'importance)

**Transformation** :
```
Texte original :
"PostgreSQL est une base de donn√©es puissante. Les bases de donn√©es sont essentielles."

‚Üì Traitement (tokenization + stemming)

tsvector :
'base':4,9 'donn':6,11 'essenti':13 'postgresql':1 'puiss':7
```

### Cr√©er un tsvector

#### M√©thode 1 : Conversion Directe (sans langue)

```sql
-- Conversion simple en tsvector
SELECT 'PostgreSQL est une base de donn√©es puissante'::tsvector;

-- R√©sultat :
-- 'PostgreSQL' 'base' 'de' 'donn√©es' 'est' 'puissante' 'une'
-- (pas de stemming, mots tri√©s alphab√©tiquement)
```

**‚ö†Ô∏è Attention** : Cette m√©thode ne fait **PAS** de stemming et garde tous les mots tels quels.

#### M√©thode 2 : to_tsvector() - La M√©thode Recommand√©e

```sql
-- Avec stemming et langue fran√ßaise
SELECT to_tsvector('french', 'PostgreSQL est une base de donn√©es puissante');

-- R√©sultat :
-- 'base':4 'donn':6 'postgresql':1 'puiss':7
-- (stemming appliqu√©, positions conserv√©es, mots vides supprim√©s)
```

**Explication** :
- `'french'` : Configuration linguistique (fran√ßais)
- **Stemming** : "donn√©es" ‚Üí "donn", "puissante" ‚Üí "puiss"
- **Stop words** : "est", "une", "de" supprim√©s (mots vides)
- **Positions** : Les chiffres indiquent la position d'origine

#### Langues Disponibles

```sql
-- Lister les configurations disponibles
SELECT cfgname FROM pg_ts_config;

-- R√©sultat typique :
-- simple      (pas de stemming)
-- arabic
-- danish
-- dutch
-- english
-- finnish
-- french      ‚Üê Pour le fran√ßais
-- german
-- hungarian
-- italian
-- norwegian
-- portuguese
-- romanian
-- russian
-- spanish
-- swedish
-- turkish
```

### Anatomie d'un tsvector

```sql
-- Exemple d√©taill√©
SELECT to_tsvector('french',
    'Les bases de donn√©es PostgreSQL sont tr√®s puissantes. ' ||
    'PostgreSQL g√®re les donn√©es efficacement.'
);

-- R√©sultat :
-- 'base':2 'donn':4,11 'efficac':12 'ger':10 'postgresql':5,9 'puiss':8 'tres':7
```

**D√©composition** :
```
'base':2           ‚Üí Lex√®me "base" √† la position 2
'donn':4,11        ‚Üí Lex√®me "donn" aux positions 4 et 11 (donn√©es r√©p√©t√©)
'postgresql':5,9   ‚Üí "PostgreSQL" appara√Æt 2 fois
'puiss':8          ‚Üí "puissantes" ‚Üí stemmed en "puiss"
```

### Op√©rations sur tsvector

#### Concat√©nation

```sql
-- Combiner plusieurs tsvector
SELECT
    to_tsvector('french', 'PostgreSQL est puissant') ||
    to_tsvector('french', 'et performant');

-- R√©sultat : 'perform':6 'postgresql':1 'puiss':3'
```

#### Extraction d'Information

```sql
-- Nombre de lex√®mes uniques
SELECT length(to_tsvector('french', 'PostgreSQL est une base de donn√©es PostgreSQL'));
-- R√©sultat : 4 (postgresql, base, donn, puiss)

-- Extraire tous les lex√®mes
SELECT unnest(to_tsvector('french', 'PostgreSQL et les bases de donn√©es'));
-- R√©sultat :
-- base
-- donn
-- postgresql
```

### tsvector avec Poids

Les lex√®mes peuvent avoir des **poids** (A, B, C, D) pour indiquer leur importance.

```sql
-- Cr√©er un tsvector avec poids
SELECT
    setweight(to_tsvector('french', 'PostgreSQL'), 'A') ||  -- Titre (poids A)
    setweight(to_tsvector('french', 'Base de donn√©es performante'), 'B');  -- Description (poids B)

-- R√©sultat : 'base':3B 'donn':5B 'perform':6B 'postgresql':1A
```

**Poids standard** :
- **A** : Titre (le plus important)
- **B** : Sous-titre ou r√©sum√©
- **C** : Contenu principal
- **D** : M√©tadonn√©es ou contenu secondaire (d√©faut)

---

## 3. tsquery : La Requ√™te de Recherche

### Qu'est-ce qu'un tsquery ?

Un **tsquery** repr√©sente une requ√™te de recherche avec :
- Les termes √† rechercher (normalis√©s/stemmed)
- Les op√©rateurs logiques (AND, OR, NOT)
- Les op√©rateurs de proximit√©

### Cr√©er un tsquery

#### M√©thode 1 : to_tsquery() - Requ√™te Structur√©e

```sql
-- Recherche simple
SELECT to_tsquery('french', 'postgresql');
-- R√©sultat : 'postgresql'

-- Recherche avec AND
SELECT to_tsquery('french', 'postgresql & base');
-- R√©sultat : 'postgresql' & 'base'

-- Recherche avec OR
SELECT to_tsquery('french', 'postgresql | mysql');
-- R√©sultat : 'postgresql' | 'mysql'

-- Recherche avec NOT
SELECT to_tsquery('french', 'postgresql & !oracle');
-- R√©sultat : 'postgresql' & !'oracle'
```

**Op√©rateurs disponibles** :
- `&` : AND (intersection)
- `|` : OR (union)
- `!` : NOT (n√©gation)
- `<->` : Suivi de (mots adjacents)
- `<N>` : Proximit√© (N mots d'√©cart maximum)

**‚ö†Ô∏è Important** : `to_tsquery()` exige une syntaxe stricte (op√©rateurs explicites).

#### M√©thode 2 : plainto_tsquery() - Requ√™te en Texte Libre

```sql
-- Convertit du texte libre en tsquery (plus tol√©rant)
SELECT plainto_tsquery('french', 'postgresql base donn√©es');
-- R√©sultat : 'postgresql' & 'base' & 'donn'
-- (tous les mots avec AND implicite)

-- G√®re les mots vides automatiquement
SELECT plainto_tsquery('french', 'le postgresql et les bases de donn√©es');
-- R√©sultat : 'postgresql' & 'base' & 'donn'
-- ("le", "et", "les", "de" ignor√©s)
```

**Quand utiliser ?** : Pour les recherches utilisateur en texte libre (comme Google).

#### M√©thode 3 : phraseto_tsquery() - Phrase Exacte

```sql
-- Recherche de phrase exacte
SELECT phraseto_tsquery('french', 'base de donn√©es');
-- R√©sultat : 'base' <-> 'donn'
-- (cherche "base" imm√©diatement suivi de "donn")

-- √âquivalent √† :
SELECT to_tsquery('french', 'base <-> donn√©es');
```

**Usage** : Recherche de citations ou expressions exactes.

#### M√©thode 4 : websearch_to_tsquery() - Style Google (PostgreSQL 11+)

```sql
-- Syntaxe intuitive fa√ßon Google
SELECT websearch_to_tsquery('french', 'postgresql "base de donn√©es" -oracle');
-- R√©sultat : 'postgresql' & 'base' <-> 'donn' & !'oracle'
```

**Syntaxe** :
- Guillemets `"..."` : Phrase exacte
- Mot seul : Recherche du mot
- `-mot` : Exclusion (NOT)
- `OR` : Union explicite
- AND implicite entre mots

**Recommandation** : C'est la m√©thode **la plus user-friendly** pour les interfaces de recherche.

---

## 4. L'Op√©rateur de Correspondance : @@

### Le C≈ìur du Full-Text Search

L'op√©rateur `@@` teste si un `tsvector` correspond √† un `tsquery`.

**Syntaxe** :
```sql
tsvector @@ tsquery  ‚Üí boolean
```

### Exemples Simples

```sql
-- Est-ce que le document contient "postgresql" ?
SELECT
    to_tsvector('french', 'PostgreSQL est puissant') @@
    to_tsquery('french', 'postgresql');
-- R√©sultat : true

-- Est-ce que le document contient "mysql" ?
SELECT
    to_tsvector('french', 'PostgreSQL est puissant') @@
    to_tsquery('french', 'mysql');
-- R√©sultat : false
```

### Requ√™tes avec Op√©rateurs

#### AND : Tous les Termes Doivent √ätre Pr√©sents

```sql
-- Document contenant "postgresql" ET "base"
SELECT
    to_tsvector('french', 'PostgreSQL est une base de donn√©es') @@
    to_tsquery('french', 'postgresql & base');
-- R√©sultat : true

SELECT
    to_tsvector('french', 'PostgreSQL est performant') @@
    to_tsquery('french', 'postgresql & base');
-- R√©sultat : false (manque "base")
```

#### OR : Au Moins Un Terme Doit √ätre Pr√©sent

```sql
-- Document contenant "postgresql" OU "mysql"
SELECT
    to_tsvector('french', 'PostgreSQL est open-source') @@
    to_tsquery('french', 'postgresql | mysql');
-- R√©sultat : true (contient postgresql)

SELECT
    to_tsvector('french', 'Oracle est propri√©taire') @@
    to_tsquery('french', 'postgresql | mysql');
-- R√©sultat : false (ni postgresql ni mysql)
```

#### NOT : Exclusion

```sql
-- Document contenant "base" mais PAS "oracle"
SELECT
    to_tsvector('french', 'Base de donn√©es PostgreSQL') @@
    to_tsquery('french', 'base & !oracle');
-- R√©sultat : true

SELECT
    to_tsvector('french', 'Base de donn√©es Oracle') @@
    to_tsquery('french', 'base & !oracle');
-- R√©sultat : false (contient "oracle")
```

#### Proximit√© : Mots Proches

```sql
-- "base" imm√©diatement suivi de "donn√©es"
SELECT
    to_tsvector('french', 'une base de donn√©es') @@
    phraseto_tsquery('french', 'base donn√©es');
-- R√©sultat : true

-- "base" et "donn√©es" s√©par√©s par d'autres mots
SELECT
    to_tsvector('french', 'une base relationnelle de donn√©es') @@
    phraseto_tsquery('french', 'base donn√©es');
-- R√©sultat : false (pas adjacents)
```

### Ordre des Op√©randes

L'op√©rateur `@@` est **commutatif** :

```sql
-- Ces deux requ√™tes sont √©quivalentes
SELECT to_tsvector('french', 'texte') @@ to_tsquery('french', 'mot');
SELECT to_tsquery('french', 'mot') @@ to_tsvector('french', 'texte');
```

---

## 5. Applications Pratiques

### Cas 1 : Table de Produits avec Recherche

```sql
-- Cr√©er une table de produits
CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    description TEXT,
    categorie VARCHAR(100),
    prix NUMERIC(10, 2)
);

-- Ins√©rer des donn√©es
INSERT INTO produits (nom, description, categorie, prix) VALUES
    ('Chaussures de sport Nike', 'Chaussures running l√©g√®res et confortables', 'Sport', 89.99),
    ('Escarpin rouge Gucci', 'Escarpins √©l√©gants pour femme, couleur rouge', 'Mode', 450.00),
    ('Baskets Adidas blanches', 'Baskets casual pour homme et femme', 'Sport', 75.50),
    ('Sandales d''√©t√©', 'Sandales confortables pour l''√©t√©', 'Mode', 35.00);

-- Recherche avec Full-Text Search
SELECT
    nom,
    description,
    prix
FROM produits
WHERE
    to_tsvector('french', nom || ' ' || description) @@
    plainto_tsquery('french', 'chaussure rouge femme');
```

**R√©sultat** :
```
nom                        | description                                    | prix
---------------------------+-----------------------------------------------+-------
Escarpin rouge Gucci       | Escarpins √©l√©gants pour femme, couleur rouge  | 450.00
Baskets Adidas blanches    | Baskets casual pour homme et femme            | 75.50
```

### Cas 2 : Blog avec Recherche d'Articles

```sql
-- Table d'articles
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(200),
    contenu TEXT,
    auteur VARCHAR(100),
    publie_le DATE
);

INSERT INTO articles (titre, contenu, auteur, publie_le) VALUES
    ('Introduction √† PostgreSQL',
     'PostgreSQL est un syst√®me de gestion de base de donn√©es relationnel et objet. ' ||
     'Il est connu pour sa fiabilit√© et ses fonctionnalit√©s avanc√©es.',
     'Jean Dupont',
     '2024-01-15'),
    ('Guide du Full-Text Search',
     'Le Full-Text Search permet de rechercher efficacement dans de grandes quantit√©s de texte. ' ||
     'PostgreSQL offre des fonctionnalit√©s puissantes pour la recherche textuelle.',
     'Marie Martin',
     '2024-02-20'),
    ('Optimisation des requ√™tes SQL',
     'L''optimisation des requ√™tes est essentielle pour de bonnes performances. ' ||
     'Les index et l''analyse du plan d''ex√©cution sont des outils cl√©s.',
     'Jean Dupont',
     '2024-03-10');

-- Recherche d'articles
SELECT
    titre,
    auteur,
    LEFT(contenu, 100) || '...' AS extrait
FROM articles
WHERE
    to_tsvector('french', titre || ' ' || contenu) @@
    websearch_to_tsquery('french', 'postgresql recherche');
```

**R√©sultat** :
```
titre                        | auteur       | extrait
-----------------------------+--------------+----------------------------------------
Introduction √† PostgreSQL    | Jean Dupont  | PostgreSQL est un syst√®me de gestion...
Guide du Full-Text Search    | Marie Martin | Le Full-Text Search permet de rechercher...
```

### Cas 3 : Colonne tsvector Pr√©-calcul√©e (Optimisation)

Pour √©viter de recalculer le tsvector √† chaque requ√™te, on peut le stocker dans une colonne d√©di√©e.

```sql
-- Ajouter une colonne tsvector
ALTER TABLE articles
ADD COLUMN search_vector tsvector;

-- Remplir la colonne avec les donn√©es existantes
UPDATE articles
SET search_vector =
    setweight(to_tsvector('french', COALESCE(titre, '')), 'A') ||
    setweight(to_tsvector('french', COALESCE(contenu, '')), 'B');

-- Cr√©er un index GIN pour la performance
CREATE INDEX idx_articles_search ON articles USING GIN(search_vector);

-- Maintenir automatiquement avec un trigger
CREATE FUNCTION articles_search_trigger() RETURNS trigger AS $$
BEGIN
    NEW.search_vector :=
        setweight(to_tsvector('french', COALESCE(NEW.titre, '')), 'A') ||
        setweight(to_tsvector('french', COALESCE(NEW.contenu, '')), 'B');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tsvector_update
BEFORE INSERT OR UPDATE ON articles
FOR EACH ROW EXECUTE FUNCTION articles_search_trigger();

-- Recherche ultra-rapide (utilise l'index)
SELECT titre, auteur
FROM articles
WHERE search_vector @@ websearch_to_tsquery('french', 'postgresql base donn√©es');
```

**Avantages** :
- ‚úÖ Pas de recalcul √† chaque recherche
- ‚úÖ Index GIN pour des performances optimales
- ‚úÖ Mise √† jour automatique via trigger
- ‚úÖ Poids distincts (titre vs contenu)

---

## 6. Gestion du Stemming et des Variantes

### Comment Fonctionne le Stemming ?

Le **stemming** r√©duit les mots √† leur racine (stem/lemme).

```sql
-- Exemples de stemming fran√ßais
SELECT to_tsvector('french', 'chanter chantons chantaient chantera');
-- R√©sultat : 'chant':1,2,3,4
-- (tous r√©duits √† "chant")

SELECT to_tsvector('french', 'base bases donn√©es donn√©e');
-- R√©sultat : 'base':1,2 'donn':3,4
-- "bases" ‚Üí "base", "donn√©es/donn√©e" ‚Üí "donn"

SELECT to_tsvector('french', 'heureux heureuse heureusement');
-- R√©sultat : 'heur':1,2,3
-- (tous r√©duits √† "heur")
```

### Impact sur les Recherches

```sql
-- Recherche de "chaussure" trouve aussi "chaussures"
SELECT
    'Les chaussures de sport sont confortables'::text AS texte,
    to_tsvector('french', 'Les chaussures de sport sont confortables') @@
    plainto_tsquery('french', 'chaussure') AS trouve;
-- R√©sultat : true

-- Recherche de "donn√©es" trouve aussi "donn√©e"
SELECT
    'La donn√©e est importante'::text AS texte,
    to_tsvector('french', 'La donn√©e est importante') @@
    plainto_tsquery('french', 'donn√©es') AS trouve;
-- R√©sultat : true
```

### Stop Words (Mots Vides)

Les **stop words** sont des mots tr√®s courants qui sont automatiquement ignor√©s.

```sql
-- Mots vides fran√ßais ignor√©s
SELECT to_tsvector('french', 'le la les de des un une et ou');
-- R√©sultat : '' (vide, tous les mots sont des stop words)

-- Impact sur les recherches
SELECT to_tsvector('french', 'Le PostgreSQL et les bases de donn√©es');
-- R√©sultat : 'base':5 'donn':7 'postgresql':2
-- ("le", "et", "les", "de" ignor√©s)
```

**Liste partielle des stop words fran√ßais** :
- Articles : le, la, les, un, une, des
- Pr√©positions : de, √†, en, par, pour, dans
- Conjonctions : et, ou, mais
- Pronoms : je, tu, il, nous, vous, ils

### Configuration Simple (sans langue)

Pour d√©sactiver le stemming et les stop words :

```sql
-- Configuration "simple" : pas de stemming
SELECT to_tsvector('simple', 'Les chaussures sont rouges');
-- R√©sultat : 'chaussures':2 'les':1 'rouges':4 'sont':3
-- (tous les mots conserv√©s, pas de stemming)
```

---

## 7. Debugging et Comprendre les R√©sultats

### Visualiser le Traitement

```sql
-- Voir comment un texte est d√©compos√©
SELECT * FROM ts_debug('french', 'PostgreSQL est une base de donn√©es puissante');
```

**R√©sultat** (extrait) :
```
alias      | description          | token      | dictionaries  | dictionary | lexemes
-----------+---------------------+------------+---------------+------------+---------
asciiword  | Word, all ASCII     | PostgreSQL | {french_stem} | french_stem| {postgresql}
blank      | Space symbols       |            | {}            |            |
asciiword  | Word, all ASCII     | est        | {french_stem} | french_stem| {}
blank      | Space symbols       |            | {}            |            |
asciiword  | Word, all ASCII     | une        | {french_stem} | french_stem| {}
...
```

**Colonnes importantes** :
- `token` : Mot original
- `dictionary` : Dictionnaire utilis√©
- `lexemes` : Forme normalis√©e (vide si stop word)

### Comprendre Pourquoi une Recherche √âchoue

```sql
-- Texte √† rechercher
WITH doc AS (
    SELECT 'PostgreSQL est rapide' AS texte
)
-- Analyser le document
SELECT
    texte,
    to_tsvector('french', texte) AS doc_vector,
    to_tsquery('french', 'performant') AS requete,
    to_tsvector('french', texte) @@ to_tsquery('french', 'performant') AS trouve
FROM doc;
```

**R√©sultat** :
```
texte                  | doc_vector             | requete      | trouve
-----------------------+------------------------+-------------+--------
PostgreSQL est rapide  | 'postgresql':1 'rapid':3 | 'perform':1 | false
```

**Explication** : "rapide" (stemmed: "rapid") ‚â† "performant" (stemmed: "perform")

### Tester le Stemming d'un Mot

```sql
-- Voir le stem d'un mot sp√©cifique
SELECT to_tsvector('french', 'performant');
-- R√©sultat : 'perform':1

SELECT to_tsvector('french', 'performance');
-- R√©sultat : 'perform':1

-- Ces deux mots ont le m√™me stem, donc se trouvent mutuellement
SELECT
    to_tsvector('french', 'syst√®me performant') @@
    to_tsquery('french', 'performance');
-- R√©sultat : true
```

---

## 8. Op√©rateurs et Fonctions Avanc√©s

### Op√©rateurs de Proximit√©

#### Adjacence Stricte (<->)

```sql
-- "base" imm√©diatement suivi de "donn√©es"
SELECT
    to_tsvector('french', 'base de donn√©es') @@
    to_tsquery('french', 'base <-> donn√©es');
-- R√©sultat : true (apr√®s suppression de "de", ils sont adjacents)

SELECT
    to_tsvector('french', 'base relationnelle de donn√©es') @@
    to_tsquery('french', 'base <-> donn√©es');
-- R√©sultat : false ("relationnelle" entre les deux)
```

#### Proximit√© avec Distance (<N>)

```sql
-- "base" et "donn√©es" s√©par√©s par max 2 mots
SELECT
    to_tsvector('french', 'base relationnelle de donn√©es') @@
    to_tsquery('french', 'base <2> donn√©es');
-- R√©sultat : true

-- Distance trop grande
SELECT
    to_tsvector('french', 'base tr√®s grande et complexe de donn√©es') @@
    to_tsquery('french', 'base <2> donn√©es');
-- R√©sultat : false (trop de mots entre)
```

### Pr√©fixes (Recherche par D√©but de Mot)

```sql
-- Chercher tous les mots commen√ßant par "post"
SELECT
    to_tsvector('french', 'PostgreSQL PostGIS poster') @@
    to_tsquery('french', 'post:*');
-- R√©sultat : true

-- Utile pour l'autocompl√©tion
SELECT
    to_tsvector('french', 'd√©veloppement d√©veloppeur d√©velopp√©') @@
    to_tsquery('french', 'devel:*');
-- R√©sultat : true (tous commencent par "devel")
```

### Fonctions Utiles

#### ts_rank : Calculer la Pertinence

```sql
-- Calculer le score de pertinence
WITH doc AS (
    SELECT
        'PostgreSQL' AS id,
        'PostgreSQL est un SGBD. PostgreSQL est open-source.' AS texte
)
SELECT
    id,
    ts_rank(
        to_tsvector('french', texte),
        to_tsquery('french', 'postgresql')
    ) AS score
FROM doc;
-- R√©sultat : score ‚âà 0.06 (plus le score est √©lev√©, plus pertinent)
```

#### ts_headline : Extraire des Extraits

```sql
-- G√©n√©rer un extrait avec les mots trouv√©s mis en √©vidence
SELECT ts_headline('french',
    'PostgreSQL est un syst√®me de gestion de base de donn√©es. ' ||
    'PostgreSQL offre de nombreuses fonctionnalit√©s avanc√©es.',
    to_tsquery('french', 'postgresql & base')
);

-- R√©sultat :
-- "<b>PostgreSQL</b> est un syst√®me de gestion de <b>base</b> de donn√©es..."
```

#### ts_rewrite : Modifier une Requ√™te

```sql
-- R√©√©crire une requ√™te (synonymes)
SELECT ts_rewrite(
    to_tsquery('french', 'postgresql'),
    to_tsquery('french', 'postgresql'),
    to_tsquery('french', 'postgres | postgresql')
);
-- R√©sultat : 'postgres' | 'postgresql'
```

---

## 9. Bonnes Pratiques

### ‚úÖ Utiliser websearch_to_tsquery() pour les Entr√©es Utilisateur

```sql
-- ‚úÖ BON : Tol√©rant, syntaxe intuitive
SELECT * FROM articles
WHERE search_vector @@ websearch_to_tsquery('french', 'postgresql "base donn√©es"');

-- ‚ùå √Ä √âVITER : N√©cessite syntaxe stricte, erreurs faciles
SELECT * FROM articles
WHERE search_vector @@ to_tsquery('french', 'postgresql & base <-> donn√©es');
```

### ‚úÖ Cr√©er des Colonnes tsvector D√©di√©es

```sql
-- ‚úÖ BON : Performance optimale
ALTER TABLE produits ADD COLUMN search_vector tsvector;
CREATE INDEX idx_produits_search ON produits USING GIN(search_vector);

-- ‚ùå LENT : Recalcul √† chaque requ√™te
SELECT * FROM produits
WHERE to_tsvector('french', nom || ' ' || description) @@ ...;
```

### ‚úÖ Utiliser des Poids pour Hi√©rarchiser

```sql
-- ‚úÖ BON : Titre plus important que contenu
UPDATE articles
SET search_vector =
    setweight(to_tsvector('french', titre), 'A') ||
    setweight(to_tsvector('french', contenu), 'B');

-- Recherche avec ranking
SELECT titre, ts_rank(search_vector, query) AS score
FROM articles, to_tsquery('french', 'postgresql') query
WHERE search_vector @@ query
ORDER BY score DESC;
```

### ‚úÖ G√©rer les Valeurs NULL

```sql
-- ‚úÖ BON : Protection contre NULL
to_tsvector('french', COALESCE(colonne, ''))

-- ‚ùå ERREUR : NULL g√©n√®re une erreur
to_tsvector('french', colonne)  -- si colonne est NULL
```

### ‚úÖ Choisir la Bonne Configuration Linguistique

```sql
-- ‚úÖ BON : Langue appropri√©e
to_tsvector('french', texte_francais)
to_tsvector('english', english_text)

-- ‚ùå MAUVAIS : Mauvais stemming
to_tsvector('english', texte_francais)  -- Stemming anglais sur fran√ßais
```

### ‚úÖ Combiner Full-Text avec Filtres Classiques

```sql
-- ‚úÖ BON : Combiner recherche texte + filtres
SELECT * FROM produits
WHERE
    search_vector @@ plainto_tsquery('french', 'chaussure')
    AND prix BETWEEN 50 AND 200
    AND categorie = 'Sport';
```

---

## 10. Performance et Index GIN

### Cr√©er un Index GIN

```sql
-- Index GIN sur tsvector (requis pour la performance)
CREATE INDEX idx_articles_search
ON articles
USING GIN(search_vector);
```

**Sans index GIN** :
```
Seq Scan on articles  (cost=0..150 rows=10)
  Filter: (search_vector @@ to_tsquery(...))
Planning Time: 0.5ms
Execution Time: 45ms
```

**Avec index GIN** :
```
Bitmap Index Scan on idx_articles_search  (cost=0..5 rows=10)
  Index Cond: (search_vector @@ to_tsquery(...))
Planning Time: 0.3ms
Execution Time: 2ms
```

**Gain** : 20√ó plus rapide !

### Options d'Index GIN

```sql
-- Index GIN standard
CREATE INDEX idx_standard ON articles USING GIN(search_vector);

-- Index GIN avec fastupdate (mises √† jour plus rapides)
CREATE INDEX idx_fastupdate ON articles
USING GIN(search_vector)
WITH (fastupdate = on);

-- Index GIN avec maintenance r√©duite
CREATE INDEX idx_low_maintenance ON articles
USING GIN(search_vector)
WITH (fastupdate = on, gin_pending_list_limit = 4096);
```

### Maintenance des Index GIN

```sql
-- Statistiques de l'index
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE indexname = 'idx_articles_search';

-- Reconstruire l'index si n√©cessaire
REINDEX INDEX idx_articles_search;
```

---

## 11. Cas d'Usage Avanc√© : Moteur de Recherche Complet

```sql
-- Table compl√®te avec recherche full-text
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(200),
    description TEXT,
    contenu TEXT,
    auteur VARCHAR(100),
    categorie VARCHAR(50),
    tags TEXT[],
    created_at TIMESTAMP DEFAULT NOW(),
    search_vector tsvector
);

-- Trigger pour maintenir search_vector
CREATE FUNCTION documents_search_trigger() RETURNS trigger AS $$
BEGIN
    NEW.search_vector :=
        setweight(to_tsvector('french', COALESCE(NEW.titre, '')), 'A') ||
        setweight(to_tsvector('french', COALESCE(NEW.description, '')), 'B') ||
        setweight(to_tsvector('french', COALESCE(NEW.contenu, '')), 'C') ||
        setweight(to_tsvector('french', COALESCE(NEW.auteur, '')), 'D') ||
        setweight(to_tsvector('french', COALESCE(array_to_string(NEW.tags, ' '), '')), 'B');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tsvector_update
BEFORE INSERT OR UPDATE ON documents
FOR EACH ROW EXECUTE FUNCTION documents_search_trigger();

-- Index GIN
CREATE INDEX idx_documents_search ON documents USING GIN(search_vector);

-- Fonction de recherche compl√®te avec ranking et highlights
CREATE OR REPLACE FUNCTION search_documents(search_query TEXT)
RETURNS TABLE (
    id INT,
    titre VARCHAR,
    description TEXT,
    score REAL,
    extrait TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        d.id,
        d.titre,
        d.description,
        ts_rank(d.search_vector, query) AS score,
        ts_headline('french', d.contenu, query, 'MaxWords=50, MinWords=25') AS extrait
    FROM
        documents d,
        websearch_to_tsquery('french', search_query) query
    WHERE d.search_vector @@ query
    ORDER BY score DESC
    LIMIT 20;
END;
$$ LANGUAGE plpgsql;

-- Utilisation
SELECT * FROM search_documents('postgresql base donn√©es');
```

---

## 12. Comparaison : LIKE vs Full-Text Search

### Performance

```sql
-- Test avec 100,000 articles

-- M√©thode 1 : LIKE (LENT)
EXPLAIN ANALYZE
SELECT * FROM articles
WHERE contenu LIKE '%postgresql%';
-- Seq Scan: 2500ms

-- M√©thode 2 : ILIKE (ENCORE PLUS LENT)
EXPLAIN ANALYZE
SELECT * FROM articles
WHERE contenu ILIKE '%postgresql%';
-- Seq Scan: 3200ms

-- M√©thode 3 : Full-Text Search (RAPIDE)
EXPLAIN ANALYZE
SELECT * FROM articles
WHERE search_vector @@ to_tsquery('french', 'postgresql');
-- Bitmap Index Scan: 12ms

-- Gain: 200√ó plus rapide !
```

### Fonctionnalit√©s

| Aspect | LIKE/ILIKE | Full-Text Search |
|--------|------------|------------------|
| **Performance** | ‚ùå Lent (scan s√©quentiel) | ‚úÖ Rapide (index GIN) |
| **Indexable** | ‚ö†Ô∏è Partiel (trigram) | ‚úÖ Oui (GIN) |
| **Stemming** | ‚ùå Non | ‚úÖ Oui |
| **Langues** | ‚ùå Non | ‚úÖ 20+ langues |
| **Ranking** | ‚ùå Non | ‚úÖ Oui (pertinence) |
| **Phrases** | ‚ö†Ô∏è Basique | ‚úÖ Avanc√© (proximit√©) |
| **Stop words** | ‚ùå Non | ‚úÖ Oui |
| **Op√©rateurs** | ‚ö†Ô∏è Basique (%, _) | ‚úÖ Riche (&, \|, !, <->) |
| **Highlights** | ‚ùå Non | ‚úÖ Oui (ts_headline) |

**Conclusion** : Full-Text Search est sup√©rieur dans presque tous les cas.

---

## 13. R√©sum√© et Aide-M√©moire

### tsvector : Document Index√©

```sql
-- Cr√©er un tsvector
to_tsvector('french', 'texte √† indexer')

-- Avec poids
setweight(to_tsvector('french', 'titre'), 'A')

-- Concat√©nation
tsvector1 || tsvector2
```

### tsquery : Requ√™te

```sql
-- Requ√™te structur√©e (op√©rateurs explicites)
to_tsquery('french', 'mot1 & mot2 | mot3')

-- Texte libre (recommand√© pour utilisateurs)
plainto_tsquery('french', 'mots en texte libre')
websearch_to_tsquery('french', 'syntaxe "google style" -exclusion')

-- Phrase exacte
phraseto_tsquery('french', 'phrase exacte')
```

### Op√©rateur de Recherche

```sql
-- Correspondance
tsvector @@ tsquery

-- Exemple complet
to_tsvector('french', 'texte') @@ plainto_tsquery('french', 'recherche')
```

### Op√©rateurs tsquery

| Op√©rateur | Signification | Exemple |
|-----------|---------------|---------|
| `&` | AND (ET) | `mot1 & mot2` |
| `\|` | OR (OU) | `mot1 \| mot2` |
| `!` | NOT (NON) | `mot1 & !mot2` |
| `<->` | Suivi imm√©diat | `mot1 <-> mot2` |
| `<N>` | Proximit√© (N mots) | `mot1 <2> mot2` |
| `:*` | Pr√©fixe | `post:*` |

### Fonctions Utiles

```sql
-- Ranking (pertinence)
ts_rank(tsvector, tsquery)

-- Extraits avec mots en √©vidence
ts_headline('french', texte, tsquery)

-- Debug
ts_debug('french', texte)
```

### Pattern Complet

```sql
-- 1. Cr√©er la colonne
ALTER TABLE ma_table ADD COLUMN search_vector tsvector;

-- 2. Remplir
UPDATE ma_table SET search_vector =
    setweight(to_tsvector('french', COALESCE(titre, '')), 'A') ||
    setweight(to_tsvector('french', COALESCE(contenu, '')), 'B');

-- 3. Index GIN
CREATE INDEX idx_search ON ma_table USING GIN(search_vector);

-- 4. Trigger auto-update
CREATE TRIGGER tsvector_update BEFORE INSERT OR UPDATE ON ma_table
FOR EACH ROW EXECUTE FUNCTION ma_table_search_trigger();

-- 5. Recherche
SELECT * FROM ma_table
WHERE search_vector @@ websearch_to_tsquery('french', 'recherche utilisateur')
ORDER BY ts_rank(search_vector, websearch_to_tsquery('french', 'recherche utilisateur')) DESC;
```

---

## Conclusion

Les types **tsvector** et **tsquery** sont au c≈ìur du syst√®me Full-Text Search de PostgreSQL. Ils permettent de construire des moteurs de recherche puissants et performants directement dans la base de donn√©es, sans d√©pendre d'outils externes comme Elasticsearch.

**Points cl√©s √† retenir** :

1. **tsvector** repr√©sente un document pr√©par√© pour la recherche
   - Lex√®mes normalis√©s (stemming)
   - Positions conserv√©es
   - Poids optionnels (A, B, C, D)

2. **tsquery** repr√©sente une requ√™te de recherche
   - Op√©rateurs logiques (&, |, !)
   - Op√©rateurs de proximit√© (<->, <N>)
   - Pr√©fixes (:*)

3. **Op√©rateur @@** teste la correspondance
   - `tsvector @@ tsquery` ‚Üí boolean

4. **Performance** avec index GIN
   - Requis pour la rapidit√©
   - 100√ó √† 1000√ó plus rapide que LIKE

5. **Bonnes pratiques**
   - Colonne tsvector d√©di√©e + trigger
   - websearch_to_tsquery() pour entr√©es utilisateur
   - Poids pour hi√©rarchiser (titre > contenu)
   - Index GIN obligatoire

Le Full-Text Search PostgreSQL est une alternative s√©rieuse aux solutions externes (Elasticsearch, Solr) pour la plupart des cas d'usage, avec l'avantage de la simplicit√© (tout en SQL) et de la coh√©rence transactionnelle.

Dans les prochaines sections, vous d√©couvrirez le **ranking** (tri par pertinence) et la **pond√©ration** pour affiner vos r√©sultats de recherche !

---

**Ressources compl√©mentaires** :
- Documentation PostgreSQL Full-Text Search : https://www.postgresql.org/docs/current/textsearch.html
- Tutorial interactif : https://www.compose.com/articles/mastering-postgresql-tools-full-text-search-and-phrase-search/
- tsvector et tsquery d√©taill√©s : https://www.postgresql.org/docs/current/datatype-textsearch.html

‚è≠Ô∏è [Ranking et pond√©ration (ts_rank, setweight)](/18-extensions-et-integrations/03.2-ranking-ponderation.md)
