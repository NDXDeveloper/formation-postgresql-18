üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.7.3. pg_stat_kcache : M√©triques Syst√®me pour PostgreSQL

## Introduction

**pg_stat_kcache** est une extension PostgreSQL qui collecte des **m√©triques au niveau syst√®me** (CPU, I/O disque, m√©moire) pour chaque requ√™te SQL ex√©cut√©e. Elle compl√®te l'extension **pg_stat_statements** en ajoutant une dimension syst√®me indispensable pour l'analyse de performance.

### Pourquoi les m√©triques syst√®me sont-elles importantes ?

Lorsque vous analysez la performance d'une base de donn√©es, conna√Ætre uniquement le **temps d'ex√©cution** d'une requ√™te n'est pas suffisant. Vous devez comprendre **o√π** ce temps est pass√© :

- ‚è±Ô∏è **Temps CPU** : La requ√™te calcule beaucoup ? (tri, agr√©gation, jointures complexes)
- üíæ **I/O disque** : La requ√™te lit/√©crit beaucoup sur disque ? (scan s√©quentiel, index inefficace)
- üìä **Cache hits** : Les donn√©es sont-elles en m√©moire ou lues depuis le disque ?
- üß† **M√©moire** : Quelle quantit√© de RAM la requ√™te consomme-t-elle ?

**Exemple concret** :

```
Requ√™te A : 10 secondes d'ex√©cution
‚îú‚îÄ 1 seconde de CPU
‚îî‚îÄ 9 secondes d'attente I/O disque  ‚Üê GOULOT D'√âTRANGLEMENT

Requ√™te B : 10 secondes d'ex√©cution
‚îú‚îÄ 9.5 secondes de CPU  ‚Üê GOULOT D'√âTRANGLEMENT
‚îî‚îÄ 0.5 seconde d'I/O disque
```

**Sans pg_stat_kcache** : Vous savez que les deux requ√™tes prennent 10 secondes, mais vous ne savez pas pourquoi.

**Avec pg_stat_kcache** : Vous identifiez imm√©diatement que :
- Requ√™te A ‚Üí Ajouter un index pour r√©duire l'I/O
- Requ√™te B ‚Üí Optimiser l'algorithme pour r√©duire le CPU

### Qu'est-ce que pg_stat_kcache apporte ?

pg_stat_kcache enrichit **pg_stat_statements** avec :

- ‚úÖ **Temps CPU utilisateur** : Temps pass√© √† ex√©cuter du code utilisateur
- ‚úÖ **Temps CPU syst√®me** : Temps pass√© dans les appels syst√®me (kernel)
- ‚úÖ **Lectures disque** : Nombre de blocs lus depuis le disque
- ‚úÖ **√âcritures disque** : Nombre de blocs √©crits sur le disque
- ‚úÖ **Lectures logiques** : Nombre de blocs lus (cache + disque)
- ‚úÖ **Faults de m√©moire** : D√©fauts de page mineurs/majeurs

### Architecture : pg_stat_statements + pg_stat_kcache

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Application                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ Ex√©cute des requ√™tes SQL
                  ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           PostgreSQL Server                    ‚îÇ
‚îÇ                                                ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  Extension: pg_stat_statements            ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  (Collecte: temps, appels, lignes)        ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                  ‚Üì                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  Extension: pg_stat_kcache                ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  (Collecte: CPU, I/O, m√©moire)            ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  Via /proc/[pid]/stat (Linux)             ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                  ‚Üì                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  Vue: pg_stat_kcache                      ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  (M√©triques accessibles via SQL)          ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Pr√©requis conceptuels

Pour bien comprendre pg_stat_kcache, quelques notions de base :

#### Qu'est-ce que le CPU ?

Le **CPU (processeur)** ex√©cute les instructions de votre code. Dans PostgreSQL :
- **Calculs** : Agr√©gations (SUM, AVG), tris (ORDER BY), jointures
- **Comparaisons** : Filtres WHERE, √©valuations de conditions
- **Traitement** : D√©compression, parsing, optimisation de requ√™tes

**Temps CPU** = Temps o√π le processeur travaille activement pour votre requ√™te.

#### Qu'est-ce que l'I/O disque ?

L'**I/O (Input/Output)** repr√©sente les lectures et √©critures sur le disque :
- **Lectures** : R√©cup√©rer des donn√©es depuis le disque (quand pas en cache)
- **√âcritures** : Persister des donn√©es modifi√©es (INSERT, UPDATE, DELETE)

**Temps I/O** = Temps d'attente pour que le disque r√©ponde.

**Important** : Le disque est **1000√ó plus lent** que la RAM. C'est souvent le goulot d'√©tranglement principal.

#### Qu'est-ce que le cache (Buffer Cache) ?

PostgreSQL maintient un **cache en m√©moire** (`shared_buffers`) pour √©viter de relire le disque :
- **Cache hit** : Donn√©e trouv√©e en m√©moire (rapide, ~¬µs)
- **Cache miss** : Donn√©e lue depuis le disque (lent, ~ms)

**Objectif** : Maximiser le taux de cache hit (>95% est excellent).

---

## Installation et Configuration

### Pr√©requis

- **PostgreSQL 9.4+** (id√©alement PostgreSQL 18)
- **Linux** : pg_stat_kcache utilise `/proc/[pid]/stat` (sp√©cifique √† Linux)
- **pg_stat_statements** : Doit √™tre install√© et activ√©
- **Droits superutilisateur** : Pour l'installation initiale

**Note** : pg_stat_kcache ne fonctionne que sur Linux. Sur Windows/macOS, certaines m√©triques ne seront pas disponibles.

### Processus d'installation (th√©orique)

#### √âtape 1 : Installer pg_stat_statements (si pas d√©j√† fait)

pg_stat_kcache d√©pend de pg_stat_statements.

```ini
# postgresql.conf
shared_preload_libraries = 'pg_stat_statements'

# Configuration recommand√©e pour pg_stat_statements
pg_stat_statements.max = 10000          # Nombre de requ√™tes distinctes √† tracker
pg_stat_statements.track = all          # Tracker toutes les requ√™tes
pg_stat_statements.track_utility = on   # Inclure les commandes DDL
```

**Important** : Red√©marrer PostgreSQL apr√®s modification de `shared_preload_libraries`.

```sql
-- Cr√©er l'extension pg_stat_statements
CREATE EXTENSION pg_stat_statements;
```

#### √âtape 2 : Installer pg_stat_kcache

Ajouter pg_stat_kcache aux biblioth√®ques pr√©charg√©es :

```ini
# postgresql.conf
shared_preload_libraries = 'pg_stat_statements,pg_stat_kcache'
```

**Important** : Les extensions doivent √™tre s√©par√©es par des virgules, sans espaces.

Red√©marrer PostgreSQL :

```bash
# Commande syst√®me (exemple pour systemd)
sudo systemctl restart postgresql
```

#### √âtape 3 : Cr√©er l'extension

```sql
-- Se connecter √† la base de donn√©es
CREATE EXTENSION pg_stat_kcache;
```

#### √âtape 4 : V√©rifier l'installation

```sql
-- V√©rifier que l'extension est active
SELECT * FROM pg_extension WHERE extname = 'pg_stat_kcache';

-- V√©rifier que la vue existe
\d pg_stat_kcache

-- Tester une requ√™te simple
SELECT * FROM pg_stat_kcache LIMIT 5;
```

Si tout fonctionne, vous devriez voir des m√©triques syst√®me pour les requ√™tes ex√©cut√©es.

### Configuration Avanc√©e (Optionnelle)

pg_stat_kcache h√©rite de la configuration de pg_stat_statements. Quelques param√®tres utiles :

```ini
# Augmenter le nombre de requ√™tes track√©es
pg_stat_statements.max = 20000

# R√©initialisation automatique en cas de saturation
# (par d√©faut, les anciennes requ√™tes sont √©vinc√©es)

# Activer le tracking des fonctions (co√ªt additionnel)
pg_stat_statements.track = all
```

---

## Comprendre les M√©triques de pg_stat_kcache

### Structure de la vue pg_stat_kcache

```sql
SELECT * FROM pg_stat_kcache LIMIT 1;
```

**Colonnes principales** :

| Colonne | Type | Signification |
|---------|------|---------------|
| `queryid` | bigint | Identifiant unique de la requ√™te (hash) |
| `userid` | oid | Utilisateur ayant ex√©cut√© la requ√™te |
| `dbid` | oid | Base de donn√©es |
| `user_time` | double precision | Temps CPU utilisateur (secondes) |
| `system_time` | double precision | Temps CPU syst√®me/kernel (secondes) |
| `minflts` | bigint | Minor page faults (acc√®s m√©moire sans I/O) |
| `majflts` | bigint | Major page faults (acc√®s m√©moire avec I/O disque) |
| `nswaps` | bigint | Nombre de swaps (rare, indique manque de RAM) |
| `reads` | bigint | Nombre de lectures I/O (blocs lus depuis disque) |
| `writes` | bigint | Nombre d'√©critures I/O (blocs √©crits sur disque) |
| `msgsnds` | bigint | Messages IPC envoy√©s |
| `msgrcvs` | bigint | Messages IPC re√ßus |
| `nsignals` | bigint | Signaux re√ßus |
| `nvcsws` | bigint | Context switches volontaires |
| `nivcsws` | bigint | Context switches involontaires |

### M√©triques Cl√©s Expliqu√©es

#### 1. user_time (Temps CPU Utilisateur)

**D√©finition** : Temps pass√© √† ex√©cuter le code PostgreSQL (calculs, traitement de donn√©es).

**Interpr√©tation** :
- **√âlev√©** ‚Üí La requ√™te fait beaucoup de calculs (jointures, agr√©gations, tris)
- **Faible** ‚Üí La requ√™te est l√©g√®re en calculs ou passe son temps √† attendre (I/O)

**Exemple** :
```sql
SELECT
    query,
    calls,
    total_exec_time,
    user_time,
    ROUND(100.0 * user_time / NULLIF(total_exec_time, 0), 2) as cpu_percent
FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
WHERE total_exec_time > 0
ORDER BY user_time DESC
LIMIT 10;
```

**Si cpu_percent > 80%** ‚Üí La requ√™te est CPU-bound (optimiser l'algorithme, ajouter des index pour r√©duire les calculs).

#### 2. system_time (Temps CPU Syst√®me)

**D√©finition** : Temps pass√© dans les appels syst√®me (kernel) : I/O, gestion de la m√©moire, locks.

**Interpr√©tation** :
- **√âlev√©** ‚Üí La requ√™te fait beaucoup d'appels syst√®me (I/O, locks, network)
- **G√©n√©ralement plus faible** que `user_time` pour des requ√™tes normales

**Ratio typique** : `user_time` / `system_time` ‚âà 3:1 √† 10:1

**Si system_time > user_time** ‚Üí Probl√®me potentiel (trop d'I/O, contention, locks).

#### 3. reads / writes (I/O Disque)

**D√©finition** :
- `reads` : Nombre de blocs de 8 Ko lus depuis le disque (cache miss)
- `writes` : Nombre de blocs de 8 Ko √©crits sur le disque

**Interpr√©tation** :
```sql
SELECT
    query,
    calls,
    reads,
    writes,
    ROUND(reads / NULLIF(calls, 0)::numeric, 2) as avg_reads_per_call,
    ROUND(writes / NULLIF(calls, 0)::numeric, 2) as avg_writes_per_call
FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
WHERE calls > 100
ORDER BY reads DESC
LIMIT 10;
```

**Crit√®res** :
- **avg_reads_per_call > 1000** ‚Üí Requ√™te lit beaucoup de donn√©es (scan s√©quentiel ?)
- **avg_writes_per_call > 100** ‚Üí Requ√™te √©crit beaucoup (bulk insert/update ?)

**Optimisation** :
- R√©duire `reads` ‚Üí Ajouter des index, augmenter `shared_buffers`, optimiser les requ√™tes
- R√©duire `writes` ‚Üí Batch des op√©rations, utiliser COPY au lieu de INSERT

#### 4. minflts / majflts (Page Faults)

**D√©finition** :
- **Minor page fault** : Acc√®s √† une page m√©moire non charg√©e mais disponible en RAM (rapide)
- **Major page fault** : Acc√®s √† une page m√©moire n√©cessitant une lecture disque (lent)

**Interpr√©tation** :
```sql
SELECT
    query,
    minflts,
    majflts,
    CASE
        WHEN majflts > minflts * 0.01 THEN 'ALERTE: Trop de major faults'
        ELSE 'OK'
    END as status
FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
ORDER BY majflts DESC
LIMIT 10;
```

**Crit√®res** :
- **majflts √©lev√©** ‚Üí Manque de RAM, donn√©es swapp√©es sur disque
- **minflts √©lev√©** ‚Üí Normal pour grandes allocations m√©moire

**Action** : Si `majflts` est √©lev√©, augmentez la RAM du serveur ou optimisez les requ√™tes pour consommer moins de m√©moire.

#### 5. nvcsws / nivcsws (Context Switches)

**D√©finition** :
- **Volontaire (nvcsws)** : Le processus c√®de volontairement le CPU (attente I/O, lock)
- **Involontaire (nivcsws)** : Le syst√®me force le changement de contexte (pr√©emption)

**Interpr√©tation** :
- **nvcsws √©lev√©** ‚Üí La requ√™te attend souvent (I/O, locks, network)
- **nivcsws √©lev√©** ‚Üí Forte contention CPU (trop de processus concurrents)

**Ratio sain** : `nvcsws` >> `nivcsws` (typiquement 10:1 ou plus)

---

## Requ√™tes d'Analyse Essentielles

### 1. Top 10 des requ√™tes consommant le plus de CPU

```sql
SELECT
    LEFT(query, 100) as query_snippet,
    calls,
    ROUND(total_exec_time::numeric, 2) as total_time_ms,
    ROUND((user_time + system_time)::numeric, 2) as total_cpu_s,
    ROUND(100.0 * (user_time + system_time) / NULLIF(total_exec_time / 1000.0, 0), 2) as cpu_percent,
    ROUND((user_time / NULLIF(calls, 0))::numeric, 4) as avg_user_time_per_call
FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
WHERE total_exec_time > 0
ORDER BY (user_time + system_time) DESC
LIMIT 10;
```

**Interpr√©tation** :
- `cpu_percent > 80%` ‚Üí Requ√™te CPU-bound (optimiser l'algorithme)
- `cpu_percent < 20%` ‚Üí Requ√™te I/O-bound (optimiser l'I/O)

### 2. Top 10 des requ√™tes avec le plus d'I/O disque

```sql
SELECT
    LEFT(query, 100) as query_snippet,
    calls,
    reads,
    writes,
    reads + writes as total_io,
    ROUND((reads + writes) / NULLIF(calls, 0)::numeric, 2) as avg_io_per_call,
    pg_size_pretty((reads + writes) * 8192) as total_io_size  -- 8KB par bloc
FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
WHERE calls > 0
ORDER BY (reads + writes) DESC
LIMIT 10;
```

**Interpr√©tation** :
- `avg_io_per_call > 1000` ‚Üí Requ√™te lit/√©crit beaucoup de donn√©es
- `reads >> writes` ‚Üí Requ√™te en lecture intensive (SELECT, scan)
- `writes > reads` ‚Üí Requ√™te en √©criture intensive (INSERT, UPDATE)

### 3. Identifier les requ√™tes I/O-bound vs CPU-bound

```sql
SELECT
    LEFT(query, 80) as query_snippet,
    calls,
    ROUND(total_exec_time::numeric, 2) as total_time_ms,
    ROUND((user_time + system_time)::numeric, 2) as cpu_time_s,
    ROUND(100.0 * (user_time + system_time) / NULLIF(total_exec_time / 1000.0, 0), 2) as cpu_percent,
    reads + writes as total_io,
    CASE
        WHEN (user_time + system_time) / NULLIF(total_exec_time / 1000.0, 0) > 0.5 THEN 'CPU-bound'
        WHEN (reads + writes) > calls * 100 THEN 'IO-bound'
        ELSE 'Balanced'
    END as bottleneck_type
FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
WHERE total_exec_time > 1000  -- Au moins 1 seconde au total
ORDER BY total_exec_time DESC
LIMIT 20;
```

**Actions selon le type** :

| Type | Sympt√¥mes | Actions |
|------|-----------|---------|
| **CPU-bound** | cpu_percent > 50% | Optimiser l'algorithme, ajouter des index, r√©duire les jointures |
| **IO-bound** | total_io √©lev√©, cpu_percent < 30% | Ajouter des index, augmenter shared_buffers, optimiser les scans |
| **Balanced** | Mixte | Optimiser les deux aspects |

### 4. Analyse du ratio cache hit

```sql
SELECT
    LEFT(query, 80) as query_snippet,
    calls,
    shared_blks_hit,      -- Blocs trouv√©s en cache (pg_stat_statements)
    shared_blks_read,     -- Blocs lus depuis disque (pg_stat_statements)
    reads as disk_reads,  -- Confirmation via pg_stat_kcache
    ROUND(100.0 * shared_blks_hit / NULLIF(shared_blks_hit + shared_blks_read, 0), 2) as cache_hit_ratio
FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
WHERE shared_blks_hit + shared_blks_read > 0
ORDER BY shared_blks_read DESC
LIMIT 10;
```

**Interpr√©tation** :
- **cache_hit_ratio > 95%** : Excellent, la plupart des donn√©es sont en cache
- **cache_hit_ratio < 80%** : Probl√©matique, trop de lectures disque
  - ‚Üí Augmenter `shared_buffers`
  - ‚Üí Ajouter des index pour r√©duire les scans s√©quentiels
  - ‚Üí Optimiser les requ√™tes

### 5. D√©tecter les requ√™tes avec trop de context switches

```sql
SELECT
    LEFT(query, 80) as query_snippet,
    calls,
    nvcsws as voluntary_ctx_switches,
    nivcsws as involuntary_ctx_switches,
    ROUND(nvcsws / NULLIF(calls, 0)::numeric, 2) as avg_voluntary_per_call,
    ROUND(nivcsws / NULLIF(calls, 0)::numeric, 2) as avg_involuntary_per_call,
    CASE
        WHEN nivcsws > nvcsws * 0.1 THEN 'High CPU contention'
        WHEN nvcsws > calls * 1000 THEN 'High I/O wait'
        ELSE 'Normal'
    END as status
FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
WHERE calls > 10
ORDER BY nivcsws DESC
LIMIT 10;
```

**Interpr√©tation** :
- **High CPU contention** : Trop de processus concurrents, envisager de limiter les connexions
- **High I/O wait** : La requ√™te passe son temps √† attendre l'I/O

### 6. Requ√™tes avec major page faults (swapping)

```sql
SELECT
    LEFT(query, 80) as query_snippet,
    calls,
    majflts as major_faults,
    ROUND(majflts / NULLIF(calls, 0)::numeric, 2) as avg_majflts_per_call
FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
WHERE majflts > 0
ORDER BY majflts DESC
LIMIT 10;
```

**Action** : Si `majflts` est √©lev√©, c'est un signe critique de manque de RAM. Le syst√®me swappe sur disque (tr√®s lent).

**Solutions** :
- Augmenter la RAM du serveur
- R√©duire `shared_buffers` si trop √©lev√© (paradoxalement)
- Optimiser les requ√™tes pour consommer moins de m√©moire (`work_mem`)

---

## Cas d'Usage D√©taill√©s

### 1. Identifier une requ√™te lente due √† l'I/O

**Sc√©nario** : Une requ√™te prend 30 secondes et ralentit l'application.

```sql
-- Analyser la requ√™te sp√©cifique
SELECT
    query,
    calls,
    total_exec_time / calls as avg_time_ms,
    (user_time + system_time) / calls as avg_cpu_s,
    (reads + writes) / calls as avg_io_per_call,
    100.0 * (user_time + system_time) / (total_exec_time / 1000.0) as cpu_percent
FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
WHERE query LIKE '%ma_table_problematique%'
  AND total_exec_time > 10000;
```

**R√©sultats hypoth√©tiques** :
```
avg_time_ms: 30000
avg_cpu_s: 2.5
avg_io_per_call: 50000
cpu_percent: 8.3%
```

**Diagnostic** :
- **cpu_percent = 8.3%** ‚Üí Tr√®s peu de temps CPU, donc pas CPU-bound
- **avg_io_per_call = 50000** ‚Üí 50 000 blocs lus = 400 Mo par appel !
- **Conclusion** : La requ√™te est I/O-bound, elle fait probablement un scan s√©quentiel massif

**Actions** :
```sql
-- 1. V√©rifier le plan d'ex√©cution
EXPLAIN (ANALYZE, BUFFERS) SELECT ... FROM ma_table_problematique WHERE ...;

-- 2. Chercher "Seq Scan" dans le plan
-- 3. Ajouter un index sur les colonnes du WHERE

CREATE INDEX idx_ma_table_colonne ON ma_table_problematique(colonne);

-- 4. R√©-analyser apr√®s ajout de l'index
ANALYZE ma_table_problematique;
```

### 2. D√©tecter une requ√™te gourmande en CPU

**Sc√©nario** : Le serveur a une charge CPU √©lev√©e (>80%).

```sql
-- Identifier les requ√™tes CPU-intensives
SELECT
    LEFT(query, 100) as query_snippet,
    calls,
    ROUND((user_time + system_time)::numeric, 2) as total_cpu_s,
    ROUND((user_time + system_time) / calls::numeric, 4) as avg_cpu_per_call,
    ROUND(100.0 * (user_time + system_time) / NULLIF(total_exec_time / 1000.0, 0), 2) as cpu_percent
FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
WHERE (user_time + system_time) > 10  -- Au moins 10 secondes de CPU total
ORDER BY (user_time + system_time) DESC
LIMIT 5;
```

**R√©sultats hypoth√©tiques** :
```
query: SELECT ... FROM orders o JOIN products p ... ORDER BY ...
total_cpu_s: 1250.5
avg_cpu_per_call: 0.25
cpu_percent: 92%
```

**Diagnostic** :
- **cpu_percent = 92%** ‚Üí Requ√™te CPU-bound
- La requ√™te fait probablement des calculs intensifs (jointures, tris, agr√©gations)

**Actions** :
```sql
-- 1. Analyser le plan
EXPLAIN (ANALYZE, BUFFERS) SELECT ... FROM orders o JOIN products p ...;

-- 2. V√©rifier les co√ªts des n≈ìuds (Sort, Hash Join, Aggregate)
-- 3. Optimiser :
--    - Ajouter des index pour √©viter les tris (ORDER BY)
--    - Pr√©filtrer avec WHERE pour r√©duire les jointures
--    - Utiliser des vues mat√©rialis√©es pour les agr√©gations

CREATE INDEX idx_orders_date ON orders(order_date)
WHERE order_date >= CURRENT_DATE - INTERVAL '1 year';

-- 4. R√©√©crire la requ√™te si n√©cessaire
-- Exemple : Remplacer une sous-requ√™te corr√©l√©e par une jointure
```

### 3. Analyser une charge mixte (OLTP)

**Sc√©nario** : Application web avec beaucoup de petites requ√™tes.

```sql
-- Vue d'ensemble de la charge
SELECT
    CASE
        WHEN (user_time + system_time) / NULLIF(total_exec_time / 1000.0, 0) > 0.5 THEN 'CPU-bound'
        WHEN (reads + writes) / NULLIF(calls, 0) > 100 THEN 'IO-bound'
        ELSE 'Balanced'
    END as workload_type,
    COUNT(*) as query_count,
    SUM(calls) as total_calls,
    ROUND(SUM(total_exec_time)::numeric, 2) as total_time_ms,
    ROUND(SUM(user_time + system_time)::numeric, 2) as total_cpu_s,
    SUM(reads + writes) as total_io
FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
GROUP BY workload_type
ORDER BY total_calls DESC;
```

**R√©sultats hypoth√©tiques** :
```
workload_type | query_count | total_calls | total_time_ms | total_cpu_s | total_io
--------------+-------------+-------------+---------------+-------------+----------
Balanced      | 150         | 5,234,890   | 12,500,000    | 3,450       | 250,000
CPU-bound     | 25          | 45,230      | 8,750,000     | 6,800       | 5,000
IO-bound      | 18          | 12,450      | 22,100,000    | 1,200       | 1,500,000
```

**Diagnostic** :
- Charge majoritairement **Balanced** (bon signe)
- Quelques requ√™tes **CPU-bound** consomment beaucoup de CPU (focus prioritaire)
- Quelques requ√™tes **IO-bound** avec beaucoup d'I/O (focus secondaire)

**Strat√©gie d'optimisation** :
1. Optimiser d'abord les 25 requ√™tes CPU-bound (impact majeur)
2. Puis les 18 requ√™tes IO-bound
3. Surveiller l'√©volution avec pg_stat_kcache

### 4. Diagnostiquer un probl√®me de m√©moire (swapping)

**Sc√©nario** : Le serveur est lent, vous soup√ßonnez un manque de RAM.

```sql
-- D√©tecter le swapping via major page faults
SELECT
    datname,
    SUM(majflts) as total_major_faults,
    SUM(minflts) as total_minor_faults,
    ROUND(100.0 * SUM(majflts) / NULLIF(SUM(majflts) + SUM(minflts), 0), 2) as major_fault_percent
FROM pg_stat_kcache psk
JOIN pg_database d ON d.oid = psk.dbid
GROUP BY datname
ORDER BY total_major_faults DESC;
```

**Interpr√©tation** :
- **major_fault_percent > 1%** ‚Üí Probl√®me de m√©moire, le syst√®me swappe
- **major_fault_percent < 0.1%** ‚Üí Normal, pas de swapping significatif

**Actions si swapping d√©tect√©** :

```sql
-- 1. Identifier les requ√™tes responsables
SELECT
    LEFT(query, 100) as query_snippet,
    calls,
    majflts,
    ROUND(majflts / calls::numeric, 2) as majflts_per_call
FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
WHERE majflts > 0
ORDER BY majflts DESC
LIMIT 10;

-- 2. V√©rifier la configuration m√©moire
SHOW shared_buffers;
SHOW work_mem;
SHOW maintenance_work_mem;

-- 3. Actions correctives :
-- a) Augmenter la RAM du serveur (solution long terme)
-- b) R√©duire shared_buffers si trop √©lev√© (25% de RAM max recommand√©)
-- c) Limiter work_mem pour les requ√™tes individuelles
-- d) Optimiser les requ√™tes pour consommer moins de m√©moire
```

---

## Int√©gration avec l'√âcosyst√®me

### pg_stat_kcache + Monitoring (Prometheus + Grafana)

pg_stat_kcache peut √™tre int√©gr√© dans un syst√®me de monitoring moderne.

#### Architecture de monitoring

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         PostgreSQL Server               ‚îÇ
‚îÇ  - pg_stat_statements                   ‚îÇ
‚îÇ  - pg_stat_kcache                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ Exposition des m√©triques
              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      postgres_exporter                  ‚îÇ
‚îÇ  (Exporte les m√©triques au format       ‚îÇ
‚îÇ   Prometheus)                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ Scraping (HTTP)
              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Prometheus                      ‚îÇ
‚îÇ  (Time-series database)                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ Requ√™tes PromQL
              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          Grafana                        ‚îÇ
‚îÇ  (Visualisation et dashboards)          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### Configuration de postgres_exporter

```yaml
# queries.yaml - Configuration pour exporter pg_stat_kcache

pg_stat_kcache:
  query: |
    SELECT
      pss.userid,
      pss.dbid,
      pss.queryid,
      LEFT(pss.query, 100) as query_snippet,
      pss.calls,
      pss.total_exec_time,
      psk.user_time,
      psk.system_time,
      psk.reads,
      psk.writes
    FROM pg_stat_statements pss
    JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
    WHERE pss.calls > 100
    ORDER BY pss.total_exec_time DESC
    LIMIT 100
  metrics:
    - userid:
        usage: "LABEL"
        description: "User ID"
    - dbid:
        usage: "LABEL"
        description: "Database ID"
    - query_snippet:
        usage: "LABEL"
        description: "Query text snippet"
    - calls:
        usage: "COUNTER"
        description: "Number of times executed"
    - total_exec_time:
        usage: "COUNTER"
        description: "Total execution time in ms"
    - user_time:
        usage: "COUNTER"
        description: "User CPU time in seconds"
    - system_time:
        usage: "COUNTER"
        description: "System CPU time in seconds"
    - reads:
        usage: "COUNTER"
        description: "Number of disk reads"
    - writes:
        usage: "COUNTER"
        description: "Number of disk writes"
```

#### Dashboard Grafana recommand√©

**Panels sugg√©r√©s** :

1. **CPU Usage by Query**
   - Graph : `rate(pg_stat_kcache_user_time[5m])` par query
   - Permet d'identifier les requ√™tes CPU-intensives en temps r√©el

2. **I/O Operations by Query**
   - Graph : `rate(pg_stat_kcache_reads[5m])` et `rate(pg_stat_kcache_writes[5m])`
   - Montre l'activit√© I/O par requ√™te

3. **CPU vs I/O Bottleneck**
   - Scatter plot : user_time vs (reads + writes)
   - Visualise quel type de requ√™tes domine

4. **Top Queries by Resource Type**
   - Table : Requ√™tes tri√©es par CPU, puis par I/O
   - Vue d'ensemble pour prioriser les optimisations

### pg_stat_kcache + pgBadger

pgBadger peut g√©n√©rer des rapports incluant les m√©triques syst√®me si les logs PostgreSQL sont configur√©s correctement.

**Configuration des logs** :

```ini
# postgresql.conf
logging_collector = on
log_directory = 'pg_log'
log_filename = 'postgresql-%Y-%m-%d.log'
log_rotation_age = 1d
log_rotation_size = 1GB

# Logger les requ√™tes lentes avec leurs m√©triques
log_min_duration_statement = 1000  # 1 seconde
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
log_checkpoints = on
log_connections = on
log_disconnections = on
log_lock_waits = on
log_temp_files = 0
```

**G√©n√©rer un rapport pgBadger** :

```bash
# Analyser les logs
pgbadger /var/log/postgresql/postgresql-2025-11-23.log -o report.html

# Le rapport inclura :
# - Top queries par temps d'ex√©cution
# - Statistiques I/O (si disponibles)
# - Graphiques temporels
```

### pg_stat_kcache + pg_cron (Automatisation)

Automatiser la collecte et l'archivage des statistiques :

```sql
-- Cr√©er une table d'historique
CREATE TABLE monitoring.pg_stat_kcache_history (
    snapshot_time TIMESTAMPTZ DEFAULT NOW(),
    queryid BIGINT,
    query TEXT,
    calls BIGINT,
    total_exec_time DOUBLE PRECISION,
    user_time DOUBLE PRECISION,
    system_time DOUBLE PRECISION,
    reads BIGINT,
    writes BIGINT
);

-- Cr√©er une partition par mois (avec pg_partman)
SELECT partman.create_parent(
    p_parent_table := 'monitoring.pg_stat_kcache_history',
    p_control := 'snapshot_time',
    p_interval := 'monthly',
    p_premake := 3
);

-- Job pour archiver les stats toutes les heures
SELECT cron.schedule(
    'archive_pg_stat_kcache',
    '0 * * * *',  -- Toutes les heures
    $$
    INSERT INTO monitoring.pg_stat_kcache_history
        (queryid, query, calls, total_exec_time, user_time, system_time, reads, writes)
    SELECT
        psk.queryid,
        LEFT(pss.query, 500),
        pss.calls,
        pss.total_exec_time,
        psk.user_time,
        psk.system_time,
        psk.reads,
        psk.writes
    FROM pg_stat_statements pss
    JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
    WHERE pss.calls > 10
      AND pss.total_exec_time > 100;
    $$
);
```

**Avantages de l'archivage** :
- Analyse de tendances sur le long terme
- D√©tection de r√©gressions de performance
- Corr√©lation avec des √©v√©nements (d√©ploiements, pics de charge)

---

## Bonnes Pratiques

### 1. Activer pg_stat_kcache d√®s l'installation

‚úÖ **Pourquoi** : Les m√©triques syst√®me sont invisibles sans pg_stat_kcache. Impossible de diagnostiquer finement les probl√®mes de performance.

‚úÖ **Quand** : D√®s le d√©part, en production et en d√©veloppement.

```ini
# postgresql.conf (configuration de base)
shared_preload_libraries = 'pg_stat_statements,pg_stat_kcache'
pg_stat_statements.max = 10000
pg_stat_statements.track = all
```

### 2. R√©initialiser les statistiques p√©riodiquement

pg_stat_kcache accumule les statistiques depuis le dernier reset. Pour une analyse claire :

```sql
-- R√©initialiser toutes les stats (attention : perte d'historique)
SELECT pg_stat_statements_reset();

-- Note : pg_stat_kcache se r√©initialise automatiquement avec pg_stat_statements
```

**Recommandation** : Archiver les stats avant de reset (voir section pg_cron ci-dessus).

### 3. Analyser les m√©triques par p√©riode

Les m√©triques cumulatives peuvent √™tre trompeuses. Analysez par p√©riode :

```sql
-- Cr√©er une baseline (snapshot initial)
CREATE TEMP TABLE stats_baseline AS
SELECT * FROM pg_stat_statements;

CREATE TEMP TABLE kcache_baseline AS
SELECT * FROM pg_stat_kcache;

-- Attendre un certain temps (ex: 1 heure)

-- Analyser le delta
SELECT
    pss_now.query,
    pss_now.calls - COALESCE(pss_base.calls, 0) as calls_delta,
    pss_now.total_exec_time - COALESCE(pss_base.total_exec_time, 0) as time_delta,
    psk_now.user_time - COALESCE(psk_base.user_time, 0) as cpu_delta,
    psk_now.reads - COALESCE(psk_base.reads, 0) as reads_delta
FROM pg_stat_statements pss_now
LEFT JOIN stats_baseline pss_base USING (queryid, userid, dbid)
JOIN pg_stat_kcache psk_now USING (queryid, userid, dbid)
LEFT JOIN kcache_baseline psk_base USING (queryid, userid, dbid)
WHERE pss_now.calls > COALESCE(pss_base.calls, 0)
ORDER BY time_delta DESC
LIMIT 20;
```

### 4. Corr√©ler avec EXPLAIN ANALYZE

pg_stat_kcache donne des m√©triques agr√©g√©es. Pour comprendre **pourquoi**, utilisez EXPLAIN :

```sql
-- 1. Identifier une requ√™te probl√©matique avec pg_stat_kcache
SELECT query FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid)
WHERE reads > 100000
LIMIT 1;

-- 2. Analyser en d√©tail avec EXPLAIN
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
[copier-coller la requ√™te identifi√©e];

-- 3. Chercher dans le plan :
-- - Seq Scan sur grandes tables ‚Üí Ajouter index
-- - Sort avec beaucoup de m√©moire ‚Üí Ajuster work_mem
-- - Nested Loop sur grandes tables ‚Üí Revoir les jointures
```

### 5. D√©finir des seuils d'alerte

Configurez des alertes sur les m√©triques critiques :

```sql
-- Vue pour identifier les requ√™tes probl√©matiques
CREATE OR REPLACE VIEW monitoring.query_health_check AS
SELECT
    LEFT(query, 100) as query_snippet,
    calls,
    ROUND(total_exec_time::numeric, 2) as total_time_ms,
    ROUND((user_time + system_time)::numeric, 2) as total_cpu_s,
    reads + writes as total_io,
    majflts,
    CASE
        WHEN majflts > 100 THEN 'CRITICAL: Memory swapping'
        WHEN (reads + writes) / NULLIF(calls, 0) > 1000 THEN 'WARNING: High I/O'
        WHEN (user_time + system_time) / calls > 1.0 THEN 'WARNING: High CPU per call'
        ELSE 'OK'
    END as health_status
FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
WHERE calls > 100
  AND total_exec_time > 10000;

-- Job d'alerte avec pg_cron
SELECT cron.schedule(
    'query_health_alerts',
    '*/15 * * * *',  -- Toutes les 15 minutes
    $$
    SELECT send_alert(
        'Query Health Issues',
        string_agg(query_snippet || ': ' || health_status, E'\n')
    )
    FROM monitoring.query_health_check
    WHERE health_status != 'OK'
    $$
);
```

### 6. Documenter les requ√™tes critiques

```sql
-- Cr√©er une table de documentation
CREATE TABLE monitoring.query_documentation (
    queryid BIGINT PRIMARY KEY,
    query_description TEXT,
    expected_cpu_s NUMERIC,
    expected_io BIGINT,
    owner TEXT,
    last_reviewed DATE
);

-- Documenter les requ√™tes importantes
INSERT INTO monitoring.query_documentation
VALUES (
    123456789,  -- queryid de la requ√™te
    'Rapport de ventes quotidien - Ex√©cut√© chaque nuit √† 2h',
    5.0,        -- CPU attendu
    50000,      -- I/O attendu
    'team-analytics',
    CURRENT_DATE
);

-- D√©tecter les r√©gressions
SELECT
    qd.query_description,
    qd.expected_cpu_s,
    ROUND((psk.user_time + psk.system_time) / pss.calls::numeric, 2) as actual_cpu_per_call,
    CASE
        WHEN (psk.user_time + psk.system_time) / pss.calls > qd.expected_cpu_s * 1.5
        THEN 'REGRESSION'
        ELSE 'OK'
    END as status
FROM monitoring.query_documentation qd
JOIN pg_stat_statements pss ON pss.queryid = qd.queryid
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
WHERE pss.calls > 0;
```

### 7. √âviter l'overhead excessif

pg_stat_kcache a un co√ªt (faible mais r√©el). Quelques recommandations :

- ‚úÖ **Limiter pg_stat_statements.max** : 10 000 √† 20 000 max (pas 100 000)
- ‚úÖ **Filtrer les requ√™tes triviales** : Analyser uniquement les requ√™tes > 100ms
- ‚úÖ **D√©sactiver sur les standby** : pg_stat_kcache n'est utile que sur le primaire

```sql
-- D√©sactiver sur standby (si pg_cron pour les stats)
CREATE OR REPLACE FUNCTION monitoring.collect_stats_if_primary()
RETURNS void AS $$
BEGIN
    IF NOT pg_is_in_recovery() THEN
        -- Collecter les stats uniquement sur le primaire
        PERFORM monitoring.archive_stats();
    END IF;
END;
$$ LANGUAGE plpgsql;
```

---

## D√©pannage (Troubleshooting)

### Probl√®me 1 : pg_stat_kcache ne collecte aucune donn√©e

**Sympt√¥mes** : La vue `pg_stat_kcache` est vide ou retourne NULL pour toutes les m√©triques.

**Diagnostics** :

```sql
-- V√©rifier que l'extension est install√©e
SELECT * FROM pg_extension WHERE extname = 'pg_stat_kcache';

-- V√©rifier que shared_preload_libraries est correct
SHOW shared_preload_libraries;  -- Doit inclure 'pg_stat_kcache'

-- V√©rifier le syst√®me d'exploitation
SELECT version();  -- pg_stat_kcache ne fonctionne que sur Linux
```

**Solutions** :
1. Si `shared_preload_libraries` ne contient pas pg_stat_kcache ‚Üí Modifier postgresql.conf et red√©marrer
2. Si sur Windows/macOS ‚Üí pg_stat_kcache ne fonctionnera pas (sp√©cifique √† Linux)
3. Si sur Linux mais toujours NULL ‚Üí V√©rifier les permissions sur `/proc/[pid]/stat`

### Probl√®me 2 : M√©triques incoh√©rentes (valeurs n√©gatives, NaN)

**Sympt√¥mes** : user_time n√©gatif ou NaN dans les r√©sultats.

**Cause** : Reset de pg_stat_statements sans reset de pg_stat_kcache (d√©synchronisation).

**Solution** :

```sql
-- R√©initialiser les deux extensions ensemble
SELECT pg_stat_statements_reset();
-- pg_stat_kcache se r√©initialise automatiquement avec pg_stat_statements

-- Attendre quelques requ√™tes, puis v√©rifier
SELECT * FROM pg_stat_kcache LIMIT 5;
```

### Probl√®me 3 : Performance d√©grad√©e apr√®s activation

**Sympt√¥mes** : L√©g√®re augmentation de la latence apr√®s activation de pg_stat_kcache.

**Cause** : Overhead de la collecte de m√©triques syst√®me (acc√®s √† /proc).

**Diagnostic** :

```sql
-- Mesurer l'overhead (avant/apr√®s activation)
-- Sur une charge de test constante

-- V√©rifier pg_stat_statements.max
SHOW pg_stat_statements.max;  -- Si > 20000, r√©duire
```

**Solutions** :
1. R√©duire `pg_stat_statements.max` √† 10 000
2. Si l'overhead est inacceptable, d√©sactiver pg_stat_kcache (rare)
3. S'assurer que le serveur n'est pas d√©j√† satur√© (CPU/I/O)

### Probl√®me 4 : Requ√™tes manquantes dans pg_stat_kcache

**Sympt√¥mes** : Certaines requ√™tes apparaissent dans pg_stat_statements mais pas dans pg_stat_kcache.

**Cause** : Les deux extensions peuvent avoir des limites diff√©rentes.

**Diagnostic** :

```sql
-- Comparer les counts
SELECT
    (SELECT COUNT(*) FROM pg_stat_statements) as stmt_count,
    (SELECT COUNT(*) FROM pg_stat_kcache) as kcache_count;
```

**Solution** : G√©n√©ralement, pg_stat_kcache suit pg_stat_statements. Si d√©synchronis√©, r√©initialiser les deux.

### Probl√®me 5 : Valeurs CPU tr√®s √©lev√©es

**Sympt√¥mes** : user_time + system_time > total_exec_time (impossible).

**Cause** : M√©triques cumulatives sur plusieurs processus backend (rare).

**Diagnostic** :

```sql
-- V√©rifier les requ√™tes individuelles
SELECT
    queryid,
    calls,
    total_exec_time / 1000.0 as total_s,
    user_time + system_time as cpu_s,
    (user_time + system_time) / (total_exec_time / 1000.0) as ratio
FROM pg_stat_statements pss
JOIN pg_stat_kcache psk USING (queryid, userid, dbid)
WHERE total_exec_time > 0
ORDER BY ratio DESC;
```

**Solution** : Si `ratio > 1.2` de mani√®re syst√©matique, cela peut indiquer un bug ou une configuration inhabituelle. V√©rifier les versions de PostgreSQL et pg_stat_kcache.

---

## Limitations et Consid√©rations

### Limitations de pg_stat_kcache

1. **Sp√©cifique √† Linux** : Ne fonctionne pas sur Windows, macOS, BSD
   - Alternative : pg_stat_statements seul (sans m√©triques syst√®me)

2. **Overhead l√©ger** : ~1-5% de co√ªt additionnel
   - Acceptable pour la plupart des workloads
   - Peut √™tre probl√©matique sur des syst√®mes d√©j√† satur√©s

3. **Pr√©cision limit√©e** : M√©triques agr√©g√©es, pas en temps r√©el
   - Pour du profiling d√©taill√©, utiliser des outils syst√®me (perf, strace)

4. **Pas de m√©triques par connexion** : Agr√©gation par requ√™te (queryid)
   - Impossible de savoir quel utilisateur/session consomme le plus

5. **D√©pend de /proc** : N√©cessite un acc√®s lecture √† `/proc/[pid]/stat`
   - Peut ne pas fonctionner dans certains containers (permissions restreintes)

### Limitations de l'Analyse Syst√®me

1. **Context switches** : M√©triques utiles mais pas toujours actionnables
   - D√©pendent fortement de la charge syst√®me globale

2. **Major page faults** : Rare sur des syst√®mes bien configur√©s
   - Si fr√©quent, c'est un probl√®me critique (manque de RAM)

3. **Corr√©lation imparfaite** : Les m√©triques syst√®me ne remplacent pas EXPLAIN
   - Utilisez pg_stat_kcache comme guide, puis EXPLAIN pour comprendre

### Quand NE PAS Utiliser pg_stat_kcache

‚ùå **Ne pas utiliser si** :
- Syst√®me Windows/macOS (ne fonctionnera pas)
- Overhead inacceptable pour votre workload (rare)
- Pas besoin de m√©triques syst√®me (pg_stat_statements suffit pour beaucoup de cas)

---

## Alternatives et Compl√©ments

### pg_stat_kcache vs Outils Syst√®me (top, htop, iostat)

| Crit√®re | pg_stat_kcache | Outils Syst√®me |
|---------|----------------|----------------|
| **Granularit√©** | Par requ√™te SQL | Par processus |
| **Persistance** | Stock√© en base | Temps r√©el uniquement |
| **Accessibilit√©** | SQL (facile) | CLI (n√©cessite acc√®s serveur) |
| **Corr√©lation** | Directe avec requ√™tes | Manuelle |

**Verdict** : pg_stat_kcache pour analyse SQL, outils syst√®me pour diagnostic temps r√©el.

### pg_stat_kcache vs auto_explain

**auto_explain** : Extension qui log automatiquement les plans des requ√™tes lentes.

```ini
# postgresql.conf
shared_preload_libraries = 'pg_stat_statements,pg_stat_kcache,auto_explain'

auto_explain.log_min_duration = 1000  # Log si > 1s
auto_explain.log_analyze = on
auto_explain.log_buffers = on
```

**Compl√©mentarit√©** :
- **pg_stat_kcache** : Vue d'ensemble, m√©triques agr√©g√©es
- **auto_explain** : D√©tails sp√©cifiques, plans d'ex√©cution

**Workflow recommand√©** :
1. Identifier les requ√™tes probl√©matiques avec pg_stat_kcache
2. Activer auto_explain pour capturer les plans de ces requ√™tes
3. Optimiser selon les informations combin√©es

### pg_stat_kcache vs pg_stat_progress_*

PostgreSQL 18 offre des vues `pg_stat_progress_*` pour tracker les op√©rations longues :
- `pg_stat_progress_vacuum`
- `pg_stat_progress_create_index`
- `pg_stat_progress_copy`

**Compl√©mentarit√©** :
- **pg_stat_kcache** : Performance des requ√™tes utilisateur
- **pg_stat_progress_*** : Progression des op√©rations de maintenance

---

## Pour Aller Plus Loin

### Ressources Officielles

- **GitHub pg_stat_kcache** : https://github.com/powa-team/pg_stat_kcache
- **Documentation PostgreSQL - Monitoring** : https://www.postgresql.org/docs/current/monitoring-stats.html
- **pg_stat_statements** : https://www.postgresql.org/docs/current/pgstatstatements.html

### Outils de l'√âcosyst√®me

- **PoWA (PostgreSQL Workload Analyzer)** : Interface web pour visualiser pg_stat_kcache
- **pgBadger** : G√©n√©rateur de rapports incluant les m√©triques syst√®me
- **postgres_exporter** : Exporteur Prometheus pour Grafana

### Lectures Recommand√©es

- **PostgreSQL High Performance** (Gregory Smith) - Chapitre sur le monitoring
- **The Art of PostgreSQL** (Dimitri Fontaine) - Profiling et optimisation

### Communaut√© et Support

- **GitHub Issues** : Signaler des bugs ou demander des fonctionnalit√©s
- **PostgreSQL Mailing Lists** : pgsql-performance@postgresql.org
- **Slack/Discord** : Communaut√©s PostgreSQL actives

---

## R√©sum√©

**pg_stat_kcache** est une extension PostgreSQL essentielle pour comprendre la consommation de ressources syst√®me (CPU, I/O, m√©moire) au niveau des requ√™tes SQL.

### Points Cl√©s

- ‚úÖ **M√©triques syst√®me d√©taill√©es** : CPU, I/O disque, page faults, context switches
- ‚úÖ **Compl√®te pg_stat_statements** : Dimension syst√®me indispensable
- ‚úÖ **Diagnostic pr√©cis** : Identifier si une requ√™te est CPU-bound ou I/O-bound
- ‚úÖ **Production-ready** : Overhead minimal, utilis√© par des milliers d'entreprises
- ‚úÖ **Int√©gration facile** : Prometheus, Grafana, pgBadger

### Quand Utiliser pg_stat_kcache ?

- **Analyse de performance** : Comprendre o√π le temps est pass√© (CPU vs I/O)
- **Optimisation** : Prioriser les requ√™tes √† optimiser selon leur impact syst√®me
- **Capacity planning** : Dimensionner CPU, RAM, disques selon la charge r√©elle
- **Monitoring continu** : D√©tecter les r√©gressions et anomalies

### Workflow Type

1. **Activer** pg_stat_kcache en production
2. **Monitorer** avec Prometheus + Grafana (dashboards temps r√©el)
3. **Analyser** r√©guli√®rement les top consumers (CPU, I/O)
4. **Optimiser** les requ√™tes identifi√©es (index, r√©√©criture)
5. **Valider** l'am√©lioration avec les m√©triques

### M√©triques Essentielles √† Surveiller

| M√©trique | Seuil | Action si d√©pass√© |
|----------|-------|-------------------|
| `cpu_percent > 50%` | CPU-bound | Optimiser algorithme, ajouter index |
| `avg_io_per_call > 1000` | IO-bound | Ajouter index, augmenter cache |
| `majflts > 0` | Swapping | Augmenter RAM, optimiser m√©moire |
| `cache_hit_ratio < 90%` | Cache miss | Augmenter shared_buffers |

### Prochaines √âtapes

1. Activer pg_stat_kcache sur votre environnement de test
2. Identifier les 10 requ√™tes top CPU et top I/O
3. Analyser avec EXPLAIN ANALYZE
4. Mettre en place un monitoring Grafana
5. √âtablir des baselines et alertes

---

**En Conclusion** : pg_stat_kcache transforme l'analyse de performance PostgreSQL en fournissant des m√©triques syst√®me essentielles. Coupl√© √† pg_stat_statements et EXPLAIN, il forme la triade indispensable pour diagnostiquer et optimiser les performances de votre base de donn√©es. Pour tout DBA, DevOps ou d√©veloppeur soucieux de performance, pg_stat_kcache est un outil incontournable.

---


‚è≠Ô∏è [HypoPG : Indexation hypoth√©tique](/18-extensions-et-integrations/07.4-hypopg.md)
