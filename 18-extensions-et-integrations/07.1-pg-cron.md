ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 18.7.1. pg_cron : Planification de TÃ¢ches dans PostgreSQL

## Introduction

**pg_cron** est une extension PostgreSQL qui permet de planifier et d'exÃ©cuter automatiquement des tÃ¢ches (jobs) directement au sein de votre base de donnÃ©es, de maniÃ¨re similaire au systÃ¨me Unix/Linux `cron`.

### Qu'est-ce qu'une tÃ¢che planifiÃ©e ?

Une tÃ¢che planifiÃ©e est une opÃ©ration qui s'exÃ©cute automatiquement Ã  des moments prÃ©dÃ©finis, sans intervention manuelle. Par exemple :
- Nettoyer des donnÃ©es obsolÃ¨tes tous les jours Ã  minuit
- GÃ©nÃ©rer des rapports toutes les heures
- RafraÃ®chir des vues matÃ©rialisÃ©es chaque lundi matin
- Effectuer des sauvegardes automatiques

### Pourquoi utiliser pg_cron ?

Avant pg_cron, pour automatiser des tÃ¢ches PostgreSQL, il fallait :
- Utiliser le cron systÃ¨me Unix/Linux (externe Ã  PostgreSQL)
- CrÃ©er des scripts shell complexes
- GÃ©rer l'authentification et les connexions manuellement
- Maintenir une infrastructure parallÃ¨le

**Avec pg_cron**, tout est intÃ©grÃ© dans PostgreSQL :
- âœ… Gestion centralisÃ©e dans la base de donnÃ©es
- âœ… Pas besoin d'accÃ¨s systÃ¨me (serveur)
- âœ… Configuration simple via SQL
- âœ… Logs et historique intÃ©grÃ©s
- âœ… Fonctionne sur tous les systÃ¨mes (Windows, Linux, macOS)

---

## Architecture et Fonctionnement

### Comment pg_cron fonctionne-t-il ?

pg_cron est un **processus d'arriÃ¨re-plan (background worker)** qui :

1. **DÃ©marre avec PostgreSQL** : Il se lance automatiquement au dÃ©marrage de l'instance
2. **VÃ©rifie le planning** : Toutes les secondes (par dÃ©faut), il consulte sa table de jobs
3. **ExÃ©cute les tÃ¢ches** : Lorsqu'une tÃ¢che doit s'exÃ©cuter, pg_cron lance une connexion PostgreSQL et exÃ©cute le SQL dÃ©fini
4. **Enregistre les rÃ©sultats** : Chaque exÃ©cution est tracÃ©e (succÃ¨s/Ã©chec, durÃ©e, messages)

### Architecture technique

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Instance PostgreSQL            â”‚
â”‚                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Extension pg_cron               â”‚ â”‚
â”‚  â”‚   (Background Worker)             â”‚ â”‚
â”‚  â”‚                                   â”‚ â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚ â”‚
â”‚  â”‚   â”‚  Scheduler Thread       â”‚     â”‚ â”‚
â”‚  â”‚   â”‚  (vÃ©rifie les jobs)     â”‚     â”‚ â”‚
â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚ â”‚
â”‚  â”‚            â†“                      â”‚ â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚ â”‚
â”‚  â”‚   â”‚  Executor Threads       â”‚     â”‚ â”‚
â”‚  â”‚   â”‚  (exÃ©cute le SQL)       â”‚     â”‚ â”‚
â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Tables pg_cron                  â”‚ â”‚
â”‚  â”‚   - cron.job (dÃ©finitions)        â”‚ â”‚
â”‚  â”‚   - cron.job_run_details (logs)   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Installation et Configuration

### PrÃ©requis

- PostgreSQL 10 ou supÃ©rieur (idÃ©alement PostgreSQL 18)
- Droits superutilisateur pour l'installation initiale
- Extension disponible (selon votre distribution PostgreSQL)

### Processus d'installation (thÃ©orique)

#### Ã‰tape 1 : Modifier postgresql.conf

Pour que pg_cron se charge au dÃ©marrage, il faut l'ajouter dans les bibliothÃ¨ques prÃ©chargÃ©es :

```ini
shared_preload_libraries = 'pg_cron'
```

**Important** : Ce paramÃ¨tre nÃ©cessite un redÃ©marrage complet de PostgreSQL.

#### Ã‰tape 2 : Configurer la base de donnÃ©es cible

pg_cron doit savoir dans quelle base de donnÃ©es stocker ses mÃ©tadonnÃ©es :

```ini
cron.database_name = 'postgres'
```

Cette base contiendra les tables `cron.job` et `cron.job_run_details`.

#### Ã‰tape 3 : CrÃ©er l'extension

Une fois PostgreSQL redÃ©marrÃ©, se connecter Ã  la base de donnÃ©es spÃ©cifiÃ©e et crÃ©er l'extension :

```sql
CREATE EXTENSION pg_cron;
```

Cette commande crÃ©e :
- Le schÃ©ma `cron`
- La table `cron.job` (dÃ©finitions des tÃ¢ches)
- La table `cron.job_run_details` (historique d'exÃ©cution)
- Les fonctions de gestion

---

## Syntaxe de Planification (Cron Syntax)

### Format gÃ©nÃ©ral

pg_cron utilise la syntaxe **cron standard** avec 5 champs :

```
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ minute (0 - 59)
 â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ heure (0 - 23)
 â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ jour du mois (1 - 31)
 â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ mois (1 - 12)
 â”‚ â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ jour de la semaine (0 - 7) (0 et 7 = dimanche)
 â”‚ â”‚ â”‚ â”‚ â”‚
 * * * * *
```

### OpÃ©rateurs spÃ©ciaux

| Symbole | Signification | Exemple |
|---------|--------------|---------|
| `*` | Toutes les valeurs | `* * * * *` = chaque minute |
| `,` | Liste de valeurs | `0,30 * * * *` = Ã  0 et 30 minutes |
| `-` | Plage de valeurs | `0 9-17 * * *` = toutes les heures de 9h Ã  17h |
| `/` | Intervalle | `*/15 * * * *` = toutes les 15 minutes |

### Exemples de syntaxe courante

```
'0 0 * * *'          â†’ Tous les jours Ã  minuit (00:00)
'30 2 * * *'         â†’ Tous les jours Ã  2h30
'0 9-17 * * *'       â†’ Toutes les heures entre 9h et 17h
'*/15 * * * *'       â†’ Toutes les 15 minutes
'0 0 * * 0'          â†’ Tous les dimanches Ã  minuit
'0 9 1 * *'          â†’ Le 1er de chaque mois Ã  9h
'0 0 1 1 *'          â†’ Le 1er janvier Ã  minuit
'0 22 * * 1-5'       â†’ Du lundi au vendredi Ã  22h
'*/5 9-17 * * 1-5'   â†’ Toutes les 5 min en semaine, pendant les heures de bureau
```

### Raccourcis pratiques

pg_cron supporte Ã©galement des raccourcis textuels :

```sql
'@hourly'    â†’ Ã‰quivalent Ã  '0 * * * *'
'@daily'     â†’ Ã‰quivalent Ã  '0 0 * * *'
'@weekly'    â†’ Ã‰quivalent Ã  '0 0 * * 0'
'@monthly'   â†’ Ã‰quivalent Ã  '0 0 1 * *'
'@yearly'    â†’ Ã‰quivalent Ã  '0 0 1 1 *'
```

---

## Gestion des TÃ¢ches

### CrÃ©er une tÃ¢che

Pour crÃ©er une nouvelle tÃ¢che, on utilise la fonction `cron.schedule()` :

```sql
SELECT cron.schedule(
    'nom_du_job',           -- Nom descriptif de la tÃ¢che
    '0 0 * * *',            -- Planning cron
    'DELETE FROM logs WHERE created_at < NOW() - INTERVAL ''30 days'''  -- SQL Ã  exÃ©cuter
);
```

**Exemple concret** : Nettoyer les anciens logs tous les jours Ã  minuit

```sql
SELECT cron.schedule(
    'nettoyer_logs_anciens',
    '0 0 * * *',
    'DELETE FROM logs WHERE created_at < NOW() - INTERVAL ''30 days'''
);
```

**Retour** : La fonction retourne un `jobid` (identifiant unique du job), par exemple `42`.

### CrÃ©er une tÃ¢che sans nom

Si vous ne spÃ©cifiez pas de nom, pg_cron gÃ©nÃ¨re un nom automatique basÃ© sur le jobid :

```sql
SELECT cron.schedule(
    '*/10 * * * *',
    'REFRESH MATERIALIZED VIEW CONCURRENTLY stats_view'
);
```

### CrÃ©er une tÃ¢che dans une autre base de donnÃ©es

Par dÃ©faut, les jobs s'exÃ©cutent dans la base de donnÃ©es oÃ¹ ils sont dÃ©finis. Pour exÃ©cuter dans une autre base :

```sql
SELECT cron.schedule_in_database(
    'backup_analytics',
    '0 2 * * *',
    'SELECT pg_dump_function()',
    'analytics_db'  -- Nom de la base cible
);
```

### Lister les tÃ¢ches actives

Pour voir toutes les tÃ¢ches dÃ©finies :

```sql
SELECT * FROM cron.job;
```

**Colonnes principales** :
- `jobid` : Identifiant unique
- `schedule` : Expression cron
- `command` : Commande SQL Ã  exÃ©cuter
- `nodename` : Serveur d'exÃ©cution (pour les configurations distribuÃ©es)
- `nodeport` : Port du serveur
- `database` : Base de donnÃ©es cible
- `username` : Utilisateur qui exÃ©cute la tÃ¢che
- `active` : TÃ¢che active ou non

### DÃ©sactiver temporairement une tÃ¢che

Pour suspendre une tÃ¢che sans la supprimer :

```sql
UPDATE cron.job SET active = false WHERE jobid = 42;
```

Pour la rÃ©activer :

```sql
UPDATE cron.job SET active = true WHERE jobid = 42;
```

### Modifier une tÃ¢che existante

#### Modifier le planning

```sql
SELECT cron.alter_job(
    42,                    -- jobid
    schedule := '0 3 * * *'  -- Nouveau planning
);
```

#### Modifier la commande

```sql
SELECT cron.alter_job(
    42,
    command := 'DELETE FROM logs WHERE created_at < NOW() - INTERVAL ''60 days'''
);
```

#### Modifier plusieurs propriÃ©tÃ©s

```sql
SELECT cron.alter_job(
    42,
    schedule := '0 4 * * *',
    command := 'VACUUM ANALYZE logs',
    database := 'production'
);
```

### Supprimer une tÃ¢che

Pour supprimer dÃ©finitivement une tÃ¢che :

```sql
SELECT cron.unschedule(42);  -- Par jobid
```

Ou par nom :

```sql
SELECT cron.unschedule('nettoyer_logs_anciens');
```

---

## Surveillance et Historique

### Table d'historique : cron.job_run_details

Chaque exÃ©cution de tÃ¢che est enregistrÃ©e dans la table `cron.job_run_details` :

```sql
SELECT * FROM cron.job_run_details
ORDER BY start_time DESC
LIMIT 10;
```

**Colonnes principales** :
- `jobid` : Identifiant de la tÃ¢che
- `runid` : Identifiant unique de l'exÃ©cution
- `job_pid` : PID du processus PostgreSQL
- `database` : Base de donnÃ©es d'exÃ©cution
- `username` : Utilisateur ayant exÃ©cutÃ©
- `command` : Commande SQL exÃ©cutÃ©e
- `status` : Statut (succeeded, failed, running)
- `return_message` : Message d'erreur en cas d'Ã©chec
- `start_time` : Heure de dÃ©but
- `end_time` : Heure de fin

### Exemples de requÃªtes de surveillance

#### TÃ¢ches ayant Ã©chouÃ© dans les derniÃ¨res 24h

```sql
SELECT
    jobid,
    command,
    status,
    return_message,
    start_time
FROM cron.job_run_details
WHERE status = 'failed'
  AND start_time > NOW() - INTERVAL '24 hours'
ORDER BY start_time DESC;
```

#### DurÃ©e moyenne d'exÃ©cution par tÃ¢che

```sql
SELECT
    jobid,
    COUNT(*) as executions,
    AVG(EXTRACT(EPOCH FROM (end_time - start_time))) as avg_duration_seconds,
    MAX(EXTRACT(EPOCH FROM (end_time - start_time))) as max_duration_seconds
FROM cron.job_run_details
WHERE status = 'succeeded'
  AND start_time > NOW() - INTERVAL '7 days'
GROUP BY jobid
ORDER BY avg_duration_seconds DESC;
```

#### Taux de succÃ¨s par tÃ¢che

```sql
SELECT
    j.jobid,
    j.schedule,
    j.command,
    COUNT(*) as total_runs,
    COUNT(*) FILTER (WHERE jrd.status = 'succeeded') as successes,
    COUNT(*) FILTER (WHERE jrd.status = 'failed') as failures,
    ROUND(100.0 * COUNT(*) FILTER (WHERE jrd.status = 'succeeded') / COUNT(*), 2) as success_rate
FROM cron.job j
JOIN cron.job_run_details jrd ON j.jobid = jrd.jobid
WHERE jrd.start_time > NOW() - INTERVAL '30 days'
GROUP BY j.jobid, j.schedule, j.command
ORDER BY success_rate;
```

### Nettoyer l'historique

Pour Ã©viter que la table `job_run_details` ne devienne trop volumineuse, il est recommandÃ© de la nettoyer rÃ©guliÃ¨rement :

```sql
-- Supprimer l'historique de plus de 30 jours
DELETE FROM cron.job_run_details
WHERE start_time < NOW() - INTERVAL '30 days';
```

**Astuce** : On peut automatiser ce nettoyage avec... pg_cron lui-mÃªme ! ğŸ”„

```sql
SELECT cron.schedule(
    'nettoyer_historique_cron',
    '0 3 * * 0',  -- Tous les dimanches Ã  3h
    'DELETE FROM cron.job_run_details WHERE start_time < NOW() - INTERVAL ''30 days'''
);
```

---

## Cas d'Usage Courants

### 1. Maintenance de base de donnÃ©es

#### Nettoyer les donnÃ©es obsolÃ¨tes

```sql
SELECT cron.schedule(
    'purge_sessions_expirees',
    '*/30 * * * *',  -- Toutes les 30 minutes
    'DELETE FROM user_sessions WHERE expires_at < NOW()'
);
```

#### VACUUM et ANALYZE rÃ©guliers

```sql
SELECT cron.schedule(
    'vacuum_hebdomadaire',
    '0 2 * * 0',  -- Dimanches Ã  2h
    'VACUUM ANALYZE'
);
```

#### RafraÃ®chir les vues matÃ©rialisÃ©es

```sql
SELECT cron.schedule(
    'refresh_mv_stats',
    '0 * * * *',  -- Toutes les heures
    'REFRESH MATERIALIZED VIEW CONCURRENTLY ventes_mensuelles'
);
```

### 2. Traitement de donnÃ©es

#### AgrÃ©gation quotidienne

```sql
SELECT cron.schedule(
    'agreger_stats_jour',
    '5 0 * * *',  -- Tous les jours Ã  00:05
    $$
    INSERT INTO stats_quotidiennes (date, total_ventes, nb_commandes)
    SELECT
        CURRENT_DATE - 1,
        SUM(montant),
        COUNT(*)
    FROM commandes
    WHERE created_at >= CURRENT_DATE - 1
      AND created_at < CURRENT_DATE
    $$
);
```

#### Import de donnÃ©es externes

```sql
SELECT cron.schedule(
    'import_taux_change',
    '0 9 * * 1-5',  -- Tous les jours ouvrÃ©s Ã  9h
    'SELECT import_exchange_rates_from_api()'
);
```

### 3. Notifications et alertes

#### VÃ©rifier les anomalies

```sql
SELECT cron.schedule(
    'detecter_anomalies',
    '*/5 * * * *',  -- Toutes les 5 minutes
    $$
    SELECT send_alert('Anomalie dÃ©tectÃ©e')
    WHERE EXISTS (
        SELECT 1 FROM transactions
        WHERE montant > 10000
          AND created_at > NOW() - INTERVAL '5 minutes'
    )
    $$
);
```

#### Envoyer des rapports

```sql
SELECT cron.schedule(
    'rapport_hebdomadaire',
    '0 8 * * 1',  -- Lundis Ã  8h
    'SELECT generate_and_email_weekly_report()'
);
```

### 4. Gestion des partitions

#### CrÃ©er des partitions futures

```sql
SELECT cron.schedule(
    'creer_partitions_mensuelles',
    '0 0 25 * *',  -- Le 25 de chaque mois
    $$
    SELECT create_next_month_partition('logs')
    $$
);
```

#### DÃ©tacher et archiver des anciennes partitions

```sql
SELECT cron.schedule(
    'archiver_anciennes_partitions',
    '0 3 1 * *',  -- Le 1er de chaque mois Ã  3h
    $$
    SELECT detach_and_archive_old_partitions('logs', 6)  -- Garder 6 mois
    $$
);
```

### 5. Sauvegardes logiques

#### Export rÃ©gulier de tables

```sql
SELECT cron.schedule(
    'backup_referentiels',
    '0 1 * * *',  -- Tous les jours Ã  1h
    $$
    COPY (SELECT * FROM produits) TO '/backups/produits.csv' WITH CSV HEADER
    $$
);
```

**Note** : NÃ©cessite les permissions appropriÃ©es sur le systÃ¨me de fichiers.

---

## Bonnes Pratiques

### 1. Nommage des jobs

- âœ… Utilisez des noms descriptifs et explicites
- âœ… Incluez l'action et la frÃ©quence si pertinent
- âŒ Ã‰vitez les noms gÃ©nÃ©riques comme "job1", "task_backup"

**Exemples** :
```
âœ… 'nettoyer_sessions_expirees_horaire'
âœ… 'agreger_ventes_quotidien'
âœ… 'backup_complet_dimanche'
âŒ 'job1'
âŒ 'maintenance'
```

### 2. Gestion des erreurs

Les erreurs dans les tÃ¢ches pg_cron ne bloquent pas l'exÃ©cution des autres jobs, mais :

- **Surveillez** : Consultez rÃ©guliÃ¨rement `cron.job_run_details`
- **Alertez** : Mettez en place des alertes sur les Ã©checs
- **Testez** : Validez vos commandes SQL avant de les planifier

### 3. Utiliser des fonctions stockÃ©es

Au lieu d'Ã©crire du SQL complexe directement dans `cron.schedule()`, crÃ©ez des fonctions :

```sql
-- CrÃ©er la fonction
CREATE OR REPLACE FUNCTION maintenance_quotidienne()
RETURNS void AS $$
BEGIN
    DELETE FROM logs WHERE created_at < NOW() - INTERVAL '30 days';
    DELETE FROM temp_data WHERE processed = true;
    VACUUM ANALYZE logs;
END;
$$ LANGUAGE plpgsql;

-- Planifier la fonction
SELECT cron.schedule(
    'maintenance_quotidienne',
    '0 3 * * *',
    'SELECT maintenance_quotidienne()'
);
```

**Avantages** :
- Code plus lisible
- Meilleure maintenabilitÃ©
- Gestion d'erreurs amÃ©liorÃ©e
- RÃ©utilisabilitÃ©

### 4. Ã‰viter les chevauchements

Si une tÃ¢che peut prendre du temps, Ã©vitez qu'elle ne se chevauche avec elle-mÃªme :

```sql
-- Utiliser un advisory lock
CREATE OR REPLACE FUNCTION process_long_running_task()
RETURNS void AS $$
BEGIN
    -- Tentative de verrouillage (non-bloquant)
    IF pg_try_advisory_lock(123456) THEN
        BEGIN
            -- Votre traitement long ici
            PERFORM traitement_long();

            -- LibÃ©rer le verrou
            PERFORM pg_advisory_unlock(123456);
        EXCEPTION
            WHEN OTHERS THEN
                PERFORM pg_advisory_unlock(123456);
                RAISE;
        END;
    ELSE
        RAISE NOTICE 'TÃ¢che dÃ©jÃ  en cours, skip';
    END IF;
END;
$$ LANGUAGE plpgsql;
```

### 5. Documenter les tÃ¢ches

Ajoutez des commentaires sur vos jobs :

```sql
COMMENT ON FUNCTION maintenance_quotidienne() IS
'ExÃ©cute la maintenance quotidienne :
- Supprime les logs de plus de 30 jours
- Nettoie les donnÃ©es temporaires
- Lance VACUUM ANALYZE
PlanifiÃ© pour s''exÃ©cuter tous les jours Ã  3h du matin';
```

### 6. Limiter les ressources

Les tÃ¢ches pg_cron s'exÃ©cutent dans des connexions PostgreSQL normales. Pour Ã©viter la surcharge :

```sql
-- Limiter le temps d'exÃ©cution
SET statement_timeout = '5min';

-- Limiter la mÃ©moire utilisÃ©e
SET work_mem = '64MB';
```

### 7. Planification intelligente

- **Heures creuses** : Planifiez les tÃ¢ches lourdes pendant les heures de faible activitÃ©
- **Ã‰taler les tÃ¢ches** : Ã‰vitez de lancer tous les jobs Ã  minuit pile
- **Tenant compte des sauvegardes** : Ne planifiez pas de maintenance pendant les fenÃªtres de backup

**Exemple** :
```
âœ… Job A : 02:00 - Backup
âœ… Job B : 03:00 - VACUUM
âœ… Job C : 03:30 - AgrÃ©gation
âœ… Job D : 04:00 - Nettoyage

âŒ Job A, B, C, D tous Ã  00:00 â†’ Surcharge !
```

### 8. Gestion des fuseaux horaires

pg_cron utilise le fuseau horaire du serveur PostgreSQL. Soyez explicite si nÃ©cessaire :

```sql
-- VÃ©rifier le fuseau horaire
SHOW timezone;

-- DÃ©finir si nÃ©cessaire
SET timezone = 'Europe/Paris';
```

---

## Limitations et ConsidÃ©rations

### 1. PrÃ©cision temporelle

- pg_cron vÃ©rifie les jobs **toutes les secondes** par dÃ©faut
- La granularitÃ© minimale est donc d'**une minute** (comme cron Unix)
- Pour des tÃ¢ches nÃ©cessitant une prÃ©cision Ã  la seconde, pg_cron n'est pas adaptÃ©

### 2. DÃ©pendances entre jobs

pg_cron n'a **pas de gestion native des dÃ©pendances** entre jobs :
- Impossible de dire "Job B dÃ©marre seulement si Job A a rÃ©ussi"
- Pas de workflows complexes

**Solution** : ImplÃ©menter la logique dans une fonction PL/pgSQL qui appelle d'autres fonctions sÃ©quentiellement.

### 3. Performances et scalabilitÃ©

- Chaque job s'exÃ©cute dans sa **propre connexion PostgreSQL**
- Attention au nombre de jobs simultanÃ©s vs `max_connections`
- Les jobs longs peuvent monopoliser des connexions

### 4. SÃ©curitÃ© et permissions

- Les jobs s'exÃ©cutent avec les **permissions de l'utilisateur qui les a crÃ©Ã©s**
- Soyez prudent avec les superutilisateurs
- Utilisez le **principe du moindre privilÃ¨ge**

**Exemple** :
```sql
-- CrÃ©er un rÃ´le dÃ©diÃ© aux jobs cron
CREATE ROLE cron_worker;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO cron_worker;

-- Ensuite, crÃ©er les jobs en tant que cet utilisateur
```

### 5. Pas de garantie d'exÃ©cution

- Si PostgreSQL est arrÃªtÃ© au moment de l'exÃ©cution, **le job est manquÃ©**
- pg_cron ne rattrape pas les exÃ©cutions manquÃ©es au redÃ©marrage
- Il n'y a pas de "catch-up" comme dans certains orchestrateurs

### 6. Haute disponibilitÃ©

Dans une configuration avec rÃ©plication :
- pg_cron s'exÃ©cute **uniquement sur le serveur primaire**
- En cas de failover, les jobs basculent sur le nouveau primaire
- VÃ©rifiez la configuration aprÃ¨s une promotion

### 7. Pas de parallÃ©lisation automatique

- pg_cron exÃ©cute les jobs **sÃ©quentiellement** par dÃ©faut
- Plusieurs jobs au mÃªme horaire sont exÃ©cutÃ©s dans l'ordre de leur `jobid`
- Pour du parallÃ©lisme, crÃ©ez des jobs Ã  des horaires lÃ©gÃ¨rement dÃ©calÃ©s

---

## Comparaison avec d'Autres Solutions

### pg_cron vs Cron SystÃ¨me (Unix/Linux)

| CritÃ¨re | pg_cron | Cron SystÃ¨me |
|---------|---------|--------------|
| **IntÃ©gration** | Natif PostgreSQL | Externe (OS) |
| **Configuration** | SQL (simple) | Fichiers crontab |
| **PortabilitÃ©** | Tous OS (Windows inclus) | Unix/Linux uniquement |
| **Logs** | Table PostgreSQL | Fichiers syslog/journalctl |
| **AccÃ¨s nÃ©cessaire** | Base de donnÃ©es | AccÃ¨s serveur (root/user) |
| **Transactions** | Support natif | Non applicable |
| **HA** | Suit le primaire | Configuration manuelle |

**Verdict** : pg_cron est idÃ©al pour les tÃ¢ches purement PostgreSQL, tandis que le cron systÃ¨me convient mieux pour des orchestrations complexes impliquant plusieurs systÃ¨mes.

### pg_cron vs pg_agent

**pg_agent** est une autre extension de planification, plus ancienne :

| CritÃ¨re | pg_cron | pg_agent |
|---------|---------|----------|
| **Maintenance** | Actif, moderne | Peu maintenu |
| **ComplexitÃ©** | Simple | Plus complexe |
| **Interface** | SQL pur | NÃ©cessite pgAdmin |
| **DÃ©pendances** | Aucune | pgAdmin requis |
| **Logs** | Natifs SQL | Interface graphique |

**Verdict** : pg_cron est devenu le standard de facto pour la planification dans PostgreSQL moderne.

### pg_cron vs Orchestrateurs externes (Airflow, Prefect, Temporal)

| CritÃ¨re | pg_cron | Orchestrateurs |
|---------|---------|----------------|
| **Workflows** | Simples | Complexes, DAGs |
| **DÃ©pendances** | Non | Oui (natif) |
| **Monitoring** | Basique | AvancÃ© (dashboards) |
| **ScalabilitÃ©** | LimitÃ©e | Ã‰levÃ©e |
| **Infrastructure** | Aucune | Serveurs dÃ©diÃ©s |
| **Courbe d'apprentissage** | Faible | Moyenne Ã  Ã©levÃ©e |

**Verdict** : pg_cron pour des tÃ¢ches simples et locales, les orchestrateurs pour des pipelines de donnÃ©es complexes multi-systÃ¨mes.

---

## DÃ©pannage (Troubleshooting)

### ProblÃ¨me 1 : pg_cron ne dÃ©marre pas

**SymptÃ´mes** : AprÃ¨s installation, les jobs ne s'exÃ©cutent pas.

**Causes possibles** :
1. `shared_preload_libraries` non configurÃ©
2. `cron.database_name` absent ou incorrect
3. PostgreSQL non redÃ©marrÃ© aprÃ¨s configuration

**Solutions** :
```sql
-- VÃ©rifier que l'extension est chargÃ©e
SELECT * FROM pg_extension WHERE extname = 'pg_cron';

-- VÃ©rifier les background workers
SELECT * FROM pg_stat_activity WHERE backend_type = 'pg_cron launcher';
```

### ProblÃ¨me 2 : Jobs ne s'exÃ©cutent pas

**SymptÃ´mes** : Les jobs sont crÃ©Ã©s mais aucune trace dans `job_run_details`.

**VÃ©rifications** :
```sql
-- Le job est-il actif ?
SELECT jobid, active, schedule, command FROM cron.job WHERE jobid = 42;

-- Y a-t-il des erreurs de syntaxe cron ?
-- Testez votre expression sur https://crontab.guru

-- Le prochain lancement est-il dans le futur ?
-- pg_cron ne rattrape pas les exÃ©cutions passÃ©es
```

### ProblÃ¨me 3 : Jobs Ã©chouent systÃ©matiquement

**Diagnostic** :
```sql
SELECT
    jobid,
    status,
    return_message,
    command
FROM cron.job_run_details
WHERE status = 'failed'
  AND jobid = 42
ORDER BY start_time DESC
LIMIT 5;
```

**Causes frÃ©quentes** :
- Erreur SQL dans la commande
- Permissions insuffisantes
- Objets manquants (tables, fonctions)
- Timeout

**Solution** : Testez la commande manuellement avant de la planifier.

### ProblÃ¨me 4 : Jobs trop lents

**SymptÃ´mes** : Les jobs prennent plus de temps que prÃ©vu.

**Analyse** :
```sql
SELECT
    jobid,
    command,
    EXTRACT(EPOCH FROM (end_time - start_time)) as duration_seconds
FROM cron.job_run_details
WHERE jobid = 42
  AND status = 'succeeded'
ORDER BY start_time DESC
LIMIT 10;
```

**Solutions** :
- Optimiser la requÃªte SQL (ajouter des index, EXPLAIN ANALYZE)
- Diviser le job en sous-tÃ¢ches plus petites
- ExÃ©cuter aux heures creuses
- Utiliser `CONCURRENTLY` pour les opÃ©rations qui le supportent

### ProblÃ¨me 5 : Saturation des connexions

**SymptÃ´mes** : Erreur "FATAL: sorry, too many clients already".

**Cause** : Trop de jobs simultanÃ©s pour `max_connections`.

**Solutions** :
```sql
-- VÃ©rifier le nombre de connexions
SELECT COUNT(*) FROM pg_stat_activity;

-- VÃ©rifier max_connections
SHOW max_connections;

-- Ã‰taler les jobs dans le temps
-- Au lieu de tous les jobs Ã  00:00, les rÃ©partir :
-- Job A : 00:00
-- Job B : 00:05
-- Job C : 00:10
```

---

## Configuration AvancÃ©e

### ParamÃ¨tres postgresql.conf

```ini
# Obligatoire
shared_preload_libraries = 'pg_cron'
cron.database_name = 'postgres'

# Optionnel : dÃ©finir le fuseau horaire
cron.timezone = 'Europe/Paris'

# Optionnel : nombre de workers simultanÃ©s (dÃ©faut : 8)
# Augmenter si vous avez beaucoup de jobs concurrents
cron.max_running_jobs = 16

# Optionnel : utiliser un socket Unix au lieu de TCP (plus sÃ©curisÃ©)
cron.use_background_workers = on

# Optionnel : fichier de log spÃ©cifique (si besoin)
cron.log_statement = 'all'
cron.log_min_messages = 'warning'
```

### Surveillance et alerting

#### Script de monitoring des Ã©checs

```sql
-- Vue pour simplifier la surveillance
CREATE OR REPLACE VIEW cron.failed_jobs_last_24h AS
SELECT
    j.jobid,
    j.schedule,
    j.command,
    jrd.status,
    jrd.return_message,
    jrd.start_time,
    jrd.end_time
FROM cron.job j
JOIN cron.job_run_details jrd ON j.jobid = jrd.jobid
WHERE jrd.status = 'failed'
  AND jrd.start_time > NOW() - INTERVAL '24 hours'
ORDER BY jrd.start_time DESC;

-- Job de notification en cas d'Ã©chec
SELECT cron.schedule(
    'alerter_echecs_cron',
    '*/30 * * * *',  -- Toutes les 30 minutes
    $$
    SELECT send_alert_email(
        'admin@company.com',
        'Ã‰checs pg_cron dÃ©tectÃ©s',
        'DÃ©tails: ' ||
        (SELECT string_agg(jobid::text || ': ' || return_message, E'\n')
         FROM cron.failed_jobs_last_24h)
    )
    WHERE EXISTS (SELECT 1 FROM cron.failed_jobs_last_24h)
    $$
);
```

### Backup de la configuration des jobs

```sql
-- Export de tous les jobs actifs
COPY (
    SELECT
        jobid,
        schedule,
        command,
        nodename,
        nodeport,
        database,
        username
    FROM cron.job
    WHERE active = true
) TO '/backup/cron_jobs_backup.csv' WITH CSV HEADER;

-- Script de restauration (exemple conceptuel)
-- Ã€ adapter selon vos besoins
```

---

## IntÃ©gration avec des Architectures Modernes

### pg_cron et Kubernetes

Dans un environnement Kubernetes avec PostgreSQL :

**ConsidÃ©rations** :
- pg_cron s'exÃ©cute dans le pod du serveur primaire
- En cas de failover (avec Patroni), les jobs basculent automatiquement
- Les StatefulSets garantissent la persistance des mÃ©tadonnÃ©es

**Bonnes pratiques** :
- DÃ©finir des jobs via des ConfigMaps pour la portabilitÃ©
- Utiliser des Services pour les connexions stables
- Monitorer avec Prometheus (pg_cron_exporter)

### pg_cron et Cloud ManagÃ©

#### AWS RDS PostgreSQL

pg_cron est **disponible** sur RDS :
```sql
-- Activer pg_cron sur RDS
CREATE EXTENSION pg_cron;

-- Les jobs s'exÃ©cutent automatiquement sur le primaire
-- En cas de failover, ils migrent vers le nouveau primaire
```

#### Azure Database for PostgreSQL

pg_cron est **supportÃ©** :
```sql
-- Activer via le portail Azure ou CLI
-- Les principes restent identiques
```

#### Google Cloud SQL

pg_cron **n'est pas disponible** nativement sur Cloud SQL (au moment de PostgreSQL 18).

**Alternative** : Utiliser Cloud Scheduler + Cloud Functions pour orchestrer des requÃªtes SQL.

---

## Pour Aller Plus Loin

### Ressources officielles

- **Documentation pg_cron** : https://github.com/citusdata/pg_cron
- **Wiki PostgreSQL Extensions** : https://wiki.postgresql.org/wiki/Extensions

### CommunautÃ© et Support

- **GitHub Issues** : Pour signaler des bugs ou demander des fonctionnalitÃ©s
- **Mailing list PostgreSQL** : pgsql-general@postgresql.org
- **Reddit** : r/PostgreSQL

### FonctionnalitÃ©s avancÃ©es (non couvertes ici)

- **Distributed cron** : ExÃ©cuter des jobs sur plusieurs nÅ“uds PostgreSQL
- **Custom background workers** : CrÃ©er vos propres workers pour des besoins spÃ©cifiques
- **Integration avec pg_partman** : Automatiser complÃ¨tement la gestion des partitions
- **Audit et compliance** : Tracer toutes les exÃ©cutions pour des besoins rÃ©glementaires

---

## RÃ©sumÃ©

**pg_cron** est une extension PostgreSQL puissante qui permet de :

- âœ… **Planifier** des tÃ¢ches rÃ©currentes directement dans PostgreSQL
- âœ… **Simplifier** l'administration sans dÃ©pendre du cron systÃ¨me
- âœ… **Automatiser** la maintenance, les agrÃ©gations, les nettoyages
- âœ… **Surveiller** l'exÃ©cution via des tables SQL standards
- âœ… **IntÃ©grer** facilement dans des architectures cloud et Kubernetes

**Cas d'usage typiques** :
- Maintenance de base de donnÃ©es (VACUUM, ANALYZE)
- Nettoyage de donnÃ©es obsolÃ¨tes
- AgrÃ©gations et rapports rÃ©guliers
- RafraÃ®chissement de vues matÃ©rialisÃ©es
- Gestion automatisÃ©e de partitions

**Points d'attention** :
- NÃ©cessite un redÃ©marrage PostgreSQL initial
- Pas de gestion native des dÃ©pendances entre jobs
- Surveillance et alerting Ã  mettre en place
- Attention aux chevauchements et Ã  la saturation des connexions

**Alternative Ã  considÃ©rer si** :
- Vous avez besoin de workflows complexes avec dÃ©pendances â†’ Airflow, Prefect
- Vous orchestrez plusieurs systÃ¨mes externes â†’ Orchestrateurs dÃ©diÃ©s
- Vous Ãªtes sur Cloud SQL (GCP) oÃ¹ pg_cron n'est pas disponible â†’ Cloud Scheduler

Pour un dÃ©veloppeur ou DevOps travaillant avec PostgreSQL, **pg_cron est un outil indispensable** qui simplifie grandement l'automatisation tout en restant dans l'Ã©cosystÃ¨me PostgreSQL.

---

**Prochaines Ã©tapes recommandÃ©es** :
1. Installer pg_cron dans un environnement de test
2. CrÃ©er quelques jobs simples pour se familiariser
3. Mettre en place une surveillance des Ã©checs
4. Documenter et standardiser les patterns de jobs dans votre organisation
5. IntÃ©grer pg_cron dans vos runbooks et procÃ©dures d'exploitation

---


â­ï¸ [pg_partman : Gestion automatisÃ©e de partitions](/18-extensions-et-integrations/07.2-pg-partman.md)
