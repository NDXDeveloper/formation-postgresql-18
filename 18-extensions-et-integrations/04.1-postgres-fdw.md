üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.4.1. postgres_fdw : F√©d√©ration PostgreSQL

## Introduction

**postgres_fdw** (Foreign Data Wrapper) est une extension PostgreSQL qui permet d'acc√©der √† des donn√©es stock√©es dans d'autres bases PostgreSQL comme si elles √©taient locales. C'est un peu comme cr√©er un "pont" entre deux bases de donn√©es PostgreSQL pour qu'elles puissent communiquer.

### Pourquoi utiliser postgres_fdw ?

Imaginez que votre entreprise poss√®de :
- Une base de donn√©es PostgreSQL pour les **ventes** (sur un serveur A)
- Une base de donn√©es PostgreSQL pour les **stocks** (sur un serveur B)

Avec postgres_fdw, vous pouvez interroger les donn√©es des deux bases depuis une seule requ√™te SQL, sans avoir √† :
- Dupliquer les donn√©es
- Cr√©er des exports/imports manuels
- √âcrire du code applicatif complexe

## Concepts Fondamentaux

### Qu'est-ce qu'un Foreign Data Wrapper ?

Un **Foreign Data Wrapper (FDW)** est une technologie standardis√©e (norme SQL/MED) qui permet √† PostgreSQL de se connecter √† des sources de donn√©es externes. PostgreSQL agit comme une "passerelle" vers d'autres syst√®mes.

**postgres_fdw** est le FDW sp√©cialis√© pour se connecter √† d'autres bases PostgreSQL.

### Terminologie

| Terme | D√©finition |
|-------|------------|
| **Serveur local** | La base PostgreSQL depuis laquelle vous lancez vos requ√™tes |
| **Serveur distant** | La base PostgreSQL qui contient les donn√©es que vous voulez interroger |
| **Foreign Server** | La d√©finition de connexion au serveur distant dans PostgreSQL |
| **Foreign Table** | Une table virtuelle sur le serveur local qui repr√©sente une table distante |
| **User Mapping** | Les identifiants de connexion pour acc√©der au serveur distant |

### Sch√©ma d'architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Serveur Local (PostgreSQL)      ‚îÇ
‚îÇ                                    ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  Votre requ√™te SQL           ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ             ‚îÇ                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  Foreign Table (virtuelle)   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  - clients_distants          ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ             ‚îÇ                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  postgres_fdw (extension)    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ Connexion r√©seau
              ‚îÇ (protocole PostgreSQL)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Serveur Distant (PostgreSQL)     ‚îÇ
‚îÇ                                    ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  Table r√©elle                ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  - clients (donn√©es)         ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Installation et Configuration

### √âtape 1 : Installer l'extension

Sur le serveur local, postgres_fdw est g√©n√©ralement inclus dans PostgreSQL. Il suffit de l'activer :

```sql
-- Sur la base de donn√©es locale
CREATE EXTENSION postgres_fdw;
```

### √âtape 2 : Cr√©er le Foreign Server

D√©finissez la connexion vers le serveur distant :

```sql
CREATE SERVER serveur_ventes
    FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (
        host 'db-ventes.exemple.com',  -- Adresse du serveur distant
        port '5432',                     -- Port PostgreSQL (5432 par d√©faut)
        dbname 'ventes_db'               -- Nom de la base distante
    );
```

**Explications** :
- `serveur_ventes` : Nom que vous donnez √† cette connexion (peut √™tre n'importe quoi)
- `host` : Adresse IP ou nom de domaine du serveur distant
- `port` : Port d'√©coute PostgreSQL
- `dbname` : Nom de la base de donn√©es distante

### √âtape 3 : Cr√©er le User Mapping

D√©finissez les identifiants de connexion :

```sql
CREATE USER MAPPING FOR utilisateur_local
    SERVER serveur_ventes
    OPTIONS (
        user 'admin_ventes',      -- Utilisateur sur le serveur distant
        password 'mot_de_passe'   -- Mot de passe (attention : stock√© en clair!)
    );
```

**‚ö†Ô∏è S√©curit√©** : Le mot de passe est stock√© dans le catalogue syst√®me. En production, utilisez :
- Des certificats SSL
- Des fichiers `.pgpass`
- Des gestionnaires de secrets

### √âtape 4 : Cr√©er une Foreign Table

Cr√©ez une table virtuelle qui repr√©sente la table distante :

```sql
CREATE FOREIGN TABLE clients_distants (
    id INTEGER,
    nom VARCHAR(100),
    email VARCHAR(100),
    date_creation TIMESTAMP
)
SERVER serveur_ventes
OPTIONS (
    schema_name 'public',    -- Sch√©ma sur le serveur distant
    table_name 'clients'     -- Nom de la table distante
);
```

**Important** : La structure (colonnes, types) doit correspondre √† la table distante.

### M√©thode alternative : IMPORT FOREIGN SCHEMA

Au lieu de d√©finir manuellement chaque colonne, vous pouvez importer automatiquement la structure :

```sql
IMPORT FOREIGN SCHEMA public
    LIMIT TO (clients, commandes)  -- Limiter aux tables sp√©cifiques
    FROM SERVER serveur_ventes
    INTO public;                    -- Sch√©ma local de destination
```

Cette commande cr√©e automatiquement les foreign tables correspondantes.

## Utilisation

### Requ√™tes de lecture

Une fois configur√©e, une foreign table s'utilise comme une table normale :

```sql
-- S√©lectionner tous les clients distants
SELECT * FROM clients_distants;

-- Filtrer
SELECT nom, email
FROM clients_distants
WHERE date_creation > '2024-01-01';

-- Jointure avec une table locale
SELECT
    c.nom,
    l.montant
FROM clients_distants c
INNER JOIN ventes_locales l ON c.id = l.client_id;
```

### Requ√™tes d'√©criture

postgres_fdw supporte √©galement les op√©rations d'√©criture :

```sql
-- Insertion
INSERT INTO clients_distants (id, nom, email, date_creation)
VALUES (100, 'Nouveau Client', 'client@exemple.com', NOW());

-- Mise √† jour
UPDATE clients_distants
SET email = 'nouveau@exemple.com'
WHERE id = 100;

-- Suppression
DELETE FROM clients_distants WHERE id = 100;
```

**Note** : Ces op√©rations modifient directement les donn√©es sur le serveur distant.

## Comment √ßa fonctionne ?

### Le m√©canisme de Query Pushdown

postgres_fdw est **intelligent** : il essaie d'envoyer un maximum de traitement vers le serveur distant pour optimiser les performances.

**Exemple** :

```sql
SELECT nom, email
FROM clients_distants
WHERE pays = 'France'
ORDER BY nom;
```

**Sans pushdown** (mauvais) :
1. Transf√©rer TOUTES les lignes vers le serveur local
2. Filtrer `WHERE pays = 'France'` localement
3. Trier `ORDER BY nom` localement

**Avec pushdown** (bon) :
1. Envoyer la requ√™te compl√®te au serveur distant
2. Le serveur distant fait le filtrage et le tri
3. Seules les lignes r√©sultantes sont transf√©r√©es

### V√©rifier le pushdown avec EXPLAIN

```sql
EXPLAIN (VERBOSE)
SELECT * FROM clients_distants WHERE pays = 'France';
```

R√©sultat exemple :

```
Foreign Scan on clients_distants
  Output: id, nom, email, pays
  Remote SQL: SELECT id, nom, email, pays
              FROM public.clients
              WHERE (pays = 'France'::text)
```

Le `Remote SQL` montre que le `WHERE` est bien ex√©cut√© √† distance.

### Op√©rations pouss√©es vs rapatri√©es

| Op√©ration | Pouss√©e ? | Commentaire |
|-----------|-----------|-------------|
| `WHERE` avec op√©rateurs simples | ‚úÖ Oui | `=`, `<`, `>`, `IN`, etc. |
| `ORDER BY` | ‚úÖ Oui | Tri distant |
| `LIMIT` | ‚úÖ Oui | Limitation √† distance |
| `JOIN` entre foreign tables du m√™me serveur | ‚úÖ Oui | Jointure distante |
| `JOIN` entre foreign table et table locale | ‚ùå Non | Rapatriement des donn√©es |
| Agr√©gations (`SUM`, `COUNT`, etc.) | ‚úÖ Oui | Depuis PostgreSQL 10+ |
| Fonctions complexes ou personnalis√©es | ‚ùå Variable | D√©pend de la fonction |

## Cas d'usage r√©els

### 1. F√©d√©ration de bases multiples

**Contexte** : Une entreprise avec plusieurs filiales, chacune ayant sa propre base PostgreSQL.

**Solution** : Cr√©er une base "f√©d√©r√©e" centrale qui interroge toutes les bases filiales via postgres_fdw.

```sql
-- Filiale Paris
CREATE FOREIGN TABLE ventes_paris (...) SERVER serveur_paris;

-- Filiale Lyon
CREATE FOREIGN TABLE ventes_lyon (...) SERVER serveur_lyon;

-- Requ√™te consolid√©e
SELECT 'Paris' AS filiale, SUM(montant)
FROM ventes_paris
UNION ALL
SELECT 'Lyon', SUM(montant)
FROM ventes_lyon;
```

### 2. Migration progressive

**Contexte** : Migrer d'une ancienne base vers une nouvelle sans interruption de service.

**Solution** :
1. Nouvelle base avec foreign tables vers l'ancienne
2. Applications lisent la nouvelle base
3. Les donn√©es non migr√©es sont accessibles via FDW
4. Migration progressive table par table

### 3. Reporting et Data Warehouse

**Contexte** : Base de production OLTP + base analytique OLAP.

**Solution** : La base analytique utilise postgres_fdw pour importer des donn√©es en temps r√©el depuis la production sans impacter celle-ci.

```sql
-- Sur le serveur de reporting
CREATE FOREIGN TABLE ventes_production (...) SERVER prod_oltp;

-- ETL simplifi√©
INSERT INTO ventes_analyse
SELECT * FROM ventes_production
WHERE date > (SELECT MAX(date) FROM ventes_analyse);
```

### 4. S√©paration des domaines m√©tier

**Contexte** : Architecture microservices avec une base par service.

**Solution** : Chaque service acc√®de √† ses propres donn√©es, mais peut lire (lecture seule) les donn√©es d'autres services via FDW quand n√©cessaire.

```
Service Commandes ‚Üí FDW vers Service Clients (lecture)
Service Facturation ‚Üí FDW vers Service Commandes (lecture)
```

## Performance et Optimisation

### Bonnes pratiques

#### 1. Utiliser des index sur les tables distantes

Les index sur le serveur distant sont utilis√©s lors du pushdown :

```sql
-- Sur le serveur DISTANT
CREATE INDEX idx_clients_pays ON clients(pays);

-- Sur le serveur LOCAL, ce filtre b√©n√©ficiera de l'index
SELECT * FROM clients_distants WHERE pays = 'France';
```

#### 2. Limiter les colonnes s√©lectionn√©es

```sql
-- ‚ùå Mauvais : transf√®re toutes les colonnes
SELECT * FROM clients_distants WHERE id = 100;

-- ‚úÖ Bon : transf√®re seulement les colonnes n√©cessaires
SELECT nom, email FROM clients_distants WHERE id = 100;
```

#### 3. Utiliser des filtres restrictifs

```sql
-- ‚ùå Mauvais : transf√®re toute la table
SELECT * FROM clients_distants;

-- ‚úÖ Bon : filtre c√¥t√© distant
SELECT * FROM clients_distants WHERE date_creation > '2024-01-01';
```

#### 4. Options de performance

```sql
-- Lors de la cr√©ation du serveur
CREATE SERVER serveur_ventes
    FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (
        host 'db-ventes.exemple.com',
        port '5432',
        dbname 'ventes_db',
        fetch_size '10000',      -- Taille des lots (par d√©faut 100)
        use_remote_estimate 'true' -- Utiliser les stats distantes
    );
```

**Options importantes** :
- `fetch_size` : Nombre de lignes r√©cup√©r√©es par lot (augmenter pour gros volumes)
- `use_remote_estimate` : Utilise les statistiques du serveur distant pour le plan d'ex√©cution

### Surveillance

#### V√©rifier les connexions actives

```sql
-- Sur le serveur DISTANT
SELECT
    datname,
    usename,
    application_name,
    client_addr,
    state
FROM pg_stat_activity
WHERE application_name = 'postgres_fdw';
```

#### Analyser les performances

```sql
EXPLAIN (ANALYZE, VERBOSE, BUFFERS)
SELECT * FROM clients_distants WHERE pays = 'France';
```

Regardez :
- **Remote SQL** : Que fait le serveur distant ?
- **Execution Time** : Temps total
- **Rows** : Nombre de lignes transf√©r√©es

## Gestion des Transactions

### Comportement transactionnel

postgres_fdw participe aux transactions du serveur local :

```sql
BEGIN;

-- Modification locale
UPDATE ventes_locales SET statut = 'trait√©' WHERE id = 1;

-- Modification distante
UPDATE clients_distants SET derniere_commande = NOW() WHERE id = 100;

COMMIT;  -- Les DEUX modifications sont valid√©es
```

**Important** : Si `COMMIT` √©choue, PostgreSQL essaie de faire un `ROLLBACK` sur le serveur distant, mais ce n'est **pas une transaction distribu√©e garantie √† 100%** (pas de 2PC par d√©faut).

### Transactions √† deux phases (2PC)

Pour des garanties transactionnelles fortes, activez le 2PC :

```sql
-- Sur le Foreign Server
ALTER SERVER serveur_ventes OPTIONS (ADD use_two_phase_commit 'true');
```

Cela garantit que les transactions sont atomiques entre les deux serveurs, au prix d'une latence accrue.

## S√©curit√©

### Contr√¥le d'acc√®s

#### Permissions n√©cessaires

**Sur le serveur LOCAL** :
```sql
-- L'utilisateur doit pouvoir utiliser le foreign server
GRANT USAGE ON FOREIGN SERVER serveur_ventes TO utilisateur;

-- Et acc√©der √† la foreign table
GRANT SELECT ON clients_distants TO utilisateur;
```

**Sur le serveur DISTANT** :
```sql
-- L'utilisateur mapp√© doit avoir les permissions
GRANT SELECT ON clients TO admin_ventes;
```

### Bonnes pratiques de s√©curit√©

#### 1. Cr√©er des utilisateurs d√©di√©s

```sql
-- Sur le serveur DISTANT
CREATE USER fdw_readonly WITH PASSWORD 'mot_de_passe_fort';
GRANT CONNECT ON DATABASE ventes_db TO fdw_readonly;
GRANT USAGE ON SCHEMA public TO fdw_readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO fdw_readonly;
```

#### 2. Utiliser SSL/TLS

```sql
CREATE SERVER serveur_ventes
    FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (
        host 'db-ventes.exemple.com',
        port '5432',
        dbname 'ventes_db',
        sslmode 'require'  -- Force SSL
    );
```

#### 3. Fichier .pgpass pour les mots de passe

Au lieu de stocker les mots de passe dans PostgreSQL :

**Sur le serveur local**, cr√©ez `~/.pgpass` :
```
db-ventes.exemple.com:5432:ventes_db:admin_ventes:mot_de_passe_fort
```

Permissions : `chmod 600 ~/.pgpass`

Puis cr√©ez le mapping sans mot de passe :
```sql
CREATE USER MAPPING FOR utilisateur_local
    SERVER serveur_ventes
    OPTIONS (user 'admin_ventes');  -- Pas de password
```

## Limitations et Consid√©rations

### Limitations techniques

#### 1. Pas de DDL sur les foreign tables

```sql
-- ‚ùå Impossible
ALTER TABLE clients_distants ADD COLUMN telephone VARCHAR(20);

-- ‚úÖ √Ä faire sur le serveur distant
-- Puis resynchoniser la d√©finition locale
```

#### 2. Pas d'index locaux

Vous ne pouvez pas cr√©er d'index sur une foreign table :

```sql
-- ‚ùå Erreur
CREATE INDEX idx_nom ON clients_distants(nom);
```

Seuls les index du serveur distant sont utilis√©s.

#### 3. Certaines op√©rations ne sont pas pouss√©es

- Fonctions d√©finies par l'utilisateur (UDF)
- Certaines fonctions PostgreSQL sp√©cifiques
- Expressions complexes

#### 4. Latence r√©seau

Chaque requ√™te traverse le r√©seau. Pour des volumes importants :
- Privil√©giez la r√©plication physique ou logique
- Utilisez des vues mat√©rialis√©es pour le cache

### Quand NE PAS utiliser postgres_fdw

‚ùå **√âvitez** postgres_fdw quand :
- Les donn√©es doivent √™tre **ultra-rapides** (millisecondes) : Privil√©giez la r√©plication
- Vous avez besoin de **transactions distribu√©es complexes** : Utilisez une solution d√©di√©e (XA, Saga)
- Les volumes de donn√©es transf√©r√©es sont **tr√®s importants** : Pr√©f√©rez ETL batch ou r√©plication
- La **latence r√©seau** est √©lev√©e (>50ms) : Les performances seront d√©grad√©es

‚úÖ **Utilisez** postgres_fdw quand :
- Vous avez besoin d'**acc√®s ponctuel** √† des donn√©es distantes
- Vous voulez **f√©d√©rer** plusieurs bases PostgreSQL
- Vous faites des **migrations progressives**
- Vous construisez un **data warehouse** avec sources multiples

## D√©pannage

### Probl√®mes courants

#### Erreur : "could not connect to server"

```
ERROR:  could not connect to server "serveur_ventes"
DETAIL:  could not translate host name "db-ventes.exemple.com" to address
```

**Solutions** :
- V√©rifier la connectivit√© r√©seau : `ping db-ventes.exemple.com`
- V√©rifier le firewall (port 5432 ouvert ?)
- V√©rifier `pg_hba.conf` sur le serveur distant

#### Erreur : "password authentication failed"

```
ERROR:  password authentication failed for user "admin_ventes"
```

**Solutions** :
- V√©rifier les credentials dans le user mapping
- V√©rifier que l'utilisateur existe sur le serveur distant
- V√©rifier `pg_hba.conf` autorise la connexion

#### Performances lentes

**Diagnostic** :
```sql
EXPLAIN (ANALYZE, VERBOSE)
SELECT * FROM clients_distants WHERE condition;
```

**Solutions** :
- V√©rifier que le WHERE est pouss√© (Remote SQL)
- Ajouter des index sur le serveur distant
- Augmenter `fetch_size`
- Limiter les colonnes s√©lectionn√©es

#### Voir les connexions FDW

```sql
-- Sur le serveur distant
SELECT * FROM pg_stat_activity
WHERE application_name LIKE '%fdw%';
```

## Outils et Extensions Compl√©mentaires

### postgres_fdw_validator

Valide la configuration avant de l'appliquer :

```sql
SELECT * FROM postgres_fdw_validator(
    '{"host": "db-ventes.exemple.com", "port": "5432", "dbname": "ventes_db"}'::text[]
);
```

### Monitoring avec pg_stat_statements

Sur le serveur distant, activez `pg_stat_statements` pour voir les requ√™tes FDW :

```sql
CREATE EXTENSION pg_stat_statements;

-- Voir les requ√™tes FDW
SELECT query, calls, total_exec_time
FROM pg_stat_statements
WHERE query LIKE '%clients%'
ORDER BY total_exec_time DESC;
```

## Conclusion

### R√©sum√© des points cl√©s

‚úÖ **postgres_fdw** permet d'acc√©der √† des donn√©es PostgreSQL distantes comme si elles √©taient locales

‚úÖ Configuration en 4 √©tapes : Extension ‚Üí Foreign Server ‚Üí User Mapping ‚Üí Foreign Table

‚úÖ **Query Pushdown** : PostgreSQL optimise en envoyant le maximum de traitement √† distance

‚úÖ Cas d'usage principaux : F√©d√©ration, migration, reporting, microservices

‚ö†Ô∏è Attention √† la latence r√©seau et aux volumes de donn√©es

‚ö†Ô∏è Ne remplace pas la r√©plication pour les besoins haute performance

### Prochaines √©tapes

Pour aller plus loin :
1. **Pratiquer** : Cr√©er deux instances PostgreSQL locales et configurer postgres_fdw
2. **Explorer** les autres FDW : `file_fdw`, `oracle_fdw`, `mysql_fdw`
3. **Approfondir** les options de performance et le monitoring
4. **√âtudier** la r√©plication logique pour comparer les approches

### Ressources

- [Documentation officielle postgres_fdw](https://www.postgresql.org/docs/current/postgres-fdw.html)
- [Wiki PostgreSQL - Foreign Data Wrappers](https://wiki.postgresql.org/wiki/Foreign_data_wrappers)
- Livre : *PostgreSQL: Up and Running* (O'Reilly)

---


‚è≠Ô∏è [file_fdw, oracle_fdw, mysql_fdw](/18-extensions-et-integrations/04.2-autres-fdw.md)
