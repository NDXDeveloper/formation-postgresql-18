ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 18.7.2. pg_partman : Gestion AutomatisÃ©e de Partitions dans PostgreSQL

## Introduction

**pg_partman** (PostgreSQL Partition Manager) est une extension PostgreSQL qui automatise et simplifie la gestion des tables partitionnÃ©es. Elle prend en charge la crÃ©ation, la maintenance et la suppression automatique de partitions selon des rÃ¨gles dÃ©finies.

### Qu'est-ce que le partitionnement de tables ?

Avant de parler de pg_partman, il est essentiel de comprendre le concept de **partitionnement**.

Le partitionnement consiste Ã  diviser une grande table en plusieurs sous-tables plus petites appelÃ©es **partitions**, tout en conservant une interface unique pour les requÃªtes.

**Analogie** : Imaginez une bibliothÃ¨que avec des millions de livres. Au lieu de tout mettre sur une seule Ã©tagÃ¨re gÃ©ante (impossible Ã  gÃ©rer), vous organisez les livres par catÃ©gorie, par annÃ©e, par auteur, etc. Chaque section devient plus facile Ã  parcourir.

**Exemple concret** :

```
Table "commandes" (100 millions de lignes)
         â†“
Partitionnement par annÃ©e
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ commandes_2023 (12 millions de lignes)  â”‚
â”‚ commandes_2024 (35 millions de lignes)  â”‚
â”‚ commandes_2025 (53 millions de lignes)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Pourquoi partitionner ?

Les avantages du partitionnement :

- âœ… **Performance** : Les requÃªtes ne scannent que les partitions nÃ©cessaires (partition pruning)
- âœ… **Maintenance** : VACUUM, REINDEX plus rapides sur de petites partitions
- âœ… **Archivage** : DÃ©tacher/supprimer des anciennes partitions facilement
- âœ… **Gestion de l'espace** : DÃ©placer des partitions sur diffÃ©rents tablespaces
- âœ… **Sauvegarde** : Sauvegarder uniquement les partitions actives

**Cas d'usage typiques** :
- Tables de logs avec des millions d'entrÃ©es quotidiennes
- DonnÃ©es historiques (commandes, transactions, Ã©vÃ©nements)
- Tables de sÃ©ries temporelles (IoT, monitoring, mÃ©triques)
- DonnÃ©es multi-tenants (un client par partition)

### Le problÃ¨me sans pg_partman

PostgreSQL supporte nativement le partitionnement dÃ©claratif depuis la version 10, mais la gestion manuelle est **fastidieuse** :

- âŒ CrÃ©er manuellement chaque nouvelle partition (chaque mois, chaque jour...)
- âŒ Surveiller quand crÃ©er les prochaines partitions
- âŒ DÃ©tacher et archiver les anciennes partitions
- âŒ Maintenir les index sur chaque partition
- âŒ GÃ©rer les contraintes et permissions

**Sans automatisation**, vous devriez Ã©crire et exÃ©cuter rÃ©guliÃ¨rement des scripts comme :

```sql
-- Tous les mois, manuellement :
CREATE TABLE commandes_2025_12 PARTITION OF commandes
    FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');

CREATE INDEX idx_commandes_2025_12_date ON commandes_2025_12(date_commande);
-- ... et ainsi de suite pour tous les index

-- DÃ©tacher les anciennes partitions
ALTER TABLE commandes DETACH PARTITION commandes_2023_01;
```

### La solution : pg_partman

**pg_partman** automatise tout ce processus :

- âœ… **CrÃ©ation automatique** de nouvelles partitions Ã  l'avance
- âœ… **DÃ©tachement automatique** des anciennes partitions
- âœ… **Gestion des index** automatique
- âœ… **IntÃ©gration avec pg_cron** pour une automatisation complÃ¨te
- âœ… **Maintenance simplifiÃ©e** avec des fonctions dÃ©diÃ©es
- âœ… **Support de tous les types** de partitionnement (Range, List, Hash)

---

## Architecture et Concepts Fondamentaux

### Comment pg_partman fonctionne-t-il ?

pg_partman repose sur trois piliers :

1. **MÃ©tadonnÃ©es** : Tables de configuration qui dÃ©crivent les rÃ¨gles de partitionnement
2. **Fonctions de maintenance** : Scripts qui crÃ©ent/dÃ©tachent les partitions
3. **Automatisation** : IntÃ©gration avec pg_cron pour exÃ©cution rÃ©guliÃ¨re

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Table Principale (Parent)               â”‚
â”‚              commandes                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â†“              â†“              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Partition 1  â”‚ â”‚ Partition 2  â”‚ â”‚ Partition 3  â”‚
â”‚ 2024-01      â”‚ â”‚ 2024-02      â”‚ â”‚ 2024-03      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†‘              â†‘              â†‘
        â”‚              â”‚              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          pg_partman                              â”‚
â”‚  - CrÃ©e automatiquement les partitions futures   â”‚
â”‚  - DÃ©tache les anciennes partitions              â”‚
â”‚  - Maintient les index et contraintes            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†‘
        â”‚ (planification)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    pg_cron     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Types de partitionnement supportÃ©s

pg_partman supporte les trois types de partitionnement natifs de PostgreSQL :

#### 1. Range (Plage) - Le plus courant

Partitionnement basÃ© sur des plages de valeurs, typiquement pour des dates.

**Exemple** : Partitionner par mois

```
commandes_2024_01: du 2024-01-01 au 2024-02-01
commandes_2024_02: du 2024-02-01 au 2024-03-01
commandes_2024_03: du 2024-03-01 au 2024-04-01
```

**Cas d'usage** : Tables temporelles (logs, Ã©vÃ©nements, transactions)

#### 2. List (Liste)

Partitionnement basÃ© sur des valeurs discrÃ¨tes.

**Exemple** : Partitionner par rÃ©gion

```
commandes_europe: rÃ©gion IN ('FR', 'DE', 'IT', 'ES')
commandes_amerique: rÃ©gion IN ('US', 'CA', 'MX')
commandes_asie: rÃ©gion IN ('JP', 'CN', 'KR')
```

**Cas d'usage** : DonnÃ©es multi-tenants, segmentation par catÃ©gorie

#### 3. Hash

Partitionnement basÃ© sur un hash, pour distribuer uniformÃ©ment les donnÃ©es.

**Exemple** : Partitionner par hash de l'ID utilisateur

```
commandes_hash_0: MODULUS 4, REMAINDER 0
commandes_hash_1: MODULUS 4, REMAINDER 1
commandes_hash_2: MODULUS 4, REMAINDER 2
commandes_hash_3: MODULUS 4, REMAINDER 3
```

**Cas d'usage** : Distribution uniforme pour parallÃ©lisation, sharding logique

### Terminologie pg_partman

Quelques termes clÃ©s Ã  connaÃ®tre :

| Terme | Signification |
|-------|---------------|
| **Parent table** | Table principale partitionnÃ©e (ex: `commandes`) |
| **Child partition** | Partition individuelle (ex: `commandes_2024_01`) |
| **Premake** | Nombre de partitions Ã  crÃ©er Ã  l'avance |
| **Retention** | DurÃ©e de conservation avant dÃ©tachement |
| **Partition interval** | Intervalle de chaque partition (ex: 1 mois, 1 jour) |
| **Template table** | ModÃ¨le pour crÃ©er de nouvelles partitions |
| **Constraint validation** | Validation des contraintes aprÃ¨s dÃ©tachement |

---

## Installation et Configuration

### PrÃ©requis

- PostgreSQL 11 ou supÃ©rieur (idÃ©alement PostgreSQL 18)
- Droits superutilisateur ou CREATE sur le schÃ©ma
- Extension pg_cron (fortement recommandÃ©e pour l'automatisation)

### Processus d'installation (thÃ©orique)

#### Ã‰tape 1 : Installer l'extension

pg_partman doit Ãªtre disponible dans votre distribution PostgreSQL (package systÃ¨me ou compilation).

```sql
-- CrÃ©er l'extension dans la base de donnÃ©es cible
CREATE SCHEMA partman;
CREATE EXTENSION pg_partman SCHEMA partman;
```

**Note** : Il est recommandÃ© de crÃ©er pg_partman dans son propre schÃ©ma pour sÃ©parer les objets.

#### Ã‰tape 2 : VÃ©rifier l'installation

```sql
-- Lister les fonctions pg_partman
SELECT proname
FROM pg_proc
WHERE pronamespace = 'partman'::regnamespace
ORDER BY proname;

-- VÃ©rifier les tables de mÃ©tadonnÃ©es
SELECT tablename
FROM pg_tables
WHERE schemaname = 'partman'
ORDER BY tablename;
```

Les principales tables de mÃ©tadonnÃ©es :
- `partman.part_config` : Configuration des tables partitionnÃ©es
- `partman.part_config_sub` : Configuration pour le partitionnement en cascade (sub-partitions)

#### Ã‰tape 3 : Configurer les permissions

```sql
-- Accorder les permissions nÃ©cessaires
GRANT USAGE ON SCHEMA partman TO votre_utilisateur;
GRANT ALL ON ALL TABLES IN SCHEMA partman TO votre_utilisateur;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA partman TO votre_utilisateur;
```

---

## CrÃ©er une Table PartitionnÃ©e avec pg_partman

### MÃ©thode 1 : Partitionner une nouvelle table (Range/Time)

C'est le cas d'usage le plus courant : partitionner par date.

#### Ã‰tape 1 : CrÃ©er la table parent

```sql
CREATE TABLE logs (
    id BIGSERIAL,
    timestamp TIMESTAMPTZ NOT NULL,
    user_id INTEGER,
    action VARCHAR(100),
    details JSONB
) PARTITION BY RANGE (timestamp);
```

**Important** :
- La colonne de partitionnement (`timestamp`) doit Ãªtre dans la clÃ© primaire si vous en dÃ©finissez une
- Utilisez `PARTITION BY RANGE (colonne)` pour le partitionnement temporel

#### Ã‰tape 2 : CrÃ©er la table template (optionnel mais recommandÃ©)

La table template dÃ©finit les index et contraintes qui seront automatiquement appliquÃ©s Ã  chaque nouvelle partition.

```sql
CREATE TABLE logs_template (LIKE logs INCLUDING ALL);

-- Ajouter les index dÃ©sirÃ©s
CREATE INDEX idx_logs_user_id ON logs_template(user_id);
CREATE INDEX idx_logs_action ON logs_template(action);
```

#### Ã‰tape 3 : Configurer pg_partman

```sql
SELECT partman.create_parent(
    p_parent_table := 'public.logs',
    p_control := 'timestamp',
    p_interval := 'daily',  -- 'daily', 'weekly', 'monthly', 'quarterly', 'yearly'
    p_premake := 4,         -- CrÃ©er 4 partitions Ã  l'avance
    p_start_partition := '2025-01-01',  -- PremiÃ¨re partition
    p_template_table := 'public.logs_template'
);
```

**ParamÃ¨tres expliquÃ©s** :

- `p_parent_table` : Nom complet de la table parent (schÃ©ma.table)
- `p_control` : Colonne de partitionnement
- `p_interval` : Intervalle de chaque partition
  - `'daily'` : Une partition par jour
  - `'weekly'` : Une partition par semaine
  - `'monthly'` : Une partition par mois
  - `'quarterly'` : Une partition par trimestre
  - `'yearly'` : Une partition par an
- `p_premake` : Nombre de partitions futures Ã  crÃ©er d'avance (recommandÃ©: 4-10)
- `p_start_partition` : Date de dÃ©but de la premiÃ¨re partition
- `p_template_table` : Table modÃ¨le pour les index et contraintes

#### Ã‰tape 4 : VÃ©rifier la crÃ©ation

```sql
-- Voir la configuration
SELECT * FROM partman.part_config WHERE parent_table = 'public.logs';

-- Lister les partitions crÃ©Ã©es
SELECT
    schemaname,
    tablename
FROM pg_tables
WHERE tablename LIKE 'logs_%'
ORDER BY tablename;
```

### MÃ©thode 2 : Partitionner une table existante avec donnÃ©es

Si vous avez dÃ©jÃ  une table non partitionnÃ©e avec des donnÃ©es, pg_partman peut vous aider.

**Attention** : Cette opÃ©ration nÃ©cessite une maintenance et peut Ãªtre longue selon le volume de donnÃ©es.

#### Ã‰tape 1 : CrÃ©er la nouvelle table partitionnÃ©e

```sql
CREATE TABLE commandes_partitioned (
    LIKE commandes INCLUDING ALL
) PARTITION BY RANGE (date_commande);
```

#### Ã‰tape 2 : Configurer pg_partman

```sql
SELECT partman.create_parent(
    p_parent_table := 'public.commandes_partitioned',
    p_control := 'date_commande',
    p_interval := 'monthly',
    p_premake := 4,
    p_start_partition := '2024-01-01'
);
```

#### Ã‰tape 3 : Migrer les donnÃ©es (attention : opÃ©ration lourde)

```sql
-- MÃ©thode 1 : INSERT SELECT (requiert une fenÃªtre de maintenance)
INSERT INTO commandes_partitioned
SELECT * FROM commandes;

-- MÃ©thode 2 : Batch par batch pour limiter le verrou
-- (Ã  scripter selon vos besoins)
```

#### Ã‰tape 4 : Renommer les tables

```sql
BEGIN;
    ALTER TABLE commandes RENAME TO commandes_old;
    ALTER TABLE commandes_partitioned RENAME TO commandes;
    -- RecrÃ©er les index, contraintes, etc.
COMMIT;
```

**Note** : Pour de trÃ¨s grandes tables, considÃ©rez des stratÃ©gies de migration progressive avec pg_partman et rÃ©plication logique.

### MÃ©thode 3 : Partitionnement par ID (Range numÃ©rique)

Pour des tables oÃ¹ le partitionnement temporel n'est pas pertinent.

```sql
CREATE TABLE utilisateurs (
    id BIGSERIAL,
    nom VARCHAR(100),
    email VARCHAR(255),
    created_at TIMESTAMPTZ
) PARTITION BY RANGE (id);

SELECT partman.create_parent(
    p_parent_table := 'public.utilisateurs',
    p_control := 'id',
    p_type := 'native',
    p_interval := '1000000',  -- Une partition tous les 1 million d'IDs
    p_premake := 4
);
```

**Cas d'usage** : Tables avec auto-incrÃ©mentation, sans dimension temporelle forte.

### MÃ©thode 4 : Partitionnement en cascade (Sub-partitioning)

Pour des cas complexes : partitionner par annÃ©e, puis par mois.

```sql
-- Table parent (partitionnÃ©e par annÃ©e)
CREATE TABLE metriques (
    timestamp TIMESTAMPTZ NOT NULL,
    sensor_id INTEGER,
    valeur NUMERIC
) PARTITION BY RANGE (timestamp);

-- CrÃ©er le parent avec pg_partman
SELECT partman.create_parent(
    p_parent_table := 'public.metriques',
    p_control := 'timestamp',
    p_interval := 'yearly',
    p_premake := 2
);

-- Ensuite, sub-partitionner chaque partition annuelle par mois
-- (NÃ©cessite des appels Ã  create_sub_parent pour chaque partition)
```

**Note** : Le sub-partitioning est avancÃ© et moins courant. Utilisez-le seulement si nÃ©cessaire.

---

## Maintenance AutomatisÃ©e

### La fonction clÃ© : run_maintenance()

`partman.run_maintenance()` est la fonction centrale qui :

1. **CrÃ©e** de nouvelles partitions selon le paramÃ¨tre `premake`
2. **DÃ©tache** les anciennes partitions selon le paramÃ¨tre `retention`
3. **Analyse** les partitions (ANALYZE)

**Syntaxe** :

```sql
SELECT partman.run_maintenance(
    p_parent_table := NULL,  -- NULL = toutes les tables configurÃ©es
    p_analyze := TRUE,       -- ExÃ©cuter ANALYZE sur les nouvelles partitions
    p_jobmon := TRUE         -- Logger dans partman.part_config
);
```

### Automatisation avec pg_cron

pg_partman est conÃ§u pour Ãªtre exÃ©cutÃ© rÃ©guliÃ¨rement via pg_cron.

#### Configuration recommandÃ©e

```sql
-- ExÃ©cuter la maintenance toutes les heures
SELECT cron.schedule(
    'pg_partman_maintenance',
    '0 * * * *',  -- Toutes les heures Ã  H:00
    'SELECT partman.run_maintenance();'
);
```

**FrÃ©quence recommandÃ©e** :
- **Partitionnement daily** : ExÃ©cuter 1-2 fois par jour
- **Partitionnement monthly** : ExÃ©cuter quotidiennement ou hebdomadairement
- **Partitionnement hourly** (rare) : ExÃ©cuter toutes les 15-30 minutes

#### VÃ©rifier les exÃ©cutions

```sql
-- Voir les logs de maintenance (si jobmon activÃ©)
SELECT * FROM partman.part_config
WHERE last_partition IS NOT NULL
ORDER BY last_partition DESC;

-- Combiner avec l'historique pg_cron
SELECT
    jobid,
    runid,
    status,
    return_message,
    start_time,
    end_time
FROM cron.job_run_details
WHERE command LIKE '%run_maintenance%'
ORDER BY start_time DESC
LIMIT 10;
```

### Maintenance manuelle

Pour forcer la crÃ©ation de partitions ou tester la configuration :

```sql
-- ExÃ©cuter la maintenance pour une table spÃ©cifique
SELECT partman.run_maintenance(
    p_parent_table := 'public.logs'
);

-- VÃ©rifier les partitions crÃ©Ã©es
SELECT
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size
FROM pg_tables
WHERE tablename LIKE 'logs_%'
ORDER BY tablename;
```

---

## Configuration AvancÃ©e

### ParamÃ¨tres de retention (conservation)

Pour dÃ©tacher automatiquement les anciennes partitions aprÃ¨s un certain dÃ©lai :

```sql
UPDATE partman.part_config
SET
    retention = '90 days',           -- DÃ©tacher aprÃ¨s 90 jours
    retention_keep_table = TRUE,     -- Garder la table dÃ©tachÃ©e
    retention_keep_index = FALSE     -- Supprimer les index aprÃ¨s dÃ©tachement
WHERE parent_table = 'public.logs';
```

**Options de retention** :

| ParamÃ¨tre | Signification |
|-----------|--------------|
| `retention` | DurÃ©e avant dÃ©tachement (ex: '90 days', '6 months', '2 years') |
| `retention_keep_table` | `TRUE` = garder la table dÃ©tachÃ©e, `FALSE` = supprimer |
| `retention_keep_index` | `TRUE` = garder les index, `FALSE` = supprimer (Ã©conomiser de l'espace) |
| `retention_schema` | SchÃ©ma oÃ¹ dÃ©placer les partitions dÃ©tachÃ©es (si `retention_keep_table = TRUE`) |

**Exemple de workflow d'archivage** :

```sql
-- Configuration pour archivage
UPDATE partman.part_config
SET
    retention = '1 year',
    retention_keep_table = TRUE,
    retention_keep_index = FALSE,
    retention_schema = 'archive'
WHERE parent_table = 'public.logs';

-- CrÃ©er le schÃ©ma d'archive si nÃ©cessaire
CREATE SCHEMA IF NOT EXISTS archive;
```

AprÃ¨s un an, les partitions seront automatiquement :
1. DÃ©tachÃ©es de la table parent
2. DÃ©placÃ©es dans le schÃ©ma `archive`
3. Leurs index seront supprimÃ©s (Ã©conomie d'espace)

### ParamÃ¨tres de premake (anticipation)

ContrÃ´ler combien de partitions futures crÃ©er :

```sql
UPDATE partman.part_config
SET premake = 10  -- CrÃ©er 10 partitions Ã  l'avance
WHERE parent_table = 'public.logs';
```

**Recommandations** :
- **Partitionnement daily** : `premake = 7-14` (1-2 semaines Ã  l'avance)
- **Partitionnement monthly** : `premake = 3-6` (3-6 mois Ã  l'avance)
- **Partitionnement yearly** : `premake = 2-3` (2-3 ans Ã  l'avance)

**Pourquoi prÃ©voir Ã  l'avance ?**
- Ã‰viter les erreurs d'insertion si une partition manque
- Garantir la continuitÃ© du service
- Limiter l'impact de pannes de maintenance

### Gestion des contraintes

pg_partman peut gÃ©rer automatiquement les contraintes CHECK sur les partitions :

```sql
UPDATE partman.part_config
SET
    constraint_cols = ARRAY['user_id', 'status'],  -- Colonnes pour contraintes CHECK
    optimize_constraint = 10  -- Optimiser aprÃ¨s 10 lignes
WHERE parent_table = 'public.logs';
```

**Note** : Avec le partitionnement natif moderne, les contraintes CHECK ne sont gÃ©nÃ©ralement pas nÃ©cessaires grÃ¢ce au **partition pruning** automatique.

### Infinite time partitions

Pour crÃ©er automatiquement des partitions indÃ©finiment dans le futur :

```sql
UPDATE partman.part_config
SET infinite_time_partitions = TRUE
WHERE parent_table = 'public.logs';
```

**Effet** : pg_partman crÃ©era toujours `premake` partitions dans le futur, sans limite temporelle.

### Gestion des timezones

SpÃ©cifier un fuseau horaire pour les partitions temporelles :

```sql
UPDATE partman.part_config
SET datetime_string = 'YYYY-MM-DD HH24:MI:SS'
WHERE parent_table = 'public.logs';

-- Ou dÃ©finir un timezone spÃ©cifique
UPDATE partman.part_config
SET datetime_string = 'YYYY-MM-DD HH24:MI:SS TZ'
WHERE parent_table = 'public.logs';
```

---

## Surveillance et Monitoring

### VÃ©rifier la configuration active

```sql
-- Vue d'ensemble de toutes les tables partitionnÃ©es
SELECT
    parent_table,
    partition_interval,
    premake,
    retention,
    datetime_string,
    last_partition,
    constraint_valid
FROM partman.part_config
ORDER BY parent_table;
```

### Identifier les partitions existantes

```sql
-- Fonction utilitaire de pg_partman
SELECT partman.show_partitions(
    'public.logs',     -- Table parent
    'DESC',            -- Ordre (ASC ou DESC)
    FALSE              -- Inclure les tables template ?
);
```

### VÃ©rifier la taille des partitions

```sql
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) as table_size,
    pg_size_pretty(pg_indexes_size(schemaname||'.'||tablename)) as indexes_size
FROM pg_tables
WHERE tablename LIKE 'logs_%'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
LIMIT 20;
```

### VÃ©rifier la distribution des donnÃ©es

```sql
-- Nombre de lignes par partition
SELECT
    schemaname,
    tablename,
    n_live_tup as row_count
FROM pg_stat_user_tables
WHERE tablename LIKE 'logs_%'
ORDER BY n_live_tup DESC;
```

### Alerting sur les problÃ¨mes potentiels

#### DÃ©tection de partitions manquantes dans le futur

```sql
-- CrÃ©er une fonction de surveillance
CREATE OR REPLACE FUNCTION partman.check_premake_warning()
RETURNS TABLE(parent_table TEXT, warning TEXT) AS $$
BEGIN
    RETURN QUERY
    SELECT
        pc.parent_table::TEXT,
        'Seulement ' || pc.premake || ' partitions futures' AS warning
    FROM partman.part_config pc
    WHERE pc.premake < 3;
END;
$$ LANGUAGE plpgsql;

-- Planifier une vÃ©rification quotidienne avec pg_cron
SELECT cron.schedule(
    'check_partman_premake',
    '0 8 * * *',  -- Tous les jours Ã  8h
    $$
    SELECT send_alert_if_needed(
        'Partman Warning',
        (SELECT string_agg(parent_table || ': ' || warning, E'\n')
         FROM partman.check_premake_warning())
    )
    WHERE EXISTS (SELECT 1 FROM partman.check_premake_warning())
    $$
);
```

#### DÃ©tection de partitions anciennes non dÃ©tachÃ©es

```sql
CREATE OR REPLACE FUNCTION partman.check_old_partitions()
RETURNS TABLE(partition_name TEXT, age_days INTEGER) AS $$
BEGIN
    RETURN QUERY
    SELECT
        schemaname || '.' || tablename AS partition_name,
        EXTRACT(DAY FROM NOW() - last_autovacuum)::INTEGER AS age_days
    FROM pg_stat_user_tables
    WHERE tablename LIKE '%_p%'
      AND last_autovacuum < NOW() - INTERVAL '180 days'
    ORDER BY last_autovacuum;
END;
$$ LANGUAGE plpgsql;
```

### Logs et historique

pg_partman ne possÃ¨de pas de systÃ¨me de logs intÃ©grÃ© sophistiquÃ©, mais vous pouvez :

1. **Utiliser les logs PostgreSQL** : Activez `log_statement = 'ddl'` pour tracer les CREATE/DROP TABLE
2. **Utiliser pg_stat_user_tables** : Suivre les statistiques d'accÃ¨s aux partitions
3. **CrÃ©er une table d'audit personnalisÃ©e** :

```sql
CREATE TABLE partman.maintenance_log (
    log_id SERIAL PRIMARY KEY,
    execution_time TIMESTAMPTZ DEFAULT NOW(),
    parent_table TEXT,
    action TEXT,  -- 'create', 'detach', 'drop'
    partition_name TEXT,
    details JSONB
);

-- Fonction wrapper pour logger
CREATE OR REPLACE FUNCTION partman.run_maintenance_with_log()
RETURNS void AS $$
BEGIN
    PERFORM partman.run_maintenance();

    INSERT INTO partman.maintenance_log (parent_table, action, details)
    VALUES ('all', 'maintenance_run', jsonb_build_object('timestamp', NOW()));
END;
$$ LANGUAGE plpgsql;
```

---

## OpÃ©rations AvancÃ©es

### DÃ©tacher manuellement une partition

Pour dÃ©tacher une partition avant le dÃ©lai de retention :

```sql
-- DÃ©tacher la partition
ALTER TABLE logs DETACH PARTITION logs_p2023_01_01;

-- La partition existe toujours comme table indÃ©pendante
-- Vous pouvez l'archiver, la dÃ©placer vers un tablespace diffÃ©rent, etc.

-- Pour la supprimer complÃ¨tement
DROP TABLE logs_p2023_01_01;
```

### Rattacher une partition

Si vous avez dÃ©tachÃ© une partition et souhaitez la rÃ©intÃ©grer :

```sql
-- VÃ©rifier que les donnÃ©es respectent les contraintes
ALTER TABLE logs ATTACH PARTITION logs_p2023_01_01
    FOR VALUES FROM ('2023-01-01') TO ('2023-02-01');
```

**Important** : PostgreSQL vÃ©rifiera que toutes les lignes de la partition dÃ©tachÃ©e respectent bien les bornes dÃ©finies.

### RÃ©partitionner une table (Repartitioning)

Si vous souhaitez changer l'intervalle de partitionnement (ex: passer de mensuel Ã  hebdomadaire) :

**MÃ©thode 1** : CrÃ©er une nouvelle table et migrer

```sql
-- 1. CrÃ©er la nouvelle table partitionnÃ©e
CREATE TABLE logs_new (LIKE logs INCLUDING ALL)
PARTITION BY RANGE (timestamp);

-- 2. Configurer pg_partman avec le nouvel intervalle
SELECT partman.create_parent(
    p_parent_table := 'public.logs_new',
    p_control := 'timestamp',
    p_interval := 'weekly',  -- Nouvel intervalle
    p_premake := 8
);

-- 3. Migrer les donnÃ©es (par batch)
-- 4. Renommer les tables
```

**MÃ©thode 2** : Utiliser des partitions temporaires et consolider

(Plus complexe, Ã  scripter selon vos besoins spÃ©cifiques)

### DÃ©placer des partitions vers un autre tablespace

Pour optimiser le stockage (ex: anciennes partitions sur disque lent) :

```sql
-- CrÃ©er un tablespace pour archives
CREATE TABLESPACE archive_ts LOCATION '/mnt/slow_disk/postgres/archive';

-- DÃ©placer une partition
ALTER TABLE logs_p2023_01_01 SET TABLESPACE archive_ts;

-- Automatiser via pg_partman (aprÃ¨s dÃ©tachement)
UPDATE partman.part_config
SET retention_schema = 'archive'
WHERE parent_table = 'public.logs';
```

### Gestion des partitions par dÃ©faut

PostgreSQL permet une partition "default" pour capturer les donnÃ©es hors plages dÃ©finies :

```sql
-- CrÃ©er une partition par dÃ©faut
CREATE TABLE logs_default PARTITION OF logs DEFAULT;

-- ATTENTION : pg_partman ne gÃ¨re pas automatiquement les partitions default
-- Vous devrez surveiller manuellement cette partition
```

**Recommandation** : Utilisez `premake` suffisamment Ã©levÃ© pour Ã©viter d'avoir besoin d'une partition default.

---

## StratÃ©gies de Partitionnement

### Choisir le bon intervalle

| Intervalle | Volume typique | Cas d'usage |
|------------|----------------|-------------|
| **Hourly** | Millions de lignes/heure | IoT temps rÃ©el, logs haute frÃ©quence |
| **Daily** | Centaines de milliers/jour | Logs applicatifs, Ã©vÃ©nements |
| **Weekly** | Millions de lignes/semaine | DonnÃ©es agrÃ©gÃ©es, analytics |
| **Monthly** | Dizaines de millions/mois | Transactions, commandes, donnÃ©es historiques |
| **Quarterly** | Centaines de millions/trimestre | Archivage long terme |
| **Yearly** | Milliards de lignes/an | DonnÃ©es rÃ©glementaires, audit |

**RÃ¨gle gÃ©nÃ©rale** : Une partition ne devrait pas dÃ©passer 100-200 Go pour des performances optimales.

### Partitionnement par date vs par ID

| CritÃ¨re | Par Date (timestamp) | Par ID (sÃ©quence) |
|---------|----------------------|-------------------|
| **Pattern d'accÃ¨s** | RequÃªtes rÃ©centes frÃ©quentes | AccÃ¨s uniforme sur tout le dataset |
| **Archivage** | Facile (dÃ©tacher l'ancien) | Complexe |
| **Performance** | Excellente pour requÃªtes temporelles | Bonne pour distribution uniforme |
| **Maintenance** | Automatique avec pg_partman | Moins automatisable |

**Conseil** : PrivilÃ©giez le partitionnement temporel (par date) sauf cas spÃ©cifiques.

### Partitionnement simple vs en cascade

| Approche | Avantages | InconvÃ©nients |
|----------|-----------|---------------|
| **Simple** (1 niveau) | Simple Ã  gÃ©rer, performant | Moins flexible |
| **Cascade** (2+ niveaux) | TrÃ¨s granulaire, flexible | Complexe, overhead |

**Exemple cascade** : Partitionner par annÃ©e, puis chaque annÃ©e par mois
- `logs_2024` â†’ `logs_2024_01`, `logs_2024_02`, ...
- `logs_2025` â†’ `logs_2025_01`, `logs_2025_02`, ...

**Recommandation** : Utilisez le partitionnement simple sauf si vous avez des besoins trÃ¨s spÃ©cifiques.

---

## Cas d'Usage DÃ©taillÃ©s

### 1. Table de Logs Applicatifs

**Contexte** : Application web avec 50 millions de logs par mois.

**Objectif** : Conserver 3 mois en ligne, archiver l'ancien.

```sql
-- CrÃ©er la table
CREATE TABLE app_logs (
    log_id BIGSERIAL,
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    level VARCHAR(20),
    message TEXT,
    user_id INTEGER,
    request_id UUID
) PARTITION BY RANGE (timestamp);

-- Template avec index
CREATE TABLE app_logs_template (LIKE app_logs INCLUDING ALL);
CREATE INDEX idx_app_logs_user ON app_logs_template(user_id);
CREATE INDEX idx_app_logs_level ON app_logs_template(level) WHERE level IN ('ERROR', 'CRITICAL');

-- Configurer pg_partman
SELECT partman.create_parent(
    p_parent_table := 'public.app_logs',
    p_control := 'timestamp',
    p_interval := 'daily',
    p_premake := 7,  -- 1 semaine Ã  l'avance
    p_template_table := 'public.app_logs_template'
);

-- DÃ©finir la retention
UPDATE partman.part_config
SET
    retention = '90 days',
    retention_keep_table = TRUE,
    retention_keep_index = FALSE,
    retention_schema = 'archive'
WHERE parent_table = 'public.app_logs';

-- Automatiser avec pg_cron
SELECT cron.schedule(
    'maintain_app_logs',
    '0 2 * * *',  -- Tous les jours Ã  2h
    'SELECT partman.run_maintenance(''public.app_logs'');'
);
```

**RÃ©sultat** :
- Nouvelles partitions crÃ©Ã©es automatiquement chaque jour
- Logs de plus de 90 jours dÃ©placÃ©s vers `archive.app_logs_pYYYY_MM_DD`
- Espace disque Ã©conomisÃ© (index supprimÃ©s sur archives)

### 2. Table de Transactions E-commerce

**Contexte** : Site e-commerce avec millions de transactions.

**Objectif** : Partitionnement mensuel, conservation 2 ans.

```sql
CREATE TABLE transactions (
    transaction_id BIGSERIAL,
    date_transaction TIMESTAMPTZ NOT NULL,
    user_id INTEGER NOT NULL,
    montant NUMERIC(10,2),
    statut VARCHAR(20),
    details JSONB
) PARTITION BY RANGE (date_transaction);

-- Template
CREATE TABLE transactions_template (LIKE transactions INCLUDING ALL);
CREATE INDEX idx_trans_user ON transactions_template(user_id);
CREATE INDEX idx_trans_status ON transactions_template(statut);
CREATE INDEX idx_trans_montant ON transactions_template(montant) WHERE montant > 1000;

-- Configuration pg_partman
SELECT partman.create_parent(
    p_parent_table := 'public.transactions',
    p_control := 'date_transaction',
    p_interval := 'monthly',
    p_premake := 6,  -- 6 mois Ã  l'avance
    p_template_table := 'public.transactions_template'
);

-- Retention 2 ans
UPDATE partman.part_config
SET
    retention = '2 years',
    retention_keep_table = FALSE  -- Supprimer aprÃ¨s 2 ans
WHERE parent_table = 'public.transactions';
```

### 3. DonnÃ©es IoT / SÃ©ries Temporelles

**Contexte** : Capteurs IoT gÃ©nÃ©rant 100 millions de mesures par jour.

**Objectif** : Partitionnement horaire, agrÃ©gation et archivage.

```sql
CREATE TABLE sensor_data (
    sensor_id INTEGER,
    timestamp TIMESTAMPTZ NOT NULL,
    temperature NUMERIC(5,2),
    humidity NUMERIC(5,2),
    pressure NUMERIC(7,2)
) PARTITION BY RANGE (timestamp);

-- Configuration pour partitionnement horaire
SELECT partman.create_parent(
    p_parent_table := 'public.sensor_data',
    p_control := 'timestamp',
    p_interval := 'hourly',
    p_premake := 48  -- 48h Ã  l'avance
);

-- Retention courte (7 jours en brut)
UPDATE partman.part_config
SET
    retention = '7 days',
    retention_keep_table = FALSE
WHERE parent_table = 'public.sensor_data';

-- CrÃ©er une table agrÃ©gÃ©e (quotidienne) pour historique long terme
CREATE TABLE sensor_data_daily (
    sensor_id INTEGER,
    date DATE,
    avg_temperature NUMERIC(5,2),
    avg_humidity NUMERIC(5,2),
    avg_pressure NUMERIC(7,2),
    PRIMARY KEY (sensor_id, date)
);

-- Job d'agrÃ©gation quotidien (avec pg_cron)
SELECT cron.schedule(
    'aggregate_sensor_data',
    '0 1 * * *',  -- Tous les jours Ã  1h
    $$
    INSERT INTO sensor_data_daily (sensor_id, date, avg_temperature, avg_humidity, avg_pressure)
    SELECT
        sensor_id,
        DATE(timestamp) as date,
        AVG(temperature),
        AVG(humidity),
        AVG(pressure)
    FROM sensor_data
    WHERE timestamp >= CURRENT_DATE - 1
      AND timestamp < CURRENT_DATE
    GROUP BY sensor_id, DATE(timestamp)
    ON CONFLICT (sensor_id, date) DO UPDATE
    SET
        avg_temperature = EXCLUDED.avg_temperature,
        avg_humidity = EXCLUDED.avg_humidity,
        avg_pressure = EXCLUDED.avg_pressure;
    $$
);
```

### 4. Table Multi-tenant (Partitionnement par Liste)

**Contexte** : Application SaaS avec sÃ©paration stricte par client.

**Objectif** : Partitionnement par tenant_id.

```sql
CREATE TABLE tenant_data (
    id BIGSERIAL,
    tenant_id INTEGER NOT NULL,
    data JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
) PARTITION BY LIST (tenant_id);

-- pg_partman supporte aussi le partitionnement par liste
SELECT partman.create_parent(
    p_parent_table := 'public.tenant_data',
    p_control := 'tenant_id',
    p_type := 'native',
    p_interval := 'list'  -- Mode liste
);

-- CrÃ©ation manuelle de partitions par tenant
CREATE TABLE tenant_data_p1 PARTITION OF tenant_data FOR VALUES IN (1);
CREATE TABLE tenant_data_p2 PARTITION OF tenant_data FOR VALUES IN (2);
-- ... etc

-- Note : La gestion automatique est moins avancÃ©e pour les partitions de type LIST
-- Il faudra souvent crÃ©er manuellement les nouvelles partitions
```

---

## Bonnes Pratiques

### 1. Planification initiale

âœ… **Analysez votre workload** :
- Volume de donnÃ©es quotidien/mensuel
- Pattern de requÃªtes (rÃ©centes vs historiques)
- Exigences de retention

âœ… **Choisissez le bon intervalle** :
- Trop petit = trop de partitions = overhead de gestion
- Trop grand = partitions volumineuses = mauvaises performances

âœ… **Testez sur un environnement de dev** avant la production

### 2. Configuration de premake

âœ… **Soyez gÃ©nÃ©reux** : Mieux vaut crÃ©er trop de partitions que pas assez
âœ… **Adaptez selon l'intervalle** :
- Daily : 7-14 jours d'avance
- Monthly : 3-6 mois d'avance
- Yearly : 2-3 ans d'avance

âŒ Ne jamais avoir `premake < 2` pour Ã©viter les surprises

### 3. Gestion de la retention

âœ… **DÃ©finissez une politique claire** :
- Combien de temps conserver en ligne ?
- Archiver ou supprimer aprÃ¨s ?
- Besoins rÃ©glementaires (RGPD, SOX, etc.) ?

âœ… **Utilisez un schÃ©ma d'archive** :
```sql
CREATE SCHEMA archive;
UPDATE partman.part_config
SET
    retention_schema = 'archive',
    retention_keep_index = FALSE  -- Ã‰conomiser l'espace
WHERE parent_table = 'public.logs';
```

âœ… **Sauvegardez les archives** rÃ©guliÃ¨rement (pg_dump par schÃ©ma)

### 4. Surveillance proactive

âœ… **CrÃ©ez des alertes** :
- Partitions manquantes dans le futur
- Ã‰checs de run_maintenance()
- Partitions dÃ©sÃ©quilibrÃ©es (taille anormale)

âœ… **VÃ©rifiez rÃ©guliÃ¨rement** `partman.part_config`

âœ… **Auditez les performances** :
```sql
-- Identifier les slow queries sur partitions
SELECT * FROM pg_stat_statements
WHERE query LIKE '%logs_%'
ORDER BY total_exec_time DESC;
```

### 5. Template tables

âœ… **Utilisez toujours des templates** pour :
- Garantir la cohÃ©rence des index
- Appliquer les mÃªmes contraintes partout
- Simplifier la maintenance

âŒ Ne modifiez jamais directement les index sur les partitions individuelles

### 6. Nommage cohÃ©rent

âœ… **Suivez les conventions pg_partman** :
- Tables parent claires (`logs`, `transactions`)
- Partitions automatiquement nommÃ©es (`logs_p2025_01_01`)

âœ… **Documentez votre schÃ©ma** :
```sql
COMMENT ON TABLE logs IS
'Table de logs applicatifs, partitionnÃ©e quotidiennement.
Retention: 90 jours en ligne, archives dans schema "archive".
Maintenance: automatique via pg_cron (run_maintenance toutes les heures).';
```

### 7. Tests avant migration

- âœ… **Testez la migration** sur un clone de production
- âœ… **Mesurez les performances** avant/aprÃ¨s
- âœ… **PrÃ©parez un rollback plan**
- âœ… **PrÃ©voyez une fenÃªtre de maintenance** pour grandes tables

### 8. Coordination avec les backups

âœ… **Excluez les archives** des backups rÃ©guliers si possible :
```bash
# pg_dump avec exclusion de schema
pg_dump -Fc -f backup.dump -N archive mydb
```

âœ… **Sauvegardez les archives sÃ©parÃ©ment** (moins frÃ©quemment)

âœ… **Testez les restaurations** de partitions individuelles

---

## DÃ©pannage (Troubleshooting)

### ProblÃ¨me 1 : Partitions ne se crÃ©ent pas automatiquement

**SymptÃ´mes** : `run_maintenance()` ne crÃ©e pas de nouvelles partitions.

**Diagnostics** :

```sql
-- VÃ©rifier la configuration
SELECT * FROM partman.part_config
WHERE parent_table = 'public.logs';

-- VÃ©rifier si premake est suffisant
SELECT
    parent_table,
    premake,
    last_partition
FROM partman.part_config;

-- VÃ©rifier les jobs pg_cron
SELECT * FROM cron.job WHERE command LIKE '%partman%';
```

**Solutions** :
1. Augmenter `premake` si nÃ©cessaire
2. VÃ©rifier que pg_cron s'exÃ©cute bien
3. ExÃ©cuter manuellement `run_maintenance()` pour tester

### ProblÃ¨me 2 : Erreur "no partition of relation for row"

**SymptÃ´mes** : Erreur lors d'insertion dans une table partitionnÃ©e.

**Cause** : Aucune partition ne correspond Ã  la valeur insÃ©rÃ©e (souvent une date future).

**Solution** :

```sql
-- CrÃ©er manuellement la partition manquante
SELECT partman.create_partition_time(
    'public.logs',
    '2026-01-15',  -- Date de la partition nÃ©cessaire
    'daily'
);

-- Puis augmenter premake pour Ã©viter le problÃ¨me
UPDATE partman.part_config
SET premake = 30  -- Augmenter significativement
WHERE parent_table = 'public.logs';

-- Relancer la maintenance
SELECT partman.run_maintenance('public.logs');
```

### ProblÃ¨me 3 : Performances dÃ©gradÃ©es aprÃ¨s partitionnement

**SymptÃ´mes** : RequÃªtes plus lentes qu'avant le partitionnement.

**Diagnostics** :

```sql
-- VÃ©rifier que partition pruning fonctionne
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM logs
WHERE timestamp >= '2025-01-01'
  AND timestamp < '2025-02-01';

-- Doit afficher : "Partitions scanned: 1 of X"
```

**Causes possibles** :
1. **Index manquants** : VÃ©rifiez que les index sont bien crÃ©Ã©s sur chaque partition
2. **Partition pruning inactif** : RequÃªtes sans filtre sur la clÃ© de partitionnement
3. **Statistiques obsolÃ¨tes** : ExÃ©cuter ANALYZE

**Solutions** :

```sql
-- RecrÃ©er les index via template
SELECT partman.reapply_privileges('public.logs');

-- Analyser toutes les partitions
SELECT partman.run_maintenance(
    p_parent_table := 'public.logs',
    p_analyze := TRUE
);

-- Forcer une analyse complÃ¨te
ANALYZE logs;
```

### ProblÃ¨me 4 : Trop de partitions

**SymptÃ´mes** : Des milliers de partitions, lenteur dans les mÃ©tadonnÃ©es (pg_class).

**Cause** : Intervalle trop petit ou retention trop longue.

**Solution** :

```sql
-- RÃ©duire la retention
UPDATE partman.part_config
SET retention = '30 days'  -- Au lieu de '365 days'
WHERE parent_table = 'public.logs';

-- Forcer le nettoyage
SELECT partman.run_maintenance('public.logs');

-- Ou dÃ©tacher manuellement en masse (avec prÃ©caution)
DO $$
DECLARE
    part RECORD;
BEGIN
    FOR part IN
        SELECT tablename
        FROM pg_tables
        WHERE tablename LIKE 'logs_p2023%'
    LOOP
        EXECUTE format('ALTER TABLE logs DETACH PARTITION %I', part.tablename);
        EXECUTE format('DROP TABLE %I', part.tablename);
    END LOOP;
END $$;
```

### ProblÃ¨me 5 : Contraintes de clÃ© Ã©trangÃ¨re

**SymptÃ´mes** : Erreur lors de la crÃ©ation de FK vers une table partitionnÃ©e.

**Cause** : Les FK sur tables partitionnÃ©es ont des limitations.

**Solution** :

```sql
-- Les FK doivent inclure la clÃ© de partitionnement
CREATE TABLE orders (
    order_id BIGSERIAL,
    created_at TIMESTAMPTZ NOT NULL,
    user_id INTEGER
) PARTITION BY RANGE (created_at);

CREATE TABLE order_items (
    item_id BIGSERIAL,
    order_id BIGINT,
    created_at TIMESTAMPTZ NOT NULL,  -- Doit Ãªtre prÃ©sent !
    FOREIGN KEY (order_id, created_at)
        REFERENCES orders(order_id, created_at)
) PARTITION BY RANGE (created_at);
```

**Alternative** : Utiliser des triggers pour valider l'intÃ©gritÃ© rÃ©fÃ©rentielle.

### ProblÃ¨me 6 : pg_partman ne dÃ©tache pas les anciennes partitions

**Diagnostics** :

```sql
-- VÃ©rifier la configuration de retention
SELECT
    parent_table,
    retention,
    retention_keep_table,
    retention_schema
FROM partman.part_config
WHERE parent_table = 'public.logs';

-- VÃ©rifier si run_maintenance est appelÃ©
SELECT * FROM cron.job_run_details
WHERE command LIKE '%run_maintenance%'
ORDER BY start_time DESC
LIMIT 5;
```

**Solutions** :
1. VÃ©rifier que `retention` est dÃ©fini (pas NULL)
2. VÃ©rifier que le schÃ©ma de destination existe (`retention_schema`)
3. ExÃ©cuter manuellement pour tester :

```sql
SELECT partman.run_maintenance('public.logs');

-- VÃ©rifier les logs PostgreSQL pour voir les erreurs
```

---

## IntÃ©gration avec l'Ã‰cosystÃ¨me PostgreSQL

### pg_partman + pg_cron : L'automatisation complÃ¨te

Configuration optimale pour automatisation totale :

```sql
-- Job de maintenance principal (toutes les heures)
SELECT cron.schedule(
    'pg_partman_maintenance',
    '0 * * * *',
    'SELECT partman.run_maintenance();'
);

-- Job de vÃ©rification quotidien
SELECT cron.schedule(
    'pg_partman_check',
    '0 9 * * *',
    $$
    SELECT send_alert(
        'Partman Status',
        string_agg(parent_table || ': ' || last_partition, E'\n')
    )
    FROM partman.part_config;
    $$
);

-- Job de nettoyage hebdomadaire des logs
SELECT cron.schedule(
    'pg_partman_cleanup_logs',
    '0 3 * * 0',
    'DELETE FROM partman.maintenance_log WHERE execution_time < NOW() - INTERVAL ''90 days'''
);
```

### pg_partman + Patroni/Replication

Dans une configuration haute disponibilitÃ© :

**Important** : pg_partman doit s'exÃ©cuter **uniquement sur le serveur primaire**.

```sql
-- CrÃ©er un wrapper qui vÃ©rifie le rÃ´le
CREATE OR REPLACE FUNCTION partman.run_maintenance_if_primary()
RETURNS void AS $$
BEGIN
    -- VÃ©rifier si c'est le primaire
    IF pg_is_in_recovery() = FALSE THEN
        PERFORM partman.run_maintenance();
    ELSE
        RAISE NOTICE 'Serveur en standby, skip maintenance';
    END IF;
END;
$$ LANGUAGE plpgsql;

-- Job pg_cron utilisant le wrapper
SELECT cron.schedule(
    'pg_partman_maintenance_ha',
    '0 * * * *',
    'SELECT partman.run_maintenance_if_primary();'
);
```

**Failover** : En cas de promotion d'un standby, pg_cron basculera automatiquement et continuera la maintenance sur le nouveau primaire.

### pg_partman + TimescaleDB

pg_partman peut coexister avec TimescaleDB, mais gÃ©nÃ©ralement TimescaleDB gÃ¨re lui-mÃªme le partitionnement (hypertables).

**Recommandation** : Utilisez soit pg_partman, soit TimescaleDB, pas les deux ensemble sur les mÃªmes tables.

### pg_partman + Monitoring (Prometheus/Grafana)

Exporter des mÃ©triques de partitionnement :

```sql
-- Vue pour exposition des mÃ©triques
CREATE OR REPLACE VIEW partman.metrics AS
SELECT
    parent_table,
    EXTRACT(EPOCH FROM COALESCE(retention, '0'::interval)) as retention_seconds,
    premake,
    (SELECT COUNT(*)
     FROM pg_tables
     WHERE tablename LIKE REPLACE(parent_table, 'public.', '') || '_%') as partition_count
FROM partman.part_config;

-- Utiliser postgres_exporter pour exposer cette vue
```

**Dashboard Grafana** recommandÃ© :
- Nombre de partitions par table
- Taille totale par table partitionnÃ©e
- Ã‚ge de la derniÃ¨re partition crÃ©Ã©e
- Ã‰checs de maintenance

---

## Performances et Optimisations

### Impact du Partitionnement sur les Performances

**AmÃ©liorations attendues** :

| OpÃ©ration | AmÃ©lioration | Raison |
|-----------|--------------|--------|
| **SELECT sur plage rÃ©cente** | 10-100x | Partition pruning |
| **DELETE en masse** | 100-1000x | DROP/DETACH partition vs DELETE |
| **VACUUM** | 10-50x | OpÃ©ration sur petites partitions |
| **Index rebuild** | 10-50x | Moins de donnÃ©es par partition |
| **Backup sÃ©lectif** | Variable | Backup uniquement partitions actives |

**Overhead potentiel** :

| OpÃ©ration | Impact | Mitigation |
|-----------|--------|------------|
| **Planning de requÃªte** | +10-50ms | Utiliser prepared statements |
| **Scan complet** | LÃ©gÃ¨rement plus lent | Ã‰viter les queries sans filtre temporel |
| **MÃ©tadonnÃ©es** | Augmentation pg_class | Limiter le nombre total de partitions |

### Optimisation des RequÃªtes sur Tables PartitionnÃ©es

#### Utiliser le Partition Pruning

**Mauvaise requÃªte** (scan toutes les partitions) :

```sql
-- âŒ Pas de filtre sur clÃ© de partitionnement
SELECT * FROM logs WHERE user_id = 12345;
-- â†’ Scannera TOUTES les partitions !
```

**Bonne requÃªte** (partition pruning actif) :

```sql
-- âœ… Filtre sur la clÃ© de partitionnement
SELECT * FROM logs
WHERE timestamp >= '2025-11-01'
  AND timestamp < '2025-12-01'
  AND user_id = 12345;
-- â†’ Scannera uniquement la partition de novembre 2025
```

#### VÃ©rifier le Plan d'ExÃ©cution

```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM logs
WHERE timestamp >= CURRENT_DATE - INTERVAL '7 days';

-- Chercher dans le plan :
-- "Partitions scanned: 7 of 100" â† Bon signe !
-- "Partitions scanned: 100 of 100" â† Mauvais signe !
```

#### Index StratÃ©giques

```sql
-- Template avec index composites intelligents
CREATE TABLE logs_template (LIKE logs INCLUDING ALL);

-- Index composite : clÃ© de partition + colonnes frÃ©quentes
CREATE INDEX idx_logs_timestamp_user ON logs_template(timestamp, user_id);
CREATE INDEX idx_logs_timestamp_level ON logs_template(timestamp, level);

-- Ã‰viter les index redondants sur chaque partition
-- Un index sur (user_id) seul est gÃ©nÃ©ralement moins utile
```

### Tuning de pg_partman

#### RÃ©duire l'Overhead de run_maintenance()

```sql
-- DÃ©sactiver ANALYZE si les partitions sont rarement modifiÃ©es
UPDATE partman.part_config
SET optimize_trigger = 0  -- DÃ©sactiver l'analyse automatique
WHERE parent_table = 'public.logs';

-- Analyser manuellement Ã  la demande
ANALYZE logs;
```

#### ParallÃ©lisation

pg_partman n'a pas de parallÃ©lisation native, mais vous pouvez :

```sql
-- ExÃ©cuter la maintenance en parallÃ¨le pour plusieurs tables
SELECT cron.schedule('maintain_logs', '0 * * * *',
    'SELECT partman.run_maintenance(''public.logs'');');

SELECT cron.schedule('maintain_transactions', '5 * * * *',  -- DÃ©calÃ© de 5min
    'SELECT partman.run_maintenance(''public.transactions'');');
```

---

## Migrer vers pg_partman depuis une Solution Manuelle

Si vous avez dÃ©jÃ  des partitions crÃ©Ã©es manuellement, pg_partman peut reprendre la gestion.

### Ã‰tape 1 : Analyser l'existant

```sql
-- Identifier les partitions actuelles
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size
FROM pg_tables
WHERE tablename LIKE 'logs_%'
ORDER BY tablename;
```

### Ã‰tape 2 : Adapter le schÃ©ma si nÃ©cessaire

pg_partman attend une nomenclature spÃ©cifique :
- Tables parent : `logs`
- Partitions : `logs_pYYYY_MM_DD` (pour daily), `logs_pYYYY_MM` (pour monthly)

Si vos partitions ont une nomenclature diffÃ©rente, vous devrez peut-Ãªtre les renommer :

```sql
-- Exemple : Renommer logs_202501 en logs_p2025_01
ALTER TABLE logs_202501 RENAME TO logs_p2025_01;
```

### Ã‰tape 3 : Configurer pg_partman

```sql
SELECT partman.create_parent(
    p_parent_table := 'public.logs',
    p_control := 'timestamp',
    p_interval := 'monthly',
    p_premake := 4,
    p_start_partition := (SELECT MAX(partition_boundary) FROM existing_partitions)
);
```

### Ã‰tape 4 : Tester la maintenance

```sql
-- ExÃ©cuter manuellement
SELECT partman.run_maintenance('public.logs');

-- VÃ©rifier que de nouvelles partitions sont crÃ©Ã©es
SELECT partman.show_partitions('public.logs');
```

### Ã‰tape 5 : Automatiser

```sql
SELECT cron.schedule(
    'maintain_migrated_logs',
    '0 2 * * *',
    'SELECT partman.run_maintenance(''public.logs'');'
);
```

---

## Comparaison avec Autres Solutions

### pg_partman vs Partitionnement Manuel

| CritÃ¨re | pg_partman | Manuel |
|---------|------------|--------|
| **ComplexitÃ©** | Faible (automatisÃ©) | Ã‰levÃ©e (scripts custom) |
| **Maintenance** | Automatique | Manuelle |
| **Risque d'erreur** | Faible | Ã‰levÃ© |
| **FlexibilitÃ©** | Moyenne | Maximale |
| **Overhead** | Minimal | Aucun |

**Verdict** : pg_partman est recommandÃ© pour 95% des cas d'usage.

### pg_partman vs TimescaleDB

| CritÃ¨re | pg_partman | TimescaleDB |
|---------|------------|-------------|
| **Type de donnÃ©es** | GÃ©nÃ©raliste | SÃ©ries temporelles |
| **ComplexitÃ©** | Moyenne | Faible (abstrait) |
| **Performance** | Excellente | Excellente (optimisÃ©e pour time-series) |
| **Features avancÃ©es** | Basiques | Compression, continuous aggregates |
| **DÃ©pendance** | Extension simple | NÃ©cessite TimescaleDB |

**Verdict** : TimescaleDB pour sÃ©ries temporelles IoT/mÃ©triques, pg_partman pour cas gÃ©nÃ©riques.

### pg_partman vs Citus (Partitionnement DistribuÃ©)

| CritÃ¨re | pg_partman | Citus |
|---------|------------|-------|
| **Architecture** | Single-node | Distributed (multi-nodes) |
| **ScalabilitÃ©** | Verticale | Horizontale |
| **ComplexitÃ©** | Faible | Ã‰levÃ©e |
| **CoÃ»t** | Gratuit (open-source) | Gratuit + Enterprise |

**Verdict** : pg_partman pour single-node, Citus pour sharding distribuÃ© sur plusieurs serveurs.

---

## SÃ©curitÃ© et Permissions

### Permissions Minimales pour pg_partman

```sql
-- CrÃ©er un rÃ´le dÃ©diÃ© Ã  pg_partman
CREATE ROLE partman_worker;

-- Permissions sur le schÃ©ma partman
GRANT USAGE ON SCHEMA partman TO partman_worker;
GRANT ALL ON ALL TABLES IN SCHEMA partman TO partman_worker;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA partman TO partman_worker;

-- Permissions sur les tables Ã  partitionner
GRANT ALL ON ALL TABLES IN SCHEMA public TO partman_worker;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO partman_worker;

-- Permission de crÃ©er des objets
GRANT CREATE ON SCHEMA public TO partman_worker;
```

### Audit des OpÃ©rations pg_partman

```sql
-- Activer l'audit des DDL
ALTER SYSTEM SET log_statement = 'ddl';
SELECT pg_reload_conf();

-- CrÃ©er une table d'audit personnalisÃ©e
CREATE TABLE partman.audit_log (
    audit_id SERIAL PRIMARY KEY,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    operation TEXT,
    parent_table TEXT,
    partition_name TEXT,
    executed_by NAME DEFAULT CURRENT_USER
);

-- Trigger pour audit (exemple conceptuel)
-- Ã€ adapter selon vos besoins
```

---

## Limitations et ConsidÃ©rations

### Limitations de pg_partman

1. **Pas de support pour les vues partitionnÃ©es** : Uniquement les tables
2. **Gestion limitÃ©e des partitions LIST** : Moins automatisÃ©e que RANGE
3. **Pas de migration de donnÃ©es automatique** : Doit Ãªtre scriptÃ©e manuellement
4. **DÃ©pend de pg_cron** : Pour l'automatisation (ou Ã©quivalent)
5. **Pas de gestion de dÃ©pendances complexes** : Entre partitions ou avec d'autres tables

### Limitations de PostgreSQL

1. **Foreign Keys** : Les FK sur tables partitionnÃ©es doivent inclure la clÃ© de partitionnement
2. **Triggers BEFORE ROW** : Peuvent Ãªtre plus lents avec de nombreuses partitions
3. **Nombre de partitions** : Au-delÃ  de 1000 partitions, overhead sur les mÃ©tadonnÃ©es
4. **Partition pruning** : Ne fonctionne qu'avec des filtres sur la clÃ© de partitionnement

### Quand NE PAS Utiliser le Partitionnement

âŒ **Ne partitionnez pas si** :
- Votre table a moins de 10 millions de lignes
- Vous n'avez pas de dimension temporelle ou catÃ©gorielle claire
- Vos requÃªtes ne filtrent jamais sur une colonne spÃ©cifique
- Vous n'avez pas de stratÃ©gie d'archivage

Le partitionnement ajoute de la complexitÃ©. Il doit rÃ©soudre un problÃ¨me rÃ©el (performance, archivage).

---

## Pour Aller Plus Loin

### Ressources Officielles

- **GitHub pg_partman** : https://github.com/pgpartman/pg_partman
- **Documentation PostgreSQL - Partitioning** : https://www.postgresql.org/docs/current/ddl-partitioning.html

### Lectures RecommandÃ©es

- **PostgreSQL: Up and Running** (Regina Obe, Leo Hsu) - Chapitre sur le partitionnement
- **The Art of PostgreSQL** (Dimitri Fontaine) - StratÃ©gies avancÃ©es

### CommunautÃ© et Support

- **GitHub Issues** : Signaler des bugs ou demander des fonctionnalitÃ©s
- **PostgreSQL Mailing Lists** : pgsql-general@postgresql.org
- **Slack/Discord** : CommunautÃ©s PostgreSQL actives

### FonctionnalitÃ©s AvancÃ©es (Non Couvertes)

- **Sub-partitioning** : Partitionnement en cascade (annÃ©e â†’ mois)
- **Custom retention policies** : Logique de retention personnalisÃ©e
- **Integration avec pg_dump/pg_restore** : StratÃ©gies de backup avancÃ©es
- **Constraint exclusion** : Optimisation pour anciennes versions de PostgreSQL

---

## RÃ©sumÃ©

**pg_partman** est une extension PostgreSQL indispensable pour gÃ©rer efficacement les tables partitionnÃ©es Ã  grande Ã©chelle.

### Points ClÃ©s

- âœ… **Automatisation complÃ¨te** : CrÃ©ation, maintenance, et suppression de partitions
- âœ… **IntÃ©gration pg_cron** : Planification automatique de la maintenance
- âœ… **Gestion de retention** : Archivage et nettoyage automatisÃ©s
- âœ… **FlexibilitÃ©** : Support Range, List, Hash, avec ou sans template
- âœ… **Production-ready** : UtilisÃ© par des milliers d'entreprises

### Quand Utiliser pg_partman ?

- Tables avec **10+ millions de lignes**
- DonnÃ©es **temporelles** (logs, Ã©vÃ©nements, transactions)
- Besoin d'**archivage** rÃ©gulier
- Optimisation des **performances** sur requÃªtes rÃ©centes
- Simplification de la **maintenance** (VACUUM, REINDEX)

### Architecture RecommandÃ©e

```
PostgreSQL 18
    â”œâ”€â”€ pg_partman (gestion de partitions)
    â”œâ”€â”€ pg_cron (automatisation)
    â””â”€â”€ Monitoring (alertes sur Ã©checs)
```

### Workflow Type

1. **CrÃ©er** la table partitionnÃ©e avec pg_partman
2. **Configurer** premake, retention, template
3. **Automatiser** avec pg_cron (run_maintenance)
4. **Surveiller** rÃ©guliÃ¨rement (logs, alertes)
5. **Optimiser** selon les besoins (ajuster intervalle, retention)

### Prochaines Ã‰tapes

1. Installer pg_partman dans un environnement de test
2. CrÃ©er une table partitionnÃ©e simple (logs, Ã©vÃ©nements)
3. Configurer l'automatisation avec pg_cron
4. Observer le comportement sur plusieurs jours
5. Migrer vers production avec confiance

---

**En Conclusion** : pg_partman transforme le partitionnement PostgreSQL d'un processus manuel fastidieux en une gestion automatisÃ©e et fiable. Pour tout dÃ©veloppeur ou DBA gÃ©rant des tables volumineuses, c'est un outil incontournable qui simplifie considÃ©rablement l'exploitation et amÃ©liore les performances.

---


â­ï¸ [pg_stat_kcache : MÃ©triques systÃ¨me](/18-extensions-et-integrations/07.3-pg-stat-kcache.md)
