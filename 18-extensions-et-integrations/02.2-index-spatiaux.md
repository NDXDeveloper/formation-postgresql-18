üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.2.2. Index Spatiaux : GiST et SP-GiST

## Introduction

Imaginez que vous devez trouver tous les restaurants dans un rayon de 1 km autour de votre position parmi des millions d'√©tablissements. Sans index spatial, PostgreSQL devrait calculer la distance entre votre position et **chaque** restaurant de la base. C'est extr√™mement lent !

Les **index spatiaux** sont la solution : ils organisent les donn√©es g√©ographiques de mani√®re intelligente pour acc√©l√©rer drastiquement les requ√™tes spatiales. Ils peuvent transformer une requ√™te de plusieurs minutes en quelques millisecondes.

Dans ce chapitre, nous allons d√©couvrir les deux principaux types d'index spatiaux utilis√©s avec PostGIS :
- **GiST** (Generalized Search Tree) : L'index spatial par excellence
- **SP-GiST** (Space-Partitioned GiST) : Pour des structures spatiales sp√©cifiques

---

## 1. Pourquoi Avons-nous Besoin d'Index Spatiaux ?

### Le Probl√®me Sans Index

Consid√©rons une table avec 1 million de restaurants :

```sql
-- Sans index : SCAN S√âQUENTIEL (tr√®s lent)
SELECT nom, adresse
FROM restaurants
WHERE ST_DWithin(
    position::geography,
    ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326)::geography,
    1000  -- 1 km
);
-- Temps d'ex√©cution : 30-60 secondes (scan de TOUTE la table)
```

PostgreSQL doit :
1. Parcourir **TOUS** les restaurants un par un
2. Calculer la distance pour **CHACUN**
3. Filtrer ceux qui sont √† moins de 1 km

**Co√ªt** : O(n) o√π n = nombre total de restaurants

### La Solution : Index Spatial

Avec un index spatial :

```sql
-- Cr√©er l'index
CREATE INDEX idx_restaurants_position
ON restaurants
USING GIST(position);

-- M√™me requ√™te : utilise l'INDEX (ultra rapide)
SELECT nom, adresse
FROM restaurants
WHERE ST_DWithin(
    position::geography,
    ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326)::geography,
    1000
);
-- Temps d'ex√©cution : 5-50 millisecondes (scan d'une fraction de la table)
```

**Co√ªt** : O(log n) - gain de performance de 100√ó √† 1000√ó

---

## 2. L'Index GiST (Generalized Search Tree)

### Qu'est-ce que GiST ?

**GiST** (Generalized Search Tree) est une structure d'indexation g√©n√©rique et extensible. Dans le contexte de PostGIS, il est utilis√© pour organiser efficacement les donn√©es spatiales.

**Caract√©ristiques principales** :
- Structure d'**arbre √©quilibr√©**
- Bas√© sur les **bo√Ætes englobantes** (bounding boxes)
- Supporte **toutes les g√©om√©tries** PostGIS (Point, LineString, Polygon, etc.)
- **Polyvalent** et performant pour la plupart des cas d'usage

### Comment Fonctionne GiST ?

GiST organise l'espace g√©ographique de mani√®re hi√©rarchique en utilisant des **rectangles englobants** (bounding boxes ou MBR - Minimum Bounding Rectangle).

#### Principe de la Bo√Æte Englobante

Chaque g√©om√©trie est entour√©e d'un rectangle qui la contient compl√®tement :

```
Point :                 LineString :            Polygon :

    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  ‚Ä¢  ‚îÇ               ‚îÇ    /‚îÄ\   ‚îÇ           ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îÇ   /   \  ‚îÇ           ‚îÇ  ‚îÇ    ‚îÇ  ‚îÇ
  Bounding Box            ‚îÇ  /     \ ‚îÇ           ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         Bounding Box           Bounding Box
```

#### Structure Hi√©rarchique (Arbre)

GiST organise ces bo√Ætes en arbre :

```
                        Niveau 0 (Racine)
                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                     ‚îÇ   France enti√®re ‚îÇ
                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ               ‚îÇ               ‚îÇ
         Niveau 1        Niveau 1        Niveau 1
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ √éle-de-  ‚îÇ     ‚îÇ  Rh√¥ne-  ‚îÇ     ‚îÇ Provence ‚îÇ
      ‚îÇ  France  ‚îÇ     ‚îÇ  Alpes   ‚îÇ     ‚îÇ   PACA   ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ                ‚îÇ                 ‚îÇ
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ    ‚îÇ    ‚îÇ      ‚îÇ    ‚îÇ    ‚îÇ      ‚îÇ    ‚îÇ    ‚îÇ
   Paris Lyon Rouen Lyon  Grenoble  Marseille Nice Toulon
   [‚Ä¢] [‚Ä¢] [‚Ä¢]   [‚Ä¢]    [‚Ä¢]        [‚Ä¢]      [‚Ä¢]  [‚Ä¢]

   Niveau 2 (Feuilles) : G√©om√©tries r√©elles
```

#### Recherche avec GiST

Lorsque vous cherchez des points dans une zone :

1. **Niveau racine** : V√©rifier quelles r√©gions intersectent la zone de recherche
2. **Descendre** uniquement dans les branches pertinentes
3. **Niveau feuille** : V√©rifier les g√©om√©tries r√©elles

**Exemple** : Chercher des restaurants pr√®s de Paris
- ‚ùå Ignore les branches "Rh√¥ne-Alpes" et "PACA"
- ‚úÖ Descend uniquement dans "√éle-de-France" ‚Üí Paris
- R√©sultat : 99% des donn√©es ignor√©es sans calcul !

### Cr√©er un Index GiST

#### Syntaxe de Base

```sql
-- Index GiST sur une colonne de g√©om√©trie
CREATE INDEX nom_index
ON nom_table
USING GIST(colonne_geometrie);
```

#### Exemples Pratiques

```sql
-- 1. Index sur une table de points (restaurants)
CREATE INDEX idx_restaurants_position
ON restaurants
USING GIST(position);

-- 2. Index sur une table de polygones (arrondissements)
CREATE INDEX idx_arrondissements_zone
ON arrondissements
USING GIST(zone);

-- 3. Index sur une table de lignes (routes)
CREATE INDEX idx_routes_trace
ON routes
USING GIST(trace);

-- 4. Index avec FILLFACTOR personnalis√© (pour donn√©es √©volutives)
CREATE INDEX idx_lieux_position
ON lieux
USING GIST(position)
WITH (fillfactor = 90);
-- fillfactor = 90 laisse 10% d'espace libre pour les futures insertions
```

### Op√©rations Acc√©l√©r√©es par GiST

L'index GiST am√©liore la performance des op√©rateurs spatiaux suivants :

| Op√©rateur/Fonction | Description | Exemple |
|-------------------|-------------|---------|
| `&&` | Bo√Ætes englobantes se chevauchent | `geom1 && geom2` |
| `ST_Intersects()` | G√©om√©tries se croisent | `ST_Intersects(a, b)` |
| `ST_Contains()` | Une g√©om√©trie en contient une autre | `ST_Contains(polygon, point)` |
| `ST_Within()` | Une g√©om√©trie est dans une autre | `ST_Within(point, polygon)` |
| `ST_DWithin()` | Distance inf√©rieure √† | `ST_DWithin(a, b, 1000)` |
| `ST_Covers()` | Une g√©om√©trie couvre une autre | `ST_Covers(a, b)` |
| `ST_CoveredBy()` | Une g√©om√©trie est couverte par | `ST_CoveredBy(a, b)` |
| `ST_Overlaps()` | G√©om√©tries se chevauchent | `ST_Overlaps(a, b)` |

#### Exemple : Requ√™te Optimis√©e

```sql
-- SANS index : scan s√©quentiel
EXPLAIN ANALYZE
SELECT r.nom
FROM restaurants r
JOIN arrondissements a ON ST_Contains(a.zone, r.position)
WHERE a.nom = '5e arrondissement';

-- Plan d'ex√©cution SANS index :
-- Seq Scan on restaurants (cost=0..10000 rows=50000)
-- Temps : 250ms

-- AVEC index : scan d'index
EXPLAIN ANALYZE
SELECT r.nom
FROM restaurants r
JOIN arrondissements a ON ST_Contains(a.zone, r.position)
WHERE a.nom = '5e arrondissement';

-- Plan d'ex√©cution AVEC index :
-- Index Scan using idx_restaurants_position (cost=0..150 rows=50)
-- Temps : 5ms
-- ‚ö° Am√©lioration : 50√ó plus rapide !
```

### Maintenance des Index GiST

#### Surveillance de la Taille

```sql
-- Taille des index GiST
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS taille
FROM pg_stat_user_indexes
WHERE indexrelname LIKE 'idx_%position%'
ORDER BY pg_relation_size(indexrelid) DESC;
```

#### Statistiques d'Utilisation

```sql
-- Statistiques d'utilisation des index
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan AS nombre_scans,
    idx_tup_read AS tuples_lus,
    idx_tup_fetch AS tuples_recuperes
FROM pg_stat_user_indexes
WHERE indexrelname LIKE 'idx_%position%'
ORDER BY idx_scan DESC;
```

#### Reconstruction (REINDEX)

Parfois, un index devient "gonfl√©" (bloat) apr√®s de nombreuses modifications. Il faut le reconstruire :

```sql
-- Reconstruire un index sp√©cifique
REINDEX INDEX idx_restaurants_position;

-- Reconstruire tous les index d'une table
REINDEX TABLE restaurants;

-- Version non bloquante (PostgreSQL 12+)
REINDEX INDEX CONCURRENTLY idx_restaurants_position;
```

**Quand reconstruire ?**
- Apr√®s des modifications massives (millions d'UPDATE/DELETE)
- Si les performances se d√©gradent
- En cas de bloat important (>50% de l'espace est inutilis√©)

---

## 3. L'Index SP-GiST (Space-Partitioned GiST)

### Qu'est-ce que SP-GiST ?

**SP-GiST** (Space-Partitioned GiST) est une variante de GiST qui utilise un partitionnement de l'espace plut√¥t que des bo√Ætes englobantes.

**Diff√©rences avec GiST** :

| Aspect | GiST | SP-GiST |
|--------|------|---------|
| Partitionnement | Bo√Ætes englobantes qui se chevauchent | Partitions qui ne se chevauchent PAS |
| Structure | Arbre √©quilibr√© | Arbre potentiellement non √©quilibr√© |
| Cas d'usage | G√©n√©ral (toutes g√©om√©tries) | Sp√©cialis√© (points, quadtrees) |
| Performance Points | Bonne | Excellente |
| Performance Polygones | Excellente | Moins bonne |

### Comment Fonctionne SP-GiST ?

SP-GiST utilise un **partitionnement r√©cursif de l'espace**, typiquement avec une structure **Quadtree** (arbre quaternaire).

#### Principe du Quadtree

L'espace est divis√© r√©cursivement en 4 quadrants :

```
Niveau 0 : Espace initial
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 ‚îÇ
‚îÇ                 ‚îÇ
‚îÇ        ‚Ä¢        ‚îÇ  ‚Üê Point √† indexer
‚îÇ                 ‚îÇ
‚îÇ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Niveau 1 : Division en 4 quadrants
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   NW   ‚îÇ   NE   ‚îÇ
‚îÇ        ‚îÇ        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   SW   ‚îÇ‚Ä¢  SE   ‚îÇ  ‚Üê Point dans quadrant SE
‚îÇ        ‚îÇ        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Niveau 2 : Subdivision du quadrant SE
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   NW   ‚îÇ   NE   ‚îÇ
‚îÇ        ‚îÇ        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚îÄ‚î§
‚îÇ   SW   ‚îÇNW ‚îÇ‚Ä¢‚îÇNE‚îÇ  ‚Üê Point dans SE.NE.SW
‚îÇ        ‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îº‚îÄ‚îÄ‚î§
‚îÇ        ‚îÇSW ‚îÇ ‚îÇSE‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚îÄ‚îò
```

**Avantages du Quadtree** :
- Partitions **disjointes** (pas de chevauchement)
- Excellent pour les **requ√™tes de points**
- Bon pour les **donn√©es tr√®s denses** dans certaines zones

### Cr√©er un Index SP-GiST

#### Syntaxe de Base

```sql
-- Index SP-GiST sur une colonne de g√©om√©trie
CREATE INDEX nom_index
ON nom_table
USING SPGIST(colonne_geometrie);
```

#### Exemples Pratiques

```sql
-- 1. Index SP-GiST sur des points (capteurs IoT)
CREATE INDEX idx_capteurs_position
ON capteurs_iot
USING SPGIST(position);

-- 2. Index SP-GiST sur des points GPS
CREATE INDEX idx_traces_gps_point
ON traces_gps
USING SPGIST(point_gps);

-- 3. Index SP-GiST avec strat√©gie Quadtree explicite
CREATE INDEX idx_marqueurs_position
ON marqueurs
USING SPGIST(position quad_point_ops);
-- quad_point_ops = strat√©gie quadtree pour les points 2D
```

### Quand Utiliser SP-GiST vs GiST ?

#### Utiliser SP-GiST pour :

‚úÖ **Donn√©es exclusivement de type Point**
```sql
-- Table de capteurs (uniquement des points)
CREATE TABLE capteurs (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    position GEOMETRY(Point, 4326)
);

-- SP-GiST optimal pour cette table
CREATE INDEX idx_capteurs_position
ON capteurs
USING SPGIST(position);
```

‚úÖ **Requ√™tes de type "point dans une zone"**
```sql
-- Trouver tous les capteurs dans un rectangle
SELECT * FROM capteurs
WHERE position && ST_MakeEnvelope(2.3, 48.8, 2.4, 48.9, 4326);
-- SP-GiST excellent pour ce type de requ√™te
```

‚úÖ **Donn√©es avec distribution spatiale in√©gale**
- Beaucoup de points concentr√©s dans certaines zones
- Peu de points ailleurs
- SP-GiST s'adapte mieux √† cette h√©t√©rog√©n√©it√©

#### Utiliser GiST pour :

‚úÖ **G√©om√©tries mixtes ou complexes**
```sql
-- Table avec des polygones
CREATE TABLE zones (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    geometrie GEOMETRY(Polygon, 4326)  -- Polygones
);

-- GiST pr√©f√©rable pour les polygones
CREATE INDEX idx_zones_geometrie
ON zones
USING GIST(geometrie);
```

‚úÖ **Requ√™tes complexes (intersections, contenance)**
```sql
-- Trouver les zones qui intersectent un polygone
SELECT * FROM zones
WHERE ST_Intersects(geometrie, autre_polygone);
-- GiST plus efficace pour ces op√©rations
```

‚úÖ **Cas g√©n√©ral (par d√©faut)**
- Si vous h√©sitez, **choisissez GiST**
- C'est l'index "par d√©faut" et le plus polyvalent

### Comparaison de Performance

#### Benchmark : Table de 1 Million de Points

```sql
-- Cr√©er une table de test avec 1M de points
CREATE TABLE points_test (
    id SERIAL PRIMARY KEY,
    position GEOMETRY(Point, 4326)
);

-- Ins√©rer 1 million de points al√©atoires en France
INSERT INTO points_test (position)
SELECT ST_SetSRID(
    ST_MakePoint(
        -5 + random() * 15,  -- Longitude : -5 √† 10
        41 + random() * 10   -- Latitude : 41 √† 51
    ),
    4326
)
FROM generate_series(1, 1000000);

-- Test 1 : Index GiST
CREATE INDEX idx_gist ON points_test USING GIST(position);
ANALYZE points_test;

EXPLAIN ANALYZE
SELECT COUNT(*) FROM points_test
WHERE ST_DWithin(
    position::geography,
    ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326)::geography,
    5000
);
-- R√©sultat GiST : ~15ms, 1234 lignes scann√©es

-- Test 2 : Index SP-GiST
DROP INDEX idx_gist;
CREATE INDEX idx_spgist ON points_test USING SPGIST(position);
ANALYZE points_test;

EXPLAIN ANALYZE
SELECT COUNT(*) FROM points_test
WHERE ST_DWithin(
    position::geography,
    ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326)::geography,
    5000
);
-- R√©sultat SP-GiST : ~12ms, 1198 lignes scann√©es
-- ‚ö° SP-GiST l√©g√®rement plus rapide pour cette requ√™te sur points
```

**R√©sultats typiques** :
- **Points uniquement** : SP-GiST 10-20% plus rapide
- **G√©om√©tries mixtes** : GiST 20-50% plus rapide
- **Insertion/Mise √† jour** : Performance comparable

---

## 4. Optimisations Avanc√©es

### Index sur Sous-Ensemble (Index Partiel)

Cr√©er un index uniquement sur une partie des donn√©es :

```sql
-- Index uniquement sur les restaurants actifs
CREATE INDEX idx_restaurants_actifs_position
ON restaurants
USING GIST(position)
WHERE actif = true;

-- Avantages : index plus petit, plus rapide, moins de maintenance
```

### Index avec INCLUDE (Covering Index)

Ajouter des colonnes suppl√©mentaires √† l'index pour √©viter d'acc√©der √† la table :

```sql
-- Index incluant le nom du restaurant (PostgreSQL 11+)
CREATE INDEX idx_restaurants_position_covering
ON restaurants
USING GIST(position)
INCLUDE (nom, adresse);

-- La requ√™te peut tout r√©cup√©rer depuis l'index (plus rapide)
SELECT nom, adresse
FROM restaurants
WHERE ST_DWithin(position::geography, point_ref::geography, 1000);
```

### Index Multi-Colonnes (Rare avec Spatial)

Combiner une colonne spatiale avec une autre colonne :

```sql
-- Index combin√© (spatial + attribut)
-- ATTENTION : rarement utile en pratique avec spatial
CREATE INDEX idx_restaurants_position_type
ON restaurants
USING GIST(position, type);
```

### Tuning du FILLFACTOR

Le param√®tre `fillfactor` contr√¥le le taux de remplissage des pages d'index :

```sql
-- fillfactor = 100 (d√©faut GiST) : pages pleines
-- Bon pour : donn√©es statiques ou en lecture seule
CREATE INDEX idx_static
ON table_statique
USING GIST(geom)
WITH (fillfactor = 100);

-- fillfactor = 90 : laisse 10% d'espace libre
-- Bon pour : donn√©es fr√©quemment mises √† jour
CREATE INDEX idx_dynamic
ON table_dynamique
USING GIST(geom)
WITH (fillfactor = 90);

-- fillfactor = 70 : laisse 30% d'espace libre
-- Bon pour : insertions massives fr√©quentes
CREATE INDEX idx_high_write
ON table_insertion_massive
USING GIST(geom)
WITH (fillfactor = 70);
```

---

## 5. V√©rifier l'Utilisation des Index

### Avec EXPLAIN ANALYZE

```sql
-- V√©rifier si l'index est utilis√©
EXPLAIN (ANALYZE, BUFFERS)
SELECT nom
FROM restaurants
WHERE ST_DWithin(
    position::geography,
    ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326)::geography,
    1000
);

-- Sortie attendue avec index :
-- Index Scan using idx_restaurants_position on restaurants
--   Index Cond: (position && '...'::geometry)
--   Filter: ST_DWithin(...)
--   Buffers: shared hit=45
-- Planning Time: 0.123 ms
-- Execution Time: 3.456 ms

-- Sortie SANS index (mauvais) :
-- Seq Scan on restaurants
--   Filter: ST_DWithin(...)
--   Rows Removed by Filter: 999950
--   Buffers: shared hit=12543
-- Planning Time: 0.089 ms
-- Execution Time: 245.678 ms
```

### Forcer l'Utilisation d'un Index

Parfois, le planificateur ne choisit pas l'index. Vous pouvez le forcer :

```sql
-- D√©sactiver le scan s√©quentiel (forcer l'index)
SET enable_seqscan = off;

-- Ex√©cuter la requ√™te
SELECT nom FROM restaurants WHERE ...;

-- R√©activer (important !)
SET enable_seqscan = on;
```

**‚ö†Ô∏è Attention** : Forcer un index n'est g√©n√©ralement pas une bonne id√©e. Si PostgreSQL ne l'utilise pas, c'est souvent parce que le scan s√©quentiel est vraiment plus rapide.

### Statistiques d'Index

```sql
-- V√©rifier les statistiques des index spatiaux
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan AS scans_index,
    idx_tup_read AS tuples_lus,
    idx_tup_fetch AS tuples_extraits,
    pg_size_pretty(pg_relation_size(indexrelid)) AS taille_index
FROM pg_stat_user_indexes
WHERE indexrelname LIKE 'idx_%'
ORDER BY idx_scan DESC;

-- Index inutilis√©s (candidats √† la suppression)
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS taille
FROM pg_stat_user_indexes
WHERE idx_scan = 0
  AND indexrelname NOT LIKE 'pg_%'
ORDER BY pg_relation_size(indexrelid) DESC;
```

---

## 6. Probl√®mes Courants et Solutions

### Probl√®me 1 : L'Index N'est Pas Utilis√©

**Sympt√¥me** : EXPLAIN montre un Seq Scan au lieu d'un Index Scan

**Causes possibles** :

1. **SRID manquant ou diff√©rent**
```sql
-- ‚ùå MAUVAIS : SRID non d√©fini
WHERE ST_DWithin(position, ST_MakePoint(2.3, 48.8), 1000);

-- ‚úÖ BON : SRID explicite et coh√©rent
WHERE ST_DWithin(
    position,
    ST_SetSRID(ST_MakePoint(2.3, 48.8), 4326),
    1000
);
```

2. **Statistiques obsol√®tes**
```sql
-- Mettre √† jour les statistiques
ANALYZE restaurants;
```

3. **Table trop petite**
```sql
-- Si la table a moins de ~1000 lignes,
-- un scan s√©quentiel peut √™tre plus rapide que l'index
-- C'est normal !
```

4. **Requ√™te retourne trop de lignes**
```sql
-- Si la requ√™te retourne >10-20% de la table,
-- PostgreSQL pr√©f√®re un scan s√©quentiel
-- Solution : affiner la requ√™te ou accepter le scan s√©quentiel
```

### Probl√®me 2 : Performances D√©grad√©es Apr√®s Mises √† Jour

**Sympt√¥me** : L'index √©tait rapide, il devient lent progressivement

**Cause** : Bloat (gonflement) de l'index apr√®s de nombreuses modifications

**Solution** :
```sql
-- 1. V√©rifier le bloat
SELECT
    indexrelname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS taille_actuelle
FROM pg_stat_user_indexes
WHERE indexrelname = 'idx_restaurants_position';

-- 2. Reconstruire l'index
REINDEX INDEX CONCURRENTLY idx_restaurants_position;

-- 3. Analyser la table
ANALYZE restaurants;
```

### Probl√®me 3 : Index Trop Volumineux

**Sympt√¥me** : L'index prend plus de place que la table elle-m√™me

**Causes et solutions** :

1. **Trop de colonnes INCLUDE**
```sql
-- ‚ùå MAUVAIS : trop de colonnes
CREATE INDEX idx_bad
ON restaurants
USING GIST(position)
INCLUDE (nom, adresse, telephone, email, description, ...);

-- ‚úÖ BON : uniquement les colonnes essentielles
CREATE INDEX idx_good
ON restaurants
USING GIST(position)
INCLUDE (nom);
```

2. **Index sur toutes les lignes alors qu'un sous-ensemble suffit**
```sql
-- ‚úÖ BON : index partiel (uniquement restaurants actifs)
CREATE INDEX idx_restaurants_actifs
ON restaurants
USING GIST(position)
WHERE actif = true;
```

### Probl√®me 4 : Insertions Lentes

**Sympt√¥me** : Les INSERT/UPDATE sont devenus tr√®s lents

**Cause** : Maintien des index lors des √©critures

**Solutions** :

1. **Insertions massives : D√©sactiver temporairement les index**
```sql
-- Sauvegarder la d√©finition de l'index
\d+ restaurants

-- Supprimer l'index
DROP INDEX idx_restaurants_position;

-- Faire les insertions massives
INSERT INTO restaurants SELECT ...;

-- Recr√©er l'index
CREATE INDEX idx_restaurants_position
ON restaurants
USING GIST(position);

-- Analyser
ANALYZE restaurants;
```

2. **Ajuster le FILLFACTOR pour des √©critures fr√©quentes**
```sql
-- Laisser plus d'espace libre
CREATE INDEX idx_restaurants_position
ON restaurants
USING GIST(position)
WITH (fillfactor = 70);
```

---

## 7. Bonnes Pratiques

### ‚úÖ Cr√©er l'Index APR√àS l'Import de Donn√©es

```sql
-- 1. Cr√©er la table
CREATE TABLE restaurants (...);

-- 2. Importer les donn√©es (COPY, INSERT massif)
COPY restaurants FROM '/tmp/restaurants.csv' CSV HEADER;

-- 3. PUIS cr√©er l'index (beaucoup plus rapide)
CREATE INDEX idx_restaurants_position
ON restaurants
USING GIST(position);

-- 4. Analyser
ANALYZE restaurants;
```

**Raison** : Cr√©er l'index apr√®s l'import est ~10√ó plus rapide que de l'avoir pendant l'import.

### ‚úÖ Toujours Analyser Apr√®s Cr√©ation d'Index

```sql
CREATE INDEX idx_restaurants_position ON restaurants USING GIST(position);
ANALYZE restaurants;  -- ‚Üê IMPORTANT !
```

**Raison** : ANALYZE met √† jour les statistiques que le planificateur utilise pour choisir d'utiliser l'index.

### ‚úÖ Un Seul Index Spatial par Table (G√©n√©ralement)

```sql
-- ‚ùå √âVITER : plusieurs index spatiaux sur la m√™me colonne
CREATE INDEX idx_gist ON restaurants USING GIST(position);
CREATE INDEX idx_spgist ON restaurants USING SPGIST(position);
-- Gaspillage d'espace et de temps de maintenance

-- ‚úÖ BON : un seul index, bien choisi
CREATE INDEX idx_restaurants_position ON restaurants USING GIST(position);
```

### ‚úÖ Pr√©f√©rer GiST par D√©faut

```sql
-- Sauf cas sp√©cifique (points uniquement), utiliser GiST
CREATE INDEX idx_default ON ma_table USING GIST(geom);
```

### ‚úÖ Nommer les Index de Mani√®re Coh√©rente

```sql
-- Convention recommand√©e : idx_<table>_<colonne>_<type>
CREATE INDEX idx_restaurants_position_gist
ON restaurants
USING GIST(position);

CREATE INDEX idx_zones_geometrie_gist
ON zones
USING GIST(geometrie);
```

### ‚úÖ Surveiller la Sant√© des Index

```sql
-- Script de monitoring mensuel
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexrelid)) AS taille,
    CASE
        WHEN idx_scan = 0 THEN '‚ö†Ô∏è Jamais utilis√©'
        WHEN idx_scan < 10 THEN '‚ö†Ô∏è Rarement utilis√©'
        ELSE '‚úÖ Utilis√© r√©guli√®rement'
    END AS statut
FROM pg_stat_user_indexes
WHERE indexrelname LIKE 'idx_%gist%'
   OR indexrelname LIKE 'idx_%spgist%'
ORDER BY pg_relation_size(indexrelid) DESC;
```

---

## 8. Cas d'Usage R√©els

### Cas 1 : Application de Livraison (Type Uber Eats)

**Besoin** : Trouver les restaurants dans un rayon de 3 km autour d'un client

```sql
-- Table restaurants
CREATE TABLE restaurants (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    cuisine VARCHAR(50),
    position GEOMETRY(Point, 4326),
    actif BOOLEAN DEFAULT true
);

-- Index spatial optimis√© (partiel : uniquement restaurants actifs)
CREATE INDEX idx_restaurants_actifs_position
ON restaurants
USING GIST(position)
WHERE actif = true;

-- Requ√™te de recherche
SELECT
    id,
    nom,
    cuisine,
    ST_Distance(position::geography, client_position::geography) AS distance_m
FROM restaurants
WHERE actif = true
  AND ST_DWithin(
      position::geography,
      ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326)::geography,
      3000  -- 3 km
  )
ORDER BY distance_m
LIMIT 20;

-- Performance : <10ms pour 1M de restaurants
```

### Cas 2 : Syst√®me de Tracking GPS (Flottes de V√©hicules)

**Besoin** : Stocker et requ√™ter des millions de positions GPS

```sql
-- Table de positions (tr√®s volumineuse)
CREATE TABLE positions_gps (
    id BIGSERIAL PRIMARY KEY,
    vehicule_id INTEGER,
    timestamp TIMESTAMPTZ,
    position GEOMETRY(Point, 4326),
    vitesse NUMERIC(5, 2)
);

-- Index spatial SP-GiST (optimal pour points)
CREATE INDEX idx_positions_gps_position
ON positions_gps
USING SPGIST(position);

-- Index composite pour requ√™tes temporelles + spatiales
CREATE INDEX idx_positions_gps_timestamp
ON positions_gps(vehicule_id, timestamp DESC);

-- Requ√™te : Position des v√©hicules dans une zone √† un moment donn√©
SELECT
    vehicule_id,
    timestamp,
    ST_AsText(position) AS position,
    vitesse
FROM positions_gps
WHERE timestamp > NOW() - INTERVAL '1 hour'
  AND position && ST_MakeEnvelope(2.3, 48.8, 2.4, 48.9, 4326)
ORDER BY timestamp DESC;
```

### Cas 3 : Analyse de Zones G√©ographiques (SIG)

**Besoin** : Requ√™tes d'intersection entre polygones (quartiers, parcelles)

```sql
-- Table de parcelles cadastrales
CREATE TABLE parcelles (
    id SERIAL PRIMARY KEY,
    reference VARCHAR(50),
    proprietaire VARCHAR(100),
    superficie NUMERIC(10, 2),
    geometrie GEOMETRY(Polygon, 2154)  -- Lambert 93 (France)
);

-- Index GiST (meilleur pour polygones)
CREATE INDEX idx_parcelles_geometrie
ON parcelles
USING GIST(geometrie);

-- Requ√™te : Parcelles intersectant une zone d'urbanisme
SELECT
    p.reference,
    p.proprietaire,
    ST_Area(ST_Intersection(p.geometrie, zone.geometrie)) AS surface_impactee
FROM parcelles p
JOIN zones_urbanisme zone ON ST_Intersects(p.geometrie, zone.geometrie)
WHERE zone.type = 'Zone constructible'
ORDER BY surface_impactee DESC;
```

---

## 9. R√©sum√© : GiST vs SP-GiST

| Crit√®re | GiST | SP-GiST |
|---------|------|---------|
| **Type de donn√©es** | Tous types g√©om√©triques | Principalement Points |
| **Structure** | Arbre avec bo√Ætes englobantes chevauchantes | Quadtree avec partitions disjointes |
| **Performance Points** | ‚≠ê‚≠ê‚≠ê‚≠ê Tr√®s bonne | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellente |
| **Performance Polygones** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellente | ‚≠ê‚≠ê‚≠ê Acceptable |
| **Op√©rations spatiales** | Toutes | Limit√©es |
| **√âquilibrage** | Automatique | Peut √™tre d√©s√©quilibr√© |
| **Taille de l'index** | Moyenne | L√©g√®rement plus petite |
| **Maintenance** | Standard | Standard |
| **Recommandation** | **Index par d√©faut** | Points uniquement + haute densit√© |

---

## 10. Checklist de Mise en Place

### Avant de Cr√©er un Index Spatial

- [ ] La table contient > 1000 lignes (sinon l'index est inutile)
- [ ] Les requ√™tes spatiales sont lentes (v√©rifier avec EXPLAIN)
- [ ] Le SRID est d√©fini correctement sur toutes les g√©om√©tries
- [ ] Les donn√©es sont propres (g√©om√©tries valides)

### Cr√©ation de l'Index

- [ ] Choisir le bon type (GiST par d√©faut, SP-GiST pour points uniquement)
- [ ] Nommer l'index de mani√®re coh√©rente
- [ ] Consid√©rer un index partiel si applicable
- [ ] D√©finir le FILLFACTOR si donn√©es fr√©quemment modifi√©es
- [ ] Ex√©cuter ANALYZE apr√®s cr√©ation

### Apr√®s Cr√©ation

- [ ] V√©rifier avec EXPLAIN que l'index est utilis√©
- [ ] Mesurer les performances (avant/apr√®s)
- [ ] Surveiller la taille de l'index
- [ ] Planifier la maintenance (REINDEX si n√©cessaire)
- [ ] Documenter la strat√©gie d'indexation

---

## Conclusion

Les index spatiaux **GiST** et **SP-GiST** sont essentiels pour obtenir de bonnes performances avec PostGIS. Ils transforment des requ√™tes de plusieurs secondes en quelques millisecondes.

**Points cl√©s √† retenir** :

1. **GiST** est l'index spatial par excellence :
   - Polyvalent (tous types de g√©om√©tries)
   - Performant pour la plupart des cas
   - **√Ä utiliser par d√©faut**

2. **SP-GiST** est sp√©cialis√© :
   - Optimal pour les **points uniquement**
   - Structure Quadtree
   - Meilleur avec distributions spatiales in√©gales

3. **Toujours** :
   - Cr√©er l'index APR√àS l'import de donn√©es
   - Ex√©cuter ANALYZE apr√®s cr√©ation
   - V√©rifier avec EXPLAIN
   - Surveiller les performances

4. **Index = Trade-off** :
   - Acc√©l√®re les lectures (SELECT)
   - Ralentit les √©critures (INSERT/UPDATE)
   - Occupe de l'espace disque
   - N√©cessite de la maintenance

**R√®gle d'or** : Un index bien plac√© peut am√©liorer les performances de 100√ó √† 1000√ó. Mais un index mal plac√© gaspille des ressources. Mesurez toujours l'impact r√©el !

---

**Ressources compl√©mentaires** :
- Documentation PostGIS sur les index : https://postgis.net/docs/using_postgis_dbmanagement.html#idxing
- PostgreSQL GiST : https://www.postgresql.org/docs/current/gist.html
- PostgreSQL SP-GiST : https://www.postgresql.org/docs/current/spgist.html
- Comparaison des index PostgreSQL : https://www.postgresql.org/docs/current/indexes-types.html

‚è≠Ô∏è [Fonctions spatiales (ST_Distance, ST_Intersects)](/18-extensions-et-integrations/02.3-fonctions-spatiales.md)
