ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 18.7.4. HypoPG : Indexation HypothÃ©tique dans PostgreSQL

## Introduction

**HypoPG** (Hypothetical Indexes for PostgreSQL) est une extension PostgreSQL qui permet de crÃ©er des **index virtuels** (hypothÃ©tiques) pour tester leur impact sur les plans d'exÃ©cution des requÃªtes, **sans rÃ©ellement crÃ©er ces index** sur le disque.

### Le ProblÃ¨me : Tester des Index est CoÃ»teux

Dans PostgreSQL, crÃ©er un index est une opÃ©ration qui :

- âŒ **Prend du temps** : De quelques secondes Ã  plusieurs heures selon la taille de la table
- âŒ **Bloque les Ã©critures** : Sauf avec `CONCURRENT` (plus lent)
- âŒ **Consomme de l'espace** : L'index occupe de l'espace disque
- âŒ **Impacte les performances** : Les Ã©critures (INSERT/UPDATE/DELETE) sont ralenties
- âŒ **Peut Ãªtre inutile** : Si l'index n'amÃ©liore pas vraiment les performances

**ScÃ©nario typique** :

```
DÃ©veloppeur : "Cette requÃªte est lente. Je vais crÃ©er un index sur la colonne X."
â†“
CREATE INDEX ... (30 minutes sur une grande table)
â†“
EXPLAIN ANALYZE ... (vÃ©rification)
â†“
RÃ©sultat : L'index n'est pas utilisÃ© par le planificateur ! ğŸ˜±
â†“
DROP INDEX ... (encore 10 minutes)
â†“
Recommencer avec un autre index...
```

**Ce processus est long, risquÃ© et coÃ»teux, surtout en production.**

### La Solution : HypoPG

HypoPG permet de :

- âœ… **CrÃ©er des index virtuels** : En quelques millisecondes
- âœ… **Tester leur impact** : Le planificateur les voit comme de vrais index
- âœ… **ZÃ©ro impact disque** : Aucun espace consommÃ©
- âœ… **ZÃ©ro impact performance** : Pas de ralentissement des Ã©critures
- âœ… **Tester plusieurs scÃ©narios** : CrÃ©er/supprimer instantanÃ©ment
- âœ… **Valider avant crÃ©ation** : CrÃ©er seulement les index vraiment utiles

**Avec HypoPG** :

```
DÃ©veloppeur : "Cette requÃªte est lente. Je vais TESTER un index avec HypoPG."
â†“
SELECT hypopg_create_index(...) (instantanÃ©)
â†“
EXPLAIN ... (le planificateur voit l'index virtuel)
â†“
RÃ©sultat : L'index n'est pas utilisÃ© â†’ Pas besoin de le crÃ©er ! âœ…
â†“
Ou : L'index amÃ©liore le plan â†’ Le crÃ©er rÃ©ellement
```

### Analogie Simple

Imaginez que vous voulez rÃ©organiser les meubles dans votre maison :

- **Sans HypoPG** : Vous dÃ©placez physiquement tous les meubles (lourd, fatiguant), puis vous rÃ©alisez que Ã§a ne marche pas. Vous devez tout remettre et recommencer.

- **Avec HypoPG** : Vous utilisez un logiciel 3D pour tester diffÃ©rentes configurations virtuellement, puis vous ne dÃ©placez physiquement les meubles qu'une seule fois, quand vous Ãªtes sÃ»r de la configuration optimale.

---

## Concepts Fondamentaux

### Qu'est-ce qu'un Index HypothÃ©tique ?

Un **index hypothÃ©tique** est une structure de donnÃ©es **virtuelle** qui :

1. **N'existe que dans les mÃ©tadonnÃ©es** : StockÃ© en mÃ©moire, pas sur disque
2. **Est visible par le planificateur** : PostgreSQL le considÃ¨re dans ses calculs de coÃ»t
3. **N'est PAS utilisable pour les requÃªtes rÃ©elles** : Seulement pour EXPLAIN, pas pour SELECT
4. **DisparaÃ®t Ã  la dÃ©connexion** : Les index virtuels sont liÃ©s Ã  la session

**SchÃ©ma conceptuel** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Session PostgreSQL                    â”‚
â”‚                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Tables RÃ©elles                           â”‚  â”‚
â”‚  â”‚  - customers (1M lignes)                  â”‚  â”‚
â”‚  â”‚  - orders (10M lignes)                    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚              â†“                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Index RÃ©els (sur disque)                 â”‚  â”‚
â”‚  â”‚  - idx_customers_pk                       â”‚  â”‚
â”‚  â”‚  - idx_orders_customer_id                 â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚              +                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Index HypothÃ©tiques (en mÃ©moire)         â”‚  â”‚
â”‚  â”‚  - hypoidx_1: orders(order_date)          â”‚  â”‚
â”‚  â”‚  - hypoidx_2: orders(status, amount)      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Planificateur de RequÃªtes                â”‚  â”‚
â”‚  â”‚  (voit les index rÃ©els ET hypothÃ©tiques)  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Comment le Planificateur Voit les Index HypothÃ©tiques

Le planificateur PostgreSQL utilise des **statistiques** pour estimer le coÃ»t des diffÃ©rents plans d'exÃ©cution :

- **Nombre de lignes** dans la table
- **Taille des donnÃ©es** (pages, tuples)
- **SÃ©lectivitÃ©** des colonnes (distribution des valeurs)
- **Index disponibles** et leur coÃ»t d'utilisation

HypoPG **injecte des mÃ©tadonnÃ©es fictives** qui font croire au planificateur qu'un index existe rÃ©ellement :

```
Planificateur : "Je dois exÃ©cuter SELECT * FROM orders WHERE order_date = '2025-01-15'"
                â†“
                "Quels sont mes options ?"
                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Option 1: Seq Scan (scan sÃ©quentiel de toute la table)        â”‚
â”‚ CoÃ»t estimÃ©: 100,000                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Option 2: Index Scan sur hypoidx_1 (order_date)               â”‚
â”‚ CoÃ»t estimÃ©: 150  â† BIEN MOINS CHER !                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
                "Je choisis l'Option 2"
```

**Important** : Le planificateur peut voir et choisir l'index hypothÃ©tique dans EXPLAIN, mais si vous essayez d'exÃ©cuter rÃ©ellement la requÃªte (SELECT), elle Ã©chouera car l'index n'existe pas physiquement.

---

## Installation et Configuration

### PrÃ©requis

- **PostgreSQL 9.2+** (idÃ©alement PostgreSQL 18)
- **Droits superutilisateur** : Pour l'installation initiale
- **Extension disponible** : Selon votre distribution PostgreSQL

### Processus d'Installation (ThÃ©orique)

#### Ã‰tape 1 : Installer l'extension

HypoPG ne nÃ©cessite **pas** d'Ãªtre ajoutÃ© Ã  `shared_preload_libraries` (contrairement Ã  pg_stat_statements).

```sql
-- Se connecter Ã  la base de donnÃ©es cible
CREATE EXTENSION hypopg;
```

C'est tout ! Pas besoin de redÃ©marrage PostgreSQL.

#### Ã‰tape 2 : VÃ©rifier l'installation

```sql
-- VÃ©rifier que l'extension est active
SELECT * FROM pg_extension WHERE extname = 'hypopg';

-- Lister les fonctions disponibles
\df hypopg*

-- Fonctions principales :
-- hypopg_create_index()     : CrÃ©er un index hypothÃ©tique
-- hypopg_drop_index()       : Supprimer un index hypothÃ©tique
-- hypopg_list_indexes()     : Lister les index hypothÃ©tiques
-- hypopg_reset()            : Supprimer tous les index hypothÃ©tiques
-- hypopg_get_indexdef()     : Obtenir la dÃ©finition d'un index
```

#### Ã‰tape 3 : Test rapide

```sql
-- CrÃ©er un index hypothÃ©tique simple
SELECT hypopg_create_index('CREATE INDEX ON customers(email)');

-- RÃ©sultat : Retourne l'OID de l'index virtuel crÃ©Ã©
-- Exemple : 12345

-- VÃ©rifier qu'il existe
SELECT * FROM hypopg_list_indexes();

-- Le voir dans un plan d'exÃ©cution
EXPLAIN SELECT * FROM customers WHERE email = 'user@example.com';
-- Doit mentionner l'index hypothÃ©tique si utilisÃ©
```

### Permissions et SÃ©curitÃ©

HypoPG nÃ©cessite les mÃªmes permissions que pour lire les mÃ©tadonnÃ©es de la base :

```sql
-- Permissions minimales pour utiliser HypoPG
GRANT USAGE ON SCHEMA public TO user_dev;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO user_dev;

-- Pour crÃ©er l'extension (une seule fois)
-- NÃ©cessite superutilisateur ou droits CREATE sur la base
```

**Note** : Les index hypothÃ©tiques sont **par session**. Chaque utilisateur connectÃ© a ses propres index virtuels qui ne sont pas visibles par les autres sessions.

---

## Utilisation de Base

### CrÃ©er un Index HypothÃ©tique

La fonction principale est `hypopg_create_index()`.

**Syntaxe** :

```sql
SELECT hypopg_create_index('dÃ©finition_index');
```

**Exemples** :

```sql
-- Index simple sur une colonne
SELECT hypopg_create_index('CREATE INDEX ON orders(customer_id)');

-- Index composite (multi-colonnes)
SELECT hypopg_create_index('CREATE INDEX ON orders(customer_id, order_date)');

-- Index avec nom personnalisÃ©
SELECT hypopg_create_index('CREATE INDEX idx_orders_status ON orders(status)');

-- Index partiel (avec WHERE)
SELECT hypopg_create_index('CREATE INDEX ON orders(order_date) WHERE status = ''pending''');

-- Index sur expression
SELECT hypopg_create_index('CREATE INDEX ON customers(LOWER(email))');

-- Index UNIQUE (hypothÃ©tique)
SELECT hypopg_create_index('CREATE UNIQUE INDEX ON customers(email)');

-- Index de type spÃ©cifique (GIN, GiST, etc.)
SELECT hypopg_create_index('CREATE INDEX ON documents USING GIN(content)');
```

**Retour** : La fonction retourne l'**OID** (identifiant) de l'index hypothÃ©tique crÃ©Ã©.

```sql
SELECT hypopg_create_index('CREATE INDEX ON orders(order_date)');
-- Retour : 123456
```

### Lister les Index HypothÃ©tiques

```sql
SELECT * FROM hypopg_list_indexes();
```

**Colonnes retournÃ©es** :

| Colonne | Type | Description |
|---------|------|-------------|
| `indexrelid` | oid | OID de l'index hypothÃ©tique |
| `index_name` | text | Nom de l'index (auto-gÃ©nÃ©rÃ© si non spÃ©cifiÃ©) |
| `schema_name` | text | SchÃ©ma de la table |
| `table_name` | text | Nom de la table |
| `am_name` | text | Type d'index (btree, gin, gist, etc.) |

**Exemple de rÃ©sultat** :

```
indexrelid | index_name              | schema_name | table_name | am_name
-----------+-------------------------+-------------+------------+--------
123456     | <123456>btree_orders    | public      | orders     | btree
123457     | idx_orders_status       | public      | orders     | btree
```

### Obtenir la DÃ©finition d'un Index

```sql
SELECT hypopg_get_indexdef(123456);
-- Retour : 'CREATE INDEX ON public.orders USING btree (order_date)'
```

### Tester l'Impact avec EXPLAIN

Une fois un index hypothÃ©tique crÃ©Ã©, utilisez `EXPLAIN` pour voir si le planificateur l'utilise :

```sql
-- CrÃ©er l'index hypothÃ©tique
SELECT hypopg_create_index('CREATE INDEX ON orders(order_date)');

-- Tester la requÃªte
EXPLAIN SELECT * FROM orders WHERE order_date = '2025-01-15';
```

**RÃ©sultat possible** :

```
Index Scan using <123456>btree_orders on orders
  Index Cond: (order_date = '2025-01-15'::date)
```

**InterprÃ©tation** : Le planificateur **utilise** l'index hypothÃ©tique `<123456>btree_orders`. Cela signifie que crÃ©er cet index rÃ©ellement **amÃ©liorerait** les performances de cette requÃªte.

**Si l'index n'est pas utilisÃ©** :

```
Seq Scan on orders
  Filter: (order_date = '2025-01-15'::date)
```

**InterprÃ©tation** : Le planificateur **n'utilise pas** l'index hypothÃ©tique. CrÃ©er cet index serait **inutile** pour cette requÃªte.

### Supprimer un Index HypothÃ©tique

```sql
-- Supprimer par OID
SELECT hypopg_drop_index(123456);

-- Supprimer TOUS les index hypothÃ©tiques de la session
SELECT hypopg_reset();
```

**Important** : Les index hypothÃ©tiques sont automatiquement supprimÃ©s Ã  la **dÃ©connexion** de la session.

---

## Workflow Typique d'Utilisation

### ScÃ©nario : Optimiser une RequÃªte Lente

**Ã‰tape 1 : Identifier une requÃªte problÃ©matique**

```sql
-- Via pg_stat_statements ou logs
SELECT query, calls, mean_exec_time
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 10;

-- Identifier une requÃªte cible
-- Exemple : "SELECT * FROM orders WHERE customer_id = $1 AND status = $2"
```

**Ã‰tape 2 : Analyser le plan actuel**

```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM orders
WHERE customer_id = 12345
  AND status = 'pending';
```

**RÃ©sultat hypothÃ©tique** :

```
Seq Scan on orders  (cost=0.00..500000.00 rows=100 width=200) (actual time=120.5..3500.2 rows=95 loops=1)
  Filter: ((customer_id = 12345) AND (status = 'pending'::text))
  Rows Removed by Filter: 9999905
Planning Time: 0.5 ms
Execution Time: 3500.8 ms
```

**Diagnostic** : Scan sÃ©quentiel de 10 millions de lignes, trÃ¨s lent (3.5 secondes).

**Ã‰tape 3 : CrÃ©er un index hypothÃ©tique**

```sql
-- HypothÃ¨se : Un index sur (customer_id, status) pourrait aider
SELECT hypopg_create_index('CREATE INDEX ON orders(customer_id, status)');
-- Retour : 123456
```

**Ã‰tape 4 : Tester avec l'index hypothÃ©tique**

```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM orders
WHERE customer_id = 12345
  AND status = 'pending';
```

**RÃ©sultat avec index hypothÃ©tique** :

```
Index Scan using <123456>btree_orders on orders  (cost=0.56..150.32 rows=100 width=200) (actual time=0.05..0.25 rows=95 loops=1)
  Index Cond: ((customer_id = 12345) AND (status = 'pending'::text))
Planning Time: 0.6 ms
Execution Time: 0.3 ms
```

**Diagnostic** : Le planificateur utilise l'index hypothÃ©tique et le temps d'exÃ©cution estimÃ© passe de **3500ms Ã  0.3ms** (amÃ©lioration de 99.99%) !

**Ã‰tape 5 : DÃ©cision**

L'index hypothÃ©tique amÃ©liore drastiquement les performances â†’ **Le crÃ©er rÃ©ellement**.

```sql
-- CrÃ©er l'index rÃ©el
CREATE INDEX idx_orders_customer_status ON orders(customer_id, status);
```

**Ã‰tape 6 : Valider**

```sql
-- VÃ©rifier que l'index rÃ©el est bien utilisÃ©
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM orders
WHERE customer_id = 12345
  AND status = 'pending';

-- Doit montrer l'utilisation de idx_orders_customer_status
```

**Ã‰tape 7 : Nettoyer**

```sql
-- Supprimer l'index hypothÃ©tique (optionnel, sera supprimÃ© Ã  la dÃ©connexion)
SELECT hypopg_reset();
```

---

## Cas d'Usage DÃ©taillÃ©s

### 1. Comparer Plusieurs StratÃ©gies d'Indexation

**ProblÃ¨me** : Vous ne savez pas quel index crÃ©er entre plusieurs options.

```sql
-- RequÃªte problÃ©matique
SELECT * FROM orders
WHERE customer_id = 12345
  AND order_date >= '2024-01-01'
  AND status = 'shipped';

-- Option 1 : Index sur customer_id seul
SELECT hypopg_create_index('CREATE INDEX idx1 ON orders(customer_id)');

EXPLAIN SELECT * FROM orders
WHERE customer_id = 12345
  AND order_date >= '2024-01-01'
  AND status = 'shipped';
-- Analyser le coÃ»t estimÃ© : cost=0.56..1500.32

-- Nettoyer
SELECT hypopg_reset();

-- Option 2 : Index composite (customer_id, order_date)
SELECT hypopg_create_index('CREATE INDEX idx2 ON orders(customer_id, order_date)');

EXPLAIN SELECT * FROM orders
WHERE customer_id = 12345
  AND order_date >= '2024-01-01'
  AND status = 'shipped';
-- CoÃ»t : cost=0.56..850.12 (meilleur !)

SELECT hypopg_reset();

-- Option 3 : Index composite (customer_id, status)
SELECT hypopg_create_index('CREATE INDEX idx3 ON orders(customer_id, status)');

EXPLAIN SELECT * FROM orders
WHERE customer_id = 12345
  AND order_date >= '2024-01-01'
  AND status = 'shipped';
-- CoÃ»t : cost=0.56..950.45

SELECT hypopg_reset();

-- Option 4 : Index composite complet (customer_id, order_date, status)
SELECT hypopg_create_index('CREATE INDEX idx4 ON orders(customer_id, order_date, status)');

EXPLAIN SELECT * FROM orders
WHERE customer_id = 12345
  AND order_date >= '2024-01-01'
  AND status = 'shipped';
-- CoÃ»t : cost=0.56..120.22 (le meilleur !)
```

**Conclusion** : L'index composite `(customer_id, order_date, status)` offre le meilleur plan. **Le crÃ©er rÃ©ellement**.

### 2. Tester des Index Partiels

Les **index partiels** (avec `WHERE`) ne couvrent qu'un sous-ensemble de lignes, Ã©conomisant de l'espace.

```sql
-- RequÃªte frÃ©quente : Chercher les commandes en attente
SELECT * FROM orders WHERE status = 'pending';

-- HypothÃ¨se : Les commandes 'pending' sont rares (1% de la table)
-- Index partiel pour Ã©conomiser l'espace

SELECT hypopg_create_index('CREATE INDEX ON orders(customer_id) WHERE status = ''pending''');

EXPLAIN SELECT * FROM orders
WHERE customer_id = 12345
  AND status = 'pending';

-- Le planificateur utilise-t-il l'index partiel ?
-- Si oui : Index Scan using <123456>btree_orders...
-- Si non : Seq Scan (l'index partiel n'est pas avantageux)
```

**Avantages de l'index partiel** :
- Plus petit (seulement 1% des lignes)
- Maintenance plus rapide (INSERT/UPDATE/DELETE)
- Toujours efficace pour les requÃªtes ciblÃ©es

### 3. Tester des Index sur Expressions

```sql
-- RequÃªte avec recherche insensible Ã  la casse
SELECT * FROM customers WHERE LOWER(email) = 'user@example.com';

-- Sans index : Seq Scan avec calcul de LOWER() sur chaque ligne (lent)

-- Tester un index sur l'expression
SELECT hypopg_create_index('CREATE INDEX ON customers(LOWER(email))');

EXPLAIN SELECT * FROM customers WHERE LOWER(email) = 'user@example.com';

-- Si le planificateur utilise l'index : AmÃ©lioration majeure
```

### 4. Tester des Index Couvrants (INCLUDE)

PostgreSQL 11+ supporte les **index couvrants** avec `INCLUDE` (covering index).

```sql
-- RequÃªte qui sÃ©lectionne plusieurs colonnes
SELECT customer_id, email, created_at
FROM customers
WHERE customer_id = 12345;

-- Option 1 : Index simple
SELECT hypopg_create_index('CREATE INDEX ON customers(customer_id)');
EXPLAIN SELECT customer_id, email, created_at FROM customers WHERE customer_id = 12345;
-- RÃ©sultat : Index Scan + rÃ©cupÃ©ration des donnÃ©es de la table (heap fetch)

SELECT hypopg_reset();

-- Option 2 : Index couvrant (inclut les colonnes dans l'index)
SELECT hypopg_create_index('CREATE INDEX ON customers(customer_id) INCLUDE (email, created_at)');
EXPLAIN SELECT customer_id, email, created_at FROM customers WHERE customer_id = 12345;
-- RÃ©sultat : Index Only Scan (plus rapide, pas de heap fetch)
```

**Index Only Scan** : Le planificateur peut rÃ©cupÃ©rer toutes les donnÃ©es nÃ©cessaires directement depuis l'index, sans accÃ©der Ã  la table. **TrÃ¨s performant.**

### 5. Analyser l'Impact d'un Index sur Plusieurs RequÃªtes

HypoPG permet de tester un mÃªme index sur plusieurs requÃªtes diffÃ©rentes.

```sql
-- CrÃ©er un index hypothÃ©tique
SELECT hypopg_create_index('CREATE INDEX ON orders(order_date)');

-- Tester sur plusieurs requÃªtes
EXPLAIN SELECT * FROM orders WHERE order_date = '2025-01-15';
-- Utilise l'index ?

EXPLAIN SELECT * FROM orders WHERE order_date >= '2025-01-01' AND order_date < '2025-02-01';
-- Utilise l'index ?

EXPLAIN SELECT COUNT(*) FROM orders WHERE order_date > '2024-01-01';
-- Utilise l'index ?

EXPLAIN SELECT * FROM orders ORDER BY order_date DESC LIMIT 10;
-- Utilise l'index pour Ã©viter le tri ?

-- Si l'index amÃ©liore plusieurs requÃªtes frÃ©quentes : Le crÃ©er
-- Si l'index n'amÃ©liore qu'une seule requÃªte rare : ReconsidÃ©rer
```

### 6. DÃ©tecter les Index Redondants

Avant de crÃ©er un nouvel index, vÃ©rifier qu'il n'est pas **redondant** avec un index existant.

```sql
-- Index existant : idx_orders_customer_id sur (customer_id)

-- Tester un nouvel index composite
SELECT hypopg_create_index('CREATE INDEX ON orders(customer_id, order_date)');

-- Pour une requÃªte filtrant uniquement sur customer_id
EXPLAIN SELECT * FROM orders WHERE customer_id = 12345;

-- Le planificateur choisit-il le nouvel index ou l'ancien ?
-- Si l'ancien suffit : Le nouvel index est inutile pour cette requÃªte
```

**RÃ¨gle** : Un index composite `(A, B)` peut remplacer un index simple `(A)`, mais l'inverse n'est pas vrai.

---

## Automatisation et IntÃ©gration

### Script d'Analyse AutomatisÃ©e

CrÃ©er un script qui teste automatiquement plusieurs index hypothÃ©tiques :

```sql
-- Fonction d'analyse d'index
CREATE OR REPLACE FUNCTION analyze_index_candidates(
    p_table_name TEXT,
    p_columns TEXT[],
    p_query TEXT
)
RETURNS TABLE(
    index_def TEXT,
    estimated_cost NUMERIC,
    uses_index BOOLEAN
) AS $$
DECLARE
    v_index_def TEXT;
    v_plan TEXT;
    v_cost NUMERIC;
BEGIN
    -- Tester chaque colonne individuellement
    FOREACH v_index_def IN ARRAY p_columns LOOP
        -- CrÃ©er l'index hypothÃ©tique
        PERFORM hypopg_create_index(
            format('CREATE INDEX ON %s(%s)', p_table_name, v_index_def)
        );

        -- Obtenir le plan
        EXECUTE format('EXPLAIN (FORMAT JSON) %s', p_query) INTO v_plan;

        -- Extraire le coÃ»t (simplifiÃ©)
        v_cost := (v_plan::json->0->'Plan'->>'Total Cost')::numeric;

        -- Retourner le rÃ©sultat
        RETURN QUERY SELECT
            format('CREATE INDEX ON %s(%s)', p_table_name, v_index_def),
            v_cost,
            v_plan LIKE '%<1234567%';  -- DÃ©tection basique d'utilisation d'index hypo

        -- Nettoyer
        PERFORM hypopg_reset();
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Utilisation
SELECT * FROM analyze_index_candidates(
    'orders',
    ARRAY['customer_id', 'order_date', 'status', 'customer_id, order_date'],
    'SELECT * FROM orders WHERE customer_id = 12345 AND order_date >= ''2024-01-01'''
)
ORDER BY estimated_cost;
```

### IntÃ©gration avec pg_stat_statements

Combiner HypoPG avec pg_stat_statements pour analyser les requÃªtes lentes :

```sql
-- CrÃ©er une vue des requÃªtes candidates Ã  l'optimisation
CREATE OR REPLACE VIEW optimization_candidates AS
SELECT
    queryid,
    LEFT(query, 100) as query_snippet,
    calls,
    mean_exec_time,
    total_exec_time
FROM pg_stat_statements
WHERE mean_exec_time > 100  -- Plus de 100ms en moyenne
  AND calls > 100           -- AppelÃ©e au moins 100 fois
ORDER BY total_exec_time DESC
LIMIT 20;

-- Tester des index hypothÃ©tiques sur ces requÃªtes
-- (processus manuel ou via script d'automatisation)
```

### GÃ©nÃ©rer des Recommandations d'Index

```sql
-- Fonction simple pour recommander des index
CREATE OR REPLACE FUNCTION recommend_indexes(p_query TEXT)
RETURNS TABLE(recommendation TEXT, reason TEXT) AS $$
DECLARE
    v_plan TEXT;
BEGIN
    -- Obtenir le plan actuel
    EXECUTE format('EXPLAIN %s', p_query) INTO v_plan;

    -- Analyser le plan (simplifiÃ©)
    IF v_plan LIKE '%Seq Scan%' THEN
        RETURN QUERY SELECT
            'Index recommandÃ© sur les colonnes du WHERE'::TEXT,
            'Scan sÃ©quentiel dÃ©tectÃ©'::TEXT;
    END IF;

    IF v_plan LIKE '%Sort%' THEN
        RETURN QUERY SELECT
            'Index recommandÃ© sur les colonnes du ORDER BY'::TEXT,
            'Tri en mÃ©moire dÃ©tectÃ©'::TEXT;
    END IF;

    RETURN;
END;
$$ LANGUAGE plpgsql;
```

### Workflow de Test Continu

IntÃ©grer HypoPG dans un pipeline de CI/CD :

```bash
#!/bin/bash
# Script de test d'index hypothÃ©tiques (conceptuel)

# 1. Exporter les requÃªtes lentes depuis production
psql -c "COPY (SELECT query FROM pg_stat_statements WHERE mean_exec_time > 1000) TO '/tmp/slow_queries.txt'"

# 2. Pour chaque requÃªte, tester des index hypothÃ©tiques
while read query; do
    psql -c "SELECT hypopg_create_index('...');"
    psql -c "EXPLAIN $query;"
    psql -c "SELECT hypopg_reset();"
done < /tmp/slow_queries.txt

# 3. GÃ©nÃ©rer un rapport de recommandations
# 4. Valider avec l'Ã©quipe avant crÃ©ation rÃ©elle des index
```

---

## Bonnes Pratiques

### 1. Toujours Tester Avant de CrÃ©er

âœ… **Principe** : Ne JAMAIS crÃ©er un index en production sans l'avoir testÃ© avec HypoPG.

**Workflow recommandÃ©** :

```
RequÃªte lente identifiÃ©e
    â†“
Test avec HypoPG (dev/staging)
    â†“
L'index amÃ©liore-t-il le plan ?
    â†“ OUI
CrÃ©er l'index rÃ©el (d'abord en staging)
    â†“
Valider les performances rÃ©elles
    â†“
DÃ©ployer en production
```

### 2. Tester sur des DonnÃ©es RÃ©alistes

Les statistiques du planificateur dÃ©pendent des **donnÃ©es rÃ©elles**.

âŒ **Mauvais** : Tester sur une base vide ou avec peu de donnÃ©es
âœ… **Bon** : Tester sur une base avec volume et distribution similaires Ã  la production

**Solution** : Utiliser `pg_dump` / `pg_restore` pour cloner la production en staging, ou utiliser des donnÃ©es synthÃ©tiques rÃ©alistes.

### 3. Analyser le CoÃ»t Total, Pas Seulement l'Utilisation

Un index peut Ãªtre **utilisÃ©** mais pas forcÃ©ment **optimal**.

```sql
-- ScÃ©nario : Index utilisÃ© mais coÃ»teux
EXPLAIN SELECT * FROM orders WHERE status = 'pending';

-- Avec index hypothÃ©tique :
-- Index Scan using <123456>btree_orders (cost=0.56..95000.00 rows=1000000)

-- Sans index :
-- Seq Scan on orders (cost=0.00..50000.00 rows=1000000)
```

**InterprÃ©tation** : L'index est **utilisÃ©** mais son coÃ»t (95000) est **plus Ã©levÃ©** que le scan sÃ©quentiel (50000). Ne pas crÃ©er cet index !

**Raison** : La colonne `status` a probablement une faible sÃ©lectivitÃ© (ex: 50% des lignes sont 'pending'), rendant l'index inefficace.

### 4. ConsidÃ©rer l'Ordre des Colonnes dans les Index Composites

L'ordre des colonnes dans un index composite est **crucial**.

```sql
-- Tester les deux ordres
SELECT hypopg_create_index('CREATE INDEX ON orders(customer_id, order_date)');
EXPLAIN SELECT * FROM orders WHERE customer_id = 12345 AND order_date >= '2024-01-01';
-- CoÃ»t : 150

SELECT hypopg_reset();

SELECT hypopg_create_index('CREATE INDEX ON orders(order_date, customer_id)');
EXPLAIN SELECT * FROM orders WHERE customer_id = 12345 AND order_date >= '2024-01-01';
-- CoÃ»t : 450 (moins bon)
```

**RÃ¨gle gÃ©nÃ©rale** : Placer en premier la colonne avec la **meilleure sÃ©lectivitÃ©** (qui filtre le plus de lignes).

### 5. Ne Pas Oublier l'Impact des Ã‰critures

HypoPG teste uniquement les **lectures** (SELECT). Un index ralentit les **Ã©critures** (INSERT/UPDATE/DELETE).

**Questions Ã  se poser** :

- Cette table est-elle principalement en **lecture** (OLAP) ou en **Ã©criture** (OLTP) ?
- Combien d'Ã©critures par seconde ?
- Le gain en lecture justifie-t-il le coÃ»t en Ã©criture ?

**Exemple** :

```
Table : 1 million d'INSERT par jour
RequÃªte lente : ExÃ©cutÃ©e 10 fois par jour

â†’ L'index ralentira 1 million d'Ã©critures pour accÃ©lÃ©rer 10 requÃªtes
â†’ Probablement pas un bon compromis
â†’ Envisager plutÃ´t une vue matÃ©rialisÃ©e ou une table agrÃ©gÃ©e
```

### 6. Tester les Index UNIQUE

HypoPG permet de tester des index UNIQUE, mais attention :

```sql
SELECT hypopg_create_index('CREATE UNIQUE INDEX ON customers(email)');

EXPLAIN SELECT * FROM customers WHERE email = 'user@example.com';
```

**Important** : HypoPG ne vÃ©rifie PAS que les valeurs sont uniques. C'est juste pour tester le plan.

### 7. Nettoyer RÃ©guliÃ¨rement

Les index hypothÃ©tiques consomment de la mÃ©moire (peu, mais quand mÃªme).

```sql
-- Supprimer tous les index hypothÃ©tiques aprÃ¨s chaque session de test
SELECT hypopg_reset();
```

**Note** : Ils sont automatiquement supprimÃ©s Ã  la dÃ©connexion.

### 8. Documenter les DÃ©cisions

```sql
-- CrÃ©er une table de dÃ©cisions d'indexation
CREATE TABLE monitoring.index_decisions (
    decision_id SERIAL PRIMARY KEY,
    table_name TEXT,
    index_definition TEXT,
    tested_date DATE DEFAULT CURRENT_DATE,
    cost_without_index NUMERIC,
    cost_with_index NUMERIC,
    decision TEXT,  -- 'created', 'rejected', 'pending'
    reason TEXT,
    created_by TEXT DEFAULT CURRENT_USER
);

-- Documenter chaque dÃ©cision
INSERT INTO monitoring.index_decisions
(table_name, index_definition, cost_without_index, cost_with_index, decision, reason)
VALUES (
    'orders',
    'CREATE INDEX ON orders(customer_id, order_date)',
    50000.00,
    150.00,
    'created',
    'AmÃ©lioration de 99.7% sur les requÃªtes par client et date'
);
```

---

## Limitations et ConsidÃ©rations

### Limitations de HypoPG

1. **Estimation, pas exÃ©cution rÃ©elle**
   - HypoPG montre ce que le planificateur **pense** faire
   - L'exÃ©cution rÃ©elle peut diffÃ©rer (cache, I/O, etc.)
   - Toujours valider avec EXPLAIN ANALYZE aprÃ¨s crÃ©ation rÃ©elle

2. **Pas de validation des contraintes**
   - Un index UNIQUE hypothÃ©tique ne vÃ©rifie pas l'unicitÃ©
   - Un index partiel ne vÃ©rifie pas la condition WHERE

3. **Statistiques limitÃ©es**
   - HypoPG gÃ©nÃ¨re des statistiques fictives basÃ©es sur les statistiques de la table
   - Si les statistiques sont obsolÃ¨tes (manque d'ANALYZE), HypoPG sera imprÃ©cis

4. **Pas de test de maintenance**
   - Impossible de mesurer l'impact rÃ©el sur les INSERT/UPDATE/DELETE
   - Estimation thÃ©orique uniquement

5. **Session-specific**
   - Les index hypothÃ©tiques ne sont visibles que dans la session actuelle
   - Impossible de partager entre plusieurs connexions

6. **Pas de test de fragmentation**
   - Impossible de prÃ©dire la fragmentation de l'index dans le temps
   - Impossible de tester le comportement aprÃ¨s VACUUM

### Situations oÃ¹ HypoPG est Moins Fiable

1. **Tables sans statistiques rÃ©centes**

```sql
-- VÃ©rifier la date du dernier ANALYZE
SELECT
    schemaname,
    tablename,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
WHERE tablename = 'orders';

-- Si last_analyze est ancien ou NULL : Analyser d'abord
ANALYZE orders;
```

2. **RequÃªtes avec paramÃ¨tres**

Le planificateur peut choisir diffÃ©rents plans selon les valeurs rÃ©elles des paramÃ¨tres.

```sql
-- GÃ©nÃ©rique
EXPLAIN SELECT * FROM orders WHERE customer_id = $1;

-- Avec valeur spÃ©cifique
EXPLAIN SELECT * FROM orders WHERE customer_id = 12345;
```

**Solution** : Tester avec plusieurs valeurs reprÃ©sentatives.

3. **Workload mixte (OLTP + OLAP)**

HypoPG optimise pour une requÃªte spÃ©cifique, mais peut dÃ©grader d'autres requÃªtes.

**Solution** : Tester l'index sur un **panel reprÃ©sentatif** de requÃªtes.

---

## DÃ©pannage (Troubleshooting)

### ProblÃ¨me 1 : L'Index HypothÃ©tique n'est Pas UtilisÃ©

**SymptÃ´mes** : Le plan EXPLAIN ne mentionne pas l'index hypothÃ©tique.

**Causes possibles** :

1. **Index inappropriÃ©**
   - La requÃªte ne filtre pas sur les colonnes de l'index
   - L'ordre des colonnes est incorrect (index composite)

2. **Statistiques obsolÃ¨tes**

```sql
-- Mettre Ã  jour les statistiques
ANALYZE orders;

-- RecrÃ©er l'index hypothÃ©tique et retester
SELECT hypopg_reset();
SELECT hypopg_create_index('...');
EXPLAIN ...;
```

3. **CoÃ»t estimÃ© de l'index > Seq Scan**

Le planificateur choisit le scan sÃ©quentiel car moins coÃ»teux.

```sql
-- VÃ©rifier le coÃ»t estimÃ©
EXPLAIN (FORMAT JSON) SELECT * FROM orders WHERE status = 'pending';

-- Si le coÃ»t du Seq Scan est plus bas : L'index n'est pas avantageux
```

4. **Type d'index inadaptÃ©**

```sql
-- Mauvais : B-tree pour LIKE '%pattern%'
SELECT hypopg_create_index('CREATE INDEX ON products(name)');
EXPLAIN SELECT * FROM products WHERE name LIKE '%widget%';
-- N'utilisera pas l'index (scan infixe)

-- Bon : GIN avec pg_trgm pour LIKE '%pattern%'
CREATE EXTENSION pg_trgm;
SELECT hypopg_create_index('CREATE INDEX ON products USING GIN(name gin_trgm_ops)');
EXPLAIN SELECT * FROM products WHERE name LIKE '%widget%';
```

### ProblÃ¨me 2 : RÃ©sultats Contradictoires (HypoPG vs RÃ©alitÃ©)

**SymptÃ´mes** : HypoPG prÃ©dit un gain, mais l'index rÃ©el n'amÃ©liore pas les performances.

**Causes** :

1. **Statistiques incorrectes**

```sql
-- Augmenter les cibles statistiques pour plus de prÃ©cision
ALTER TABLE orders ALTER COLUMN customer_id SET STATISTICS 1000;
ANALYZE orders;
```

2. **Cache effects**

HypoPG ne modÃ©lise pas prÃ©cisÃ©ment le cache. Un index peut Ãªtre moins utile si les donnÃ©es sont dÃ©jÃ  en cache.

3. **I/O rÃ©el vs estimÃ©**

Le planificateur estime l'I/O, mais le comportement rÃ©el dÃ©pend du hardware (SSD vs HDD).

**Solution** : Toujours valider avec `EXPLAIN (ANALYZE, BUFFERS)` aprÃ¨s crÃ©ation rÃ©elle.

### ProblÃ¨me 3 : HypoPG Ralentit les EXPLAIN

**SymptÃ´mes** : Les commandes EXPLAIN sont lentes avec beaucoup d'index hypothÃ©tiques.

**Cause** : Trop d'index hypothÃ©tiques crÃ©Ã©s (> 50).

**Solution** :

```sql
-- Lister et compter
SELECT COUNT(*) FROM hypopg_list_indexes();

-- Nettoyer
SELECT hypopg_reset();
```

### ProblÃ¨me 4 : Extension Non Disponible

**SymptÃ´mes** : `ERROR: extension "hypopg" is not available`.

**Cause** : HypoPG n'est pas installÃ© sur le serveur.

**Solution** :

- **Distributions** : Installer le package (ex: `postgresql-18-hypopg` sur Debian/Ubuntu)
- **Compilation** : Compiler depuis les sources (GitHub)
- **Cloud managÃ©** : VÃ©rifier la disponibilitÃ© (RDS, Azure, GCP)

**Note** : HypoPG n'est pas toujours disponible sur les services cloud managÃ©s.

---

## Comparaison avec d'Autres Approches

### HypoPG vs CrÃ©er/Tester/Supprimer RÃ©ellement

| CritÃ¨re | HypoPG | CrÃ©ation RÃ©elle |
|---------|--------|----------------|
| **Temps** | Millisecondes | Minutes Ã  heures |
| **Espace disque** | Aucun | Consomme de l'espace |
| **Impact production** | Aucun | Risque (locks, I/O) |
| **PrÃ©cision** | Estimation | RÃ©sultat rÃ©el |
| **Test Ã©critures** | Non | Oui |
| **Multiples tests** | Rapide et facile | Lent et risquÃ© |

**Verdict** : HypoPG pour les tests, crÃ©ation rÃ©elle pour la validation finale.

### HypoPG vs Index Advisors (outils externes)

Certains outils proposent des recommandations d'index automatiques :

- **pgAdmin** : Index advisor intÃ©grÃ©
- **pgTune** : Suggestions de configuration
- **Outils commerciaux** : Datadog, New Relic, etc.

| CritÃ¨re | HypoPG | Index Advisors |
|---------|--------|----------------|
| **ContrÃ´le** | Total (manuel) | Automatique |
| **Personnalisation** | ComplÃ¨te | LimitÃ©e |
| **ComplexitÃ©** | Moyenne | Faible |
| **CoÃ»t** | Gratuit (open-source) | Variable (souvent payant) |

**Verdict** : HypoPG pour contrÃ´le fin, Index Advisors pour recommandations rapides.

### HypoPG vs Auto-Indexing (future feature ?)

PostgreSQL n'a pas (encore) d'auto-indexing natif, mais des discussions existent dans la communautÃ©.

**HypothÃ©tique Auto-Indexing** :
- Le systÃ¨me crÃ©e/supprime automatiquement des index selon la charge
- Utiliserait HypoPG en arriÃ¨re-plan pour tester

**Pour l'instant** : HypoPG reste un outil manuel, nÃ©cessitant intervention humaine.

---

## Cas d'Usage AvancÃ©s

### 1. Tester des StratÃ©gies d'Index pour du Sharding

Avant de partitionner/sharding une table, tester les index appropriÃ©s.

```sql
-- Table avant partitionnement
CREATE TABLE events (
    event_id BIGSERIAL,
    event_date DATE,
    user_id INTEGER,
    event_type VARCHAR(50),
    data JSONB
);

-- StratÃ©gie 1 : Index global sur event_date
SELECT hypopg_create_index('CREATE INDEX ON events(event_date)');
EXPLAIN SELECT * FROM events WHERE event_date = '2025-01-15';

-- StratÃ©gie 2 : Index composite (event_date, user_id)
SELECT hypopg_reset();
SELECT hypopg_create_index('CREATE INDEX ON events(event_date, user_id)');
EXPLAIN SELECT * FROM events WHERE event_date = '2025-01-15' AND user_id = 12345;

-- Choisir la stratÃ©gie avant de partitionner
```

### 2. Optimiser des RequÃªtes Full-Text Search

```sql
-- RequÃªte de recherche textuelle
SELECT * FROM articles WHERE to_tsvector('english', content) @@ to_tsquery('postgresql & indexing');

-- Tester un index GIN
SELECT hypopg_create_index('CREATE INDEX ON articles USING GIN(to_tsvector(''english'', content))');

EXPLAIN SELECT * FROM articles WHERE to_tsvector('english', content) @@ to_tsquery('postgresql & indexing');
```

### 3. Analyser l'Impact sur des RequÃªtes de Reporting

```sql
-- RequÃªte d'agrÃ©gation complexe
SELECT
    DATE_TRUNC('month', order_date) as month,
    customer_id,
    SUM(amount) as total
FROM orders
WHERE order_date >= '2024-01-01'
GROUP BY DATE_TRUNC('month', order_date), customer_id;

-- Tester un index pour cette requÃªte
SELECT hypopg_create_index('CREATE INDEX ON orders(order_date, customer_id, amount)');

EXPLAIN SELECT ...;
```

---

## IntÃ©gration avec l'Ã‰cosystÃ¨me PostgreSQL

### HypoPG + pg_stat_statements

```sql
-- Vue combinÃ©e : RequÃªtes lentes + Recommandations d'index
CREATE OR REPLACE VIEW slow_queries_with_recommendations AS
SELECT
    queryid,
    LEFT(query, 100) as query_snippet,
    calls,
    mean_exec_time,
    -- Extraire les colonnes du WHERE (simplifiÃ©)
    regexp_matches(query, 'WHERE\s+(\w+)', 'g') as potential_index_columns
FROM pg_stat_statements
WHERE mean_exec_time > 100
ORDER BY total_exec_time DESC
LIMIT 20;
```

### HypoPG + auto_explain

Combiner avec auto_explain pour capturer automatiquement les plans des requÃªtes lentes.

```ini
# postgresql.conf
shared_preload_libraries = 'auto_explain'
auto_explain.log_min_duration = 1000
auto_explain.log_analyze = on
auto_explain.log_buffers = on
```

Ensuite, analyser les logs et tester des index hypothÃ©tiques sur les requÃªtes identifiÃ©es.

### HypoPG + pgBadger

pgBadger peut extraire des recommandations d'index depuis les logs. Utiliser HypoPG pour valider ces recommandations.

```bash
# GÃ©nÃ©rer un rapport pgBadger
pgbadger /var/log/postgresql/*.log -o report.html

# Identifier les "Queries that could benefit from indexes"
# Tester ces index avec HypoPG
```

---

## Pour Aller Plus Loin

### Ressources Officielles

- **GitHub HypoPG** : https://github.com/HypoPG/hypopg
- **Documentation PostgreSQL - Indexes** : https://www.postgresql.org/docs/current/indexes.html

### Outils ComplÃ©mentaires

- **pg_qualstats** : Collecte des statistiques sur les prÃ©dicats (WHERE clauses)
- **PoWA** : Utilise HypoPG pour des recommandations automatiques
- **pgAdmin** : Interface graphique avec suggestions d'index

### Lectures RecommandÃ©es

- **PostgreSQL: Up and Running** (Regina Obe, Leo Hsu) - Chapitre sur l'indexation
- **The Art of PostgreSQL** (Dimitri Fontaine) - StratÃ©gies d'index avancÃ©es
- **Use The Index, Luke** (Markus Winand) - Guide complet sur les index SQL

### CommunautÃ© et Support

- **GitHub Issues** : Signaler des bugs ou demander des fonctionnalitÃ©s
- **PostgreSQL Mailing Lists** : pgsql-performance@postgresql.org
- **Reddit** : r/PostgreSQL

---

## RÃ©sumÃ©

**HypoPG** est un outil indispensable pour optimiser les performances PostgreSQL en testant des index **sans les crÃ©er physiquement**.

### Points ClÃ©s

- âœ… **Test rapide** : CrÃ©er/supprimer des index virtuels en millisecondes
- âœ… **ZÃ©ro impact** : Pas d'espace disque, pas de ralentissement
- âœ… **DÃ©cisions Ã©clairÃ©es** : CrÃ©er uniquement les index rÃ©ellement utiles
- âœ… **Comparaison facile** : Tester plusieurs stratÃ©gies d'indexation
- âœ… **Production-safe** : Tester sans risque

### Quand Utiliser HypoPG ?

- **Optimisation de requÃªtes lentes** : Identifier le meilleur index
- **Comparaison de stratÃ©gies** : Tester plusieurs options d'indexation
- **Validation avant crÃ©ation** : S'assurer qu'un index sera utilisÃ©
- **Analyse d'impact** : Comprendre comment un index modifie le plan
- **Formation et apprentissage** : Comprendre le comportement du planificateur

### Workflow RecommandÃ©

```
1. Identifier une requÃªte lente (pg_stat_statements, logs)
2. Analyser le plan actuel (EXPLAIN)
3. CrÃ©er un index hypothÃ©tique (hypopg_create_index)
4. Tester le nouveau plan (EXPLAIN avec index virtuel)
5. Comparer les coÃ»ts (avec/sans index)
6. CrÃ©er l'index rÃ©el si bÃ©nÃ©fique
7. Valider avec EXPLAIN ANALYZE
8. Monitorer dans le temps
```

### MÃ©triques de SuccÃ¨s

Un index hypothÃ©tique est **candidat Ã  la crÃ©ation rÃ©elle** si :

- âœ… **CoÃ»t rÃ©duit** : Le coÃ»t estimÃ© diminue significativement (> 50%)
- âœ… **Index utilisÃ©** : Le planificateur choisit l'index dans le plan
- âœ… **SÃ©lectivitÃ© suffisante** : L'index filtre efficacement (pas de low selectivity)
- âœ… **Multiple requÃªtes** : AmÃ©liore plusieurs requÃªtes frÃ©quentes
- âœ… **Balance lecture/Ã©criture** : Le gain en lecture justifie le coÃ»t en Ã©criture

### Prochaines Ã‰tapes

1. Installer HypoPG sur votre environnement de dÃ©veloppement
2. Identifier 3-5 requÃªtes lentes avec pg_stat_statements
3. Tester des index hypothÃ©tiques pour chaque requÃªte
4. Comparer les plans et les coÃ»ts
5. CrÃ©er les index rÃ©ellement bÃ©nÃ©fiques
6. Documenter vos dÃ©cisions d'indexation

---

**En Conclusion** : HypoPG rÃ©volutionne la maniÃ¨re d'optimiser les performances PostgreSQL en permettant de tester des stratÃ©gies d'indexation rapidement et sans risque. C'est un outil essentiel pour tout dÃ©veloppeur, DBA ou DevOps soucieux d'optimiser ses bases de donnÃ©es de maniÃ¨re mÃ©thodique et efficace.

**Principe d'or** : "Tester avant de crÃ©er" - HypoPG transforme l'indexation d'un art empirique en une science prÃ©cise.

---


â­ï¸ [pg_repack : RÃ©organisation sans verrous](/18-extensions-et-integrations/07.5-pg-repack.md)
