üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.3.4. Index GIN pour la Performance

## Introduction

Imaginez que vous avez une table avec 10 millions d'articles de blog. Sans index, une recherche textuelle pourrait prendre **plusieurs minutes** car PostgreSQL doit scanner **chaque ligne** pour v√©rifier si elle correspond √† votre requ√™te. Avec un index GIN bien configur√©, la m√™me recherche s'ex√©cute en **quelques millisecondes**.

Les **index GIN** (Generalized Inverted Index) sont **indispensables** pour obtenir de bonnes performances avec le Full-Text Search. Ils transforment une op√©ration O(n) en O(log n), soit un gain de performance de **100√ó √† 10 000√ó** selon la taille des donn√©es.

**Exemple concret** :
```sql
-- SANS index GIN : 45 secondes sur 10M d'articles
SELECT titre FROM articles
WHERE to_tsvector('french', contenu) @@ plainto_tsquery('french', 'postgresql');
-- Plan : Seq Scan (balayage s√©quentiel)

-- AVEC index GIN : 15 millisecondes
CREATE INDEX idx_articles_search ON articles USING GIN(search_vector);
SELECT titre FROM articles
WHERE search_vector @@ plainto_tsquery('french', 'postgresql');
-- Plan : Bitmap Index Scan (utilise l'index)
```

**Gain : 3000√ó plus rapide !**

---

## 1. Qu'est-ce qu'un Index GIN ?

### GIN : Generalized Inverted Index

Un **index invers√©** (inverted index) fonctionne √† l'oppos√© d'un index normal :

**Index normal (B-Tree)** : Document ‚Üí Mots
```
Document 1 ‚Üí ["postgresql", "base", "donn√©es"]
Document 2 ‚Üí ["mysql", "base", "donn√©es"]
Document 3 ‚Üí ["postgresql", "performance"]
```

**Index invers√© (GIN)** : Mot ‚Üí Documents
```
"postgresql" ‚Üí [Document 1, Document 3]
"base"       ‚Üí [Document 1, Document 2]
"donn√©es"    ‚Üí [Document 1, Document 2]
"mysql"      ‚Üí [Document 2]
"performance"‚Üí [Document 3]
```

Avec un index invers√©, pour trouver tous les documents contenant "postgresql", il suffit de faire **une seule recherche** dans l'index !

### Structure d'un Index GIN

```
Index GIN sur search_vector
‚îÇ
‚îú‚îÄ‚îÄ Lex√®me: "base"
‚îÇ   ‚îú‚îÄ‚îÄ Document ID: 1
‚îÇ   ‚îú‚îÄ‚îÄ Document ID: 2
‚îÇ   ‚îú‚îÄ‚îÄ Document ID: 5
‚îÇ   ‚îî‚îÄ‚îÄ Document ID: 8
‚îÇ
‚îú‚îÄ‚îÄ Lex√®me: "donn"
‚îÇ   ‚îú‚îÄ‚îÄ Document ID: 1
‚îÇ   ‚îú‚îÄ‚îÄ Document ID: 2
‚îÇ   ‚îî‚îÄ‚îÄ Document ID: 9
‚îÇ
‚îú‚îÄ‚îÄ Lex√®me: "postgresql"
‚îÇ   ‚îú‚îÄ‚îÄ Document ID: 1
‚îÇ   ‚îú‚îÄ‚îÄ Document ID: 3
‚îÇ   ‚îú‚îÄ‚îÄ Document ID: 7
‚îÇ   ‚îî‚îÄ‚îÄ Document ID: 10
‚îÇ
‚îî‚îÄ‚îÄ ...
```

### Pourquoi GIN est Parfait pour Full-Text Search

1. **Recherche rapide** : O(log n) au lieu de O(n)
2. **Op√©rateurs complexes** : AND, OR, NOT nativement support√©s
3. **Compression efficace** : Les listes de documents sont compress√©es
4. **Scalabilit√©** : Performances constantes m√™me avec des milliards de mots

---

## 2. Cr√©er un Index GIN

### Syntaxe de Base

```sql
CREATE INDEX nom_index ON nom_table USING GIN(colonne_tsvector);
```

### Pr√©requis : Colonne tsvector

Les index GIN ne peuvent √™tre cr√©√©s **que** sur des colonnes de type `tsvector` :

```sql
-- ‚ùå IMPOSSIBLE : Index GIN sur colonne TEXT
CREATE INDEX idx_bad ON articles USING GIN(contenu);
-- Erreur : data type text has no default operator class for access method "gin"

-- ‚úÖ BON : Index GIN sur colonne tsvector
ALTER TABLE articles ADD COLUMN search_vector tsvector;
UPDATE articles SET search_vector = to_tsvector('french', contenu);
CREATE INDEX idx_articles_search ON articles USING GIN(search_vector);
```

### Exemple Complet : De Z√©ro √† l'Index

```sql
-- 1. Cr√©er la table
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(200),
    contenu TEXT,
    auteur VARCHAR(100),
    created_at TIMESTAMP DEFAULT NOW()
);

-- 2. Ins√©rer des donn√©es (simuler 100k articles)
INSERT INTO articles (titre, contenu, auteur)
SELECT
    'Article ' || i,
    'Contenu de l''article num√©ro ' || i || '. ' ||
    CASE WHEN i % 100 = 0 THEN 'PostgreSQL est mentionn√© ici.' ELSE '' END,
    'Auteur ' || (i % 50)
FROM generate_series(1, 100000) AS i;

-- 3. Ajouter la colonne tsvector
ALTER TABLE articles ADD COLUMN search_vector tsvector;

-- 4. Remplir la colonne tsvector
UPDATE articles
SET search_vector =
    setweight(to_tsvector('french', COALESCE(titre, '')), 'A') ||
    setweight(to_tsvector('french', COALESCE(contenu, '')), 'B');

-- 5. Cr√©er l'index GIN
CREATE INDEX idx_articles_search ON articles USING GIN(search_vector);

-- 6. Analyser la table (mettre √† jour les statistiques)
ANALYZE articles;
```

### Cr√©er un Index avec Expression

Si vous n'avez pas de colonne tsvector d√©di√©e, vous pouvez cr√©er un index sur une **expression** :

```sql
-- Index GIN sur expression (sans colonne d√©di√©e)
CREATE INDEX idx_articles_content_search
ON articles
USING GIN(to_tsvector('french', contenu));

-- Requ√™te qui utilise l'index
SELECT titre FROM articles
WHERE to_tsvector('french', contenu) @@ plainto_tsquery('french', 'postgresql');
```

**‚ö†Ô∏è Attention** : Les index sur expressions sont **plus lents** que sur des colonnes d√©di√©es car le tsvector doit √™tre recalcul√© pour les insertions/mises √† jour.

**Recommandation** : Toujours utiliser une colonne tsvector d√©di√©e pour de meilleures performances.

---

## 3. Performance : Avant vs Apr√®s Index GIN

### Benchmark R√©el

Testons sur une table de 100 000 articles :

#### Sans Index GIN

```sql
-- D√©sactiver l'utilisation des index (pour tester sans)
SET enable_indexscan = off;
SET enable_bitmapscan = off;

-- Recherche sans index
EXPLAIN (ANALYZE, BUFFERS)
SELECT titre, auteur
FROM articles
WHERE search_vector @@ plainto_tsquery('french', 'postgresql');
```

**R√©sultat** :
```
Seq Scan on articles  (cost=0.00..5234.00 rows=50 width=68)
                      (actual time=0.045..245.678 rows=1000 loops=1)
  Filter: (search_vector @@ plainto_tsquery('french'::regconfig, 'postgresql'::text))
  Rows Removed by Filter: 99000
  Buffers: shared hit=2234
Planning Time: 0.234 ms
Execution Time: 245.912 ms  ‚Üê 246 ms
```

**Interpr√©tation** :
- **Seq Scan** : Balayage s√©quentiel de toute la table
- **99 000 lignes filtr√©es** : Scan de 100% de la table
- **246 ms** : Temps d'ex√©cution

#### Avec Index GIN

```sql
-- R√©activer les index
RESET enable_indexscan;
RESET enable_bitmapscan;

-- M√™me recherche avec index
EXPLAIN (ANALYZE, BUFFERS)
SELECT titre, auteur
FROM articles
WHERE search_vector @@ plainto_tsquery('french', 'postgresql');
```

**R√©sultat** :
```
Bitmap Heap Scan on articles  (cost=50.45..234.67 rows=50 width=68)
                              (actual time=1.234..3.456 rows=1000 loops=1)
  Recheck Cond: (search_vector @@ plainto_tsquery('french'::regconfig, 'postgresql'::text))
  Heap Blocks: exact=987
  Buffers: shared hit=1012
  ->  Bitmap Index Scan on idx_articles_search  (cost=0.00..50.44 rows=50 width=0)
                                                  (actual time=1.123..1.123 rows=1000 loops=1)
        Index Cond: (search_vector @@ plainto_tsquery('french'::regconfig, 'postgresql'::text))
        Buffers: shared hit=25
Planning Time: 0.189 ms
Execution Time: 3.678 ms  ‚Üê 3.7 ms
```

**Interpr√©tation** :
- **Bitmap Index Scan** : Utilise l'index GIN
- **25 blocs d'index** : Seulement l'index consult√©
- **3.7 ms** : Temps d'ex√©cution

**Gain : 67√ó plus rapide (246ms ‚Üí 3.7ms) !**

### Comparaison Visuelle

```
Sans Index GIN :
[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 246 ms
Scan de 100 000 lignes

Avec Index GIN :
[‚ñà‚ñà‚ñà] 3.7 ms
Scan de 1 000 lignes (celles qui matchent)
```

---

## 4. Op√©rations Support√©es par les Index GIN

Les index GIN acc√©l√®rent l'op√©rateur `@@` et ses variantes :

### Op√©rateur @@

```sql
-- ‚úÖ Utilise l'index GIN
SELECT * FROM articles
WHERE search_vector @@ to_tsquery('french', 'postgresql');

-- ‚úÖ Utilise l'index GIN
SELECT * FROM articles
WHERE search_vector @@ plainto_tsquery('french', 'postgresql base donn√©es');

-- ‚úÖ Utilise l'index GIN
SELECT * FROM articles
WHERE search_vector @@ websearch_to_tsquery('french', 'postgresql "base donn√©es"');
```

### Op√©rations Complexes

```sql
-- ‚úÖ AND : Utilise l'index
SELECT * FROM articles
WHERE search_vector @@ to_tsquery('french', 'postgresql & base');

-- ‚úÖ OR : Utilise l'index
SELECT * FROM articles
WHERE search_vector @@ to_tsquery('french', 'postgresql | mysql');

-- ‚úÖ NOT : Utilise l'index
SELECT * FROM articles
WHERE search_vector @@ to_tsquery('french', 'base & !oracle');

-- ‚úÖ Phrases : Utilise l'index
SELECT * FROM articles
WHERE search_vector @@ phraseto_tsquery('french', 'base de donn√©es');
```

### Op√©rations NON Support√©es

```sql
-- ‚ùå N'utilise PAS l'index (fonction sur tsvector)
SELECT * FROM articles
WHERE length(search_vector) > 10;

-- ‚ùå N'utilise PAS l'index (op√©rateur non support√©)
SELECT * FROM articles
WHERE search_vector > to_tsquery('french', 'postgresql');
```

---

## 5. Options et Param√®tres d'Index GIN

### fastupdate : Acc√©l√©rer les √âcritures

Par d√©faut, les insertions/mises √† jour sont imm√©diatement appliqu√©es √† l'index GIN, ce qui peut √™tre lent.

L'option **fastupdate** permet de **mettre en attente** les mises √† jour dans une liste temporaire :

```sql
-- Cr√©er un index GIN avec fastupdate activ√©
CREATE INDEX idx_articles_search
ON articles
USING GIN(search_vector)
WITH (fastupdate = on);
```

**Comment √ßa marche** :
1. Les nouvelles entr√©es sont stock√©es dans une **pending list** (liste d'attente)
2. P√©riodiquement, la pending list est **fusionn√©e** avec l'index principal
3. Les recherches consultent **index + pending list**

**Avantages** :
- ‚úÖ Insertions/mises √† jour **plus rapides** (10-50%)
- ‚úÖ Moins de fragmentation de l'index

**Inconv√©nients** :
- ‚ö†Ô∏è Recherches l√©g√®rement plus lentes si la pending list est grande
- ‚ö†Ô∏è Consommation m√©moire suppl√©mentaire

**Recommandation** :
- **ON** : Pour tables avec insertions/mises √† jour fr√©quentes
- **OFF** : Pour tables principalement en lecture

### gin_pending_list_limit : Taille de la Liste d'Attente

D√©finit la taille maximale de la pending list (par index) :

```sql
-- Par d√©faut : 4 MB
SHOW gin_pending_list_limit;
-- R√©sultat : 4MB

-- Augmenter pour tables avec beaucoup d'√©critures
SET gin_pending_list_limit = '16MB';

-- Ou au niveau de l'index
CREATE INDEX idx_articles_search
ON articles
USING GIN(search_vector)
WITH (fastupdate = on, gin_pending_list_limit = 16384);  -- 16 MB
```

**Impact** :
- **Petite valeur (1-4 MB)** : Fusions fr√©quentes, √©critures plus lentes mais recherches rapides
- **Grande valeur (16-64 MB)** : Fusions moins fr√©quentes, √©critures rapides mais recherches un peu plus lentes

### Cr√©er l'Index CONCURRENTLY

Pour √©viter de bloquer la table pendant la cr√©ation de l'index :

```sql
-- Index cr√©√© sans bloquer les √©critures/lectures
CREATE INDEX CONCURRENTLY idx_articles_search
ON articles
USING GIN(search_vector);
```

**Avantages** :
- ‚úÖ Aucun verrou exclusif sur la table
- ‚úÖ Applications continuent de fonctionner

**Inconv√©nients** :
- ‚ö†Ô∏è Cr√©ation 2-3√ó plus lente
- ‚ö†Ô∏è Utilise plus de ressources (CPU, I/O)

**Recommandation** : Toujours utiliser CONCURRENTLY en production.

---

## 6. Maintenance des Index GIN

### Pourquoi la Maintenance est Importante

Avec le temps, les index GIN peuvent :
- **Gonfler** (bloat) apr√®s de nombreuses suppressions/mises √† jour
- Accumuler des entr√©es dans la pending list
- Devenir fragment√©s

**Sympt√¥mes d'un index d√©grad√©** :
- Recherches de plus en plus lentes
- Taille de l'index anormalement grande
- EXPLAIN montre des co√ªts √©lev√©s

### VACUUM : Nettoyer l'Index

```sql
-- Vacuum standard (nettoie la pending list)
VACUUM articles;

-- Vacuum verbose (avec d√©tails)
VACUUM VERBOSE articles;
```

**Sortie** :
```
INFO:  vacuuming "public.articles"
INFO:  index "idx_articles_search" now contains 100000 row versions in 2345 pages
DETAIL:  0 index row versions were removed.
500 index pages have been deleted, 0 are currently reusable.
```

### REINDEX : Reconstruire l'Index

Pour reconstruire compl√®tement un index :

```sql
-- Reindex un index sp√©cifique (bloque les √©critures)
REINDEX INDEX idx_articles_search;

-- Reindex tous les index d'une table
REINDEX TABLE articles;

-- Reindex sans bloquer (PostgreSQL 12+)
REINDEX INDEX CONCURRENTLY idx_articles_search;
```

**Quand reindexer ?**
- Apr√®s des suppressions massives (>50% de la table)
- Si l'index a 2√ó la taille attendue (bloat important)
- Si les performances se d√©gradent malgr√© VACUUM
- Migration de version majeure PostgreSQL

### Surveiller la Taille des Index

```sql
-- Taille des index GIN
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS taille_index,
    idx_scan AS nombre_scans,
    idx_tup_read AS tuples_lus
FROM pg_stat_user_indexes
WHERE indexrelname LIKE 'idx_%search%'
ORDER BY pg_relation_size(indexrelid) DESC;
```

**R√©sultat exemple** :
```
schemaname | tablename | indexname           | taille_index | nombre_scans | tuples_lus
-----------+-----------+---------------------+--------------+--------------+------------
public     | articles  | idx_articles_search | 45 MB        | 12543        | 2345678
```

### Estimer le Bloat

```sql
-- Extension pgstattuple pour analyser le bloat
CREATE EXTENSION IF NOT EXISTS pgstattuple;

-- Analyser un index GIN
SELECT
    indexname,
    leaf_pages,
    deleted_pages,
    ROUND(100.0 * deleted_pages / NULLIF(leaf_pages, 0), 2) AS bloat_percent
FROM pgstatginindex('idx_articles_search');
```

**Interpr√©tation** :
- **bloat_percent < 10%** : Index sain
- **bloat_percent 10-30%** : Bloat mod√©r√©, VACUUM suffit
- **bloat_percent > 30%** : Bloat important, REINDEX recommand√©

---

## 7. Optimisations Avanc√©es

### 7.1. Index Partiel (Partial Index)

Cr√©er un index uniquement sur un **sous-ensemble** des lignes :

```sql
-- Index uniquement sur les articles publi√©s
CREATE INDEX idx_articles_published_search
ON articles
USING GIN(search_vector)
WHERE statut = 'publi√©';

-- Requ√™te qui utilise l'index
SELECT titre FROM articles
WHERE search_vector @@ plainto_tsquery('french', 'postgresql')
  AND statut = 'publi√©';  -- ‚Üê Condition de l'index
```

**Avantages** :
- ‚úÖ Index plus petit (moins d'espace)
- ‚úÖ Maintenance plus rapide
- ‚úÖ Recherches plus rapides sur le sous-ensemble

**Cas d'usage** :
- Articles publi√©s vs brouillons
- Produits en stock vs rupture
- Documents actifs vs archiv√©s

### 7.2. Combiner GIN avec Index B-Tree

Pour des requ√™tes avec plusieurs filtres :

```sql
-- Index GIN pour la recherche textuelle
CREATE INDEX idx_articles_search ON articles USING GIN(search_vector);

-- Index B-Tree pour les filtres classiques
CREATE INDEX idx_articles_date ON articles(created_at);
CREATE INDEX idx_articles_auteur ON articles(auteur);

-- Requ√™te combin√©e (PostgreSQL choisit les index optimaux)
SELECT titre, created_at
FROM articles
WHERE search_vector @@ plainto_tsquery('french', 'postgresql')
  AND created_at > NOW() - INTERVAL '1 month'
  AND auteur = 'Jean Dupont';
```

**PostgreSQL peut** :
- Utiliser l'index GIN pour filtrer par texte
- Puis l'index B-Tree pour filtrer par date
- Ou vice versa, selon les statistiques

### 7.3. Param√®tres PostgreSQL pour GIN

Ajuster les param√®tres globaux pour optimiser les index GIN :

```sql
-- M√©moire pour la construction d'index
SET maintenance_work_mem = '256MB';  -- D√©faut : 64MB
-- Impact : Index cr√©√©s plus rapidement

-- M√©moire pour la pending list (par session)
SET gin_pending_list_limit = '16MB';  -- D√©faut : 4MB
-- Impact : Moins de fusions, √©critures plus rapides

-- Afficher les param√®tres GIN actuels
SHOW maintenance_work_mem;
SHOW gin_pending_list_limit;
```

**Recommandations** :
- **maintenance_work_mem** : 5-10% de la RAM pour CREATE INDEX
- **gin_pending_list_limit** : 16-32 MB pour tables avec beaucoup d'√©critures

---

## 8. Cas Pratiques Complets

### Cas 1 : Blog avec Millions d'Articles

```sql
-- Structure
CREATE TABLE blog_articles (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(200),
    contenu TEXT,
    auteur VARCHAR(100),
    categorie VARCHAR(50),
    statut VARCHAR(20) DEFAULT 'brouillon',  -- 'brouillon', 'publi√©', 'archiv√©'
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    search_vector tsvector
);

-- Trigger pour maintenir search_vector
CREATE OR REPLACE FUNCTION blog_search_trigger() RETURNS trigger AS $$
BEGIN
    NEW.search_vector :=
        setweight(to_tsvector('french', COALESCE(NEW.titre, '')), 'A') ||
        setweight(to_tsvector('french', COALESCE(NEW.contenu, '')), 'B') ||
        setweight(to_tsvector('french', COALESCE(NEW.auteur, '')), 'D');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tsvector_update
BEFORE INSERT OR UPDATE ON blog_articles
FOR EACH ROW EXECUTE FUNCTION blog_search_trigger();

-- Index GIN partiel (uniquement articles publi√©s)
CREATE INDEX idx_blog_published_search
ON blog_articles
USING GIN(search_vector)
WHERE statut = 'publi√©'
WITH (fastupdate = on, gin_pending_list_limit = 16384);

-- Index B-Tree compl√©mentaires
CREATE INDEX idx_blog_date ON blog_articles(created_at DESC);
CREATE INDEX idx_blog_categorie ON blog_articles(categorie);

-- Requ√™te optimis√©e
SELECT
    id,
    titre,
    LEFT(contenu, 200) AS extrait,
    created_at,
    ts_rank(search_vector, query) AS score
FROM
    blog_articles,
    websearch_to_tsquery('french', 'postgresql base donn√©es') query
WHERE
    statut = 'publi√©'  -- Utilise l'index partiel
    AND search_vector @@ query  -- Utilise l'index GIN
    AND created_at > NOW() - INTERVAL '1 year'  -- Peut utiliser idx_blog_date
ORDER BY score DESC
LIMIT 20;
```

### Cas 2 : E-commerce avec Recherche Produits

```sql
-- Structure
CREATE TABLE produits (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(200),
    description TEXT,
    marque VARCHAR(100),
    categorie VARCHAR(50),
    prix NUMERIC(10, 2),
    stock INTEGER,
    actif BOOLEAN DEFAULT true,
    search_vector tsvector
);

-- Trigger avec poids adapt√©s e-commerce
CREATE OR REPLACE FUNCTION produits_search_trigger() RETURNS trigger AS $$
BEGIN
    NEW.search_vector :=
        -- Nom produit : tr√®s important (doubl√©)
        setweight(to_tsvector('french', COALESCE(NEW.nom, '')), 'A') ||
        setweight(to_tsvector('french', COALESCE(NEW.nom, '')), 'A') ||
        -- Marque : important
        setweight(to_tsvector('french', COALESCE(NEW.marque, '')), 'A') ||
        -- Description : normal
        setweight(to_tsvector('french', COALESCE(NEW.description, '')), 'B') ||
        -- Cat√©gorie : faible
        setweight(to_tsvector('french', COALESCE(NEW.categorie, '')), 'C');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tsvector_update
BEFORE INSERT OR UPDATE ON produits
FOR EACH ROW EXECUTE FUNCTION produits_search_trigger();

-- Index GIN partiel (uniquement produits actifs et en stock)
CREATE INDEX idx_produits_available_search
ON produits
USING GIN(search_vector)
WHERE actif = true AND stock > 0
WITH (fastupdate = on);

-- Index compl√©mentaires
CREATE INDEX idx_produits_prix ON produits(prix);
CREATE INDEX idx_produits_categorie ON produits(categorie);

-- Recherche optimis√©e
SELECT
    nom,
    marque,
    prix,
    stock,
    ts_rank(
        ARRAY[0.05, 0.2, 0.4, 2.0],  -- Boost nom/marque
        search_vector,
        query,
        1  -- Normalisation
    ) AS score
FROM
    produits,
    websearch_to_tsquery('french', 'chaussure running nike') query
WHERE
    actif = true
    AND stock > 0  -- Conditions de l'index partiel
    AND search_vector @@ query
    AND prix BETWEEN 50 AND 200  -- Peut utiliser idx_produits_prix
ORDER BY score DESC
LIMIT 50;
```

### Cas 3 : Documentation Technique Multilingue

```sql
-- Structure
CREATE TABLE documentation (
    id SERIAL PRIMARY KEY,
    titre VARCHAR(200),
    contenu TEXT,
    langue VARCHAR(10),  -- 'fr', 'en', 'es'
    version VARCHAR(20),
    categorie VARCHAR(50),
    search_vector tsvector
);

-- Trigger intelligent multilingue
CREATE OR REPLACE FUNCTION doc_search_trigger() RETURNS trigger AS $$
DECLARE
    config regconfig;
BEGIN
    -- Choisir la configuration selon la langue
    config := CASE NEW.langue
        WHEN 'fr' THEN 'french'::regconfig
        WHEN 'en' THEN 'english'::regconfig
        WHEN 'es' THEN 'spanish'::regconfig
        ELSE 'simple'::regconfig
    END;

    NEW.search_vector :=
        setweight(to_tsvector(config, COALESCE(NEW.titre, '')), 'A') ||
        setweight(to_tsvector(config, COALESCE(NEW.contenu, '')), 'B');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tsvector_update
BEFORE INSERT OR UPDATE ON documentation
FOR EACH ROW EXECUTE FUNCTION doc_search_trigger();

-- Index GIN par langue (plus performant que index global)
CREATE INDEX idx_doc_fr_search
ON documentation
USING GIN(search_vector)
WHERE langue = 'fr';

CREATE INDEX idx_doc_en_search
ON documentation
USING GIN(search_vector)
WHERE langue = 'en';

CREATE INDEX idx_doc_es_search
ON documentation
USING GIN(search_vector)
WHERE langue = 'es';

-- Recherche par langue
SELECT
    titre,
    version,
    ts_rank(search_vector, query) AS score
FROM
    documentation,
    plainto_tsquery('french', 'connexion base donn√©es') query
WHERE
    langue = 'fr'  -- Utilise idx_doc_fr_search
    AND search_vector @@ query
ORDER BY score DESC;
```

---

## 9. Diagnostic et Troubleshooting

### V√©rifier si l'Index est Utilis√©

```sql
-- EXPLAIN montre si l'index est utilis√©
EXPLAIN (ANALYZE, BUFFERS)
SELECT titre FROM articles
WHERE search_vector @@ plainto_tsquery('french', 'postgresql');
```

**Bon signe** : "Bitmap Index Scan" ou "Index Scan"
```
Bitmap Index Scan on idx_articles_search  (cost=...)
  Index Cond: (search_vector @@ ...)
```

**Mauvais signe** : "Seq Scan"
```
Seq Scan on articles  (cost=...)
  Filter: (search_vector @@ ...)
```

### Pourquoi l'Index n'est Pas Utilis√© ?

#### Raison 1 : Statistiques Obsol√®tes

```sql
-- Mettre √† jour les statistiques
ANALYZE articles;

-- V√©rifier la date de derni√®re analyse
SELECT
    schemaname,
    tablename,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
WHERE tablename = 'articles';
```

#### Raison 2 : Pas Assez de Donn√©es

Pour de petites tables (< 1000 lignes), un scan s√©quentiel peut √™tre plus rapide qu'un index.

```sql
-- Forcer l'utilisation de l'index (debug uniquement)
SET enable_seqscan = off;

-- Tester la requ√™te
EXPLAIN SELECT * FROM articles WHERE search_vector @@ query;

-- Remettre √† normal
RESET enable_seqscan;
```

#### Raison 3 : Requ√™te Retourne Trop de Lignes

Si la requ√™te retourne > 10-20% de la table, PostgreSQL pr√©f√®re un scan s√©quentiel.

```sql
-- V√©rifier la s√©lectivit√©
SELECT
    COUNT(*) AS total,
    COUNT(*) FILTER (WHERE search_vector @@ plainto_tsquery('french', 'le')) AS matches,
    ROUND(100.0 * COUNT(*) FILTER (WHERE search_vector @@ plainto_tsquery('french', 'le')) / COUNT(*), 2) AS pourcentage
FROM articles;

-- Si pourcentage > 20%, un scan s√©quentiel est normal
```

#### Raison 4 : Requ√™te ne Correspond Pas √† l'Index

```sql
-- ‚ùå N'utilise PAS l'index partiel (condition manquante)
CREATE INDEX idx_partial ON articles USING GIN(search_vector) WHERE statut = 'publi√©';

SELECT * FROM articles WHERE search_vector @@ query;
-- Manque : AND statut = 'publi√©'

-- ‚úÖ Utilise l'index partiel
SELECT * FROM articles
WHERE search_vector @@ query AND statut = 'publi√©';
```

### Statistiques d'Utilisation des Index

```sql
-- Voir combien de fois chaque index est utilis√©
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan AS scans,
    idx_tup_read AS tuples_lus,
    idx_tup_fetch AS tuples_recuperes,
    pg_size_pretty(pg_relation_size(indexrelid)) AS taille
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;
```

**Interpr√©tation** :
- **idx_scan = 0** : Index jamais utilis√© (candidat √† la suppression)
- **idx_scan > 0** : Index utilis√© (pertinent)
- **Ratio tuples_lus/idx_scan** : Nombre moyen de r√©sultats par recherche

---

## 10. Bonnes Pratiques

### ‚úÖ Toujours Cr√©er l'Index sur Colonne tsvector D√©di√©e

```sql
-- ‚úÖ BON : Colonne d√©di√©e
ALTER TABLE articles ADD COLUMN search_vector tsvector;
UPDATE articles SET search_vector = to_tsvector('french', contenu);
CREATE INDEX idx_articles_search ON articles USING GIN(search_vector);

-- ‚ùå √âVITER : Index sur expression
CREATE INDEX idx_bad ON articles USING GIN(to_tsvector('french', contenu));
-- Plus lent √† l'insertion/mise √† jour
```

### ‚úÖ Utiliser CONCURRENTLY en Production

```sql
-- ‚úÖ BON : Pas de blocage
CREATE INDEX CONCURRENTLY idx_articles_search ON articles USING GIN(search_vector);

-- ‚ùå RISQU√â : Bloque la table (peut durer plusieurs minutes)
CREATE INDEX idx_articles_search ON articles USING GIN(search_vector);
```

### ‚úÖ Activer fastupdate pour Tables avec √âcritures Fr√©quentes

```sql
-- Tables avec insertions/mises √† jour fr√©quentes
CREATE INDEX idx_articles_search
ON articles
USING GIN(search_vector)
WITH (fastupdate = on, gin_pending_list_limit = 16384);
```

### ‚úÖ Utiliser des Index Partiels Quand Possible

```sql
-- Si 90% des recherches concernent les articles publi√©s
CREATE INDEX idx_published_search
ON articles
USING GIN(search_vector)
WHERE statut = 'publi√©';
-- Index 10√ó plus petit !
```

### ‚úÖ ANALYZE Apr√®s Cr√©ation d'Index

```sql
CREATE INDEX idx_articles_search ON articles USING GIN(search_vector);
ANALYZE articles;  -- ‚Üê IMPORTANT : Met √† jour les statistiques
```

### ‚úÖ Surveiller et Maintenir R√©guli√®rement

```sql
-- Script de maintenance hebdomadaire
VACUUM ANALYZE articles;

-- Reindex annuel (ou apr√®s op√©rations massives)
REINDEX INDEX CONCURRENTLY idx_articles_search;
```

### ‚úÖ Tester les Performances Avant et Apr√®s

```sql
-- Avant cr√©ation de l'index
\timing on
SELECT COUNT(*) FROM articles WHERE search_vector @@ query;
-- Temps : 2450 ms

-- Cr√©er l'index
CREATE INDEX idx_articles_search ON articles USING GIN(search_vector);
ANALYZE articles;

-- Apr√®s cr√©ation de l'index
SELECT COUNT(*) FROM articles WHERE search_vector @@ query;
-- Temps : 15 ms
-- Gain : 163√ó plus rapide
```

---

## 11. Comparaison : GIN vs GiST vs Autres

### GIN vs GiST

| Crit√®re | GIN | GiST |
|---------|-----|------|
| **Performance recherche** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellent | ‚≠ê‚≠ê‚≠ê‚≠ê Tr√®s bon |
| **Performance √©criture** | ‚≠ê‚≠ê‚≠ê Moyen | ‚≠ê‚≠ê‚≠ê‚≠ê Bon |
| **Taille index** | Plus grand | Plus petit |
| **Full-Text Search** | ‚úÖ Recommand√© | ‚ö†Ô∏è Possible |
| **Donn√©es spatiales** | ‚ùå Non | ‚úÖ Oui |
| **Arrays** | ‚úÖ Oui | ‚ö†Ô∏è Limit√© |
| **JSONB** | ‚úÖ Oui | ‚ö†Ô∏è Limit√© |

**Verdict Full-Text Search** : **GIN est le choix optimal**

### Quand NE PAS Utiliser GIN

- ‚ùå **Tr√®s petites tables** (< 1000 lignes) : Overhead pas justifi√©
- ‚ùå **Tables avec √©critures ultra-fr√©quentes** et peu de lectures : BRIN peut √™tre mieux
- ‚ùå **Colonnes avec tr√®s faible cardinalit√©** : B-Tree suffit

---

## 12. R√©sum√© et Checklist

### Checklist de D√©ploiement

- [ ] Cr√©er une colonne tsvector d√©di√©e
- [ ] Ajouter un trigger pour maintenir la colonne automatiquement
- [ ] Cr√©er l'index GIN (avec CONCURRENTLY en production)
- [ ] Ex√©cuter ANALYZE apr√®s cr√©ation
- [ ] V√©rifier avec EXPLAIN que l'index est utilis√©
- [ ] Mesurer les performances avant/apr√®s
- [ ] Planifier la maintenance (VACUUM hebdomadaire)
- [ ] Surveiller la taille et l'utilisation de l'index

### Commandes Essentielles

```sql
-- Cr√©ation compl√®te
ALTER TABLE ma_table ADD COLUMN search_vector tsvector;
CREATE INDEX CONCURRENTLY idx_search ON ma_table USING GIN(search_vector);
ANALYZE ma_table;

-- Maintenance
VACUUM ANALYZE ma_table;
REINDEX INDEX CONCURRENTLY idx_search;

-- Surveillance
SELECT pg_size_pretty(pg_relation_size('idx_search'));
SELECT idx_scan FROM pg_stat_user_indexes WHERE indexrelname = 'idx_search';

-- Debug
EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM ma_table WHERE search_vector @@ query;
```

### Param√®tres Recommand√©s

```sql
-- Pour la cr√©ation d'index
SET maintenance_work_mem = '256MB';  -- Ou plus selon RAM

-- Pour les √©critures fr√©quentes
CREATE INDEX ... WITH (fastupdate = on, gin_pending_list_limit = 16384);

-- Index partiel si applicable
CREATE INDEX ... WHERE condition_frequente;
```

---

## Conclusion

Les **index GIN** sont absolument **essentiels** pour obtenir de bonnes performances avec le Full-Text Search dans PostgreSQL. Ils transforment des requ√™tes de plusieurs secondes en quelques millisecondes.

**Points cl√©s √† retenir** :

1. **Index GIN = Obligatoire** pour Full-Text Search √† grande √©chelle
   - Gain de performance : 100√ó √† 10 000√ó
   - Structure d'index invers√© optimale pour la recherche textuelle

2. **Colonne tsvector d√©di√©e** recommand√©e
   - Plus performant que les index sur expressions
   - Maintenance automatique avec triggers

3. **Options d'optimisation** :
   - `fastupdate = on` pour √©critures fr√©quentes
   - `gin_pending_list_limit` adapt√© √† votre charge
   - Index partiels pour r√©duire la taille

4. **Maintenance r√©guli√®re** :
   - VACUUM pour nettoyer la pending list
   - REINDEX en cas de bloat important
   - ANALYZE pour mettre √† jour les statistiques

5. **Surveillance** :
   - V√©rifier l'utilisation avec pg_stat_user_indexes
   - Mesurer la taille avec pg_relation_size
   - Valider les plans avec EXPLAIN ANALYZE

Sans index GIN, le Full-Text Search PostgreSQL est inutilisable en production. Avec un index GIN bien configur√© et maintenu, vous obtenez un moteur de recherche performant et scalable, directement int√©gr√© √† votre base de donn√©es.

**Prochaine √©tape** : Explorez les techniques avanc√©es de recherche, les highlights, et l'int√©gration avec des interfaces utilisateur pour cr√©er des exp√©riences de recherche compl√®tes !

---

**Ressources compl√©mentaires** :
- Documentation GIN : https://www.postgresql.org/docs/current/gin.html
- GIN Implementation : https://www.postgresql.org/docs/current/gin-implementation.html
- Index Types Comparison : https://www.postgresql.org/docs/current/indexes-types.html
- Performance Tuning : https://www.postgresql.org/docs/current/performance-tips.html

‚è≠Ô∏è [Foreign Data Wrappers (FDW) : PostgreSQL comme hub de donn√©es](/18-extensions-et-integrations/04-foreign-data-wrappers.md)
